<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="如下图所示为HashMap的继承关系：  ​		HashMap由数组+链表+红黑树构成。HashMap继承AbstractMap并实现Map,Cloneable,Serializable接口。要注意HashMap的实例有两个影响其性能的参数：初始容量和负载因子。">
<meta property="og:type" content="article">
<meta property="og:title" content="HashMap源码分析">
<meta property="og:url" content="http://example.com/2022/09/21/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="WangHao&amp;博客">
<meta property="og:description" content="如下图所示为HashMap的继承关系：  ​		HashMap由数组+链表+红黑树构成。HashMap继承AbstractMap并实现Map,Cloneable,Serializable接口。要注意HashMap的实例有两个影响其性能的参数：初始容量和负载因子。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/09/21/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/blog/source_posts/HashMap源码分析/2.jpg">
<meta property="og:image" content="http://example.com/2022/09/21/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%5C3.png">
<meta property="og:image" content="http://example.com/2022/09/21/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%5C3.jpg">
<meta property="og:image" content="http://example.com/2022/09/21/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%5C1.png">
<meta property="og:image" content="http://example.com/2022/09/21/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/blog/source_posts/HashMap源码分析/4.jpg">
<meta property="og:image" content="http://example.com/2022/09/21/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/blog/source_posts/HashMap源码分析/5.jpg">
<meta property="article:published_time" content="2022-09-21T03:22:07.000Z">
<meta property="article:modified_time" content="2022-09-23T07:35:42.873Z">
<meta property="article:author" content="Jing">
<meta property="article:tag" content="HashMap源码">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/09/21/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/blog/source_posts/HashMap源码分析/2.jpg">


<link rel="canonical" href="http://example.com/2022/09/21/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2022/09/21/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","path":"2022/09/21/HashMap源码分析/","title":"HashMap源码分析"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>HashMap源码分析 | WangHao&博客</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">WangHao&博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Welcome to the home of WangHao</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="nav-number">1.</span> <span class="nav-text">成员变量</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E8%8A%82%E7%82%B9%E7%9A%84%E6%9E%84%E9%80%A0"><span class="nav-number">1.1.</span> <span class="nav-text">数据节点的构造</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="nav-number">1.3.</span> <span class="nav-text">关键方法源码解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#put-%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.1.</span> <span class="nav-text">put()方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#putTreeVal"><span class="nav-number">1.3.2.</span> <span class="nav-text">putTreeVal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#resize-%E6%89%A9%E5%AE%B9%E7%AE%97%E6%B3%95%EF%BC%9A"><span class="nav-number">1.3.3.</span> <span class="nav-text">resize()扩容算法：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#get%E3%80%81replace%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.4.</span> <span class="nav-text">get、replace方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#remove%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.5.</span> <span class="nav-text">remove方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#treeifyBin%E6%A0%91%E5%8C%96%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.6.</span> <span class="nav-text">treeifyBin树化方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#treeify"><span class="nav-number">1.3.7.</span> <span class="nav-text">treeify</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap%E5%88%A4%E6%96%AD%E5%85%83%E7%B4%A0%E7%9B%B8%E7%AD%89%E5%8E%9F%E7%90%86"><span class="nav-number">1.4.</span> <span class="nav-text">HashMap判断元素相等原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HashCode%E5%8E%9F%E7%90%86"><span class="nav-number">1.4.1.</span> <span class="nav-text">HashCode原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%86%99%E7%9A%84hashcode%E7%AE%97%E6%B3%95%E5%BC%95%E8%B5%B7%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-number">1.4.2.</span> <span class="nav-text">重写的hashcode算法引起的内存泄漏</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashTable"><span class="nav-number">1.5.</span> <span class="nav-text">HashTable</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">1.5.1.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap%EF%BC%8CLinkedHashMap%EF%BC%8CTreeMap-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.5.2.</span> <span class="nav-text">HashMap，LinkedHashMap，TreeMap 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap-%E5%92%8C-HashTable-%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82"><span class="nav-number">1.5.3.</span> <span class="nav-text">HashMap 和 HashTable 的区别。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrentHashMap-%E4%B8%8E-HashTable-%E6%95%88%E7%8E%87%E6%AF%94%E8%BE%83"><span class="nav-number">1.5.4.</span> <span class="nav-text">ConcurrentHashMap 与 HashTable 效率比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap%E4%B8%8EHashSet%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB"><span class="nav-number">1.6.</span> <span class="nav-text">HashMap与HashSet的联系与区别</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jing"
      src="/images/head.jpg">
  <p class="site-author-name" itemprop="name">Jing</p>
  <div class="site-description" itemprop="description">Stay hungry,stay foolish</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">88</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">101</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/21/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="Jing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WangHao&博客">
      <meta itemprop="description" content="Stay hungry,stay foolish">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="HashMap源码分析 | WangHao&博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          HashMap源码分析
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-09-21 11:22:07" itemprop="dateCreated datePublished" datetime="2022-09-21T11:22:07+08:00">2022-09-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-23 15:35:42" itemprop="dateModified" datetime="2022-09-23T15:35:42+08:00">2022-09-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E5%AE%B9%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">Java容器</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>如下图所示为HashMap的继承关系：</p>
<p><img src="/2022/09/21/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/blog\source_posts\HashMap源码分析\2.jpg"></p>
<p>​		HashMap由数组+链表+红黑树构成。HashMap继承<strong>AbstractMap</strong>并实现<strong>Map</strong>,<strong>Cloneable</strong>,<strong>Serializable</strong>接口。要注意HashMap的实例有两个影响其性能的参数：<strong>初始容量</strong>和<strong>负载因子</strong>。</p>
<span id="more"></span>

<h1 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 默认数组初始值大小</span></span><br><span class="line"><span class="comment">    * 0b 0001 左移四位 0b 1000 =&gt; 0d 16</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">//16</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 数组最大长度</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 默认负载因子</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 树化阈值，Node链表长度大于8会触发树化操作 将链转化为红黑树</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 树转化为链表的阈值，TreeNode树节点数小于6会将树转化为Node链表</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 树化的条件之一：数组长度大于等于64才会树化，否则优先进行扩容操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈希桶（数组），由于TreeNode继承于Node，所以树化后也可以存放TreeNode节点（父类指针可以指向子类引用）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Holds cached entrySet(). Note that AbstractMap fields are used</span></span><br><span class="line"><span class="comment">    * for keySet() and values().</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 元素个数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当前Hash表的修改次数，元素增加或减少都会加1，替换不影响</span></span><br><span class="line"><span class="comment">    * 		HashMap、TreeMap、ArrayList、LinkedList等都有modCount属性</span></span><br><span class="line"><span class="comment">    * 		Fail-Fast 机制 </span></span><br><span class="line"><span class="comment">    * 				HashMap 不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了map，</span></span><br><span class="line"><span class="comment">    * 				那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。</span></span><br><span class="line"><span class="comment">    * 				这一策略在源码中的实现是通过 modCount 域，modCount 顾名思义就是修改次数，</span></span><br><span class="line"><span class="comment">    * 				对HashMap 内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋</span></span><br><span class="line"><span class="comment">    * 				给迭代器的 expectedModCount。在迭代过程中，判断 modCount 跟expectedModCount </span></span><br><span class="line"><span class="comment">    * 				是否相等，如果不相等就表示已经有其他线程修改了Map</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  扩容阈值=数组长度*负载因子，元素个数超过这个阈值会触发扩容</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 负载因子</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="数据节点的构造"><a href="#数据节点的构造" class="headerlink" title="数据节点的构造"></a>数据节点的构造</h2><p><img src="/2022/09/21/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%5C3.png"></p>
<p><img src="/2022/09/21/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%5C3.jpg"><img src="/2022/09/21/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%5C1.png"></p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 给定数组初始长度和负载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">	<span class="comment">// 数组初始长度不能小于 0，否则抛异常</span></span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       <span class="comment">// 数组的初始长度不能大于最大值</span></span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">           initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">       <span class="comment">// 负载因子小于0，或者not a number则 抛出异常， </span></span><br><span class="line">       <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                              loadFactor);</span><br><span class="line">       <span class="comment">// 设置负载因子</span></span><br><span class="line">       <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">	<span class="comment">// 计算数组的容量，暂时存到threshold（扩容阈值）</span></span><br><span class="line">       <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 2. 给定数组容量，用默认的负载因子0.75</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 3. 使用默认的数组长度16和负载因子0.75</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  4. 用一个map集合去初始化另一个map集合</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">       putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 计算一个出一个比给定值大的2的n次方的数作为数组初始容量</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">       <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>​		构造函数1.2.3都不会创建table数组（存放node节点的桶数组），HashMap会在第一次put数据时才创建table数组。默认的构造函数构造的是<strong>初始容量16，加载因子0.75</strong>的一个空的HashMap。</p>
<p><strong>为什么hashmap的容量为什么要是2的幂？</strong></p>
<p>​		首先，HashMap的初始化的数组长度一定是2的n次的，每次扩容仍是原来的2倍的话，就不会破坏这个规律，每次扩容后，原数据都会进行数据迁移，根据二进制的计算，扩容后数据要么在原来位置，要么在【原来位置+扩容长度】，这样就不需要重新hash，效率上更高。 </p>
<p>​		<strong>HashMap为提高get put效率，减少碰撞。取模算法hash%length ,hashmap将其优化成位运算hash&amp;(length1)，但hash%length等于hash&amp;(length-1)的前提是length是2的n次幂。</strong></p>
<h2 id="关键方法源码解析"><a href="#关键方法源码解析" class="headerlink" title="关键方法源码解析"></a>关键方法源码解析</h2><h3 id="put-方法"><a href="#put-方法" class="headerlink" title="put()方法"></a>put()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">putIfAbsent</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * onlyIfAbsent参数 </span></span><br><span class="line"><span class="comment"> * 		putIfAbsent方法传true，当key已经存在且value不为null时直接返回旧值，不更新</span></span><br><span class="line"><span class="comment"> * 		其他情况传false，key已经存在时更新旧值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="comment">// 临时表量 tab=》table数组，p =》临时node节点， n =》table长度， i =》临时桶下标</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// 判断是否初始化table数组  table为null，长度为0 表示未初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    	<span class="comment">// 调用扩容方法进行初始化，后面扩容部分再分析</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 通过hash码计算出桶下标，该桶位还没有放置元素</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">    	<span class="comment">// 直接构造一个node节点作为首节点</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 该桶位已经有元素了（只有一个node、node链表 或者 红黑树）</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 第一个元素就发生hash冲突</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p; <span class="comment">// 临时变量e暂时指向key值相同的node，后续根据putIfAbsent决定是否替换旧的value值</span></span><br><span class="line">        <span class="comment">// 桶位放置的是红黑树 （TreeNode继承于Node）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">        	<span class="comment">// 红黑树中没有相同的key，插入成功，返回null</span></span><br><span class="line">        	<span class="comment">// 红黑树中已经存在相同的key，临时变量e暂时指向key值相同的node，后续根据putIfAbsent决定是否替换旧的value值</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 链表情况</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="comment">// 遍历链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123; <span class="comment">// 遍历到链表尾部，构造Node 完成插入</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 插入完成后检查链表长度是否超过 8</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                    	<span class="comment">// 尝试树化，树化前要检查table数组的长度是否小于64，小于64时优先扩容</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 遍历链表过程中发生hash冲突，有相同的key</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 直接结束循环，e已经指向了那个key相同的Node</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e; <span class="comment">// e =&gt;遍历的当前节点， p =&gt; 上一个节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// e ==null 没有遇到相同的key，已经完成了插入</span></span><br><span class="line">        <span class="comment">// e != null 遇到相同的key值，统一处理</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value; <span class="comment">// 先保存旧值</span></span><br><span class="line">            <span class="comment">// onlyIfAbsent为false 或者 旧值为空 做更新操作</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e); <span class="comment">// 节点访问后序处理</span></span><br><span class="line">            <span class="keyword">return</span> oldValue; <span class="comment">// Hash冲突，涉及更新操作时，返回旧值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount; <span class="comment">// 插入成功（没有发生更新操作）结构修改次数加1</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold) <span class="comment">// 元素个数超过阈值，触发扩容</span></span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict); <span class="comment">// 节点插入后续处理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;  <span class="comment">// 没有发生hash冲突，插入成功返回null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>调用put方法首先调用了hash方法计算hash值：</p>
<p>这是一个扰动函数，将key的hashCode和该hashCode的高16为进行异或(保证对象的 hashCode 的 32 位值只要有一位发生改变，整个 hash() 返回值就会改变。尽可能的减少碰撞。)计算出hash。会通过hash和当前数组长度-1进行&amp;运算来计算出当前要put的数据放入数组哪个桶中。比如当前我们初始容量16，也就是2的4次方。（16-1）的二进制刚好低4位都是1( 0000 0000 0000 1111)，所以hash&amp;(16-1)刚好就是取低4位。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​			在我们往HashMap插入数据时，首先会通过(n - 1) &amp; hash计算出要插入在数组中的位置，如果该位置还没数据，就直接放入。如果已经有了，那就遍历数组该桶中所有的节点，它们以链表或者红黑树的方式存储。如果在链表中没有找到就创建新节点插入链表尾部，如果找到有相同key的节点，那就替换掉value。插入时如果链表长度大于TREEIFY_THRESHOLD此时链表会转为红黑树。<br>​		每次插入数据后都会判断HashMap的size是否大于阈值（<strong>扩容阈值&#x3D;数组长度*负载因子，元素个数超过这个阈值会触发扩容</strong>），如果大于就会调用resize()方法进行扩容处理，注意size是HashMap中元素数量，扩容是扩容我们数组的长度为原来的两倍。</p>
<h3 id="putTreeVal"><a href="#putTreeVal" class="headerlink" title="putTreeVal"></a>putTreeVal</h3><p>在上述put方法中分过桶之后将元素插入红黑树。：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * map =&gt; HashMap对象</span></span><br><span class="line"><span class="comment"> * tab =&gt; table</span></span><br><span class="line"><span class="comment"> * h =&gt; hash值</span></span><br><span class="line"><span class="comment"> * k =&gt; key</span></span><br><span class="line"><span class="comment"> * v =&gt; value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title function_">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span><br><span class="line"><span class="params">	               <span class="type">int</span> h, K k, V v)</span> &#123;</span><br><span class="line">	Class&lt;?&gt; kc = <span class="literal">null</span>;</span><br><span class="line">	<span class="comment">// 标识是否被搜索过，后面用到再做说明</span></span><br><span class="line">	<span class="type">boolean</span> <span class="variable">searched</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">// 查找根节点, 索引位置的头节点并不一定为红黑树的根节点</span></span><br><span class="line">	TreeNode&lt;K,V&gt; root = (parent != <span class="literal">null</span>) ? root() : <span class="built_in">this</span>;</span><br><span class="line">	<span class="comment">// 根节点赋值给临时变量p，二分查找</span></span><br><span class="line">	<span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">	    <span class="type">int</span> dir, ph; K pk;</span><br><span class="line">	    <span class="comment">// 传入的hash值h小于p节点的hash值，将dir赋值为-1，代表向p的左子树查找</span></span><br><span class="line">	    <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">	        dir = -<span class="number">1</span>;</span><br><span class="line">	    <span class="comment">// 传入的hash值大于p节点的hash值， 将dir赋值为1，代表向p的右子树查找</span></span><br><span class="line">	    <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">	        dir = <span class="number">1</span>;</span><br><span class="line">	    <span class="comment">// 传入的hash值h等于p节点的哈希值，进一步判断key值等于p节点的key值, 如果相等就是找到与要插入的key相同的节点。将这个节点返回，在上层方法中决定是否替换value值</span></span><br><span class="line">	    <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="literal">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">	        <span class="keyword">return</span> p;</span><br><span class="line">	    <span class="comment">/* 走到这里说明hash相同而key不相同， ph == h，pk !=k, k.equals(pk) == false</span></span><br><span class="line"><span class="comment">	     * 这意味着涉及到传入的k于当前节点key值pk之间的比较了</span></span><br><span class="line"><span class="comment">     * 		判断：</span></span><br><span class="line"><span class="comment">	     * 		如果没有实现Comparable&lt;C&gt;接口或者 实现该接口 并且 k与pk Comparable比较结果相同</span></span><br><span class="line"><span class="comment">	     * 		否则就是实现了comparable接口且比较不相等，直接到插入流程</span></span><br><span class="line"><span class="comment">	     */</span></span><br><span class="line">	    <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">	              (kc = comparableClassFor(k)) == <span class="literal">null</span>) ||</span><br><span class="line">	             (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">	        <span class="comment">// 由于要用递归的方式在左右子树中搜索，所以如果已经搜索过，那么把searched设置为true，避免下次循环重复搜索</span></span><br><span class="line">	        <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">	            TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">	            searched = <span class="literal">true</span>;</span><br><span class="line">	            <span class="comment">// 在左右子树递归的寻找 是否有key的hash相同 并且equals相同的节点</span></span><br><span class="line">	            <span class="keyword">if</span> (((ch = p.left) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">	                 (q = ch.find(h, k, kc)) != <span class="literal">null</span>) ||</span><br><span class="line">	                ((ch = p.right) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">	                 (q = ch.find(h, k, kc)) != <span class="literal">null</span>))</span><br><span class="line">	                <span class="comment">// 找到了 就直接返回</span></span><br><span class="line">	                <span class="keyword">return</span> q;</span><br><span class="line">	        &#125;</span><br><span class="line">	        <span class="comment">// 说明红黑树中没有与之equals相等的 那就必须进行插入操作 必须将两个key分出大小 dir的结果必须是-1或1  </span></span><br><span class="line">	        dir = tieBreakOrder(k, pk);</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">	    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 如果dir &lt;= 0</span></span><br><span class="line"><span class="comment">        * 	p.left == null，把要添加的元素作为当前节点的左节点</span></span><br><span class="line"><span class="comment">        * 	p.left != null，p = p.left，下一轮循环</span></span><br><span class="line"><span class="comment">        * 如果dir&gt;0</span></span><br><span class="line"><span class="comment">        * 	p.right == null，把要添加的元素作为当前节点的右节点</span></span><br><span class="line"><span class="comment">        * 	p.right !=null，p = p.right，下一轮循环</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">	    <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="literal">null</span>) &#123;</span><br><span class="line">	    	<span class="comment">// 到这里p已经为null，且xp为p的父节点，至少一个子树是null</span></span><br><span class="line">	        Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">	        <span class="comment">// 创建一个新的树节点，注意这里设置了x.next为xpn，如果xpn不为null，name插入完成后还要设置xpn.prev为x</span></span><br><span class="line">	        TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">	        <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">	            xp.left = x; <span class="comment">// 新节点作为左孩子</span></span><br><span class="line">	        <span class="keyword">else</span></span><br><span class="line">	            xp.right = x; <span class="comment">// 新节点作为右孩子</span></span><br><span class="line">	        <span class="comment">// 维护双链表 并设置新节点的父节点</span></span><br><span class="line">	        xp.next = x; <span class="comment">// xp.next可能之前就有值，暂时保存在xpn中</span></span><br><span class="line">	        x.parent = x.prev = xp;</span><br><span class="line">	        <span class="comment">// 如果原来的xp.next，即xpn节点不为空时，下面操作相当于把xpn接在了x后面</span></span><br><span class="line">	        <span class="keyword">if</span> (xpn != <span class="literal">null</span>) <span class="comment">//  新节点覆盖了之前xp.next 的值</span></span><br><span class="line">	        	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	        	 * 原来的xp.next 是 xpn</span></span><br><span class="line"><span class="comment">	        	 * 现在xp.next是x，x.prev 是 xp，xpn.prev 是 x，x.next早在创建x时就设置为xpn了</span></span><br><span class="line"><span class="comment">	            ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span></span><br><span class="line"><span class="comment">	        // balanceInsertion 重新平衡</span></span><br><span class="line"><span class="comment">	        // 经过平衡，根节点可能已经过改变，为了查询方便需要把新的根节点放到table数组桶上</span></span><br><span class="line"><span class="comment">	        moveRootToFront(tab, balanceInsertion(root, x));</span></span><br><span class="line"><span class="comment">	        return null;</span></span><br><span class="line"><span class="comment">	    &#125;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="resize-扩容算法："><a href="#resize-扩容算法：" class="headerlink" title="resize()扩容算法："></a>resize()扩容算法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes or doubles table size.  If null, allocates in</span></span><br><span class="line"><span class="comment"> * accord with initial capacity target held in field threshold.</span></span><br><span class="line"><span class="comment"> * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class="line"><span class="comment"> * elements from each bin must either stay at same index, or move</span></span><br><span class="line"><span class="comment"> * with a power of two offset in the new table.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">	<span class="comment">// 临时变量接收旧table</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// 旧table的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">// 旧table触发扩容的阈值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="comment">// 新数组的长度和阈值都先给0</span></span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// oldCap等于0表示初始化时调用resize，大于0就是扩容场景</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="comment">// 数组长度不能超过最大值 1 &lt;&lt; 30</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        	<span class="comment">// 阈值给大，防止再次触发扩容</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab; <span class="comment">// 直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 新数组长度乘2后不超过数组的最大值 且 旧数组长度大于等于16</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold 阈值翻倍</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * oldCap 等于0  初始化table场景</span></span><br><span class="line"><span class="comment">     * 在构造函数没有给定数组大小的情况下 threshold为int类型的默认值0</span></span><br><span class="line"><span class="comment">     * 在构造函数给出数组长度的情况下 threshold暂时存储计算出来的数组长度</span></span><br><span class="line"><span class="comment">     * 对应的构造函数</span></span><br><span class="line"><span class="comment">     * 		HashMap(int initialCapacity)</span></span><br><span class="line"><span class="comment">     * 		HashMap(int initialCapacity, float loadFactor)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr; <span class="comment">// 初始化前threshold存的是计算的数组长度</span></span><br><span class="line">    <span class="comment">// oldThr 等于0 对应无参构造 数组长度用默认19，阈值使用16*0.75 = 12</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 1. 旧数组长度不到16时触发扩容的场景</span></span><br><span class="line"><span class="comment">     * 2. 构造函数中给出initialCapacity时初始化table场景</span></span><br><span class="line"><span class="comment">     * 以上两个场景需要单独计算新的扩容阈值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="comment">// 数组长度*负载因子</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        <span class="comment">// 判断是否到达数组长度的上限，如果到达上限直接把扩容阈值给最大值Integer.MAX_VALUE，防止再次触发扩容</span></span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr; <span class="comment">// 接收临时变量计算好的值</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    <span class="comment">// 扩容/初始化正式开始</span></span><br><span class="line">    <span class="comment">// 构建table数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab; <span class="comment">// 赋值给table成员变量，到此初始化完成</span></span><br><span class="line">    <span class="comment">// 扩容</span></span><br><span class="line">    <span class="comment">// oldTab == null为初始化场景，不执行if块里的代码</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">    	<span class="comment">// 遍历旧数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">// 桶位不为空</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">            	<span class="comment">// 临时变量e已经接收了这个同为的值，原来桶位置null，方便GC</span></span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 情况1 只有一个元素，则放到新数组对应下标的桶位即可</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 情况2 e是红黑树的头结点</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                	<span class="comment">// 数据迁移，后面分析</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">// 情况三 e是链表头结点</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                	<span class="comment">// 低链头结点、低链尾结点</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">    				<span class="comment">// 高链头结点、高链尾结点</span></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 低链：loHead =&gt; e1 -&gt; e2 -&gt;...-&gt; en &lt;= loTail </span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 高链：hiHead =&gt; e1 -&gt; e2 -&gt;...-&gt; en &lt;= hiTail</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>); <span class="comment">// 遍历到null为止</span></span><br><span class="line"></span><br><span class="line">					<span class="comment">/*</span></span><br><span class="line"><span class="comment">					 * 两个链表放到新数组对应的桶位，loHead和loTail只是收尾节点的引用，方法执行完生命周期结束 </span></span><br><span class="line"><span class="comment">					 * 		loHead =&gt; e1 -&gt; e2 -&gt;...-&gt; en &lt;= loTail </span></span><br><span class="line"><span class="comment">					 * 		newTab[j] -&gt; e1 -&gt; e2 -&gt;...-&gt; en</span></span><br><span class="line"><span class="comment">					 *  </span></span><br><span class="line"><span class="comment">					 * 		hiHead =&gt; e1 -&gt; e2 -&gt;...-&gt; en &lt;= hiTail</span></span><br><span class="line"><span class="comment">					 * 		newTab[j + oldCap]-&gt; e1 -&gt; e2 -&gt;...-&gt; en</span></span><br><span class="line"><span class="comment">					 */</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        <span class="comment">// 低链桶下标不变</span></span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        <span class="comment">// 高链桶下标加旧数组的容量</span></span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​		以table长度16扩容到32为例，如图，当hash码后四位为1111时，和数组长度N-1进行与操作(N-1) &amp; hash得到的下标都是(16-1) &amp; hash &#x3D; 15，扩容后这个链表的元素重新计算下标(32-1) &amp; hash，此时hash码的第五位参与计算，得到下标有两种情况：</p>
<p>hash码第五位为0时，下标不变，还是15，这些元素组成新的链表（低链），在新数组中桶下标不变<br>hash码第五位为1时，下标需要加上旧数组的长度16，等于31，这些元素组成新的链表（高链），在新数组中的桶下标加在原来的基础上加原数组的长度</p>
<p>​		HashMap扩容时如果数组上的元素是单个元素没有hash冲突就直接用hashcode值与上新数组的长度重新得到hashcode值放入新链表中。如果当前位置是hash冲突的不管是<strong>链表还是红黑树上的值</strong>都通过hash &amp; <strong>旧数组长度</strong>计算得到高低链，然后分别将链表放入新的桶位中，比如：</p>
<p>…01111 &amp; 1000 &#x3D;&#x3D; 0 node放到低链<br>…11111 &amp; 1000 !&#x3D; 0 node放到高链<br>其中红黑树完成两个链表的转移之后还要进一步判断数否需要树化（拆分后的两个链表长度还有可能大于8）</p>
<p><img src="/2022/09/21/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/blog\source_posts\HashMap源码分析\4.jpg"></p>
<h3 id="get、replace方法"><a href="#get、replace方法" class="headerlink" title="get、replace方法"></a>get、replace方法</h3><p>get和replace都走的是getNode方法，代码很简单(1)、先调用k的hashCode()方法得出哈希值，并通过哈希算法转换成数组的下标。 (2)、在通过数组下标快速定位到某个位置上。重点理解如果这个位置上什么都没有，则返回null。如果这个位置上有单向链表，那么它就会拿着参数K和单向链表上的每一个节点的K进行equals，如果所有equals方法都返回false，则get方法返回null。如果其中一个节点的K和参数K进行equals返回true，那么此时该节点的value就是我们要找的value了，get方法最终返回这个要找的value。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心方法：getNode</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 核心方法：getNode</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">replace</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">        e.value = value;</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="comment">// 校验table并确定桶下标</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 总是会判断第一个是不是目标，正好是就返回首节点</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 判断有没有第二个，没有就返回null，有就区分链表和红黑树两种场景找目标节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 红黑树调用getTreeNode</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123; <span class="comment">// 链表，利用next指针依次迭代</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h3><p>删除节点就是在查找节点的基础上将查找到的节点直接删除就行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object key, Object value)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> removeNode(hash(key), key, value, <span class="literal">true</span>, <span class="literal">true</span>) != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.remove and related methods.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash key的hash值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 要删除的元素的key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 要删除的元素的value，matchValue参数为true时提供，元素的值匹配上才能删除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> matchValue 是否值匹配才删除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> movable 删除后是否移动节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回删除的节点，删除失败返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,</span></span><br><span class="line"><span class="params">                           <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, index;</span><br><span class="line">    <span class="comment">// 先查</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="literal">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">// 老套路了，先看首节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p; <span class="comment">// 从这里直接跳到删除逻辑，在删除逻辑中通过 node == p 判断是不是删除的首节点 </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果没找到目标节点，下一次循环 p.next == e</span></span><br><span class="line">                    <span class="comment">// 如果找到了node，则 p.next == e, 同时p.next == node，这个关系用在删除逻辑中</span></span><br><span class="line">                    p = e; </span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 查到的目标节点node</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 再删</span></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 如果不需要匹配value，直接删除</span></span><br><span class="line"><span class="comment">		 * 如果需要匹配value，“==” 或者 equals了才删</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            	<span class="comment">/* 走红黑树删除流程，movable参数表示删除后是否移动节点</span></span><br><span class="line"><span class="comment">            	 * 参数this代指HashMap对象</span></span><br><span class="line"><span class="comment">            	 * 为什么参数中不传递要删除的元素node  QAQ</span></span><br><span class="line"><span class="comment">            	 * 因为是这样node.removeTreeNode调用的，所以在removeTreeNode里面this就是要删除的节点了</span></span><br><span class="line"><span class="comment">            	 */</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="built_in">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p) <span class="comment">// 要删除的节点node是首节点</span></span><br><span class="line">                tab[index] = node.next; <span class="comment">// 将node.next作为首节点，方法执行完node指向的对象进入GC</span></span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//  删除前 p.next == node，删除后 p.next == node.next，方法执行完node指向的对象进入GC</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="treeifyBin树化方法"><a href="#treeifyBin树化方法" class="headerlink" title="treeifyBin树化方法"></a>treeifyBin树化方法</h3><p>table某个桶位node链表长度超过8时，会调用treeifyBin，检查table数组长度达到64的情况下，先把原来的单链表结构变成了双链表结构，然后调用TreeNode::treeify(table)进行树化。红黑树的结构同时维持着双链表的结构，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * tab：table数组</span></span><br><span class="line"><span class="comment"> * hash：hash值（增加的键值对的key的hash值）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// table数组长度不到64时，优先进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 获取首节点，判断不为空</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">    	<span class="comment">// 定义头结点head和尾结点tail</span></span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// do-while循环 将把Node对象转换成了TreeNode对象，把单向链表转换成了双向链表:</span></span><br><span class="line">        <span class="comment">// hd =&gt; p1 &lt;=&gt; p2 &lt;=&gt; ... &lt;=&gt; pn &lt;= tl </span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">        	<span class="comment">// 将该Node节点转换为TreeNode节点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 把转换后的双向链表，替换原来位置上的单向链表</span></span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">            hd.treeify(tab);<span class="comment">// 双向链表转红黑树，后面分析</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将该Node节点转换为TreeNode节点</span></span><br><span class="line">TreeNode&lt;K,V&gt; <span class="title function_">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结单链表变为双链表：</p>
<ul>
<li>首先将Node节点转换为TreeNode节点，TreeNode节点中的next和prev分别维护双向链表的两个指针</li>
<li>hd和tl分别指的是双向链表头尾两个节点的引用，给tl赋值prev和next，就等于赋值最后一个节点赋值。</li>
<li>方法执行完hd和tl作为局部变量生命周期结束，双链表的头结点的地址放在了table的对应桶位tab[index] &#x3D; hd</li>
</ul>
<h3 id="treeify"><a href="#treeify" class="headerlink" title="treeify"></a>treeify</h3><p>将双链表转化为红黑树：(源码参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42410658/article/details/121957690">https://blog.csdn.net/weixin_42410658/article/details/121957690</a>)</p>
<p>treeify的作用域是TreeNode类，调用它必然是<code>TreeNode对象.treeify</code>，<strong>那么这个方法内部的this就指代这个TreeNode对象</strong>。<br>调用链表<code>首节点.treeify</code>，<strong>则this就指代首节点了</strong>，后续节点用next指针迭代就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Forms tree of the nodes linked from this node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> &#123;</span><br><span class="line">	<span class="comment">// 定义树的根节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; root = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 遍历链表，x当前节点，this为首节点，next下一个节点</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="built_in">this</span>, next; x != <span class="literal">null</span>; x = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">        <span class="comment">// 某个桶位扩容前是红黑树，扩容后还是红黑树的情况下，x的左右子树不为null。</span></span><br><span class="line">        x.left = x.right = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 第一次循环还没有设置根节点</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            x.parent = <span class="literal">null</span>; <span class="comment">// 根节点没有父节点</span></span><br><span class="line">            x.red = <span class="literal">false</span>; <span class="comment">// 根节点一定是得是黑色</span></span><br><span class="line">            root = x; <span class="comment">// 设置根节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第二次以后的循环已经存在根节点了</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="comment">// 获取当前链表节点的key和hash值</span></span><br><span class="line">            <span class="type">K</span> <span class="variable">k</span> <span class="operator">=</span> x.key;</span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> x.hash;</span><br><span class="line">            <span class="comment">// 定义当前链表节点key的运行时类型</span></span><br><span class="line">            Class&lt;?&gt; kc = <span class="literal">null</span>; </span><br><span class="line">            <span class="comment">// 遍历插入红黑树</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">            	<span class="comment">// dir 插入方向, ph 当前树节点的hash值</span></span><br><span class="line">                <span class="type">int</span> dir, ph;</span><br><span class="line">                <span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key; <span class="comment">// pk 当前树节点的key</span></span><br><span class="line">                <span class="comment">// 如果当前树节点hash值 &gt; 当前链表节点的hash值</span></span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    dir = -<span class="number">1</span>; <span class="comment">// 标识向左树插入</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>;  <span class="comment">// 右树</span></span><br><span class="line">                <span class="comment">/* ph = h，hash值相等 做以下判断（PS：和putTreeVal过程不同的是，这里不用判断key是否相等，因为已经形成链表了，key必然不会相等了）</span></span><br><span class="line"><span class="comment">                 * 	kc == null &amp;&amp;(kc = comparableClassFor(k)) == null)</span></span><br><span class="line"><span class="comment">                 * 		true：当前链表节点的key没有实现comparable，直接执行dir = tieBreakOrder(k, pk);</span></span><br><span class="line"><span class="comment">                 * 		false：实现了comparable接口，执行 || 后面的表达式</span></span><br><span class="line"><span class="comment">                 * 	dir = compareComparables(kc, k, pk)) == 0</span></span><br><span class="line"><span class="comment">                 * 		true：通过compareTo比较大小，结果为0，没办法确定dir正负值，执行dir = tieBreakOrder(k, pk);</span></span><br><span class="line"><span class="comment">                 * 		false：已经确定dir的正负值，即确定了插入左边还是右边</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="literal">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line">				<span class="comment">// 插入逻辑，之前分析过了</span></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    x.parent = xp;</span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    <span class="comment">// 每插入一个元素就重新平衡，然后返回平衡后的根节点</span></span><br><span class="line">                    root = balanceInsertion(root, x);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 目前放在table数组桶上的是链表的第一个节点，经过多次平衡这个节点很有可能不是root节点了，为了查询方便需要把root节点放到table数组桶上</span></span><br><span class="line">    moveRootToFront(tab, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HashMap判断元素相等原理"><a href="#HashMap判断元素相等原理" class="headerlink" title="HashMap判断元素相等原理"></a>HashMap判断元素相等原理</h2><p>​		Object类中的equals方法和“&#x3D;&#x3D;”是一样的，没有区别，即俩个对象的比较是比较他们的<strong>栈内存中存储的内存地址</strong>。而String类，Integer类等等一些类，是<strong>重写了equals方法</strong>，才使得equals和“&#x3D;&#x3D;不同”，他们比较的是<strong>值相等</strong>。所以，当自己创建类时，自动继承了Object的equals方法，要想实现不同的等于比较，必须重写equals方法。所以基本数据类型使用“&#x3D;&#x3D;”，包装数据类型使用equals方法。</p>
<h3 id="HashCode原理"><a href="#HashCode原理" class="headerlink" title="HashCode原理"></a>HashCode原理</h3><p>​		 Object中的hashCode方法返回的是对象本地内存地址的换算结果，不同的实例对象的hashCode是不相同的。</p>
<p>​		<strong>同一个对象多次调用 hashCode() 方法应该返回相同的值。</strong></p>
<p>​		<strong>如果两个对象相同，那么它们的hashCode值一定要相同。</strong>也告诉我们重写equals方法，一定要重写hashCode方法，也就是说hashCode值要和类中的成员变量挂上钩，对象相同-&gt;成员变量相同—-&gt;hashCode值一定相同。</p>
<p>​		如果两个对象的hashCode相同，它们并不一定相同，这里的对象相同指的是用eqauls方法比较。</p>
<p>如重写一个包含id name字段的user的equals方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较同一个类型对象, 值是否一致:</span></span><br><span class="line">    <span class="comment">//一致返回 true</span></span><br><span class="line">    <span class="comment">//不一致返回 false</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;   <span class="comment">//返回true 表示对象一致,新增失败！</span></span><br><span class="line">    <span class="comment">//比较对象地址是否一致</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//判断当前对象是否为 null 或 类型一致...</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//获取对象, 比较id name 属性是否一致....</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) o;</span><br><span class="line">    <span class="keyword">if</span> (id != user.id) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> name != <span class="literal">null</span> ? name.equals(user.name) : user.name == <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同一个类型, 相同值,调用该方法返回相同的hash值！</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;         <span class="comment">//idea hashCode生成！</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> id;</span><br><span class="line">    result = <span class="number">31</span> * result + (name != <span class="literal">null</span> ? name.hashCode() : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		在Set和Map中新添加元素的时候，随着容器中节点数量的增多不可能每次增加一个元素都与其他所有的元素两两判断是不是相等，然后再插入，而是先计算该对象的hashcode，根据hashcode来找到当前元素放置的位置，因为相同的对象肯定必须要有相同的hashcode，如果产生了hash冲突，就使用equals比较两个元素是否相等，怎样就不用两两比较。</p>
<h3 id="重写的hashcode算法引起的内存泄漏"><a href="#重写的hashcode算法引起的内存泄漏" class="headerlink" title="重写的hashcode算法引起的内存泄漏"></a>重写的hashcode算法引起的内存泄漏</h3><p>​		将HashSet中的对象进行删除前，改变了该对象实例域的值，而当前对象计算hashcode的算法有对象的成员变量参与，这样在修改了实例域之后，对象的hashcode改变了，但是对象仍然是放置在原来的位置，并没有更新到新hashcode的位置上，所以当我们用新的hashcode去找该元素去删除它的时候肯定就找不到了。</p>
<p>​		所以如果我们将对象的属性值参与了hashCode的运算中，。在进行删除的时候，就不能对其属性值进行修改。</p>
<h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><p>​		Hashtable是通过”拉链法”实现的哈希表。它包括几个重要的成员变量：table, count, threshold, loadFactor, modCount。</p>
<ul>
<li>table是一个 Entry[] 数组类型，而 Entry（在 HashMap 中有讲解过）实际上就是一个单向链表。哈希表的”key-value键值对”都是存储在Entry数组中的。</li>
<li>count 是 Hashtable 的大小，它是 Hashtable 保存的键值对的数量。</li>
<li>threshold 是 Hashtable 的阈值，用于判断是否需要调整 Hashtable 的容量。threshold 的值&#x3D;”容量*加载因子”。</li>
<li>loadFactor 就是加载因子。</li>
<li>modCount 是用来实现 fail-fast 机制的。</li>
</ul>
<p>​		HashTable的结构和HashMap的结构是差不多的。HashTable中没有引进红黑树。所有的冲突Entry都是通过链表保存的。</p>
<p><img src="/2022/09/21/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/blog\source_posts\HashMap源码分析\5.jpg"></p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>Hashtable 一共提供了 4 个构造方法：</p>
<ul>
<li><code>public Hashtable(int initialCapacity, float loadFactor)</code>： 用指定初始容量和指定加载因子构造一个新的空哈希表。useAltHashing 为 boolean，其如果为真，则执行另一散列的字符串键，以减少由于弱哈希计算导致的哈希冲突的发生。</li>
<li><code>public Hashtable(int initialCapacity)</code>：用指定初始容量和默认的加载因子 (0.75) 构造一个新的空哈希表。</li>
<li><code>public Hashtable()</code>：默认构造函数，容量为 11，加载因子为 0.75。</li>
<li><code>public Hashtable(Map&lt;? extends K, ? extends V&gt; t)</code>：构造一个与给定的 Map 具有相同映射关系的新哈希表。</li>
</ul>
<h3 id="HashMap，LinkedHashMap，TreeMap-的区别"><a href="#HashMap，LinkedHashMap，TreeMap-的区别" class="headerlink" title="HashMap，LinkedHashMap，TreeMap 的区别"></a>HashMap，LinkedHashMap，TreeMap 的区别</h3><p>HashMap</p>
<p>LinkedHashMap 保存了记录的插入顺序，在用 Iterator 遍历时，先取到的记录肯定是先插入的；遍历比 HashMap 慢；</p>
<p>TreeMap 实现 SortMap 接口，能够把它保存的记录根据键排序（默认按键值升序排序，也可以指定排序的比较器）</p>
<h3 id="HashMap-和-HashTable-的区别。"><a href="#HashMap-和-HashTable-的区别。" class="headerlink" title="HashMap 和 HashTable 的区别。"></a>HashMap 和 HashTable 的区别。</h3><p>①、HashMap 是线程不安全的，HashTable 是线程安全的；</p>
<p>②、由于线程安全，所以 HashTable 的效率比不上 HashMap；</p>
<p>③、HashMap最多只允许一条记录的键为null，允许多条记录的值为null，而 HashTable不允许；</p>
<p>④、HashMap 默认初始化数组的大小为16，HashTable 为 11，前者扩容时，扩大两倍，后者扩大两倍+1；</p>
<p>⑤、HashMap 需要重新计算 hash 值，而 HashTable 直接使用对象的 hashCode</p>
<h3 id="ConcurrentHashMap-与-HashTable-效率比较"><a href="#ConcurrentHashMap-与-HashTable-效率比较" class="headerlink" title="ConcurrentHashMap 与 HashTable 效率比较"></a>ConcurrentHashMap 与 HashTable 效率比较</h3><p>HashTable 使用一把锁（锁住整个链表结构）处理并发问题，多个线程竞争一把锁，容易阻塞；</p>
<p>ConcurrentHashMap</p>
<ul>
<li><p>JDK 1.7 中使用分段锁（ReentrantLock + Segment + HashEntry），相当于把一个 HashMap 分成多个段，每段分配一把锁，这样支持多线程访问。锁粒度：基于 Segment，包含多个 HashEntry。</p>
</li>
<li><p>JDK 1.8 中使用 CAS + synchronized + Node + 红黑树。锁粒度：Node（首结</p>
<p>点）（实现 Map.Entry）。锁粒度降低了。</p>
</li>
</ul>
<h2 id="HashMap与HashSet的联系与区别"><a href="#HashMap与HashSet的联系与区别" class="headerlink" title="HashMap与HashSet的联系与区别"></a>HashMap与HashSet的联系与区别</h2><p>通过查看hashset的add方法源码可以发现hashset采用的是map存储结构，通过一个HashMap存储元素，元素是存放在HashMap的Key中，而Value统一使用一个Object对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>区别是：</p>
<p>1.HashMap实现了Map接口，而HashSet实现了Set接口。</p>
<p>2.HashMap用于存储键值对，而HashSet用于存储对象。</p>
<p>3.HashMap不允许有重复的键，可以允许有重复的值。HashSet不允许有重复元素。</p>
<p>4.HashMap允许有一个键为空，多个值为空，HashSet允许有一个空值。</p>
<p>5.HashMap中使用put()将元素加入map中，而HashSet使用add()将元素放入set中。</p>
<p>6.HashMap比较快，因为其使用唯一的键来获取对象。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/HashMap%E6%BA%90%E7%A0%81/" rel="tag"># HashMap源码</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/09/20/List%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="prev" title="List源码分析">
                  <i class="fa fa-chevron-left"></i> List源码分析
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/09/23/Spring%E4%BB%8B%E7%BB%8D/" rel="next" title="Spring介绍">
                  Spring介绍 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jing</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
