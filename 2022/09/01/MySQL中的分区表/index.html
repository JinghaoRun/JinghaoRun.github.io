<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="分区概述 分区是一种表的设计模式。分区功能并不是在存储引擎层完成的，因此不只有InnoDB存储引擎支持分区。 分区的过程是将一个表或索引分解为多个更小、更可管理的部分。就访问数据库的应用而言，从逻辑上讲，只有一个表或一个索引，但是在物理上这个表或索引可能由数十个物理分区组成。每个分区都是独立的对象，可以独自处理，也可以作为一个更大对象的一部分进行处理。 MySQL数据库支持的分区类型为水平分区（分">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL中的分区表">
<meta property="og:url" content="http://example.com/2022/09/01/MySQL%E4%B8%AD%E7%9A%84%E5%88%86%E5%8C%BA%E8%A1%A8/index.html">
<meta property="og:site_name" content="WangHao&amp;博客">
<meta property="og:description" content="分区概述 分区是一种表的设计模式。分区功能并不是在存储引擎层完成的，因此不只有InnoDB存储引擎支持分区。 分区的过程是将一个表或索引分解为多个更小、更可管理的部分。就访问数据库的应用而言，从逻辑上讲，只有一个表或一个索引，但是在物理上这个表或索引可能由数十个物理分区组成。每个分区都是独立的对象，可以独自处理，也可以作为一个更大对象的一部分进行处理。 MySQL数据库支持的分区类型为水平分区（分">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://note.youdao.com/yws/api/personal/file/WEB3d44d8cb323f888375f47066d09c2847?method=download&shareKey=09849fae1e53e5fe3e26dfe3bdaad8a3">
<meta property="og:image" content="https://note.youdao.com/yws/api/personal/file/9272F49427F34BFCAF5E40F6ED25B94C?method=download&shareKey=09849fae1e53e5fe3e26dfe3bdaad8a3">
<meta property="article:published_time" content="2022-09-01T13:56:55.000Z">
<meta property="article:modified_time" content="2022-09-02T01:46:38.858Z">
<meta property="article:author" content="Jing">
<meta property="article:tag" content="MySQL中的分区表">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://note.youdao.com/yws/api/personal/file/WEB3d44d8cb323f888375f47066d09c2847?method=download&shareKey=09849fae1e53e5fe3e26dfe3bdaad8a3">


<link rel="canonical" href="http://example.com/2022/09/01/MySQL%E4%B8%AD%E7%9A%84%E5%88%86%E5%8C%BA%E8%A1%A8/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2022/09/01/MySQL%E4%B8%AD%E7%9A%84%E5%88%86%E5%8C%BA%E8%A1%A8/","path":"2022/09/01/MySQL中的分区表/","title":"MySQL中的分区表"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>MySQL中的分区表 | WangHao&博客</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">WangHao&博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Welcome to the home of WangHao</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">分区概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text">分区类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RANGE-%E5%88%86%E5%8C%BA"><span class="nav-number">2.1.</span> <span class="nav-text">RANGE 分区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LIST-%E5%88%86%E5%8C%BA"><span class="nav-number">2.2.</span> <span class="nav-text">LIST 分区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HASH%E5%88%86%E5%8C%BA"><span class="nav-number">2.3.</span> <span class="nav-text">HASH分区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KEY%E5%88%86%E5%8C%BA"><span class="nav-number">2.4.</span> <span class="nav-text">KEY分区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#COLUMNS%E5%88%86%E5%8C%BA"><span class="nav-number">2.5.</span> <span class="nav-text">COLUMNS分区</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%90%E5%88%86%E5%8C%BA"><span class="nav-number">3.</span> <span class="nav-text">子分区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E4%B8%AD%E7%9A%84NULL%E5%80%BC"><span class="nav-number">4.</span> <span class="nav-text">分区中的NULL值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E7%9A%84%E6%80%A7%E8%83%BD"><span class="nav-number">5.</span> <span class="nav-text">分区的性能</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jing"
      src="/images/head.jpg">
  <p class="site-author-name" itemprop="name">Jing</p>
  <div class="site-description" itemprop="description">Stay hungry,stay foolish</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">91</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">104</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/01/MySQL%E4%B8%AD%E7%9A%84%E5%88%86%E5%8C%BA%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="Jing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WangHao&博客">
      <meta itemprop="description" content="Stay hungry,stay foolish">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="MySQL中的分区表 | WangHao&博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MySQL中的分区表
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-09-01 21:56:55" itemprop="dateCreated datePublished" datetime="2022-09-01T21:56:55+08:00">2022-09-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-02 09:46:38" itemprop="dateModified" datetime="2022-09-02T09:46:38+08:00">2022-09-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">MySQL数据库</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="分区概述"><a href="#分区概述" class="headerlink" title="分区概述"></a>分区概述</h2><ul>
<li>分区是一种表的设计模式。分区功能并不是在存储引擎层完成的，因此不只有InnoDB存储引擎支持分区。</li>
<li>分区的过程是将一个表或索引分解为多个更小、更可管理的部分。就访问数据库的应用而言，从逻辑上讲，只有一个表或一个索引，但是在物理上这个表或索引可能由数十个物理分区组成。每个分区都是独立的对象，可以独自处理，也可以作为一个更大对象的一部分进行处理。</li>
<li>MySQL数据库支持的分区类型为水平分区（分行），并不支持垂直分区（分列）。此外，MySQL数据库的分区是局部分区索引，一个分区中既存放数据又存放索引。全局分区是指，数据存放各个分区中，但是所有数据的索引放在一个对象中。目前，MySQL数据库暂时不支持全局分区。</li>
</ul>
<span id="more"></span>

<h2 id="分区类型"><a href="#分区类型" class="headerlink" title="分区类型"></a>分区类型</h2><p>当前MySQL数据库支持以下几种类型的分区：</p>
<ul>
<li>RANGE分区：行数据基于属于一个给定<strong>连续</strong>区间的列值放入分区。</li>
<li>LIST分区：和RANGE分区类型一样，只是LIST分区面向的是<strong>离散</strong>的值。</li>
<li>HASH分区：根据<strong>用户自定义的表达式</strong>来进行分区，返回值不能为负数。</li>
<li>KEY分区：根据<strong>MySQL数据库提供的散列函数</strong>来进行分区。</li>
<li>COLUMNS分区：前面四种分区的条件必须是整型（integer），如果不是整型，那么需要通过函数将其转化为整型。MySQL 5.5版本开始支持COLUMNS分区，可视为对RANGE分区和LIST分区的一种进化。COLUMNS分区<strong>可以直接使用非整型的数据进行分区，分区根据类型直接比较而得到，不需要转化为整型</strong>。此外，RANGE COLUMNS分区可以对多个列的值进行分区。</li>
</ul>
<p>不论创建何种类型的分区，如果表中存在主键或唯一索引时，分区列必须是唯一索引的一个组成部分。也就是说如果唯一索引为 <code>UNIQUE KEY (col1, col2)</code>，那么分区列必须为col1 或者 col2。接下来详细介绍这四种分区。</p>
<h3 id="RANGE-分区"><a href="#RANGE-分区" class="headerlink" title="RANGE 分区"></a>RANGE 分区</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+------------+----------------------------------------------------------------+</span><br><span class="line">| Table      | Create Table                                                   |</span><br><span class="line">+------------+----------------------------------------------------------------+</span><br><span class="line">| parti_test | CREATE TABLE `parti_test` (</span><br><span class="line">  `id` int DEFAULT NULL</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=gbk</span><br><span class="line">/*!50100 PARTITION BY RANGE (`id`)</span><br><span class="line">(PARTITION p0 VALUES LESS THAN (10) ENGINE = InnoDB,</span><br><span class="line"> PARTITION p1 VALUES LESS THAN (20) ENGINE = InnoDB,</span><br><span class="line"> PARTITION p2 VALUES LESS THAN MAXVALUE ENGINE = InnoDB) */ |</span><br><span class="line">+------------+----------------------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>例如上面这个表，就是一种RANGE分区，我们按照 id 列分成了p0，p1，p2三个区，在磁盘的物理文件中我们的确发现了三个文件，也就是说这个表在物理层面被拆分成了三个子表，代表三个分区。<br><img src="https://note.youdao.com/yws/api/personal/file/WEB3d44d8cb323f888375f47066d09c2847?method=download&shareKey=09849fae1e53e5fe3e26dfe3bdaad8a3" alt="img"><br>接下来我们插入数据9, 10,15, 21，由于表根据列id进行分区，因此数据根据id列值的范围存放在不同的物理文件中，我们可以通过explain的partitons信息查看所查询的数据位于哪个分区。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from parti_test;</span><br><span class="line">+------+</span><br><span class="line">| id   |</span><br><span class="line">+------+</span><br><span class="line">|    9 |</span><br><span class="line">|   15 |</span><br><span class="line">|   10 |</span><br><span class="line">|   21 |</span><br><span class="line">+------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from parti_test;</span><br><span class="line">+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">| id | select_type | table      | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |</span><br><span class="line">+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | parti_test | p0,p1,p2   | ALL  | NULL          | NULL | NULL    | NULL |    4 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from parti_test where id&lt;10;</span><br><span class="line">+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table      | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | parti_test | p0         | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | Using where |</span><br><span class="line">+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from parti_test where id&gt;=10 and id&lt;20;</span><br><span class="line">+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table      | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | parti_test | p1         | ALL  | NULL          | NULL | NULL    | NULL |    2 |    50.00 | Using where |</span><br><span class="line">+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from parti_test where id&gt;=20;</span><br><span class="line">+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table      | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | parti_test | p2         | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | Using where |</span><br><span class="line">+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>我们还可以通过查询information_schema架构下的PARTITIONS表来查看每个分区的具体信息，执行的语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from information_schema.PARTITIONS WHERE table_schema=database() AND table_name=&#x27;parti_test&#x27;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">                TABLE_CATALOG: def</span><br><span class="line">                 TABLE_SCHEMA: dbtest</span><br><span class="line">                   TABLE_NAME: parti_test</span><br><span class="line">               PARTITION_NAME: p0</span><br><span class="line">            SUBPARTITION_NAME: NULL</span><br><span class="line">   PARTITION_ORDINAL_POSITION: 1</span><br><span class="line">SUBPARTITION_ORDINAL_POSITION: NULL</span><br><span class="line">             PARTITION_METHOD: RANGE</span><br><span class="line">          SUBPARTITION_METHOD: NULL</span><br><span class="line">         PARTITION_EXPRESSION: `id`</span><br><span class="line">      SUBPARTITION_EXPRESSION: NULL</span><br><span class="line">        PARTITION_DESCRIPTION: 10</span><br><span class="line">                   TABLE_ROWS: 1</span><br><span class="line">               AVG_ROW_LENGTH: 16384</span><br><span class="line">                  DATA_LENGTH: 16384</span><br><span class="line">              MAX_DATA_LENGTH: 0</span><br><span class="line">                 INDEX_LENGTH: 0</span><br><span class="line">                    DATA_FREE: 0</span><br><span class="line">                  CREATE_TIME: 2021-04-26 12:45:21</span><br><span class="line">                  UPDATE_TIME: 2021-05-09 10:08:14</span><br><span class="line">                   CHECK_TIME: NULL</span><br><span class="line">                     CHECKSUM: NULL</span><br><span class="line">            PARTITION_COMMENT:</span><br><span class="line">                    NODEGROUP: default</span><br><span class="line">              TABLESPACE_NAME: NULL</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">                TABLE_CATALOG: def</span><br><span class="line">                 TABLE_SCHEMA: dbtest</span><br><span class="line">                   TABLE_NAME: parti_test</span><br><span class="line">               PARTITION_NAME: p1</span><br><span class="line">            SUBPARTITION_NAME: NULL</span><br><span class="line">   PARTITION_ORDINAL_POSITION: 2</span><br><span class="line">SUBPARTITION_ORDINAL_POSITION: NULL</span><br><span class="line">             PARTITION_METHOD: RANGE</span><br><span class="line">          SUBPARTITION_METHOD: NULL</span><br><span class="line">         PARTITION_EXPRESSION: `id`</span><br><span class="line">      SUBPARTITION_EXPRESSION: NULL</span><br><span class="line">        PARTITION_DESCRIPTION: 20</span><br><span class="line">                   TABLE_ROWS: 2</span><br><span class="line">               AVG_ROW_LENGTH: 8192</span><br><span class="line">                  DATA_LENGTH: 16384</span><br><span class="line">              MAX_DATA_LENGTH: 0</span><br><span class="line">                 INDEX_LENGTH: 0</span><br><span class="line">                    DATA_FREE: 0</span><br><span class="line">                  CREATE_TIME: 2021-04-26 12:45:21</span><br><span class="line">                  UPDATE_TIME: 2021-05-09 10:08:20</span><br><span class="line">                   CHECK_TIME: NULL</span><br><span class="line">                     CHECKSUM: NULL</span><br><span class="line">            PARTITION_COMMENT:</span><br><span class="line">                    NODEGROUP: default</span><br><span class="line">              TABLESPACE_NAME: NULL</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">                TABLE_CATALOG: def</span><br><span class="line">                 TABLE_SCHEMA: dbtest</span><br><span class="line">                   TABLE_NAME: parti_test</span><br><span class="line">               PARTITION_NAME: p2</span><br><span class="line">            SUBPARTITION_NAME: NULL</span><br><span class="line">   PARTITION_ORDINAL_POSITION: 3</span><br><span class="line">SUBPARTITION_ORDINAL_POSITION: NULL</span><br><span class="line">             PARTITION_METHOD: RANGE</span><br><span class="line">          SUBPARTITION_METHOD: NULL</span><br><span class="line">         PARTITION_EXPRESSION: `id`</span><br><span class="line">      SUBPARTITION_EXPRESSION: NULL</span><br><span class="line">        PARTITION_DESCRIPTION: MAXVALUE</span><br><span class="line">                   TABLE_ROWS: 1</span><br><span class="line">               AVG_ROW_LENGTH: 16384</span><br><span class="line">                  DATA_LENGTH: 16384</span><br><span class="line">              MAX_DATA_LENGTH: 0</span><br><span class="line">                 INDEX_LENGTH: 0</span><br><span class="line">                    DATA_FREE: 0</span><br><span class="line">                  CREATE_TIME: 2021-04-26 12:45:21</span><br><span class="line">                  UPDATE_TIME: 2021-05-09 10:08:28</span><br><span class="line">                   CHECK_TIME: NULL</span><br><span class="line">                     CHECKSUM: NULL</span><br><span class="line">            PARTITION_COMMENT:</span><br><span class="line">                    NODEGROUP: default</span><br><span class="line">              TABLESPACE_NAME: NULL</span><br><span class="line">3 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其实上面 TABLE_ROWS: 1 这里并不总是准确的，我猜想可能也是抽样统计的，并不是实时的数量，因为有时候看就是错的。</p>
</blockquote>
<p>那 RANGE 分区的优点是什么哪，我们为什么要进行分区哪？</p>
<ul>
<li>RANGE分区非常适用于对日期列的分区，例如，对于销售类的表，可以根据年份来分区存放销售记录，这样创建的好处是便于对表的管理，如果要删除2008年的数据，我们不需要执行DELETE FROM sales WHERE date&gt;&#x3D;’2008-01-01’ and date &lt;’2009-01-01’，只需删除2008年数据所在的分区即可。</li>
<li>这样创建的另一个好处是可以加快某些查询操作，例如上面我们explain查询语句发现，对于范围查询，如果落在分区范围内，只会搜索这个分区，而不会搜索整个分区——称为Partition Pruning（分区修剪）。</li>
</ul>
<h3 id="LIST-分区"><a href="#LIST-分区" class="headerlink" title="LIST 分区"></a>LIST 分区</h3><p>LIST分区和RANGE分区非常相似，只是分区列的值是离散的，而非连续的，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show create table parti_list;</span><br><span class="line">+------------+---------------------------------------------------------------------------------------------+</span><br><span class="line">| Table      | Create Table                                                                                |</span><br><span class="line">+------------+---------------------------------------------------------------------------------------------+</span><br><span class="line">| parti_list | CREATE TABLE `parti_list` (</span><br><span class="line">  `a` int DEFAULT NULL,</span><br><span class="line">  `b` int DEFAULT NULL</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci</span><br><span class="line">/*!50100 PARTITION BY LIST (`b`)</span><br><span class="line">(PARTITION p0 VALUES IN (1,3,5,7,9) ENGINE = InnoDB,</span><br><span class="line"> PARTITION p1 VALUES IN (0,2,4,6,8) ENGINE = InnoDB) */ |</span><br><span class="line">+------------+---------------------------------------------------------------------------------------------+</span><br><span class="line">1 row in set (0.03 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from parti_list;</span><br><span class="line">+------+------+</span><br><span class="line">| a    | b    |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 |    1 |</span><br><span class="line">|    1 |    3 |</span><br><span class="line">|    1 |    2 |</span><br><span class="line">|    1 |    4 |</span><br><span class="line">+------+------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from parti_list;</span><br><span class="line">+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">| id | select_type | table      | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |</span><br><span class="line">+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | parti_list | p0,p1      | ALL  | NULL          | NULL | NULL    | NULL |    4 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select table_name, partition_name, table_rows from information_schema.partitions where table_name=&#x27;parti_list&#x27; and table_schema=database() \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">    TABLE_NAME: parti_list</span><br><span class="line">PARTITION_NAME: p0</span><br><span class="line">    TABLE_ROWS: 2</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">    TABLE_NAME: parti_list</span><br><span class="line">PARTITION_NAME: p1</span><br><span class="line">    TABLE_ROWS: 2</span><br><span class="line">2 rows in set (0.03 sec)</span><br></pre></td></tr></table></figure>

<p>如果插入的值不在分区的定义中，那么MySQL数据库同样会抛出异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into parti_list select 1,11;</span><br><span class="line">ERROR 1526 (HY000): Table has no partition for value 11</span><br></pre></td></tr></table></figure>

<p>另外，在执行INSERT操作插入多个行数据的过程中如果遇到分区未定义的值，MyISAM和InnoDB存储引擎的处理会完全不同。MyISAM引擎会将之前的行数据都插入，但之后的数据不会被插入。<strong>而InnoDB存储引擎将其视为一个事务，没有任何数据被插入</strong>。</p>
<h3 id="HASH分区"><a href="#HASH分区" class="headerlink" title="HASH分区"></a>HASH分区</h3><p>HASH分区的目的是将数据均匀地分布到预先定义的各个分区中，保证各分区的数据数量大致是一样的。在RANGE和LIST分区中，必须明确指定一个给定的列值或列值集合应该保存在哪个分区中；而在HASH分区中，MySQL自动完成这些工作，用户所要做的只是基于将要被散列的列值指定一个表达式（哈希函数），以及指定被分区的表将要被分割成的分区数量。其格式为在create table 后面加上，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PARTITION BY HASH(expr)   -- expr为表达式，也就是哈希函数，即用某列的值作为函数的输入，当然也可以用列值本身</span><br><span class="line">PARTITIONS num;           -- 分区数，不写默认为1，就是不分区</span><br></pre></td></tr></table></figure>

<p>例如下列取函数 year(b) 即哈希函数为对该列取年份值，然后对哈希值取模计算分区：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show create table parti_hash;</span><br><span class="line">+------------+---------------------------------------------------------------------------------------------+</span><br><span class="line">| Table      | Create Table                                                                                |</span><br><span class="line">+------------+---------------------------------------------------------------------------------------------+</span><br><span class="line">| parti_hash | CREATE TABLE `parti_hash` (</span><br><span class="line">  `a` int DEFAULT NULL,</span><br><span class="line">  `b` datetime DEFAULT NULL</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci</span><br><span class="line">/*!50100 PARTITION BY HASH (year(`b`))</span><br><span class="line">PARTITIONS 4 */ |</span><br><span class="line">+------------+---------------------------------------------------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into parti_hash select 1, &#x27;2021-04-01&#x27;;</span><br><span class="line">Query OK, 1 row affected (0.04 sec)</span><br><span class="line">Records: 1  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from parti_hash;</span><br><span class="line">+------+---------------------+</span><br><span class="line">| a    | b                   |</span><br><span class="line">+------+---------------------+</span><br><span class="line">|    1 | 2021-04-01 00:00:00 |</span><br><span class="line">+------+---------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>因为 <code>2021 MOD 4 = 1</code>， 因此该记录会被放入分区p1中，我们可以按如下方法来验证一下，果然放在了p1中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select table_name, partition_name, table_rows from information_schema.partitions where table_name=&#x27;parti_hash&#x27; and table_schema=database() \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">    TABLE_NAME: parti_hash</span><br><span class="line">PARTITION_NAME: p0</span><br><span class="line">    TABLE_ROWS: 0</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">    TABLE_NAME: parti_hash</span><br><span class="line">PARTITION_NAME: p1</span><br><span class="line">    TABLE_ROWS: 1</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">    TABLE_NAME: parti_hash</span><br><span class="line">PARTITION_NAME: p2</span><br><span class="line">    TABLE_ROWS: 0</span><br><span class="line">*************************** 4. row ***************************</span><br><span class="line">    TABLE_NAME: parti_hash</span><br><span class="line">PARTITION_NAME: p3</span><br><span class="line">    TABLE_ROWS: 0</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>MySQL数据库还支持一种称为LINEAR HASH的分区，它使用一个更加复杂的算法来确定新行插入到已经分区的表中的位置。它的语法和HASH分区的语法相似，只是将关键字HASH改为LINEAR HASH，感兴趣的同学可以了解一下。</p>
<h3 id="KEY分区"><a href="#KEY分区" class="headerlink" title="KEY分区"></a>KEY分区</h3><p>KEY分区也很简单，使用和HASH分区相似，唯一的不同之处在于HASH分区通过用户定义的函数进行分区，而KEY分区使用MySQL数据库提供的函数进行分区。MySQL数据库使用其内部的散列函数来分区。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE parti_key (</span><br><span class="line">    -&gt; a INT,</span><br><span class="line">    -&gt; b DATETIME)ENGINE=InnoDB</span><br><span class="line">    -&gt; PARTITION BY KEY(b)</span><br><span class="line">    -&gt; PARTITIONS 4;</span><br></pre></td></tr></table></figure>

<h3 id="COLUMNS分区"><a href="#COLUMNS分区" class="headerlink" title="COLUMNS分区"></a>COLUMNS分区</h3><p>在前面介绍的RANGE、LIST、HASH和KEY这四种分区中，分区的条件必须是整型（integer），如果不是整型，那么需要通过函数将其转化为整型，如YEAR（）、TO_DAYS（）、MONTH（）等函数。MySQL5.5版本开始支持COLUMNS分区，可视为对RANGE分区和LIST分区的一种进化。COLUMNS分区可以直接使用非整型的数据进行分区，分区根据类型直接比较而得到，不需要转化为整型。此外，RANGE COLUMNS分区可以对多个列的值进行分区。</p>
<p>COLUMNS分区支持以下数据类型：</p>
<ul>
<li>所有的整型类型，如INT、SMALLINT、TINYINT和BIGINT。对FLOAT和DECIMAL则不予支持。</li>
<li>日期类型，如DATE和DATETIME。对其余的日期类型不予支持。</li>
<li>字符串类型，如CHAR、 VARCHAR、BINARY和VARBINARY。对BLOB和TEXT类型不予支持。</li>
</ul>
<p>用法也很简单，对于之前的RANGE和LIST分区，只需要用RANGE COLUMNS和LIST COLUMNS代替即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table parti_cloumns_range (</span><br><span class="line">    a int, b datetime) </span><br><span class="line">    partition by range(b)(</span><br><span class="line">    partition p0 values less than (&#x27;2015-01-01&#x27;), </span><br><span class="line">    partition p1 values less than (&#x27;2020-01-01&#x27;));</span><br><span class="line">ERROR 1697 (HY000): VALUES value for partition &#x27;p0&#x27; must have type INT -- 报错，必须是整形</span><br><span class="line"></span><br><span class="line">mysql&gt; create table parti_cloumns_range (</span><br><span class="line">    a int, b datetime) </span><br><span class="line">    partition by range columns(b)(</span><br><span class="line">    partition p0 values less than (&#x27;2015-01-01&#x27;), </span><br><span class="line">    partition p1 values less than (&#x27;2020-01-01&#x27;));</span><br><span class="line">Query OK, 0 rows affected (0.83 sec)</span><br></pre></td></tr></table></figure>

<h2 id="子分区"><a href="#子分区" class="headerlink" title="子分区"></a>子分区</h2><p>子分区（subpartitioning）是在分区的基础上再进行分区，有时也称这种分区为复合分区（composite partitioning）。MySQL数据库允许在RANGE和LIST的分区上再进行HASH或KEY的子分区。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table subparti (</span><br><span class="line">    -&gt; a int,</span><br><span class="line">    -&gt; b date)</span><br><span class="line">    -&gt; partition by range(year(b))</span><br><span class="line">    -&gt; subpartition by hash(to_days(b))</span><br><span class="line">    -&gt; subpartitions 2(</span><br><span class="line">    -&gt; partition p0 values less than (2000),</span><br><span class="line">    -&gt; partition p1 values less than (2020),</span><br><span class="line">    -&gt; partition p2 values less than maxvalue);</span><br><span class="line">Query OK, 0 rows affected (1.76 sec)</span><br></pre></td></tr></table></figure>

<p>表 subparti 先根据b列进行了RANGE分区分成三个，然后对每个分区又进行了一次HASH分区分为两个，所以分区的数量应该为（3*2&#x3D;6）个，这通过查看物理磁盘上的文件也可以得到证实。<br><img src="https://note.youdao.com/yws/api/personal/file/9272F49427F34BFCAF5E40F6ED25B94C?method=download&shareKey=09849fae1e53e5fe3e26dfe3bdaad8a3" alt="img"></p>
<p>我们也可以通过使用 SUBPARTITION 语法来显式地指出各个子分区的名字，对上述的表同样可以执行以下语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table subparti (</span><br><span class="line">    -&gt; a int,</span><br><span class="line">    -&gt; b date)</span><br><span class="line">    -&gt; partition by range(year(b))</span><br><span class="line">    -&gt; subpartition by hash(to_days(b)) (</span><br><span class="line">    -&gt; partition p0 values less than (2000) (</span><br><span class="line">    -&gt; subpartition s0,</span><br><span class="line">    -&gt; subpartition s1),</span><br><span class="line">    -&gt; partition p1 values less than (2020) (</span><br><span class="line">    -&gt; subpartition s2,</span><br><span class="line">    -&gt; subpartition s3),</span><br><span class="line">    -&gt; partition p2 values less than maxvalue (</span><br><span class="line">    -&gt; subpartition s4,</span><br><span class="line">    -&gt; subpartition s5)</span><br><span class="line">    -&gt; );</span><br><span class="line">Query OK, 0 rows affected (1.76 sec)</span><br></pre></td></tr></table></figure>

<p>子分区的建立需要注意以下几个问题：</p>
<ul>
<li>每个子分区的数量必须相同。</li>
<li>如果在一个分区表的任何分区上使用SUBPARTITION来明确定义任何子分区，那么就必须定义所有的子分区。</li>
<li>每个SUBPARTITION子句必须包括子分区的一个名字。</li>
<li>子分区的名字必须是唯一的。</li>
</ul>
<h2 id="分区中的NULL值"><a href="#分区中的NULL值" class="headerlink" title="分区中的NULL值"></a>分区中的NULL值</h2><p>MySQL数据库允许对NULL值进行分区，但是处理方法可能与其他数据库不同。<strong>MySQL数据库的分区总是把NULL值视为小于任何的一个非NULL值，这和MySQL数据库中处理NULL值的ORDER BY操作是一样的</strong>。因此对于不同的分区类型，MySQL数据库对NULL值的处理也各不相同。</p>
<ul>
<li>对于RANGE分区，如果向分区列插入了NULL值，那么MySQL数据库会将该值放入最左边的分区。</li>
<li>要在LIST分区下使用NULL值，必须显式地指出向哪个分区中可以放入NULL值，否则会报错。</li>
<li>HASH和KEY分区对NULL的处理方式与RANGE和LIST分区不一样，任何分区函数（哈希函数）都会将含有NULL值的记录返回为0，所以NULL值一定会放在p0分区。</li>
</ul>
<h2 id="分区的性能"><a href="#分区的性能" class="headerlink" title="分区的性能"></a>分区的性能</h2><p>数据库的应用分为两类：一类是<strong>OLTP（联机事务处理）</strong>，如Blog、电子商务、网络游戏等；另一类是<strong>OLAP（联机分析处理）</strong>，如数据仓库、数据集市等。在一个实际的应用环境中，可能既有OLTP的应用，也有OLAP的应用。</p>
<p>对于OLAP的应用，分区的确可以很好地提高查询的性能，因为OLAP应用的大多数查询需要频繁地扫描一张很大的表。假设有一张1亿行的表，其中有一个时间戳属性列，需要从这张表中获取一年的数据。如果按时间戳进行分区，则只需要扫描相应的分区即可。这就是前面介绍的Partition Pruning技术。</p>
<p>然而对于OLTP的应用，在分区时应该非常小心。在这种应用下，通常不可能会获取一张大表中10%的数据，大部分都是通过索引返回几条记录即可。而根据B+树索引的原理可知，对于一张大表，一般的B+树需要2～3次的磁盘IO操作，因此B+树可以很好地完成对大表的查询操作，不需要分区的帮助，更何况设计不好的分区会带来严重的性能问题。</p>
<p>一千万行的表是一张非常大的表吗？需要分区吗？例如对主键做10个HASH分区，这样每个分区就只有一百万的数据了，我们可能会认为这时查询应该变得更快了，但是考虑这样一个问题：一百万行和一千万行的数据本身构成的B+树的层次是其实都很小，可能都是两层，那么上述主键分区的索引可能并不会带来性能的提高。假设一千万行数据的B+树的高度是3，一百万行数据的B+树的高度是2，这样上述主键分区的索引可以避免一次IO，从而提高查询的效率，这没问题，但是这张表只有主键索引，没有任何其他列需要查询吗？如果我们查询其他列（非分区列），这时就需要扫描所有的10个分区，即使每个分区的查询开销为2次IO操作，那么一共需要20次IO。而对于原来单表的设计，此次查询原本只需要2～3次IO操作，所以要综合考虑，分区并不一定能带来性能提升。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/MySQL%E4%B8%AD%E7%9A%84%E5%88%86%E5%8C%BA%E8%A1%A8/" rel="tag"># MySQL中的分区表</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/09/01/MySQL%E7%9A%84%E8%81%94%E7%BB%93%EF%BC%88Join%EF%BC%89%E7%AE%97%E6%B3%95/" rel="prev" title="MySQL的联结（Join）算法">
                  <i class="fa fa-chevron-left"></i> MySQL的联结（Join）算法
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/09/03/Docker%E7%9B%B8%E5%85%B3%E4%BD%BF%E7%94%A8/" rel="next" title="Docker相关使用">
                  Docker相关使用 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jing</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
