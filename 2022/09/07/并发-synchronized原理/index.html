<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="在 Java 早期版本中，synchronized 属于 重量级锁，效率低下。 因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。 在 Java">
<meta property="og:type" content="article">
<meta property="og:title" content="synchronized原理">
<meta property="og:url" content="http://example.com/2022/09/07/%E5%B9%B6%E5%8F%91-synchronized%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="WangHao&amp;博客">
<meta property="og:description" content="在 Java 早期版本中，synchronized 属于 重量级锁，效率低下。 因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。 在 Java">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/09/07/%E5%B9%B6%E5%8F%91-synchronized%E5%8E%9F%E7%90%86/blog/source_posts/synchronized原理/1.jpg">
<meta property="og:image" content="http://example.com/2022/09/07/%E5%B9%B6%E5%8F%91-synchronized%E5%8E%9F%E7%90%86/synchronized%E5%8E%9F%E7%90%86%5C2.png">
<meta property="article:published_time" content="2022-09-07T03:26:43.000Z">
<meta property="article:modified_time" content="2022-09-11T08:35:08.894Z">
<meta property="article:author" content="Jing">
<meta property="article:tag" content="Monitor">
<meta property="article:tag" content="轻量级锁">
<meta property="article:tag" content="锁重入">
<meta property="article:tag" content="锁膨胀">
<meta property="article:tag" content="重量级锁">
<meta property="article:tag" content="自旋优化">
<meta property="article:tag" content="偏向锁">
<meta property="article:tag" content="锁消除">
<meta property="article:tag" content="锁粗化">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/09/07/%E5%B9%B6%E5%8F%91-synchronized%E5%8E%9F%E7%90%86/blog/source_posts/synchronized原理/1.jpg">


<link rel="canonical" href="http://example.com/2022/09/07/%E5%B9%B6%E5%8F%91-synchronized%E5%8E%9F%E7%90%86/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2022/09/07/%E5%B9%B6%E5%8F%91-synchronized%E5%8E%9F%E7%90%86/","path":"2022/09/07/并发-synchronized原理/","title":"synchronized原理"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>synchronized原理 | WangHao&博客</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">WangHao&博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Welcome to the home of WangHao</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#synchronized%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.</span> <span class="nav-text">synchronized的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E4%BF%AE%E9%A5%B0%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95-%EF%BC%88%E9%94%81%E5%BD%93%E5%89%8D%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%EF%BC%89"><span class="nav-number">1.0.1.</span> <span class="nav-text">1、修饰实例方法 （锁当前对象实例）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E4%BF%AE%E9%A5%B0%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95-%EF%BC%88%E9%94%81%E5%BD%93%E5%89%8D%E7%B1%BB%EF%BC%89"><span class="nav-number">1.0.2.</span> <span class="nav-text">2、修饰静态方法 （锁当前类）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E4%BF%AE%E9%A5%B0%E4%BB%A3%E7%A0%81%E5%9D%97-%EF%BC%88%E9%94%81%E6%8C%87%E5%AE%9A%E5%AF%B9%E8%B1%A1-x2F-%E7%B1%BB%EF%BC%89"><span class="nav-number">1.0.3.</span> <span class="nav-text">3、修饰代码块 （锁指定对象&#x2F;类）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="nav-number">1.0.4.</span> <span class="nav-text">总结：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#synchronized-%E5%8E%9F%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">synchronized 原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized%E5%90%8C%E6%AD%A5%E8%AF%AD%E5%8F%A5%E5%9D%97%E5%8E%9F%E7%90%86"><span class="nav-number">2.1.</span> <span class="nav-text">synchronized同步语句块原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Monitor-%E5%8E%9F%E7%90%86"><span class="nav-number">2.2.</span> <span class="nav-text">Monitor 原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized-%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E5%8E%9F%E7%90%86"><span class="nav-number">2.3.</span> <span class="nav-text">synchronized 同步方法原理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#synchronized-%E5%92%8C-volatile-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.</span> <span class="nav-text">synchronized 和 volatile 的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#synchronized-%E5%92%8C-ReentrantLock-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.</span> <span class="nav-text">synchronized 和 ReentrantLock 的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%A4%E8%80%85%E9%83%BD%E6%98%AF%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="nav-number">4.1.</span> <span class="nav-text">两者都是可重入锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized-%E4%BE%9D%E8%B5%96%E4%BA%8E-JVM-%E8%80%8C-ReentrantLock-%E4%BE%9D%E8%B5%96%E4%BA%8E-API"><span class="nav-number">4.2.</span> <span class="nav-text">synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ReentrantLock-%E6%AF%94-synchronized-%E5%A2%9E%E5%8A%A0%E4%BA%86%E4%B8%80%E4%BA%9B%E9%AB%98%E7%BA%A7%E5%8A%9F%E8%83%BD"><span class="nav-number">4.3.</span> <span class="nav-text">ReentrantLock 比 synchronized 增加了一些高级功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E4%B8%8E%E9%94%81%E9%87%8D%E5%85%A5"><span class="nav-number">4.4.</span> <span class="nav-text">轻量级锁与锁重入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%8A%A0%E9%94%81%E6%B5%81%E7%A8%8B"><span class="nav-number">4.4.1.</span> <span class="nav-text">轻量级锁加锁流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E8%A7%A3%E9%94%81%E6%B5%81%E7%A8%8B"><span class="nav-number">4.4.2.</span> <span class="nav-text">轻量级锁解锁流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%88%B0%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%EF%BC%88%E9%94%81%E8%86%A8%E8%83%80%EF%BC%89"><span class="nav-number">4.5.</span> <span class="nav-text">轻量级锁到重量级锁（锁膨胀）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E5%8A%A0%E9%94%81%E6%B5%81%E7%A8%8B"><span class="nav-number">4.5.0.1.</span> <span class="nav-text">重量级锁加锁流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E8%A7%A3%E9%94%81%E6%B5%81%E7%A8%8B"><span class="nav-number">4.5.0.2.</span> <span class="nav-text">重量级锁解锁流程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E9%87%8F%E9%94%81%E7%9A%84%E8%87%AA%E6%97%8B%E4%BC%98%E5%8C%96"><span class="nav-number">4.6.</span> <span class="nav-text">重量锁的自旋优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="nav-number">4.7.</span> <span class="nav-text">偏向锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%81%8F%E5%90%91%E7%8A%B6%E6%80%81"><span class="nav-number">4.7.1.</span> <span class="nav-text">偏向状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%81%8F%E5%90%91%E9%94%81%E6%92%A4%E9%94%80"><span class="nav-number">4.7.2.</span> <span class="nav-text">偏向锁撤销</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1-hashCode"><span class="nav-number">4.7.2.1.</span> <span class="nav-text">调用对象 hashCode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E5%AE%83%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1"><span class="nav-number">4.7.2.2.</span> <span class="nav-text">其它线程使用对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E7%94%A8-wait-x2F-notify"><span class="nav-number">4.7.2.3.</span> <span class="nav-text">调用 wait&#x2F;notify</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%B9%E9%87%8F%E9%87%8D%E5%81%8F%E5%90%91"><span class="nav-number">4.7.3.</span> <span class="nav-text">批量重偏向</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%B9%E9%87%8F%E6%92%A4%E9%94%80"><span class="nav-number">4.7.4.</span> <span class="nav-text">批量撤销</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81%E6%B6%88%E9%99%A4"><span class="nav-number">4.8.</span> <span class="nav-text">锁消除</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81%E7%B2%97%E5%8C%96"><span class="nav-number">4.9.</span> <span class="nav-text">锁粗化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">5.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%A2%84%E9%98%B2%E5%92%8C%E9%81%BF%E5%85%8D%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81"><span class="nav-number">5.1.</span> <span class="nav-text">如何预防和避免线程死锁</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jing"
      src="/images/head.jpg">
  <p class="site-author-name" itemprop="name">Jing</p>
  <div class="site-description" itemprop="description">Stay hungry,stay foolish</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">95</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">109</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/07/%E5%B9%B6%E5%8F%91-synchronized%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="Jing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WangHao&博客">
      <meta itemprop="description" content="Stay hungry,stay foolish">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="synchronized原理 | WangHao&博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          synchronized原理
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-09-07 11:26:43" itemprop="dateCreated datePublished" datetime="2022-09-07T11:26:43+08:00">2022-09-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-11 16:35:08" itemprop="dateModified" datetime="2022-09-11T16:35:08+08:00">2022-09-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Java并发编程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>在 Java 早期版本中，<code>synchronized</code> 属于 <strong>重量级锁</strong>，效率低下。 因为监视器锁（monitor）是依赖于底层的操作系统的 <code>Mutex Lock</code> 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。</p>
<p>在 Java 6 之后进行了优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p>
<span id="more"></span>

<h1 id="synchronized的使用"><a href="#synchronized的使用" class="headerlink" title="synchronized的使用"></a>synchronized的使用</h1><p>synchronized 关键字最主要的三种使用方式：</p>
<ol>
<li>修饰实例方法</li>
<li>修饰静态方法</li>
<li>修饰代码块</li>
</ol>
<h3 id="1、修饰实例方法-（锁当前对象实例）"><a href="#1、修饰实例方法-（锁当前对象实例）" class="headerlink" title="1、修饰实例方法 （锁当前对象实例）"></a><strong>1、修饰实例方法</strong> （锁当前对象实例）</h3><p>给当前对象实例加锁，进入同步代码前要获得 <strong>当前对象实例的锁</strong> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、修饰静态方法-（锁当前类）"><a href="#2、修饰静态方法-（锁当前类）" class="headerlink" title="2、修饰静态方法 （锁当前类）"></a><strong>2、修饰静态方法</strong> （锁当前类）</h3><p>给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 <strong>当前 class 的锁</strong>。</p>
<p>这是因为静态成员不属于任何一个实例对象，归整个类所有，不依赖于类的特定实例，被类的所有实例共享。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态 <code>synchronized</code> 方法和非静态 <code>synchronized</code> 方法之间的调用互斥么？不互斥！如果一个线程 A 调用一个实例对象的非静态 <code>synchronized</code> 方法，而线程 B 需要调用这个实例对象所属类的静态 <code>synchronized</code> 方法，是允许的，不会发生互斥现象，因为访问静态 <code>synchronized</code> 方法占用的锁是当前类的锁，而访问非静态 <code>synchronized</code> 方法占用的锁是当前实例对象锁。</p>
<h3 id="3、修饰代码块-（锁指定对象-x2F-类）"><a href="#3、修饰代码块-（锁指定对象-x2F-类）" class="headerlink" title="3、修饰代码块 （锁指定对象&#x2F;类）"></a><strong>3、修饰代码块</strong> （锁指定对象&#x2F;类）</h3><p>对括号里指定的对象&#x2F;类加锁：</p>
<ul>
<li><code>synchronized(object)</code> 表示进入同步代码库前要获得 <strong>给定对象的锁</strong>。</li>
<li><code>synchronized(类.class)</code> 表示进入同步代码前要获得 <strong>给定 Class 的锁</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结：</strong></h3><ul>
<li><code>synchronized</code> 关键字加到 <code>static</code> 静态方法和 <code>synchronized(class)</code> 代码块上都是是给 Class 类上锁；</li>
<li><code>synchronized</code> 关键字加到实例方法上是给对象实例上锁；</li>
<li>尽量不要使用 <code>synchronized(String a)</code> 因为 JVM 中，字符串常量池具有缓存功能。</li>
</ul>
<h1 id="synchronized-原理"><a href="#synchronized-原理" class="headerlink" title="synchronized 原理"></a>synchronized 原理</h1><h2 id="synchronized同步语句块原理"><a href="#synchronized同步语句块原理" class="headerlink" title="synchronized同步语句块原理"></a>synchronized同步语句块原理</h2><p>​		synchronized<code>同步语句块的实现使用的是</code>monitorenter<code>和</code>monitorexit<code>指令，其中</code>monitorenter<code> 指令指向同步代码块的开始位置，</code>monitorexit<code>指令则指明同步代码块的结束位置。 当执行</code>monitorenter<code>指令时，线程试图获取锁也就是获取 **对象监视器</code>monitor&#96;** 的持有权。</p>
<p>​		在执行<code>monitorenter</code>时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。</p>
<p>​		对象锁的的拥有者线程才可以执行 <code>monitorexit</code> 指令来释放锁。在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。</p>
<p>如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p>
<h2 id="Monitor-原理"><a href="#Monitor-原理" class="headerlink" title="Monitor 原理"></a>Monitor 原理</h2><p><strong>32位虚拟机对象头Mark Word：</strong></p>
<p><img src="/2022/09/07/%E5%B9%B6%E5%8F%91-synchronized%E5%8E%9F%E7%90%86/blog\source_posts\synchronized原理\1.jpg"></p>
<p>​		Monitor 被翻译为监视器或<strong>管程</strong>，每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（注意，必须是重量级）之后，该对象头的 Mark Word 就被设置为指向 Monitor 对象的指针 + “10” 重量级锁标志。</p>
<p>Monitor 结构如下：</p>
<p><img src="/2022/09/07/%E5%B9%B6%E5%8F%91-synchronized%E5%8E%9F%E7%90%86/synchronized%E5%8E%9F%E7%90%86%5C2.png"></p>
<ul>
<li>刚开始的时候 Monitor 中 Owner 为 null；</li>
<li>当 Thread-2 执行 synchronized(obj) 就会将obj 关联的 Monitor 的所有者 Owner 置为 Thread-2，Monitor 中只能有一个 Owner ；</li>
<li>在 Thread-2 持有锁的过程中，如果 Thread-3，Thread-4，Thread-5 也来执行 synchronized(obj)，就会进入 EntryList 陷入 BLOCKED 状态；</li>
<li>Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁（notifyAll），竞争时是非公平的；</li>
<li>图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程，后面讲 wait-notify 时会分析。</li>
</ul>
<p><strong><code>wait/notify</code>等方法也依赖于<code>monitor</code>对象，这就是为什么只有在同步的块或者方法中才能调用<code>wait/notify</code>等方法</strong>，否则会抛出<code>java.lang.IllegalMonitorStateException</code>的异常的原因。</p>
<h2 id="synchronized-同步方法原理"><a href="#synchronized-同步方法原理" class="headerlink" title="synchronized 同步方法原理"></a>synchronized 同步方法原理</h2><p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p>
<p>如果是实例方法，JVM 会尝试获取实例对象的锁。如果是静态方法，JVM 会尝试获取当前 class 的锁。</p>
<h1 id="synchronized-和-volatile-的区别"><a href="#synchronized-和-volatile-的区别" class="headerlink" title="synchronized 和 volatile 的区别"></a>synchronized 和 volatile 的区别</h1><p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在！</p>
<ul>
<li><code>volatile</code> 关键字是线程同步的轻量级实现，所以 <code>volatile</code>性能肯定比<code>synchronized</code>关键字要好 。但是 <code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块 。</li>
<li><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</li>
<li><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</li>
</ul>
<h1 id="synchronized-和-ReentrantLock-的区别"><a href="#synchronized-和-ReentrantLock-的区别" class="headerlink" title="synchronized 和 ReentrantLock 的区别"></a>synchronized 和 ReentrantLock 的区别</h1><h2 id="两者都是可重入锁"><a href="#两者都是可重入锁" class="headerlink" title="两者都是可重入锁"></a>两者都是可重入锁</h2><p><strong>“可重入锁”</strong> 指的是自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。</p>
<h2 id="synchronized-依赖于-JVM-而-ReentrantLock-依赖于-API"><a href="#synchronized-依赖于-JVM-而-ReentrantLock-依赖于-API" class="headerlink" title="synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API"></a>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</h2><p><code>synchronized</code> 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 <code>synchronized</code> 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。<code>ReentrantLock</code> 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try&#x2F;finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p>
<h2 id="ReentrantLock-比-synchronized-增加了一些高级功能"><a href="#ReentrantLock-比-synchronized-增加了一些高级功能" class="headerlink" title="ReentrantLock 比 synchronized 增加了一些高级功能"></a>ReentrantLock 比 synchronized 增加了一些高级功能</h2><p>相比<code>synchronized</code>，<code>ReentrantLock</code>增加了一些高级功能。主要来说主要有三点：</p>
<ul>
<li><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li>
<li><strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li>
<li><strong>可实现选择性通知（锁可以绑定多个条件）</strong>: <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>&#x2F;<code>notifyAll()</code>方法相结合可以实现等待&#x2F;通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</li>
</ul>
<blockquote>
<p><code>Condition</code>是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个<code>Lock</code>对象中可以创建多个<code>Condition</code>实例（即对象监视器），<strong>线程对象可以注册在指定的<code>Condition</code>中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用<code>notify()/notifyAll()</code>方法进行通知时，被通知的线程是由 JVM 选择的，用<code>ReentrantLock</code>类结合<code>Condition</code>实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是 Condition 接口默认提供的。而<code>synchronized</code>关键字就相当于整个 Lock 对象中只有一个<code>Condition</code>实例，所有的线程都注册在它一个身上。如果执行<code>notifyAll()</code>方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而<code>Condition</code>实例的<code>signalAll()</code>方法 只会唤醒注册在该<code>Condition</code>实例中的所有等待线程。</p>
</blockquote>
<h2 id="轻量级锁与锁重入"><a href="#轻量级锁与锁重入" class="headerlink" title="轻量级锁与锁重入"></a>轻量级锁与锁重入</h2><h3 id="轻量级锁加锁流程"><a href="#轻量级锁加锁流程" class="headerlink" title="轻量级锁加锁流程"></a>轻量级锁加锁流程</h3><p>一旦对象被 synchronized 锁住后，假如后续多个线程执行到 synchronized 处，<strong>当还没有线程对对象加锁时，此时第一个尝试加锁的线程会优先使用轻量级锁</strong>，第一个线程会先在栈中新建一个锁记录对象（Lock Record），包含：<strong>锁记录的地址和指向锁对象的引用</strong>。此时会进行 <strong>cas 操作</strong>，将锁记录对象地址与被锁住的对象的 markword 互换，第一次肯定会 cas 成功，所以对象头中的 markword 有了指向锁记录的地址和状态 00，表示由该线程给对象加锁，并且是轻量级锁，注意此时并没有关联 Monitor。当然如果这时同一线程中再次对该对象进行加锁（同一线程中有多个针对同一对象的 synchronized 方法或代码块），会 cas 失败（因为此时对象头的 Mark Word 存的是锁记录的地址，并且标志位为 00），这是因为是同一线程，进入<strong>锁重入机制</strong>，即再添加一条锁记录作为重入的计数，并且这个锁记录的地址为 null。</p>
<pre><code>    但如果是其他的线程在此时对该对象尝试进行加锁，也会 cas 失败，并进入**锁膨胀**阶段，**膨胀成重量级锁**，此时 Monitor 就登场了，下面介绍。
</code></pre>
<ul>
<li>所以cas 失败，有两种情况<ul>
<li>如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数；</li>
<li>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程。</li>
</ul>
</li>
</ul>
<h3 id="轻量级锁解锁流程"><a href="#轻量级锁解锁流程" class="headerlink" title="轻量级锁解锁流程"></a>轻量级锁解锁流程</h3><ul>
<li>当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一</li>
<li>当退出 synchronized代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象头<ul>
<li>成功，则解锁成功</li>
<li>失败，说明轻量级锁进行了锁膨胀已经升级为重量级锁，进入重量级锁解锁流程。</li>
</ul>
</li>
</ul>
<h2 id="轻量级锁到重量级锁（锁膨胀）"><a href="#轻量级锁到重量级锁（锁膨胀）" class="headerlink" title="轻量级锁到重量级锁（锁膨胀）"></a>轻量级锁到重量级锁（锁膨胀）</h2><h4 id="重量级锁加锁流程"><a href="#重量级锁加锁流程" class="headerlink" title="重量级锁加锁流程"></a>重量级锁加锁流程</h4><p>如果在尝试加轻量级锁的过程中，cas操作无法成功，这时是第二种情况即有其它线程已经为此对象加上了轻量级锁（有竞争），这时会<strong>先进行自旋</strong>，即竞争的线程先进行自旋，<strong>等自旋多次之后仍然无法cas成功时才会进行锁膨胀，将轻量级锁变为重量级锁。</strong></p>
<p>具体流程是：尝试在 jvm 里找到一个 Monitor 对象与 obj 关联，并将 obj 对象头 MarkWord 的前 30 位<strong>指向 Monitor 对象</strong>，让 Monitor 的 owner 指向当前持有锁的线程，然后 markword 状态标志位也会改变成相应的值（10），现在这个加入的线程以及后来的线程执行到 synchronized(obj) 时先检查锁住的对象关联的 Monitor 有没有主人（Owner），如果有则只能进入 Moniter 对象的 Entrylist 列表等待（等待线程为 BLOCKED 状态），等待持锁线程释放锁。</p>
<h4 id="重量级锁解锁流程"><a href="#重量级锁解锁流程" class="headerlink" title="重量级锁解锁流程"></a>重量级锁解锁流程</h4><p>当前锁住对象的线程退出同步块解锁时，首先使用 cas 将 Mark Word 的值恢复给对象头，这时会失败（轻量级解锁流程），进入重量级解锁流程。即按照被锁对象中存储的 Monitor 地址找到 Monitor 对象，将当前锁记录中存储的 MarkWord 交给 Monitor，设置 owner 为 null，唤醒 EntryList 中 BLOCKED 的线程。</p>
<h2 id="重量锁的自旋优化"><a href="#重量锁的自旋优化" class="headerlink" title="重量锁的自旋优化"></a>重量锁的自旋优化</h2><p>重量级锁竞争的时候，也可以使用自旋来进行优化（所有自旋优化会出现在轻量级锁升级成重量级锁的过程中，也会出现在重量级锁的竞争过程中），如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞，因为挂起线程和恢复线程的操作都需要转入内核态完成，会比较费时。</p>
<p>但要注意：</p>
<ul>
<li>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。</li>
<li>在 Java 6 之后自旋锁是自适应的并且强制开启，比如线程刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之就少自旋甚至不自旋，总之比较智能。</li>
</ul>
<h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 markword 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有。</p>
<blockquote>
<p>如果说轻量级锁是在无竞争的情况下使用 CAS 操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连 CAS 操作都不去做了。注意它们两个的前提都是无竞争。</p>
</blockquote>
<h3 id="偏向状态"><a href="#偏向状态" class="headerlink" title="偏向状态"></a>偏向状态</h3><p>一个对象创建时：</p>
<ul>
<li>如果开启了偏向锁（默认开启），那么对象创建后，markword 值为 0x05 即最后 3 位为 101，这时它的 thread ID、epoch、age 都为 0</li>
<li>偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 <code>X:BiasedLockingStartupDelay=0</code> 来禁用延迟</li>
<li>如果没有开启偏向锁，那么对象创建后，markword 值为 0x01 即最后 3 位为 001，这时它的 hashcode、 age 都为 0，第一次用到 hashcode 时才会赋值</li>
</ul>
<p>测试:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">// 1. 测试偏向锁的延时</span><br><span class="line">    private static void test1() &#123;</span><br><span class="line">        Dog d = new Dog();</span><br><span class="line">        log.debug(ClassLayout.parseInstance(d).toPrintable());</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(4000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(ClassLayout.parseInstance(new Dog()).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">    /*小端格式：低字节在低地址</span><br><span class="line">    // 刚开始它的 thread、epoch、age 都为 0</span><br><span class="line">     OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">          0     4        (object header)                           01 00 00 00 (00000001【001】 00000000 00000000 00000000) (1)</span><br><span class="line">          4     4        (object header)                           00 00 00 00 (00000000       00000000 00000000 00000000) (0)</span><br><span class="line"></span><br><span class="line">    // 存在延迟</span><br><span class="line"></span><br><span class="line">     OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">          0     4        (object header)                           05 00 00 00 (00000101【101】 00000000 00000000 00000000) (5)</span><br><span class="line">          4     4        (object header)                           00 00 00 00 (00000000       00000000 00000000 00000000) (0)</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    // 2. 测试偏向锁</span><br><span class="line">    // 2.1 -XX:BiasedLockingStartupDelay=0 // 关闭延时</span><br><span class="line">    // 2.2 -XX:-UseBiasedLocking           // 禁用偏向锁</span><br><span class="line">    private static void test2() &#123;</span><br><span class="line">        Dog d = new Dog();</span><br><span class="line">        ClassLayout classLayout = ClassLayout.parseInstance(d);</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">                log.debug(&quot;synchronized 前&quot;);</span><br><span class="line">                System.out.println(classLayout.toPrintable());</span><br><span class="line"></span><br><span class="line">                synchronized (d) &#123;</span><br><span class="line">                    log.debug(&quot;synchronized 中&quot;);</span><br><span class="line">                    System.out.println(classLayout.toPrintable());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                log.debug(&quot;synchronized 后&quot;);</span><br><span class="line">                System.out.println(classLayout.toPrintable());</span><br><span class="line">            &#125;, &quot;t1&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    /*</span><br><span class="line">    2.1 输出：</span><br><span class="line">    21:01:54.538 c.TestBiased [t1] - synchronized 前</span><br><span class="line">     OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">          0     4        (object header)                           05 00 00 00 (00000101 00000000 00000000 00000000) (5)</span><br><span class="line">          4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line"></span><br><span class="line">    21:01:54.546 c.TestBiased [t1] - synchronized 中</span><br><span class="line">     OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">          0     4        (object header)                           05 b0 90 b8 (00000101 10110000 10010000 10111000) (-1198477307)</span><br><span class="line">          4     4        (object header)                           03 02 00 00 (00000011 00000010 00000000 00000000) (515)</span><br><span class="line"></span><br><span class="line">    21:01:54.548 c.TestBiased [t1] - synchronized 后</span><br><span class="line">     OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">          0     4        (object header)                           05 b0 90 b8 (00000101 10110000 10010000 10111000) (-1198477307)</span><br><span class="line">          4     4        (object header)                           03 02 00 00 (00000011 00000010 00000000 00000000) (515)</span><br><span class="line"></span><br><span class="line">    注意: 处于偏向锁的对象解锁后，线程 id 仍存储于对象头中</span><br><span class="line"></span><br><span class="line">    2.2 输出：</span><br><span class="line">    21:13:00.584 c.TestBiased [t1] - synchronized 前</span><br><span class="line">     OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">          0     4        (object header)                           01 00 00 00 (00000001【无锁状态】 00000000 00000000 00000000) (1)</span><br><span class="line">          4     4        (object header)                           00 00 00 00 (00000000           00000000 00000000 00000000) (0)</span><br><span class="line"></span><br><span class="line">    21:13:00.589 c.TestBiased [t1] - synchronized 中</span><br><span class="line">     OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">          0     4        (object header)                           d8 f1 9f cc (11011000【轻量级锁】 11110001 10011111 11001100) (-861933096)</span><br><span class="line">          4     4        (object header)                           6b 00 00 00 (01101011           00000000 00000000 00000000) (107)</span><br><span class="line"></span><br><span class="line">    21:13:00.591 c.TestBiased [t1] - synchronized 后</span><br><span class="line">     OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">          0     4        (object header)                           01 00 00 00 (00000001【无锁状态】 00000000 00000000 00000000) (1)</span><br><span class="line">          4     4        (object header)                           00 00 00 00 (00000000           00000000 00000000 00000000) (0)</span><br><span class="line"></span><br><span class="line">     */</span><br></pre></td></tr></table></figure>

<h3 id="偏向锁撤销"><a href="#偏向锁撤销" class="headerlink" title="偏向锁撤销"></a>偏向锁撤销</h3><h4 id="调用对象-hashCode"><a href="#调用对象-hashCode" class="headerlink" title="调用对象 hashCode"></a>调用对象 hashCode</h4><p>调用了对象的 hashCode，但偏向锁的对象 MarkWord 中存储的是线程 id，如果调用 hashCode 会导致偏向锁被撤销</p>
<ul>
<li>轻量级锁会在锁记录中记录 hashCode</li>
<li>重量级锁会在 Monitor 中记录 hashCode</li>
</ul>
<h4 id="其它线程使用对象"><a href="#其它线程使用对象" class="headerlink" title="其它线程使用对象"></a>其它线程使用对象</h4><p>当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁，注意这里的情况具体是对象已经先偏向了线程 t1 并且现在<strong>不存在竞争，</strong>即偏向的线程 t1 已经执行结束<strong>，这个时候其他线程 t2 再来对偏向锁对象加锁会升级为轻量级锁。</strong></p>
<h4 id="调用-wait-x2F-notify"><a href="#调用-wait-x2F-notify" class="headerlink" title="调用 wait&#x2F;notify"></a>调用 wait&#x2F;notify</h4><p><strong>因为 wait&#x2F;notify 是只有重量级锁才有的操作，所以调用加锁对象的 wait&#x2F;notify 会升级为重量级锁。</strong></p>
<h3 id="批量重偏向"><a href="#批量重偏向" class="headerlink" title="批量重偏向"></a>批量重偏向</h3><p>如果对象被多个线程访问，但并没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象的 Thread ID。</p>
<p>当撤销偏向锁阈值超过 20 次后，jvm 会这样觉得，我是不是偏向错了呢，于是会在给这些后续对象加锁时重新偏向至加锁线程。</p>
<h3 id="批量撤销"><a href="#批量撤销" class="headerlink" title="批量撤销"></a>批量撤销</h3><p>当撤销偏向锁阈值超过 40 次后，jvm 会这样觉得，自己确实偏向错了，根本就不该偏向。于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的。</p>
<h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><p>在JVM-运行期（晚期）优化中如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须再进行。</p>
<h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><p>我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小——只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变少。多数情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体之中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗，所以可以进行锁粗化，<strong>将会把加锁同步的范围扩展（粗化）到整个操作序列的外部</strong>，这样就减少了加锁的次数。</p>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>​		线程死锁描述的是：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//资源 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//资源 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123; <span class="comment">//获得资源1</span></span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>); <span class="comment">//等第二个线程获取资源2</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;<span class="comment">//这里被线程二获取了这里就获取不到。</span></span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) &#123;<span class="comment">//获取资源二</span></span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>Output</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread[线程 <span class="number">1</span>,<span class="number">5</span>,main]get resource1</span><br><span class="line">Thread[线程 <span class="number">2</span>,<span class="number">5</span>,main]get resource2</span><br><span class="line">Thread[线程 <span class="number">1</span>,<span class="number">5</span>,main]waiting get resource2</span><br><span class="line">Thread[线程 <span class="number">2</span>,<span class="number">5</span>,main]waiting get resource1</span><br></pre></td></tr></table></figure>

<h2 id="如何预防和避免线程死锁"><a href="#如何预防和避免线程死锁" class="headerlink" title="如何预防和避免线程死锁"></a>如何预防和避免线程死锁</h2><ol>
<li><strong>破坏请求与保持条件</strong> ：一次性申请所有的资源。</li>
<li><strong>破坏不剥夺条件</strong> ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>
<li><strong>破坏循环等待条件</strong> ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Monitor/" rel="tag"># Monitor</a>
              <a href="/tags/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81/" rel="tag"># 轻量级锁</a>
              <a href="/tags/%E9%94%81%E9%87%8D%E5%85%A5/" rel="tag"># 锁重入</a>
              <a href="/tags/%E9%94%81%E8%86%A8%E8%83%80/" rel="tag"># 锁膨胀</a>
              <a href="/tags/%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81/" rel="tag"># 重量级锁</a>
              <a href="/tags/%E8%87%AA%E6%97%8B%E4%BC%98%E5%8C%96/" rel="tag"># 自旋优化</a>
              <a href="/tags/%E5%81%8F%E5%90%91%E9%94%81/" rel="tag"># 偏向锁</a>
              <a href="/tags/%E9%94%81%E6%B6%88%E9%99%A4/" rel="tag"># 锁消除</a>
              <a href="/tags/%E9%94%81%E7%B2%97%E5%8C%96/" rel="tag"># 锁粗化</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/09/06/%E5%B9%B6%E5%8F%91-Thread%E7%B1%BB%E6%96%B9%E6%B3%95/" rel="prev" title="Thread类方法">
                  <i class="fa fa-chevron-left"></i> Thread类方法
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/09/07/%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/" rel="next" title="线程安全问题">
                  线程安全问题 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jing</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
