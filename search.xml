<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL如何解决一主多从的过期读问题</title>
      <link href="/2023/01/27/MySQL%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E4%B8%80%E4%B8%BB%E5%A4%9A%E4%BB%8E%E7%9A%84%E8%BF%87%E6%9C%9F%E8%AF%BB%E9%97%AE%E9%A2%98/"/>
      <url>/2023/01/27/MySQL%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E4%B8%80%E4%B8%BB%E5%A4%9A%E4%BB%8E%E7%9A%84%E8%BF%87%E6%9C%9F%E8%AF%BB%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="两种架构"><a href="#两种架构" class="headerlink" title="两种架构"></a>两种架构</h2><p>基于一主多从的读写分离，如何处理主备延迟导致的读写分离问题。</p><p>读写分离的主要目标：分摊主库压力。</p><p>有两种架构：</p><p>1、客户端主动做负载均衡，把数据库的连接信息放在客户端的连接层。由客户端选择后端数据库进行查询。</p><p><img src="1.png"></p><p>2、MySQL和客户端之间加上一个中间代理层proxy，客户端只连接proxy，由proxy根据请求类型和上下文决定请求的分发路由。</p><p><img src="2.png"></p><p>两种架构特点</p><p>1、客户端直连方案，少了一层proxy转发，查询性能较好，结构也比较简单。</p><p>由于要了解后端部署细节，所以在出现主备切换、库迁移等操作时，客户端都会感知到，并且调整数据库连接信息。客户端再分配一个负责管理后端的组件，让业务端只注重于业务逻辑开发</p><p>2、带proxy的架构，使客户端不需要关注后端细节。</p><p>连接维护、后端信息维护等工作，都是由proxy完成的。但是架构整体相对复杂</p><p>两种架构都会遇到”过期读”问题：</p><p>由于主从可能存在延迟，客户端执行完一个更新事务后马上发起查询，如果查询选择的是从库的话，就有可能读到的是事务更新之前的状态。</p><p>客户端希望的是查询从库的数据结果和查主库的数据结果是一样的。</p><p>下面是解决方案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">强制走主库方案；</span><br><span class="line">sleep方案；</span><br><span class="line">判断主备无延迟方案；</span><br><span class="line">配合semi_sync方案；</span><br><span class="line">等主库位点方案；</span><br></pre></td></tr></table></figure><p>实际应用中，这几个方案可以混合使用。</p><p>比如，现在客户端对请求做分类，区分哪些请求可以接受过期读，哪些请求完全不能接受过期读。然后，对于不能接受过期读的语句，再使用等GTID或等位点的方案，</p><p>过期读本质上是由一写多读导致的，为了避免过期读，只有两种选择：</p><p>1、超时放弃</p><p>2、转到主库查询</p><h2 id="强制走主库方案"><a href="#强制走主库方案" class="headerlink" title="强制走主库方案"></a>强制走主库方案</h2><p>将查询请求做分类：</p><p>1、对于必须要拿到最新结果的请求，强制将其发到主库上。</p><p>2、对于可以读到旧数据的请求，才将其发到从库上。</p><p>这种方案虽然取巧，但是好用。</p><p>此方案最大的问题在于：当遇到实时性比较高要求的业务需求，就要放弃读写分离，所有的读写压力都在主库，等同于放弃了扩展性。</p><h2 id="Sleep方案"><a href="#Sleep方案" class="headerlink" title="Sleep方案"></a>Sleep方案</h2><p>主库更新后，读从库之前先sleep。如执行一条select sleep(1)命令。</p><p>方案假设：大多数情况下主备延迟在1s之内，做一个sleep可以有很大概率拿到到最新的数据</p><p>该方案不精确：</p><p>1、如果这个查询请求0.1s就能在从库拿到正确结果，sleep(1)也会等1s</p><p>2、如果延迟超过1s，还是会出现过期读</p><h2 id="判断主备无延迟方案"><a href="#判断主备无延迟方案" class="headerlink" title="判断主备无延迟方案"></a>判断主备无延迟方案</h2><p>要确保备库无延迟有三种做法：</p><p>在show slave status结果里的seconds_behind_master参数可以用来衡量主备延迟时间的长短。</p><p>第一种方法</p><p>每次从库执行查询请求前，先判断seconds_behind_master是否等于0，如果不等于0就要等到这个参数变为0才执行查询操作。</p><p>第二种方法</p><p>比对位点确保主备无延迟。</p><pre><code>Master_Log_File 和 Read_Master_Log_Pos,表示的是读到的主库的最新位点；Relay_Master_Log_File 和 Exec_Master_Log_Pos,表示的是备库执行的最新位点；</code></pre><p>如果Master_Log_File 和 Relay_Master_Log_File 值相同，且Read_Master_Log_Pos和Exec_Master_Log_Pos相同，说明接受到的日志已经同步完成。</p><p>第三种方法</p><p>对比GTID集合确保主备无延迟</p><p>如果两个集合相同，表示备库接收到了日志都已同步完成。</p><p>一个事务的binlog在主备库之间的状态：</p><p>1、主库执行完成，写入binlog，并反馈给客户端；</p><p>2、binlog被从主库发送给备库，备库收到</p><p>3、在备库执行binlog完成。</p><p>我们上面判断主备无延迟的逻辑是”备库收到的日志都执行完成了”，但是有一部分日志会处于客户端已经收到提交确认，而备库还没收到日志的状态。<br>在这里插入图片描述</p><p>在主库上执行完成了三个事务trx1、trx2、trx3，前两个已经传到从库并且执行完成了。trx3在主库执行完成，并且已经回复给客户端，但是还没有传到从库中。此时在从库B上执行查询请求，按照上面的三个方法的逻辑，从库会认为已经没有同步延迟，但是还是会查不到trx3.</p><h2 id="配合semi-sync"><a href="#配合semi-sync" class="headerlink" title="配合semi-sync"></a>配合semi-sync</h2><p>解决上面的问题，要引入半同步复制，即semi-sync replication</p><p>semi-sync是这样做的：</p><p>1、事务提交的时候，主库把binlog发给从库；</p><p>2、从库收到binlog以后，发回给主库一个ack，表示收到了</p><p>3、主库收到这个ack以后，才能给客户端返回”事务完成”的确认</p><p>也就是说，如果启用了semi-sync，就说明所有给客户端发送过确认的事务备库都已经收到了日志。</p><p>semi-sync+位点的判断方案，在一主一备场景是成立的，在一主多从场景中，主库只要等到一个从库的ack，就开始给客户端返回确认。</p><p>但是这样会出现问题：</p><p>1、查询落到没有收到最新日志的从库上，产生过期读。</p><p>2、业务更新高峰期，主库的位点或者GTID集合更新很快，两个位点的等值判断一直不成立，很可能出现从库上迟迟无法响应查询请求的情况</p><h2 id="等主库位点方案"><a href="#等主库位点方案" class="headerlink" title="等主库位点方案"></a>等主库位点方案</h2><p>这个命令逻辑如下：</p><p>1、在从库执行</p><p>2、参数file和pos指的是主库的文件名和位置</p><p>3、timeout可选，设置为正整数N表示这个函数最多等待N秒</p><p>4、返回正整数M，表示从命令开始执行，到应用完file和pos表示的binlog位置执行了多少事务</p><p>返回值还有一下异常结果：</p><p>1、NULL，执行期间，备库同步线程发生异常。</p><p>2、-1，等待时间超过N秒</p><p>3、0，这个位置已经执行过了</p><p>使用该方法步骤：</p><p>1、事务trx1更新完后，马上执行show master status得到当前主库执行到的File和Position</p><p>2、选定一个从库执行查询语句</p><p>3、在从库上执行select master_pos_wait(File,Position,1)</p><p>4、如果返回值是&gt;&#x3D;0的正整数，则在这个从库执行查询语句</p><p>5、否则到主库执行查询语句。</p><p>假设，每条select最多在从库上等待1s，如果1s内master_pos_wait返回一个&gt;&#x3D;0的整数，就确保了从库上执行的这个查询结果一定包含trx1数据。</p><p>如果每个从库都延迟超过了1s，查询压力都会跑到主库上去。</p><p>但是为了不允许过期读，只有两种方法：1、超时放弃 2、转到主库查询</p>]]></content>
      
      
      <categories>
          
          <category> MySQL数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 解决一主多从的过期读问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发-死锁</title>
      <link href="/2023/01/11/%E5%B9%B6%E5%8F%91-%E6%AD%BB%E9%94%81/"/>
      <url>/2023/01/11/%E5%B9%B6%E5%8F%91-%E6%AD%BB%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="死锁定义"><a href="#死锁定义" class="headerlink" title="死锁定义"></a>死锁定义</h1><p>多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。 </p><h2 id="死锁的条件"><a href="#死锁的条件" class="headerlink" title="死锁的条件"></a>死锁的条件</h2><ul><li><strong>互斥条件</strong>：该资源任意一个时刻只由一个线程占用。(同一时刻，这个碗是我的，你不能碰)</li><li><strong>请求与保持条件</strong>：一个进程因请求资源而阻塞时，对已获得的资源保持不放。（我拿着这个碗一直不放）</li><li><strong>不剥夺条件</strong>:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。（我碗中的饭没吃完，你不能抢，释放权是我自己的，我想什么时候放就什么时候放）</li><li><strong>循环等待条件</strong>:若干进程之间形成一种头尾相接的循环等待资源关系。（我拿了A碗，你拿了B碗，但是我还想要你的B碗，你还想我的A碗)。</li></ul><h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">res1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">res2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (res1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; res1&quot;</span>);</span><br><span class="line">                <span class="comment">// 延迟一下, 确保B拿到了res2</span></span><br><span class="line">                <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (res2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; res2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;ThreadA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (res2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; res2&quot;</span>);</span><br><span class="line">                <span class="comment">// 延迟一下，确保A拿到了res1</span></span><br><span class="line">                <span class="keyword">synchronized</span> (res1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; res1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;ThreadB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解决死锁的办法"><a href="#解决死锁的办法" class="headerlink" title="解决死锁的办法"></a>解决死锁的办法</h1><ul><li>预防死锁：<ul><li><strong>资源一次性分配</strong>：破坏请求和保持条件。</li><li><strong>可剥夺资源</strong>：当进程新申请的资源不满足时，释放已经分配的资源。破坏不可剥夺条件</li><li><strong>资源有序分配</strong>：系统给进程编号，按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li></ul></li><li>避免死锁：银行家算法：分配资源前先评估风险，会不会在分配后导致死锁。　即分配给一个进程资源的时候，该进程能否全部返还占用的资源。</li><li>检测死锁：建立资源分配表和进程等待表。</li><li>解除死锁：可以直接撤销死锁进程，或撤销代价最小的进程。</li></ul><h1 id="找死锁的步骤"><a href="#找死锁的步骤" class="headerlink" title="找死锁的步骤"></a>找死锁的步骤</h1><ol><li>我们通过jps确定当前执行任务的进程号</li><li>然后执行jstack命令查看当前进程堆栈信息</li><li>然后将会看到<code>Found a total of 1 deadlock</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发-死锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ使用中遇到循环依赖</title>
      <link href="/2023/01/07/RocketMQ%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%81%87%E5%88%B0%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
      <url>/2023/01/07/RocketMQ%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%81%87%E5%88%B0%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
      
        <content type="html"><![CDATA[<p>在使用RocketMq发送事务消息的过程中，启动Springboot遇到循环依赖，报错如下：</p><p><img src="1.png"></p><p>这里显示是存在循环依赖，一步步屡屡思路，首先定义TransactionProducer初始化消息生产者的时候依赖CommenTransactionListener去set TransactionListener也就是设置本地事务执行方法和事务回查方法的实现类，</p><p><img src="2.png"></p><p>在CommenTransactionListener需要调用本地事务方法就依赖了CommenProducerImp（本地事务执行方法继承并实现了一个抽象类AbstractProducer）</p><p><img src="3.png"></p><p><img src="4.png"></p><p>在抽象类中定义了生产者发送消息的实体方法，和一个本地事务抽象方法。在发送消息功能必定需要获取定义的生产者，也就是依赖与TransactionMQProducer，循环依赖由此产生。</p><p><img src="5.png"></p><p><strong>解决方法：</strong></p><p>将java属性注解注入方式改为Set注入方式，或者添加@Lazy进行懒加载，问题解决。</p><p><img src="6.png"></p><p>具体原因为，上述所有的依赖均是使用filed注入方式也就是非构造函数注入，理论上是可以自动调节循环依赖的。但是这里有一个特殊情况是TransactionMQProducer被放置在@Configuration下的@Bean中，也就是说配置类中声明的其他Bean的构造过程其实是属于配置类的业务逻辑的一部分的。也就是说我们<strong>只有先将配置类的依赖全部满足之后才可以创建他自己声明的其他的Bean</strong>。（如果不加这个限制，那么在创建自己声明的其他Bean的时候，如果用到了自己的依赖，则有空指针的风险。）</p><p>我们来分析一下初始化路径：</p><ol><li><p>spring在加载CommenProducerImp的时候发现继承于AbstractProducer，就会先去加载父类</p></li><li><p>加载AbstractProducer的时候发现依赖TransactionMQProducer，但是TransactionMQProducer定义在@Configuration注解标注下的TransactionProducer类，又去加载这个类</p></li><li><p>加载TransactionProducer类的时候发现依赖CommenTransactionListener，注意这个时候在@Configuration标注的TransactionProducer类先加载依赖而不是先创建@Bean标注的TransactionMQProducer，但是进入到依赖CommenTransactionListener中发现它又依赖CommenProducerImp回到最开始，直接GG</p></li></ol><p>解决的思路就是采用懒加载的方式在@Configuration的内部依赖上加上@lazy注解，这样Spring不会完全初始化依赖的Bean，先创建一个代理这样就可以被放入三级缓存，再去创建@Bean标注的Bean时就可以避开循环依赖。</p><p>@lazy懒加载：这种情况下Spring不会完全初始化bean，而是创建一个代理注入到另一个bean中，被注入的bean只有在第一次真正使用时才会被创建。</p><p><strong>总结：</strong>对配置类进行依赖注入，几乎等价于对配置类中的所有Bean增加了一个强依赖，极大的提高了出现无法调解的循环依赖的风险。<strong>不要对有@Configuration注解的配置类进行Field级的依赖注入。</strong></p><p><a href="https://zhuanlan.zhihu.com/p/106539798">参考</a></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 循环依赖问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ消息可靠性保证</title>
      <link href="/2023/01/06/RocketMQ%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BF%9D%E8%AF%81/"/>
      <url>/2023/01/06/RocketMQ%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BF%9D%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<h1 id="消息可靠性保证"><a href="#消息可靠性保证" class="headerlink" title="消息可靠性保证"></a>消息可靠性保证</h1><h2 id="异步发送消息保证数据一致性"><a href="#异步发送消息保证数据一致性" class="headerlink" title="异步发送消息保证数据一致性"></a>异步发送消息保证数据一致性</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>消息最终一致性方案是指当事务发起方执行完成本地事务（数据库操作）后并发出一条消息给MQ，消费者一定能够接收消息并处理事务成功，强调的是只要消息发给消息消费者<strong>最终事务要达到一致</strong>。</p><ol><li><strong>首先确保本地事务与消息发送的原子性:<strong>事务发起方在本地事务执行成功后消息必须发出去，否则就</strong>丢弃消息本地事务也回滚</strong>。即实现本地事务和消息发送的原子性，要么都成功，要么都失败。本地事务与消息发送的原子性问题是实现可靠消息最终一致性方案的关键问题。<ul><li>解决方法：本地事务包裹</li></ul></li><li><strong>其次确保消费者消费消息的可靠性：</strong>消费者必须能够从消息队列成功消费消息，如果接收消息失败可以重复接收消息。</li><li><strong>保证消费消息的幂等性（重复消费的问题）：</strong>若某一个消费节点超时但是消费成功，此时消息中间件会重复投递此消息，就导致了消息的重复消费。要解决消息重复消费的问题就要实现事务参与方的方法幂等性。</li></ol><h3 id="解决方案1：本地信息表"><a href="#解决方案1：本地信息表" class="headerlink" title="解决方案1：本地信息表"></a>解决方案1：本地信息表</h3><p>在Producer端先进行数据库操作后发消息，即：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">begin transaction</span><br><span class="line"><span class="comment">// 1. 数据库操作</span></span><br><span class="line"><span class="comment">// 2. 发送MQ</span></span><br><span class="line">commit transaction</span><br></pre></td></tr></table></figure><p>先操作数据库，数据库操作成功后再发消息，如果消息发送成功了整个事务一致性没有问题。数据库操作成功后再发消息，如果数据发送失败了整个事务也能保持一致性。但是当数据库操作成功了，发送MQ也成功了只是由于网络原因迟迟MQ没有响应，导致发送MQ超时，最终会被误认为发送失败了，最终数据库操作也回滚了，而此时消息实际已经发出去了，这就导致数据库操作和发消息不一致。所以问题是如何保证100%将消息发送成功。</p><h4 id="保证消息100发送成功"><a href="#保证消息100发送成功" class="headerlink" title="保证消息100发送成功"></a>保证消息100发送成功</h4><p>由于网络波动等原因有可能消息是发送不成功到RocketMQ中的，或者发送成功但响应超时等，当遇到这种情况下我们就需要尝试重新发送，</p><ul><li>首先将要发的消息持久化到数据库中。</li><li>然后发送消息到MQ中。</li><li>如果发送成功就删除数据库中的该条记录。</li><li>如果发送失败不要报错再尝试几次发送，如果都失败保存到数据库中，后面由定时器再去尝试发送。</li></ul><p>无论是通过尝试多次发送，还是由定时任务继续补偿发送，都要保证该消息必须100%发送到MQ中。</p><h4 id="消费时保证幂等性"><a href="#消费时保证幂等性" class="headerlink" title="消费时保证幂等性"></a>消费时保证幂等性</h4><ul><li><p>消费时一般先打印一下消息内容日志，以便于排错。</p></li><li><p>消费消息需要注意<strong>幂等性</strong>，一般是先解析消息，然后根据消息的唯一条件等值去数据库中查询该消息的状态，如果是处理中或者处理完成就<strong>不需要继续处理了</strong>。</p></li><li><p>如果是消费失败，注意判断消费的次数，如果已经3次消费失败了就不再处理了，记录错误日志，由人工干预。</p></li><li><p>业务处理完了需要更新消息的状态。在更新状态的时候注意防止并发修改，<strong>使用数据库乐观锁。</strong></p></li><li><p>当消费消息时出现错误时需要将消息的状态更新为消费失败，并累加消费失败的次数。</p></li></ul><p><strong>代码示例</strong></p><p>发送消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RocketMQService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RocketMQTemplate rocketMQTemplate;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MQConsumerLogMapper mqConsumerLogMapper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MQProducerTempMapper mqProducerTempMapper;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(Message message)</span> <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="comment">// 1. 保证100%发送成功，持久化到数据库</span></span><br><span class="line">        <span class="type">MQProducerTemp</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MQProducerTemp</span>();</span><br><span class="line">        temp.setTopic(message.getTopic());</span><br><span class="line">        temp.setTags(message.getTags());</span><br><span class="line">        temp.setKeys(message.getKeys());</span><br><span class="line">        temp.setBody(<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        temp.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="type">MQConsumerLog</span> <span class="variable">consumeLog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MQConsumerLog</span>();</span><br><span class="line">        BeanUtils.copyProperties(temp, consumeLog);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 发送消息到RocketMQ</span></span><br><span class="line">        <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mqProducerTempMapper.insert(temp);</span><br><span class="line">            mqConsumerLogMapper.insert(consumeLog);</span><br><span class="line"></span><br><span class="line">            sendResult = rocketMQTemplate.getProducer().send(message);</span><br><span class="line">            <span class="comment">// 3. 发送成功删除临时消息</span></span><br><span class="line">            <span class="keyword">if</span> (sendResult.getSendStatus() == SendStatus.SEND_OK) &#123;</span><br><span class="line">                <span class="comment">// 删除消息</span></span><br><span class="line">                mqProducerTempMapper.deleteById(temp.getId());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 可以尝试再次发送或者后面由定时任务定时发送</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;消息发送失败： &#123;&#125;&quot;</span>, e);</span><br><span class="line">            <span class="comment">// 发送失败打记录错误原因</span></span><br><span class="line">            <span class="type">MQProducerTemp</span> <span class="variable">entity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MQProducerTemp</span>();</span><br><span class="line">            entity.setId(consumeLog.getId());</span><br><span class="line">            entity.setException(e.getMessage());</span><br><span class="line">            mqProducerTempMapper.updateById(entity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>消费消息：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener(</span></span><br><span class="line"><span class="meta">        consumerGroup = &quot;testConsumerGroup&quot;,</span></span><br><span class="line"><span class="meta">        topic = &quot;test-topic&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestTopicConsumerListener</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;MessageExt&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MQConsumerLogMapper mqConsumerLogMapper;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(MessageExt messageExt)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> messageExt.getTopic();</span><br><span class="line">        <span class="type">String</span> <span class="variable">tags</span> <span class="operator">=</span> messageExt.getTags();</span><br><span class="line">        <span class="type">String</span> <span class="variable">keys</span> <span class="operator">=</span> messageExt.getKeys();</span><br><span class="line">        <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(messageExt.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;开始消费：topic=&#123;&#125;, tags=&#123;&#125;, keys=&#123;&#125;, body=&#123;&#125;&quot;</span>, topic, tags, keys, body);</span><br><span class="line"></span><br><span class="line">        <span class="type">MQConsumerLog</span> <span class="variable">mqConsumerLog</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 查询消息</span></span><br><span class="line">            mqConsumerLog = mqConsumerLogMapper.selectOne(Wrappers.&lt;MQConsumerLog&gt;lambdaQuery()</span><br><span class="line">                    .eq(MQConsumerLog::getTopic, topic)</span><br><span class="line">                    .eq(MQConsumerLog::getTags, tags)</span><br><span class="line">                    .eq(MQConsumerLog::getKeys, keys)</span><br><span class="line">                    .orderByDesc(MQConsumerLog::getCreateTime)</span><br><span class="line">                    .last(<span class="string">&quot; limit 1 &quot;</span>)</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">if</span> (mqConsumerLog == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断消息状态</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">status</span> <span class="operator">=</span> mqConsumerLog.getStatus();</span><br><span class="line">            <span class="keyword">if</span> (status == <span class="number">1</span> || status == <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="comment">// 处理中或者处理成功都不需要重复处理(消息幂等性)</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">// 2 处理失败</span></span><br><span class="line">                <span class="keyword">if</span> (mqConsumerLog.getConsumeTimes() &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                    <span class="comment">// 超过指定消费次数记录日志，人工干预</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理业务逻辑</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用乐观锁修改消息状态为成功，如果update失败表示并发修改，打印日志即可</span></span><br><span class="line">            <span class="type">MQConsumerLog</span> <span class="variable">entity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MQConsumerLog</span>();</span><br><span class="line">            entity.setStatus(<span class="number">3</span>);</span><br><span class="line">            entity.setConsumeTimes(mqConsumerLog.getConsumeTimes() + <span class="number">1</span>);</span><br><span class="line">            entity.setUpdateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            entity.setVersion(mqConsumerLog.getVersion() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> mqConsumerLogMapper.update(entity, Wrappers.&lt;MQConsumerLog&gt;lambdaUpdate()</span><br><span class="line">                    .eq(MQConsumerLog::getId, mqConsumerLog.getId())</span><br><span class="line">                    .eq(MQConsumerLog::getVersion, mqConsumerLog.getVersion())</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">if</span> (row &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;并发修改&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;消费成功：topic=&#123;&#125;, tags=&#123;&#125;, keys=&#123;&#125;, body=&#123;&#125;&quot;</span>, topic, tags, keys, body);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 标记消息状态为处理失败，并累加消费次数</span></span><br><span class="line">            <span class="type">MQConsumerLog</span> <span class="variable">entity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MQConsumerLog</span>();</span><br><span class="line">            entity.setId(mqConsumerLog.getId());</span><br><span class="line">            entity.setStatus(<span class="number">2</span>);</span><br><span class="line">            entity.setConsumeTimes(mqConsumerLog.getConsumeTimes() + <span class="number">1</span>);</span><br><span class="line">            entity.setException(e.getMessage());</span><br><span class="line">            entity.setUpdateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            entity.setVersion(mqConsumerLog.getVersion());</span><br><span class="line">            mqConsumerLogMapper.updateById(entity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决方案2：RocketMQ事务消息"><a href="#解决方案2：RocketMQ事务消息" class="headerlink" title="解决方案2：RocketMQ事务消息"></a>解决方案2：RocketMQ事务消息</h3><p>在 RocketMQ 4.3后实现了完整的事务消息，实际上是对本地消息表的一个封装，将<strong>本地消息表移动到了 MQ内部</strong>，**解决Producer 端的消息发送与本地事务执行的原子性问题(上述问题1)**。</p><p><img src="3.png"></p><p><strong>执行流程：</strong>为方便说明我们以银行转账为例，即 bank1的张三转账给bank2的李四100元：，完整的过程是</p><p>bank1中张三账户扣除100元   并发送消息给MQ</p><p>消费者取出消息    将李四的账户增加100元。</p><ol><li>Producer 发送Half Message事务消息：Producer （MQ发送方）发送事务消息至MQ Server，MQ Server将消息状态标记为Prepared（预备状态），注意此时这条消息消费者（MQ订阅方）是无法消费到的。</li><li><strong>MQ Server回应消息发送成功：</strong>MQ Server接收到 Producer 发送给的消息则回应发送成功。表示 MQ已接收到消息。</li><li><strong>Producer 执行本地事务：</strong>Producer 端执行业务代码逻辑，通过本地数据库事务控制。本例中，将张三账户扣除100元。</li><li>消息投递：若 Producer 本地事务执行成功则自动向 MQServer发送 commit消息，MQ Server接收到 Commit消息后将“张三转账到李四” 状态标记为可消费，此时MQ订阅方（bank2）即正常消费消息。若Producer 本地事务执行失败则自动向 MQServer发送 Rollback消息，MQ Server接收到 Rollback消息后将删除“张三转账到李四”。如果消息成功投递，MQ订阅方（bank2）消费消息，消费成功则向MQ回应ack，否则将重复接收消息。这里 ack默认自动回应，即程序执行正常则自动回应ack，<strong>需要注意的是消费端要保证幂等性即不能重复消费。</strong></li><li>事务回查：如果执行 Producer端<strong>本地事务</strong>过程中，执行端挂掉，或者超时，MQ Server将会不停的询问同组的其他 Producer来获取事务执行状态，这个过程叫事务回查。MQ Server会根据事务回查结果来决定是否投递消息。以上主干流程已由RocketMQ实现，对用户侧来说，用户需要分别实现本地事务执行以及本地事务回查方法，因此只需关注本地事务的执行状态（维护本地事务状态表）即可。 RoacketMQ提供 RocketMQLocalTransactionListener接口，重写executeLocalTransaction执行本地事务，checkLocalTransaction执行事务状态回查</li></ol><p><strong>TransactionListener说明</strong></p><p>TransactionListener的两个接口是rocketmq二阶段执行本地事务及事务回查的入口。其返回值LocalTransactionState如下：</p><ul><li>COMMIT_MESSAGE：提交，本地事务执行成功，返回状态</li><li>ROLLBACK_MESSAGE：回滚，本地事务执行失败，返回状态</li><li>UNKNOW：未知，其它情况，返回该状态，会进行事务回查</li></ul><p>executeLocalTransaction()方法不同返回值场景说明：</p><ul><li>COMMIT_MESSAGE：事务提交，消费方可以消费消息，不会执行checkLocalTransaction方法</li><li>ROLLBACK_MESSAGE：事务回滚，消费方不会消费这条消息，不会执行checkLocalTransaction方法</li><li>UNKNOW：开始事务回查，执行checkLocalTransaction方法</li></ul><p>checkLocalTransaction()方法不同返回值场景说明：</p><ul><li>COMMIT_MESSAGE：事务提交，消费方可以消费消息，不会再执行checkLocalTransaction方法</li><li>ROLLBACK_MESSAGE：事务回滚，消费方不会消费这条消息，不会再执行checkLocalTransaction方法</li><li>UNKNOW：事务回查，继续执行checkLocalTransaction方法</li></ul><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>如果发送事务消息，在这里我们的创建的实例必须是 TransactionMQProducer，可以自定义线程池来处理检查请求</p><p><img src="5.png"></p><p>在通过 producer.sendMessageInTransaction发送事务消息后，如果消息发送成功，就会调用到下面的的executeLocalTransaction方法，来执行本地事务。在这里，它会<strong>完成本地事务和事务日志</strong>的插入。</p><p><img src="7.png"></p><p><img src="6.png"></p><p>checkLocalTransaction 方法就是用于事务状态查询。在这里，我们通过消息的唯一标识Key查询MqMessageLog这张表，如果可以查询到结果，就提交事务消息；如果没有查询到，就返回未知状态。注意，这里还涉及到另外一个问题。如果是返回未知状态，RocketMQ Broker服务器会以1分钟的间隔时间不断回查，直至达到事务回查最大检测数，如果超过这个数字还未查询到事务状态，则回滚此消息。<br>当然，事务回查的频率和最大次数，我们都可以配置。在 Broker 端，可以通过这样来配置它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brokerConfig.setTransactionCheckInterval(<span class="number">10000</span>); <span class="comment">//回查频率10秒一次</span></span><br><span class="line">brokerConfig.setTransactionCheckMax(<span class="number">3</span>);  <span class="comment">//最大检测次数为3</span></span><br></pre></td></tr></table></figure><p><img src="8.png"></p><h3 id="消费消息的幂等性："><a href="#消费消息的幂等性：" class="headerlink" title="消费消息的幂等性："></a>消费消息的幂等性：</h3><p><strong>解决上述问题3</strong>，发送消息重复可能有以下几个原因：</p><ul><li>发送时会发送多次，由于网络原因生产者没有收到Broker的成功响应，生产者会认为发送失败还会再尝试发送。</li><li>消息投递时重复投递，由于程序bug导致。</li><li>负载均衡，当某个消费者突然宕机了，消费的负载均衡会重新分配，可能会造成重复消费。</li></ul><p>消费消息的幂等性是指同一个消息无论消费多少次对最终的结果都是一致的。那么我们如何保障消费多次和消费一次的结果完全一样呢？那就是在消费者消费消息之前首先就要判断该消息是否已经消费了！那如何判断是否消费过呢？这就需要在<strong>发送消息时将该消息保存到数据库</strong>，<strong>数据库表中包含消费状态字段，如果查询数据库中改消息已经消费过了那就直接return了</strong>，后面的逻辑不需要再执行了。那查询数据库数据的唯一条件是什么呢？注意：RocketMQ不能保证msgId字段的唯一，所以通过msgId处理消费幂等性不靠谱，可以通过 topic + tag + key(业务key，业务唯一的标识，如订单号等,本项目中是采用UUID实现的)。</p><p><img src="4.png"></p><h2 id="解决消息丢失"><a href="#解决消息丢失" class="headerlink" title="解决消息丢失"></a>解决消息丢失</h2><h3 id="生产者消息丢失"><a href="#生产者消息丢失" class="headerlink" title="生产者消息丢失"></a>生产者消息丢失</h3><p>消息在生产者就丢失了说明没有成功发送到broker中，原因可能是程序发送失败抛出异常之后没有做重试处理，同步方式由于采用阻塞的方式不会出现这种问题。对于异步发送方式导致的丢失我们可以采用以下方案：</p><p><strong>异步发送+回调通知+本地数据库存储消息表</strong></p><p>举例：</p><ol><li>用户点赞后先保存本地数据和MQ消息表，这时候消息的状态是发送中，如果本地事务失败，那么点赞失败，事务回滚。</li><li>点赞成功，直接返回客户端成功，异步发送MQ消息</li><li>MQ回调通知消息发送结果，对应更新数据库MQ发送状态</li><li>Job轮询超过一定时间（时间根据业务配置）还未发送成功的消息去重试</li><li>在监控平台配置或者Job程序处理超过一定次数一直发送不成功的消息，告警，人工介入。</li></ol><p>对于大部分异步方式来说，回调的方式就足以解决消息丢失问题。</p><p>RocketMQ分为同步刷盘和异步刷盘两种方式，默认的是异步刷盘，就有可能导致消息还未刷到硬盘上就丢失了，可以通过设置为同步刷盘的方式来保证消息可靠性，这样即使MQ挂了，恢复的时候也可以从磁盘中去恢复消息。</p><h3 id="MQ消息丢失："><a href="#MQ消息丢失：" class="headerlink" title="MQ消息丢失："></a>MQ消息丢失：</h3><p>如果生产者保证消息发送到MQ，而MQ收到消息后还在内存中，这时候宕机了又没来得及同步给从节点，就有可能导致消息丢失。</p><p>RocketMQ分为同步刷盘和异步刷盘两种方式，默认的是异步刷盘，就有可能导致消息还未刷到硬盘上就丢失了，可以通过<strong>设置为同步刷盘</strong>的方式来保证消息可靠性，这样即使MQ挂了，恢复的时候也可以从磁盘中去恢复消息。但是会导致性能降低</p><h3 id="消费者丢失"><a href="#消费者丢失" class="headerlink" title="消费者丢失"></a><strong>消费者丢失</strong></h3><p>消费者刚收到消息，此时服务器宕机，MQ认为消费者已经消费，不会重复发送消息，消息丢失。</p><p>在RocketMq中默认是需要消费者回复ack确认，若是说出现了消费者对这个数据完成了消费，但是没有返回ack确认信息，重发的机制会根据MQ的类型不同进行不同间隔的时间的重复发送。若是说出现了多次重复发送仍然不能够收到正确的Ack确定信息，就会进入死信队列。这个时候就需要外人干预处理。具体见死信队列介绍。</p><h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><p><strong>死信队列用于处理无法被正常消费的消息，即死信消息</strong>。</p><p>当一条消息初次消费失败，<strong>消息队列 RocketMQ 会自动进行消息重试</strong>；达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息，此时，消息队列 RocketMQ 不会立刻将消息丢弃，而是将其发送到该<strong>消费者对应的特殊队列中</strong>，该特殊队列称为<strong>死信队列</strong>。</p><p><strong>死信消息的特点</strong>：</p><ul><li>不会再被消费者正常消费。</li><li>有效期与正常消息相同，均为 3 天，3 天后会被自动删除。因此，请在死信消息产生后的 3 天内及时处理。</li></ul><p><strong>死信队列的特点</strong>：</p><ul><li>一个死信队列对应一个 Group ID， 而不是对应单个消费者实例。</li><li>如果一个 Group ID 未产生死信消息，消息队列 RocketMQ 不会为其创建相应的死信队列。</li><li>一个死信队列包含了对应 Group ID 产生的所有死信消息，不论该消息属于哪个 Topic。</li></ul><p>消息队列 RocketMQ 控制台提供对死信消息的查询、导出和重发的功能，也可以做一个后台线程去订阅这个死信队列，完成后续消息的处理；。</p><h2 id="重试队列"><a href="#重试队列" class="headerlink" title="重试队列"></a>重试队列</h2><p>RocketMQ会有一个针对某一个ConsumerGroup的重试队列，如果消息消费后返回了RECONSUME_LATER状态，他就会把这批消息放到消费组的重试队列中去，比如消费组是”WMSConsumerGroup”，那么就会有一个“%RETRY%WMSConsumerGroup”，这个名字的重试队列；</p><p>然后过一段时间，重试队列中的消息会再次进行处理，如果再次失败，又返回了RECONSUME_LATER，那么会再过一段时间让我们再次进行处理，默认最多重试16次；每次重试之间的间隔时间是不一样的</p><h2 id="实现延迟队列"><a href="#实现延迟队列" class="headerlink" title="实现延迟队列"></a>实现延迟队列</h2><p>rocketmq发送延时消息时先把消息按照延迟时间段发送到指定的队列中(rocketmq把每种延迟时间段的消息都存放到同一个队列中)然后通过一个定时器进行轮训这些队列，查看消息是否到期，如果到期就把这个消息发送到指定topic的队列中，这样的好处是同一队列中的消息延时时间是一致的，还有一个好处是这个队列中的消息时按照消息到期时间进行递增排序的，说的简单直白就是队列中消息越靠前的到期时间越早</p><p>缺点：定时器采用了timer，timer是单线程运行，如果延迟消息数量很大的情况下，可能单线程处理不过来，造成消息到期后也没有发送出去的情况</p><p><strong>改进点：可以在每个延迟队列上各采用一个timer，或者使用timer进行扫描，加一个线程池对消息进行处理，这样可以提供效率</strong></p><h2 id="消息队列如何保证顺序消费"><a href="#消息队列如何保证顺序消费" class="headerlink" title="消息队列如何保证顺序消费"></a>消息队列如何保证顺序消费</h2><h3 id="消息的全局顺序和局部顺序"><a href="#消息的全局顺序和局部顺序" class="headerlink" title="消息的全局顺序和局部顺序"></a><strong>消息的全局顺序和局部顺序</strong></h3><p>全局顺序就是<strong>消除一切并发</strong>（很少用），一个Topic内所有的消息按照先进先出的顺序进行发布和消费，一个 Topic 一个队列，Producer 和 Consuemr 的并发都为一。比如订单系统中，生产者把 orderId 进行取模，把相同模的数据放到 messagequeue 里面，消费者消费同一个 messagequeue，只要消费者这边有序消费，那么可以保证数据被顺序消费。</p><p>局部顺序其实就是指某个队列顺序，多队列之间还是能并行的。可以通过 MessageQueueSelector <strong>指定 Producer 某个业务只发这一个队列，然后 Comsuer 通过MessageListenerOrderly 接受消息，其实就是加锁消费。</strong>在 Broker 会有一个 mqLockTable ，顺序消息在创建拉取消息任务的时候需要在 Broker 锁定该消息队列，之后加锁成功的才能消费。而严格的顺序消息其实很难，假设现在都好好的，如果有个 Broker 宕机了，然后发生了重平衡，队列对应的消费者实例就变了，就会有可能会出现乱序的情况，如果要保持严格顺序，那此时就只能让整个集群不可用了。</p><h3 id="何保证顺序"><a href="#何保证顺序" class="headerlink" title="何保证顺序"></a>何保证顺序</h3><p>在MQ的模型中，顺序需要由3个阶段去保障：</p><ol><li>消息被发送时保持顺序</li><li>消息被存储时保持和发送的顺序一致</li><li>消息被消费时保持和存储的顺序一致</li></ol><ul><li>发送时保持顺序意味着对于有顺序要求的消息，用户应该在<strong>同一个线程中采用同步的方式发送</strong>。</li><li>存储保持和发送的顺序一致则要求在<strong>同一线程中被发送出来的消息A和B，存储时在空间上A一定在B之前</strong>。</li><li>而消费保持和存储一致则要求消息A、B到达Consumer之后必须按照先A后B的顺序被处理。</li></ul><p><img src="9.png"></p><p>对于两个订单的消息的原始数据：a1、b1、b2、a2、a3、b3（绝对时间下发生的顺序）：</p><ul><li><p>在发送时，a订单的消息需要保持a1、a2、a3的顺序，b订单的消息也相同，但是a、b订单之间的消息没有顺序关系，这意味着a、b订单的消息<strong>可以在不同的线程中被发送出去,只要同一个线程中保持发送顺序就可以</strong></p></li><li><p>消费时保证顺序的简单方式就是“什么都不做”，不对收到的消息的顺序进行调整，即只要一个分区的消息只由一个线程处理即可。</p></li></ul><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p><strong>生产者端</strong></p><p>Producer端确保消息顺序唯一要做的事情就是将消息路由到特定的分区，在RocketMQ中，通过MessageQueueSelector来实现分区的选择。</p><p><img src="10.png"></p><ul><li>List<MessageQueue> mqs：消息要发送的Topic下所有的分区</MessageQueue></li><li>Message msg：消息对象</li><li>额外的参数：用户可以传递自己的参数</li></ul><p>如下实现就可以保证相同的订单的消息被路由到相同的分区：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> ((Order) object).getOrderId;</span><br><span class="line"><span class="keyword">return</span> mqs.get(orderId % mqs.size());<span class="comment">//返回需要发送的分区</span></span><br></pre></td></tr></table></figure><p><strong>消费端</strong>              </p><p>RocketMQ消费端有两种类型：MQPullConsumer和MQPushConsumer。<br>MQPullConsumer由用户控制线程，主动从服务端获取消息，每次获取到的是一个MessageQueue中的消息。PullResult中的List msgFoundList自然和存储顺序一致，用户需要再拿到这批消息后自己保证消费的顺序。</p><p>对于PushConsumer，由用户注册MessageListener来消费消息，在客户端中需要保证调用MessageListener时消息的顺序性。Comsuer可以 通过MessageListenerOrderly 接受消息，其实就是加锁消费。**在 Broker 会有一个 mqLockTable ，顺序消息在创建拉取消息任务的时候需要在 Broker 锁定该消息队列，之后加锁成功的才能消费。      </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">consumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerOrderly</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;        </span><br><span class="line">            <span class="comment">//模拟业务处理消息的时间</span></span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1000</span>));</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(msgs.getBody(),<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在以前普通消费消息时设置的回调是MessageListenerConcurrently，而顺序消费的回调设置是MessageListenerOrderly。它的底层实现方式就是保证某一个时刻，只有一个消费者的某一个线程在消费某一个MessageQueue，消费者端并不是简单的禁止并发处理，而是给每一个MessageQueue加锁， 保证同一个MessageQueue的消息不会被并发消费，但是不同的MessageQueue的消息是可以并发处理的。   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">MessageQueueLock</span> <span class="variable">messageQueueLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageQueueLock</span>();</span><br></pre></td></tr></table></figure><p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       </p><h2 id="RocketMQ的存储结构"><a href="#RocketMQ的存储结构" class="headerlink" title="RocketMQ的存储结构"></a>RocketMQ的存储结构</h2><p>RocketMQ消息的存储是由ConsumeQueue和CommitLog配合完成的，消息真正的物理存储文件是CommitLog，ConsumeQueue是消息的逻辑队列，类似数据库的索引文件，存储的是指向物理存储的地址。每个Topic下的每个Message Queue都有一个对应的ConsumeQueue文件。即Broker在收到消息之后，会把消息保存到commitlog的文件当中，而同时在分布式的存储当中，每个broker都会保存一部分topic的数据，同时，每个topic对应的messagequeue下都会生成consumequeue文件用于保存commitlog的物理位置偏移量offset，indexfile中会保存key和offset的对应关系。 </p><ul><li>CommitLog：存储消息的元数据</li><li>ConsumerQueue：存储消息在CommitLog的索引</li><li>IndexFile：为了消息查询提供了一种通过key或时间区间来查询消息的方法，这种通过IndexFile来查找消息的方法不影响发送与消费消息的主流程</li></ul><h3 id><a href="#" class="headerlink" title></a></h3><h3 id="RocketMQ的刷盘机制"><a href="#RocketMQ的刷盘机制" class="headerlink" title="RocketMQ的刷盘机制"></a><strong>RocketMQ的刷盘机制</strong></h3><p><img src="11.png"></p><p>1、同步刷盘</p><p>​    上面左图代表同步刷盘机制。消息从Producder端发送出去后，被Broker接收，Broker接收到消息后将消息写入内存的PageCache后，立即通知刷盘线程进行刷盘，当前线程等待刷盘线程的通知。刷盘线程开始进行刷盘操作，刷盘完毕后唤醒之前等待的线程，再返回写成功状态，最后Producer会收到消息发送成功的ACK。</p><p>2、异步刷盘</p><p>​    右图代表异步刷盘机制。消息从Producder端发送出去后，被Broker接收到，Broker端接收到消息后，消息被写入PageCache后立即返回写成功给Producer端。然后另一个异步线程专门会将PageCache中的数据写到磁盘里，确保消息的持久化。</p><p>3、同步和异步刷盘的比较</p><p>​    从上图的比较可以发现同步和异步刷盘的主要区别在于消息写入PageCache后是否立即返回写状态。可以从几个维度分析两者的差异：</p><p>吞吐量。由于异步刷盘在写入PageCache后立即返回，没有经历IO操作，因此吞吐量比同步刷盘的高很多。<br>可靠性。同步刷盘是在完全写磁盘成功后才算成功，而异步刷盘是写入PageCache就返回，PageCache本质就是内存，假如在异步线程写磁盘之前机器断电了，消息还是可能丢失的，因此可靠性方面同步刷盘较高。<br>性能方面。同步刷盘写入磁盘后才算成功，而异步刷盘只需要写入内存就算成功，因此异步刷盘性能高于同步刷盘。<br>适用场景。同步刷盘可靠性高，因此适用金融等对数据要求较高的场景。异步刷盘可靠性相对来说低一些，但是性能好，因此适合要求高吞吐和高性能的场景。</p><p>4、刷盘机制配置</p><p>​    刷盘方式可以通过Broker配置文件里的flushDiskType参数设置，这个参数有两种值：</p><p>SYNC_FLUSH (同步刷盘)。<br>ASYNC_FLUSH (异步刷盘)。</p><p>注意：RocketMQ 的文件都利用了内存映射即 Mmap，将程序虚拟页面直接映射到页缓存上，无需有内核态再往用户态的拷贝。</p><h3 id="主从机制中Master-和Salve-的数据同步"><a href="#主从机制中Master-和Salve-的数据同步" class="headerlink" title="主从机制中Master 和Salve 的数据同步"></a>主从机制中<strong>Master 和Salve 的数据同步</strong></h3><p><strong>从只能读，不能写，并且只有当前客户端读的 offset 和 当前 Broker 已接受的最大 offset 超过限制的物理内存大小时候才会去从读，所以正常情况下从分担不了流量。</strong></p><p>数据同步是根据raft协议进行的：</p><ol><li>在broker收到消息后，会被标记为uncommitted状态</li><li>然后会把消息发送给所有的slave</li><li>slave在收到消息之后返回ack响应给master</li><li>master在收到超过半数的ack之后，把消息标记为committed</li><li>发送committed消息给所有slave，slave也修改状态为committed</li></ol><h2 id="路由管理"><a href="#路由管理" class="headerlink" title="路由管理"></a>路由管理</h2><h3 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h3><ul><li>RocketMQ路由注册是通过Broker与NameServer的心跳功能实现的。</li><li>Broker启动时向集群中所有的NameServer发送心跳信息，每隔30s向集群中所有NameServer发送心跳包，NameServer收到心跳包时会更新brokerLiveTable缓存中BrokerLiveInfo的lastUpdataTimeStamp信息，然后NameServer每隔10s扫描brokerLiveTable，如果连续120S没有收到心跳包，NameServer将移除Broker的路由信息同时关闭Socket连接。</li></ul><h3 id="删除路由"><a href="#删除路由" class="headerlink" title="删除路由"></a>删除路由</h3><ul><li>Broker每隔30s向NameServer发送一个心跳包，心跳包包含BrokerId，Broker地址，Broker名称，Broker所属集群名称、Broker关联的FilterServer列表。但是如果Broker宕机，NameServer无法收到心跳包，此时NameServer如何来剔除这些失效的Broker呢？</li><li>NameServer会每隔10s扫描brokerLiveTable状态表，如果BrokerLive的<strong>lastUpdateTimestamp</strong>的时间戳距当前时间超过120s，则认为Broker失效，移除该Broker，关闭与Broker连接，同时更新topicQueueTable、brokerAddrTable、brokerLiveTable、filterServerTable。</li></ul><h3 id="路由发现"><a href="#路由发现" class="headerlink" title="路由发现"></a>路由发现</h3><p>RocketMQ路由发现是非实时的，当Topic路由出现变化后，NameServer不会主动推送给客户端，而是由客户端定时拉取主题最新的路由。</p><h2 id="消费长轮训"><a href="#消费长轮训" class="headerlink" title="消费长轮训"></a>消费长轮训</h2><p>拉取长轮询分析：源码上实际上还是个监听器</p><ul><li>RocketMQ未真正实现消息推模式，而是消费者主动向消息服务器拉取消息，RocketMQ推模式是循环向消息服务端发起消息拉取请求，如果消息消费者向RocketMQ拉取消息时，消息未到达消费队列时，如果不启用长轮询机制，则会在服务端等待shortPollingTimeMills时间后（挂起）再去判断消息是否已经到达指定消息队列，如果消息仍未到达则提示拉取消息客户端PULL—NOT—FOUND（消息不存在）；</li><li>如果开启长轮询模式，RocketMQ一方面会每隔5s轮询检查一次消息是否可达，同时一有消息达到后立马通知挂起线程再次验证消息是否是自己感兴趣的消息，如果是则从CommitLog文件中提取消息返回给消息拉取客户端，否则直到挂起超时，超时时间由消息拉取方在消息拉取是封装在请求参数中，PUSH模式为15s，PULL模式通过DefaultMQPullConsumer#setBrokerSuspendMaxTimeMillis设置。RocketMQ通过在Broker客户端配置longPollingEnable为true来开启长轮询模式。</li></ul><p>实际上， push模式只不过在pull模式下加了个监控</p><p><a href="https://rocketmq.apache.org/zh/docs/featureBehavior/04transactionmessage">官方事务参考1</a></p><p><a href="https://blog.csdn.net/zhengzhaoyang122/article/details/115773059">事务参考2</a></p><p><a href="https://blog.csdn.net/vbirdbest/article/details/113092707">事务参考3</a></p><p><a href="https://blog.csdn.net/wmq880204/article/details/122824895">事务参考4</a></p><p><a href="https://blog.csdn.net/bz120413/article/details/126721459">事务源码分析</a></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ消息可靠性保证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ详解与项目使用</title>
      <link href="/2023/01/04/RocketMQ%E8%AF%A6%E8%A7%A3%E4%B8%8E%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/01/04/RocketMQ%E8%AF%A6%E8%A7%A3%E4%B8%8E%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="消息中间件的用处"><a href="#消息中间件的用处" class="headerlink" title="消息中间件的用处"></a>消息中间件的用处</h1><ol><li>解耦：传统的软件开发模式，各个模块之间相互调用，数据共享，每个模块都要时刻关注其他模块的是否更改或者是否挂掉等等，使用消息队列，可以避免模块之间直接调用，将所需共享的数据放在消息队列中，对于新增业务模块，只要对该类消息感兴趣，即可订阅该类消息，对原有系统和业务没有任何影响，降低了系统各个模块的耦合度，提高了系统的可扩展性。</li><li>异步：消息队列提供了异步处理机制，在很多时候应用不想也不需要立即处理消息，允许应用把一些消息放入消息中间件中，并不立即处理它，在之后需要的时候再慢慢处理。</li><li>削峰：在访问量骤增的场景下，需要保证应用系统的平稳性，但是这样突发流量并不常见，如果以这类峰值的标准而投放资源的话，那无疑是巨大的浪费。使用消息队列能够使关键组件支撑突发访问压力，不会因为突发的超负荷请求而完全崩溃。消息队列的容量可以配置的很大，如果采用磁盘存储消息，则几乎等于“无限”容量，这样一来，高峰期的消息可以被积压起来，在随后的时间内进行平滑的处理完成，而不至于让系统短时间内无法承载而导致崩溃。在电商网站的秒杀抢购这种突发性流量很强的业务场景中，消息队列的强大缓冲能力可以很好的起到削峰作用。</li></ol><h1 id="消息中间件选型"><a href="#消息中间件选型" class="headerlink" title="消息中间件选型"></a>消息中间件选型</h1><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><p>优点：</p><ul><li>首先，Kafka的最大优势就在于它的<strong>高吞吐量</strong>，在普通机器4CPU8G的配置下，一台机器可以抗住十几万的QPS，这一点还是相当优越的。</li><li>其次，Kafka的性能同样很高，发送消息过去基本都是毫秒级别的。</li><li>Kafka支持集群部署，如果部分机器宕机不可用，则不影响Kafka的正常使用。</li></ul><p>缺点：</p><ul><li>Kafka有可能会<strong>造成数据丢失</strong>，因为它在收到消息的时候，并不是直接写到物理磁盘的，而是先写入到磁盘缓冲区里面的。</li><li>Kafka<strong>功能比较的单一</strong>主要的就是支持收发消息，高级功能基本没有，就会造成适用场景受限。</li></ul><p>业界里一般将kafka用来处理用户的行为日志的采集的传输，用在大数据场景较多，可以接受数据的丢失，而且要求吞吐量要极高。</p><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p>优点：</p><ul><li>RabbitMQ能保证数据不丢失</li><li>能保证高可用，部分机器宕机了还可以继续使用。</li><li>支持很多高级功能，如消息重试、死信队列等</li></ul><p>缺点：</p><ul><li>首先是RabbitMQ<strong>吞吐量比较低</strong>，大概在每秒几万的样子，这样像对于大型电商促销秒杀就不能胜任。</li><li>集群线性扩展比较麻烦。</li><li>开发语言是erlang，懂得人不是很多，无法对其改造。</li></ul><h2 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h2><p>RocketMQ是阿里巴巴开源的消息中间件，各方面也表现的比较优越，几乎同时解决了Kafka和RabbitMQ它们两个的缺点。</p><p>优点：</p><ul><li>吞吐量很高，大概普通机器有十万QPS往上。</li><li>保证高可用，高性能。</li><li>保证数据绝对不丢失</li><li>支持大规模集群部署，线性扩展方便</li><li>支持各种高级的功能，如延迟消息、消息回朔等</li><li>java语言开发，满足了国内绝大部分公司技术栈</li></ul><p><img src="1.jpg"></p><h2 id="选型"><a href="#选型" class="headerlink" title="选型"></a>选型</h2><ul><li>如果我们业务只是收发消息这种单一类型的需求，而且可以允许小部分数据丢失的可能性，但是又要求极高的吞吐量和高性能的话，就直接选Kafka就行了.</li><li>如果业务比较平稳,业务量比较少，而且没有什么改源码的特殊需求的话，在面对选择MQ的时候就可以选用RabbitMQ。</li><li>如果业务要求流量很大，且对消息丢失容忍度低，就直接用RocketMQ。</li></ul><h1 id="RocketMQ简介"><a href="#RocketMQ简介" class="headerlink" title="RocketMQ简介"></a>RocketMQ简介</h1><p>​RocketMQ作为一款纯java、分布式、队列模型的开源消息中间件，支持事务消息、顺序消息、批量消息、定时消息、消息回溯等。主要功能是异步解耦和流量削峰：。</p><h2 id="RocketMQ架构"><a href="#RocketMQ架构" class="headerlink" title="RocketMQ架构"></a>RocketMQ架构</h2><p><img src="2.png"></p><h3 id="Name-Server"><a href="#Name-Server" class="headerlink" title="Name Server"></a><strong>Name Server</strong></h3><p>NameServer是一个很简单的 Topic 路由注册中心，支持 Broker 的动态注册和发现，保存 Topic 和 Borker 之间的关系。通常也是集群部署，但是各 NameServer 之间不会互相通信， 各 NameServer 都有完整的路由信息，即无状态。</p><h3 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h3><p>主要负责消息的存储、查询消费，支持主从部署，一个 Master 可以对应多个 Slave，Master 支持读写，Slave 只支持读。Broker 会向集群中的每一台 NameServer 注册自己的路由信息。</p><h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><p>就是消息生产者，可以集群部署。它会先和 NameServer 集群中的随机一台建立长连接，得知当前要发送的 Topic 存在哪台 Broker Master上，具体是Producer 每 30s 会向 NameSrv 拉取路由信息更新本地路由表，有新的 Broker 就和其建立长连接，每隔 30s 发送心跳给 Broker 。然后再与其建立长连接，支持多种负载平衡模式发送消息。</p><h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>消息消费者，也可以集群部署。它也会先和 NameServer 集群中的随机一台建立长连接，得知当前要消息的 Topic 存在哪台 Broker Master、Slave上，然后它们建立长连接，支持集群消费和广播消费消息，支持PUSH和PULL两种消费模式，并且消费者订阅消息是以 ConsumerGroup 为单位存储的，所以ConsumerGroup 中的每个 Consumer 需要有相同的订阅。因为订阅消息是随着心跳上传的，如果一个 ConsumerGroup 中 Consumer 订阅信息不一样，那么就会出现互相覆盖的情况。比如消费者 A 订阅 Topic a，消费者 B 订阅 Topic b，此时消费者 A 去 Broker 拿消息，然后 B 的心跳包发出了，Broker 更新了，然后接到 A 的请求，一脸懵逼，没这订阅关系啊。</p><h3 id="PullConsumer"><a href="#PullConsumer" class="headerlink" title="PullConsumer"></a>PullConsumer</h3><p>Pull：拉取型消费者（Pull Consumer）主动从消息服务器拉取信息，只要批量拉取到消息，用户应用就会启动消费过程，所以 Pull 称为主动消费型。Pull方式里,取消息的过程需要用户自己写,首先通过打算消费的Topic拿到MessageQueue的集合,遍历MessageQueue集合,然后针对每个MessageQueue批量取消息,一次取完后,记录该队列下一次要取的开始offset,直到取完了,再换另一个MessageQueue。</p><p><strong>缺点：</strong><br>由于主动权在消费方,消费方无法准确地决定何时去拉取最新的消息。如果一次Pull取到消息了还可以继续去Pull,如果没有Pull取到则需要等待一段时间重新Pull，在阿里中的解决是长轮询  Pull,消费者如果尝试拉取失败,不是直接return,而是把连接挂在那里wait,服务端如果有新的消息到来,把连接notify起来,这也是不错的思路。但海量的长连接block对系统的开销还是不容小觑的,还是要合理的评估时间间隔,给wait加一个时间上限比较好。</p><h4 id="PushConsumer"><a href="#PushConsumer" class="headerlink" title="PushConsumer"></a>PushConsumer</h4><p>推送型消费者（Push Consumer）封装了消息的拉取、消费进度和其他的内部维护工作，将消息到达时执行的回调接口留给用户应用程序来实现。所以 Push  称为被动消费类型，但从实现上看还是从消息服务器中拉取消息，不同于 Pull 的是 Push  首先要注册消费监听器，当监听器处触发后才开始消费消息。</p><p><strong>缺点：</strong><br>慢消费无疑是Push模式最大的致命伤,如果消费者的速度比发送者的速度慢很多,势必造成消息在broker的堆积。假设这些消息都是有用的无法丢弃的,消息就要一直在broker端保存。当然这还不是最致命的,最致命的是broker给consumer推送一堆consumer无法处理的消息,consumer不是reject就是error,然后来回踢皮球。所以push适合于没有慢消费情况的场景下</p><p><strong>建议使用主动拉去消息而不是使用事件的监听</strong>（事件驱动方式是建立好长连接，由事件（发送数据）的方式来实时推送。如果broker主动推送消息的话有可能push速度快，消费速度慢的情况，那么就会造成消息在consumer端堆积过多，同时又不能被其他consumer消费的情况。而pull的方式可以根据当前自身情况来pull，不会造成过多的压力而造成瓶颈。所以采取了pull的方式。）</p><h3 id="四者关系"><a href="#四者关系" class="headerlink" title="四者关系"></a>四者关系</h3><p>先启动 NameServer 集群，各 NameServer  之间无任何数据交互，Broker 启动之后会向所有 NameServer 定期（每  30s）发送心跳包，包括：IP、Port、TopicInfo，NameServer 会定期扫描 Broker 存活列表，如果超过 120s  没有心跳则移除此 Broker 相关信息，代表下线。<br>这样每个  NameServer 就知道集群所有 Broker 的相关信息，此时 Producer 上线从 NameServer 就可以得知它要发送的某  Topic 消息在哪个 Broker 上，和对应的 Broker （Master 角色的）建立长连接，发送消息。<br>Consumer 上线也可以从 NameServer  得知它所要接收的 Topic 是哪个 Broker ，和对应的 Master、Slave 建立连接，接收消息。</p><h3 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a><strong>Topic</strong></h3><p>Topic 是一种消息的逻辑分类，比如说你有订单类的消息，也有库存类的消息，那么就需要进行分类，一个是订单 Topic 存放订单相关的消息，一个是库存 Topic 存储库存相关的消息。</p><p>一个发送者可以发送消息给一个或者多个Topic<br>一个消息接受者可以订阅一个或多个Topic消息；</p><h3 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a><strong>Tag</strong></h3><p>标签可以被认为是对 Topic 进一步细化。一般在相同业务模块中通过引入标签来标记不同用途的消息。</p><h3 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h3><p>Group 分为两个部分 生产者和消费者</p><ul><li><strong>生产者：</strong> 表示发送同一类消息的 Producer，通常情况下发送逻辑是一致的。发送普通消息时，用于标识使用，没有特别的用处。<br>主要用来作用于事务消息，当事务消息中某条消息一直处于等待状态并超时，Broker会回查同一个Group下的其他producer，确定该消息是 commit 还是 rollback</li><li><strong>消费者：</strong>  消费者的分组就非常有意义了，消费者是标识一类 Consumer 的集合名称，这类 Consumer 通常消费一类消息，且消费逻辑一致。同一个 Consumer Group 下的各个实例将共同消费 topic 的消息，起到负载均衡的作用。<br>消费进度以 Consumer Group 为粒度管理，不同 Consumer Group 之间消费进度彼此不受影响，即消息 A 被 Consumer Group1 消费过，也会再给 Consumer Group2 消费。</li></ul><h3 id="Message-Queue"><a href="#Message-Queue" class="headerlink" title="Message Queue"></a>Message Queue</h3><p>消息队列 简称 Queue ，消息物理管理单位。用来并行发送和接收消息，相当于是Topic的分区。<br>一个Topic会有若干个Queue，消息的生产一般会比消息消费的速度要快，消息进行消费的时会有对应的业务逻辑进行处理，这个时候就会降低消息消费的速度。所有一般Topic会有若干个Queue。主要用来解决生产很快，消费很慢。<br>如果同一个Topic创建在不同的Broker，那么不同的Broker有不同的Queue，将物理存储在不同的Broker节点之上，具有水平扩展的能力。无论是生产者还是消费者，实际的操作都是针对Queue级别。</p><h3 id="Offset"><a href="#Offset" class="headerlink" title="Offset"></a><strong>Offset</strong></h3><p>在RocketMQ 中，所有消息队列都是持久化，长度无限的数据结构，所谓长度无限是指队列中的每个存储单元都是定长，访问其中的存储单元使用Offset  来访问，Offset 为 java long 类型，64 位，理论上在 100年内不会溢出，所以认为是长度无限。也可以认为 Message Queue 是一个长度无限的数组，Offset 就是下标。</p><h1 id="RocketMQ在项目中的使用："><a href="#RocketMQ在项目中的使用：" class="headerlink" title="RocketMQ在项目中的使用："></a><strong>RocketMQ在项目中的使用：</strong></h1><p>需求：将用户对帮助帖子的点赞、评论、以及申请进入活动团队、绑定邮件发送等任务使用消息中间件实现。</p><h2 id="发送者实例创建"><a href="#发送者实例创建" class="headerlink" title="发送者实例创建"></a>发送者实例创建</h2><p>这里将DefaultMQProducer在启动的一开始就作为Bean注入到容器中，其中MqProducerProperties就是从yml配置文件中读取NamesrvAddr和Group。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultProducerConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(DefaultProducerConfig.class);</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MqProducerProperties propertiesProperties;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="keyword">public</span> DefaultMQProducer <span class="title function_">defaultProducer</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException &#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(propertiesProperties.getGroup());</span><br><span class="line">        producer.setNamesrvAddr(propertiesProperties.getNamesrvAddr());</span><br><span class="line">        producer.setVipChannelEnabled(<span class="literal">false</span>);</span><br><span class="line">        producer.setRetryTimesWhenSendAsyncFailed(<span class="number">10</span>);</span><br><span class="line">        producer.start();</span><br><span class="line">        log.info(<span class="string">&quot;default producer 创建成功, &#123;&#125;, &#123;&#125;&quot;</span>, propertiesProperties.getNamesrvAddr(), propertiesProperties.getGroup());</span><br><span class="line">        <span class="keyword">return</span> producer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="发送消息实现类"><a href="#发送消息实现类" class="headerlink" title="发送消息实现类"></a>发送消息实现类</h2><p>消息发送实现类主要将MqMessageDTO中的信息构建成Message，采用同步的发送监听发送状态的方式 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqProducerServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">MqProducerService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(MqProducerServiceImpl.class);</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DefaultMQProducer defaultMQProducer;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sendMessage</span><span class="params">(MqMessageDTO mqMessageDTO)</span> &#123;</span><br><span class="line"><span class="comment">//        log.info(&quot;开始发送消息, mqMessageDTO:&#123;&#125;&quot;, JSON.toJSONString(mqMessageDTO));</span></span><br><span class="line">        SendResult sendResult;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(mqMessageDTO.getTopic(), mqMessageDTO.getTag(), mqMessageDTO.getKey(), mqMessageDTO.getContent());</span><br><span class="line">            sendResult = defaultMQProducer.send(message);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;消息发送失败, mqMessageDTO=&#123;&#125;, cause:&#123;&#125;&quot;</span>, JSON.toJSONString(mqMessageDTO), e);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (SendStatus.SEND_OK.equals(sendResult.getSendStatus())) &#123;</span><br><span class="line"><span class="comment">//            log.info(&quot;发送成功, sendResult:&#123;&#125;&quot;, JSON.toJSONString(sendResult));</span></span><br><span class="line">            mqMessageDTO.setMsgId(sendResult.getMsgId());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="启动推送型消费者"><a href="#启动推送型消费者" class="headerlink" title="启动推送型消费者"></a>启动推送型消费者</h2><p>定义一个AbstractConsumerListener接口，在接口中实现了根据MqConsumerProperties配置读取Bean中的namesrvAddr，group开启DefaultMQPushConsumer的消费者，订阅了一个topic下的所有tag，并定义了一个业务处理接口onMessage，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractConsumerListener</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(AbstractConsumerListener.class);</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MqConsumerProperties consumerProperties;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开启消费注册</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> topic</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tags  支持多个tag, 如 tag1 || tag2 || tag3</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> MQClientException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listener</span><span class="params">(String topic, String tags)</span> <span class="keyword">throws</span> MQClientException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;开启&quot;</span> + topic + <span class="string">&quot;:&quot;</span> + tags + <span class="string">&quot;消费者&quot;</span>);</span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(consumerProperties.getGroup());</span><br><span class="line">        consumer.setNamesrvAddr(consumerProperties.getNamesrvAddr());</span><br><span class="line">        <span class="comment">//订阅topics</span></span><br><span class="line">        consumer.subscribe(topic, tags);</span><br><span class="line"></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> AbstractConsumerListener.<span class="built_in">this</span>.onMessage(msgs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理body的业务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> ConsumeConcurrentlyStatus <span class="title function_">onMessage</span><span class="params">(List&lt;MessageExt&gt; msgs)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="默认消费者消费逻辑"><a href="#默认消费者消费逻辑" class="headerlink" title="默认消费者消费逻辑"></a>默认消费者消费逻辑</h2><p>继承上述接口并实现ApplicationListener<ContextRefreshedEvent>，并重写onApplicationEvent，这样在程序启动时所有的Bean构造完成后就会开启消费者：</ContextRefreshedEvent></p><p>实现ApplicationContextAware方便根据BeanName获取容器中Bean（MqConsumerBeanEnum）</p><p>重写上述接口的onMessage方法实现根据消费到的消息的Topic和Tag拼接成topicTag去MqConsumerBeanEnum中找对应业务的实现Bean。然后调用可以选择执行前置和后置方法或者调用业务处理类的方法进行业务处理。具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultConsumerListener</span> <span class="keyword">extends</span> <span class="title class_">AbstractConsumerListener</span> <span class="keyword">implements</span></span><br><span class="line">        <span class="title class_">ApplicationContextAware</span>, ApplicationListener&lt;ContextRefreshedEvent&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(DefaultConsumerListener.class);</span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">onMessage</span><span class="params">(List&lt;MessageExt&gt; msgs)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">topicTag</span> <span class="operator">=</span> msg.getTopic() + <span class="string">&quot;:&quot;</span> + msg.getTags();</span><br><span class="line">            <span class="type">MqConsumerBeanEnum</span> <span class="variable">mqConsumerBeanEnum</span> <span class="operator">=</span> MqConsumerBeanEnum.getBeanByTopicTag(topicTag);</span><br><span class="line">            <span class="keyword">if</span> (mqConsumerBeanEnum == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ConsumeConcurrentlyStatus</span> <span class="variable">consumerStatus</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">serviceBean</span> <span class="operator">=</span> applicationContext.getBean(mqConsumerBeanEnum.getBeanName());</span><br><span class="line">                <span class="keyword">if</span> (serviceBean == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (serviceBean <span class="keyword">instanceof</span> MqConsumerService) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(msg.getBody(), <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                    <span class="type">MqConsumerService</span> <span class="variable">consumerService</span> <span class="operator">=</span> (MqConsumerService) serviceBean;</span><br><span class="line">                    <span class="comment">// 预处理</span></span><br><span class="line">                    consumerService.beforeHandler(message);</span><br><span class="line">                    <span class="comment">// 处理</span></span><br><span class="line">                    consumerStatus = consumerService.handle(message);</span><br><span class="line">                    <span class="comment">// 处理之后</span></span><br><span class="line">                    consumerService.afterHandler(message, <span class="keyword">new</span> <span class="title class_">Date</span>(), consumerStatus);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;body转字符串解析失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ContextRefreshedEvent contextRefreshedEvent)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 订阅同一个topic下的多个tag</span></span><br><span class="line">            <span class="built_in">super</span>.listener(<span class="string">&quot;UniversityTeam_PROJECT&quot;</span>, <span class="string">&quot;Like_MQ || Comment_MQ || TeamsApplyOrInvite_MQ&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;consumer error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="built_in">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_25145759/article/details/114299339">PullConsumer示例</a></p><p><a href="https://blog.csdn.net/csdnnews/article/details/109505979?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167282357716800184198759%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167282357716800184198759&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-109505979-null-null.142%5Ev68%5Ewechat_v2,201%5Ev4%5Eadd_ask,213%5Ev2%5Et3_esquery_v3&utm_term=%E8%BF%9B%E9%98%B6%E5%BF%85%E7%9C%8B%E7%9A%84%20RocketMQ%EF%BC%8C%E5%B0%B1%E8%BF%99%E7%AF%87%E4%BA%86%EF%BC%81&spm=1018.2226.3001.4187">概念参考</a></p><p><a href="https://zhuanlan.zhihu.com/p/525640488">概念代码示例参考</a></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMQ详解 </tag>
            
            <tag> RocketMQ项目使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring事务</title>
      <link href="/2023/01/02/Spring%E4%BA%8B%E5%8A%A1/"/>
      <url>/2023/01/02/Spring%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p><strong>定义：事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong></p><p><strong>事务的特性（ACID）：</strong>这里在数据库提过了，再啰嗦一遍</p><p><strong>原子性（Atomicity）：</strong> 一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</p><p><strong>一致性（Consistency）：</strong> 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。</p><p><strong>隔离性（Isolation）：</strong> 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读（Read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（Serializable）。</p><p><strong>持久性（Durability）:</strong> 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p><p><strong>MySQL保证原子性的原理：</strong></p><p>如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong>，在 MySQL 中，恢复机制是通过 <strong>回滚日志（undo log）</strong> 实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用 <strong>回滚日志</strong> 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。</p><h2 id="Spring-支持两种方式的事务管理"><a href="#Spring-支持两种方式的事务管理" class="headerlink" title="Spring 支持两种方式的事务管理"></a>Spring 支持两种方式的事务管理</h2><h3 id="编程式事务管理"><a href="#编程式事务管理" class="headerlink" title="编程式事务管理"></a>编程式事务管理</h3><p>通过 TransactionTemplate或者TransactionManager手动管理事务，实际应用中很少使用</p><h3 id="声明式事务管理"><a href="#声明式事务管理" class="headerlink" title="声明式事务管理"></a>声明式事务管理</h3><p>基于@Transactional 的全注解方式使用最多，实际是通过 AOP 实现，使用 @Transactional注解进行事务管理的示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> aMethod &#123;</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">  <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">  <span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">  b.bMethod();</span><br><span class="line">  c.cMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>@Transactional</code> 的常用配置参数总结（只列出了 5 个我平时比较常用的）：</strong></p><table><thead><tr><th align="left">属性名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">propagation</td><td align="left">事务的传播行为，默认值为 REQUIRED，可选的值在上面介绍过</td></tr><tr><td align="left">isolation</td><td align="left">事务的隔离级别，默认值采用 DEFAULT，可选的值在上面介绍过</td></tr><tr><td align="left">timeout</td><td align="left">事务的超时时间，默认值为-1（不会超时）。如果超过该时间限制但事务还没有完成，则自动回滚事务。</td></tr><tr><td align="left">readOnly</td><td align="left">指定事务是否为只读事务，默认值为 false。</td></tr><tr><td align="left">rollbackFor</td><td align="left">用于指定能够触发事务回滚的异常类型，并且可以指定多个异常类型</td></tr></tbody></table><h2 id="Spring-事务传播行为"><a href="#Spring-事务传播行为" class="headerlink" title="Spring 事务传播行为"></a>Spring 事务传播行为</h2><p><strong>事务传播行为是为了解决业务层方法之间互相调用的事务问题</strong>:当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。</p><p><img src="1.jpg"></p><ol><li><strong>required</strong>（默认）：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li><li><strong>requires_new</strong>：创建一个新事务，如果当前事务存在，把当前事务挂起。也就是说不管外部方法是否开启事务，requires_new修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</li><li><strong>supports</strong>：支持使用当前事务，如果当前事务不存在，则不使用事务。</li><li><strong>not_supported</strong>：无事务执行，如果当前事务存在，把当前事务挂起。</li><li><strong>mandatory</strong>：强制，支持使用当前事务，如果当前事务不存在，则抛出Exception。</li><li><strong>never</strong>：无事务执行，如果当前有事务则抛出Exception。</li><li><strong>nested</strong>：嵌套事务，如果当前事务存在，那么在嵌套的事务中执行。如果当前事务不存在，则表现跟REQUIRED一样。</li></ol><h2 id="Spring-事务中的隔离级别"><a href="#Spring-事务中的隔离级别" class="headerlink" title="Spring 事务中的隔离级别"></a>Spring 事务中的隔离级别</h2><p>为了方便使用，Spring 也相应地定义了一个枚举类：<code>Isolation</code></p><ul><li><strong>TransactionDefinition.ISOLATION_DEFAULT:</strong> 使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ可重复读隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.</li><li><strong>TransactionDefinition.ISOLATION_READ_UNCOMMITTED:</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></li><li><strong>TransactionDefinition.ISOLATION_READ_COMMITTED:</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li><li><strong>TransactionDefinition.ISOLATION_REPEATABLE_READ:</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li><li><strong>TransactionDefinition.ISOLATION_SERIALIZABLE:</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li></ul><h2 id="Transactional-rollbackFor-x3D-Exception-class-注解"><a href="#Transactional-rollbackFor-x3D-Exception-class-注解" class="headerlink" title="@Transactional(rollbackFor &#x3D; Exception.class)注解"></a>@Transactional(rollbackFor &#x3D; Exception.class)注解</h2><p>​Exception 分为运行时异常 RuntimeException 和非运行时异常。在 @Transactional 注解中如果不配置rollbackFor属性,那么事务只会在遇到RuntimeException的时候才会回滚，加上 rollbackFor&#x3D;Exception.class,可以让事务在遇到非运行时异常时也回滚。</p><p>​当 @Transactional 注解作用于类上时，该类的<strong>所有 public 方法将都具有该类型的事务属性</strong>，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。<strong>如果类或者方法加了这个注解，那么这个类里面的方法或者该方法抛出异常，就会回滚，数据库里面的数据也会回滚。</strong></p><p>如果事务不回滚的解决方案：</p><ol><li>检查方法是不是public</li><li>检查异常是不是unchecked异常</li><li>如果是checked异常也想回滚的话，注解上写明异常类型即可@Transactional(rollbackFor&#x3D;Exception.class)</li></ol><h2 id="Spring事务原理"><a href="#Spring事务原理" class="headerlink" title="Spring事务原理"></a>Spring事务原理</h2><p>Spring事务是由 AOP机制实现的，AOP机制的本质就是动态代理，也就是说：从 Spring IOC容器获取 bean时，Spring会为目标类创建代理，从而支持事务。</p><p>如果一个类或者一个类中的 public 方法上被标注@Transactional 注解的话，Spring 容器就会在启动的时候为其创建一个代理类，在调用被@Transactional 注解的 public 方法的时候，<strong>实际调用的是，TransactionInterceptor 类中的 invoke()方法。这个方法的作用就是在目标方法之前开启事务，方法执行过程中如果遇到异常的时候回滚事务，方法调用完成之后提交事务。</strong></p><p>利用TransactionManagementConfigurationSelector给容器中会导入组件</p><ul><li>AutoProxyRegistrar<ul><li>给容器中注册一个 InfrastructureAdvisorAutoProxyCreator 组件</li><li>利用后置处理器机制在对象创建以后，包装对象，返回一个代理对象（增强器），代理对象执行方法利用拦截器链进行调用；</li></ul></li><li>ProxyTransactionManagementConfiguration（给容器中注册事务增强器）<ul><li>事务增强器要用事务注解的信息，AnnotationTransactionAttributeSource解析事务注解</li><li>事务拦截器</li></ul></li></ul><h2 id="事务失效的8大原因："><a href="#事务失效的8大原因：" class="headerlink" title="事务失效的8大原因："></a>事务失效的8大原因：</h2><ol><li><strong>数据库引擎不支持事务</strong></li><li><strong>没有被 Spring 管理：也就是加@Transactional注解的类和方法没有注入到Spring容器</strong></li><li><strong>方法不是 public 的</strong></li><li><strong>自身调用问题（经典问题）：</strong></li></ol><p>示例1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        updateOrder(order);</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        <span class="comment">// update order</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>update方法上面没有加 <code>@Transactional</code> 注解，调用有 <code>@Transactional</code> 注解的 updateOrder 方法，updateOrder 方法上的事务失效</p><p>示例2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        updateOrder(order);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        <span class="comment">// update order</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>update 方法上加了 @Transactional，updateOrder 加了 REQUIRES_NEW 新开启一个事务，那么新开的事务失效</p><p>这是Spring事务失效的经典原因： spring框架是通过<strong>TransactionInterceptor类</strong>来控制事务开启,提交,回滚等, 它会创建一个<strong>目标类的代理类</strong>. 而在本示例中,update方法调用updateOrder方法时,并不是通过代理类去调用,而是通过this调用本身的方法updateOrder方法.所以updateOrder方法的事务并不会开启.</p><p><strong>解决办法：</strong></p><ol><li>将updateOrder方法抽取到另一个XxxService方法中, 然后再将这个XxxService注入到OrderServiceImpl类中,通过xxxService.updateOrder()调用, 这样updateOrder方法的事务就会生效了.</li><li>第2种方式通过AopContext创建一个代理</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个代理</span></span><br><span class="line">    <span class="type">OrderServiceImpl</span> <span class="variable">orderServiceImpl</span> <span class="operator">=</span> (OrderServiceImpl) AopContext.currentProxy();</span><br><span class="line">        orderServiceImpl.updateOrder(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><p><strong>数据源没有配置事务管理器</strong></p></li><li><p><strong>不支持事务（传播机制）</strong></p></li><li><p><strong>异常被吃了（捕获异常）：</strong></p></li></ol><p>如下面例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">         userRepository.save(user);</span><br><span class="line">         <span class="comment">// 模拟异常，数据库的记录应该回滚</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">         log.error(<span class="string">&quot;addUser#error,user:&#123;&#125;,e&quot;</span>, user, e);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>try catch把异常吞了但是没有再抛出异常，那么事务就不会回滚就失效喽。需要在catch中再将异常抛出这样就会触发事务回滚</p><ol start="8"><li><strong>异常类型错误（checked异常失效）</strong></li></ol><p>如果抛出自定义继承Exception的异常是checked异常，但是spring事务默认回滚的是：RuntimeException。</p><p>如果是checked异常也想回滚的话，注解上写明异常类型即可@Transactional(rollbackFor&#x3D;Exception.class)</p>]]></content>
      
      
      <categories>
          
          <category> Java框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot自动装配原理</title>
      <link href="/2023/01/02/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/"/>
      <url>/2023/01/02/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Boot-Starter"><a href="#Spring-Boot-Starter" class="headerlink" title="Spring Boot Starter"></a>Spring Boot Starter</h2><p>Spring Boot通过提供众多起步依赖（Starter）降低项目依赖的复杂度。起步依赖本质上是一个Maven项目对象模型（Project Object Model, POM），定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。很多起步依赖的命名都暗示了它们提供的某种或某类功能。例如，添加spring-boot-starter-web依赖，就可以用于构建REST API服务，其包含了SpringMVC和Tomcat内嵌容器。</p><h2 id="Spring-Boot自动装配的过程"><a href="#Spring-Boot自动装配的过程" class="headerlink" title="Spring Boot自动装配的过程"></a>Spring Boot自动装配的过程</h2><p>使用Spring Boot时，我们只需引入对应的Starters，Spring Boot启动时便会自动加载相关依赖，配置相应的初始化参数，以最快捷、简单的形式对第三方软件进行集成，这便是Spring Boot的自动配置功能。流程图如下：</p><p><img src="1.jpg"></p><p>整个自动装配的过程是：Spring Boot通过@EnableAutoConfiguration注解开启自动配置，用LoadSpringFactories()方法加载&#x2F;META-INF&#x2F;spring.factories文件中注册的各种AutoConfiguration类，当某个AutoConfiguration类满足其注解**@Conditional**指定的生效条件（Starters提供的依赖、配置或Spring容器中是否存在某个Bean等）时，实例化该AutoConfiguration类中定义的Bean（组件等），并注入Spring容器，就可以完成依赖框架的自动配置。</p><p>spring.factories是一个神奇的文件，SpringBoot会自动的去扫描加载每个jar保重WEB-INF目录下的这个文件，并且读取相关的配置，然后利用反射去加载对应配置类，进行相应的环境配置和参数设置。</p><h2 id="自定义SpringBoot-Starter"><a href="#自定义SpringBoot-Starter" class="headerlink" title="自定义SpringBoot Starter"></a><strong>自定义SpringBoot Starter</strong></h2><ol><li>引入项目的配置依赖</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.5</span><span class="number">.3</span>.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建xxxService类，完成相关的操作逻辑</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String str1;</span><br><span class="line">    <span class="keyword">private</span> String str2;</span><br><span class="line"> ｝</span><br></pre></td></tr></table></figure><ol start="3"><li>定义xxxProperties类，属性配置类，完成属性配置相关的操作，比如设置属性前缀，用于在application.properties中配置</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定项目在属性文件中配置的前缀为str，即可以在属性文件中通过 str.str1=springboot，就可以改变属性类字段 str1 的值了</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;ConfigurationProperties&quot;)</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;str&quot;)</span><span class="comment">//前缀</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoProperties</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_STR1</span> <span class="operator">=</span> <span class="string">&quot;I know, you need me&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_STR2</span> <span class="operator">=</span> <span class="string">&quot;but I also need you&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> DEFAULT_STR1;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> DEFAULT_STR2;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li>定义xxxAutoConfiguration类，自动配置类，用于完成Bean创建等工作</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 java 配置类</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//引入DemoService 注入条件</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123;DemoService.class&#125;)</span></span><br><span class="line"><span class="comment">// 将 application.properties 的相关的属性字段与该类一一对应，并生成 Bean</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(DemoProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入属性类</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DemoProperties demoProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">// 当容器没有这个 Bean 的时候才创建这个 Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(DemoService.class)</span></span><br><span class="line">    <span class="keyword">public</span> DemoService <span class="title function_">helloworldService</span><span class="params">()</span> &#123;</span><br><span class="line">        DemoService demoService= <span class="keyword">new</span> <span class="title class_">DemoService</span>();</span><br><span class="line">        demoService.setStr1(demoProperties.getStr1());</span><br><span class="line">        demoService.setStr2(demoProperties.getStr2());</span><br><span class="line">        <span class="keyword">return</span> demoService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>在resources下创建目录META-INF，在 META-INF 目录下创建 spring.factories，在SpringBoot启动时会根据此文件来加载项目的自动化配置类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=包名.config.DemoAutoConfiguration </span><br></pre></td></tr></table></figure><ol start="6"><li>其他项目中使用自定义的Starter</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--引入自定义Starter--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.lhf.springboot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-demo&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">0.0</span><span class="number">.1</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ol start="7"><li>编写属性配置文件</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#配置自定义的属性信息</span><br><span class="line">str.str1=为什么我的眼里常含泪水</span><br><span class="line">str.str2=那是因为我对你爱的深沉</span><br></pre></td></tr></table></figure><ol start="8"><li>写注解使用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringController</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DemoService demoService;  <span class="comment">//引入自定义Starter中的DemoService </span></span><br><span class="line"></span><br><span class="line">      <span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line">      <span class="keyword">public</span> String <span class="title function_">addString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> demoService.getStr1()+ demoService.getStr2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_35958391/article/details/124471656">参考</a></p>]]></content>
      
      
      <categories>
          
          <category> Java框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot自动装配原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot的启动流程</title>
      <link href="/2023/01/02/SpringBoot%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
      <url>/2023/01/02/SpringBoot%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Boot的启动流程"><a href="#Spring-Boot的启动流程" class="headerlink" title="Spring Boot的启动流程"></a>Spring Boot的启动流程</h1><p>Spring Boot项目最简单的Application启动类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringBootLoveApplication</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">SpringApplication.run(SpringBootLoveApplication.class,args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出Application启动类中，包含了**@SpringBootApplication 注解**和 <strong>SpringApplication.run</strong> 启动方法，所以SpringBoot的启动可以分解为 <strong>注解</strong> 和 <strong>启动方法</strong> 两大过程，而仔细看启动类中还引入了一个org.springframework.boot.SpringApplication包，所以启动方法中又可以分为两个阶段即 <strong>创建SpringApplication 实例</strong> 和 <strong>执行run方法</strong>。</p><h2 id="SpirngBootApplication注解"><a href="#SpirngBootApplication注解" class="headerlink" title="@SpirngBootApplication注解"></a>@SpirngBootApplication注解</h2><p><img src="1.png"></p><p>从@SpringBootApplication注解内部可以发现，它虽然定义使用了多个Annotation进行标注，但实际上重要的只有三个Annotation：</p><ul><li><p>@SpringBootConfiguration（@SpringBootConfiguration注解点开查看发现里面还是应用了@Configuration：Spring IOC容器配置类。它就是JavaConfig形式的Spring Ioc容器的配置类。被标注的类等于在spring的XML配置文件中(applicationContext.xml)，装配所有bean事务，提供了一个spring的上下文环境。跟我们正常使用的@Configuration一样如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MockConfiguration</span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MockService <span class="title function_">mockService</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MockServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>任何一个标注了@Configuration的Java类定义都是一个JavaConfig配置类。任何一个标注了@Bean的方法，其返回值将作为一个bean定义注册到Spring的IoC容器，方法名将默认成该bean定义的id。</strong></p></li><li><p>@ComponentScan 自动扫描并加载符合条件的组件或者bean定义，默认扫描SpringApplication的run方法里的class所在的包路径下文件，所以通常将该启动类放到根包路径下，会被自动装配的注解包括@Controller、@Service、@Component、@Repository或者bean定义。也可以指定扫描路径。</p></li><li><p>@EnableAutoConfiguration 跟@EnableScheduling、@EnableCaching一样使用@Import将所有符合自动配置条件的bean定义加载到IOC容器。</p></li></ul><p>即 @SpringBootApplication &#x3D; (默认属性)@Configuration + @EnableAutoConfiguration + @ComponentScan<strong>实现利用springboot的自动装载加载了META-INF下的spring.factories配置文件，将配置文件的所有类都注册到容器IOC中。</strong></p><h2 id="创建SpringApplication-实例"><a href="#创建SpringApplication-实例" class="headerlink" title="创建SpringApplication 实例"></a>创建SpringApplication 实例</h2><p>从启动类中的run方法跟进去，SpringApplication.run -&gt; return  run -&gt; return new SpringApplication(primarySources).run(args)这个方法是启动方法中的第一阶段即创建SpringApplication实例。</p><p><strong>进入run方法后，首先会 new 一个SpringApplication 对象，创建这个对象的构造函数做了一些准备工作，编号第2~5步就是构造函数里面所做的事情</strong></p><p><strong>2、确定应用程序类型</strong></p><p>在SpringApplication的构造方法内，首先会通过  WebApplicationType.deduceFromClasspath()； 方法判断当前应用程序的容器，默认使用的是Servlet  容器，除了servlet之外，还有NONE 和 REACTIVE （响应式编程）；</p><p><strong>3、加载所有的初始化器</strong></p><p>这里加载的初始化器是springboot自带初始化器，是从 META-INF&#x2F;spring.factories  配置文件中加载的。我们也可以自己实现一个自定义的初始化器：实现 ApplicationContextInitializer接口既可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.application;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextInitializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ConfigurableApplicationContext;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义的初始化器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplicationContextInitializer</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextInitializer</span>&lt;ConfigurableApplicationContext&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(ConfigurableApplicationContext configurableApplicationContext)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是初始化的 MyApplicationContextInitializer...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过application.properties中指定context.initializer.classes&#x3D;run.ut.app.MyApplicationContextInitializer来执行自定义初始化器。</p><p><strong>4、加载所有的监听器</strong></p><p>加载监听器也是从 META-INF&#x2F;spring.factories 配置文件中加载的，与初始化不同的是，监听器加载的是实现了 ApplicationListener 接口的类，也可以加载自定义监听器。</p><p><strong>5、设置程序运行的主类</strong></p><p>deduceMainApplicationClass(); 这个方法仅仅是找到main方法所在的类，为后面的扫包作准备，deduce是推断的意思，所以准确地说，这个方法作用是推断出主方法所在的类；</p><h2 id="执行run方法"><a href="#执行run方法" class="headerlink" title="执行run方法"></a>执行run方法</h2><p><strong>1.开启计时器</strong></p><p>计个时。</p><p><strong>2.将java.awt.headless设置为true</strong></p><p>这里将java.awt.headless设置为true，表示运行在服务器端，在没有显示器器和鼠标键盘的模式下照样可以工作，模拟输入输出设备功能。</p><p><strong>3. 获取并启用监听器</strong></p><p>这一步 通过监听器来实现初始化的的基本操作，这一步做了2件事情</p><ol><li>创建所有 Spring 运行监听器并发布应用启动事件</li><li>启用监听器</li></ol><p><strong>4.设置应用程序参数</strong></p><p>将执行run方法时传入的参数封装成一个对象</p><p><strong>5.准备环境变量</strong></p><p>准备环境变量，包含系统属性和用户配置的属性，执行的代码块在 prepareEnvironment 方法内</p><p><strong>6.忽略bean信息</strong></p><p>这个方法configureIgnoreBeanInfo() 这个方法是将 spring.beaninfo.ignore 的默认值值设为true，意思是跳过beanInfo的搜索，其设置默认值的原理和第2步一样；</p><p><strong>7.打印 banner 信息</strong></p><p><strong>8.创建应用程序的上下文</strong></p><p>实例化应用程序的上下文， 调用 createApplicationContext() 方法，这里就是用反射创建对象</p><p><strong>10.实例化异常报告器</strong></p><p>异常报告器是用来捕捉全局异常使用的，当springboot应用程序在发生异常时，异常报告器会将其捕捉并做相应处理，在spring.factories 文件里配置了默认的异常报告器，需要注意的是，这个异常报告器只会捕获启动过程抛出的异常，如果是在启动完成后，在用户请求时报错，异常报告器不会捕获请求中出现的异常。</p><p><strong>11.准备上下文环境</strong></p><p>这里准备的上下文环境是为了下一步刷新做准备的，里面还做了一些额外的事情</p><ul><li>实例化单例的beanName生成器：在 postProcessApplicationContext(context); 方法里面。使用单例模式创建 了BeanNameGenerator 对象，其实就是beanName生成器，用来生成bean对象的名称</li><li>执行初始化方法：初始化方法有哪些呢？还记得第3步里面加载的初始化器嘛？其实是执行第3步加载出来的所有初始化器，实现了ApplicationContextInitializer 接口的类</li><li>将启动参数注册到容器中：这里将启动参数以单例的模式注册到容器中，是为了以后方便拿来使用，参数的beanName 为 ：springApplicationArguments</li></ul><p><strong>12. 刷新上下文</strong></p><p>刷新上下文已经是spring的范畴了，自动装配和启动 tomcat就是在这个方法里面完成的，还有其他的spring自带的机制在这里就不一一细说了，</p><p><strong>13.刷新上下文后置处理</strong></p><p>afterRefresh 方法是启动后的一些处理，留给用户扩展使用，目前这个方法里面是空的，</p><p><strong>14.结束计时器</strong></p><p><strong>15.发布上下文准备就绪事件</strong></p><p><strong>16.执行自定义的run方法</strong></p><p>这是一个扩展功能，callRunners(context, applicationArguments) 可以在启动完成后执行自定义的run方法；有2中方式可以实现：</p><ol><li>实现 ApplicationRunner 接口</li><li>实现 CommandLineRunner 接口</li></ol><p>接下来我们验证一把，为了方便代码可读性，我把这2种方式都放在同一个类里面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring.init;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.ApplicationArguments;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.ApplicationRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.CommandLineRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义run方法的2种方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunner</span> <span class="keyword">implements</span> <span class="title class_">ApplicationRunner</span>, CommandLineRunner &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 我是自定义的run方法1，实现 ApplicationRunner 接口既可运行&quot;</span>        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 我是自定义的run方法2，实现 CommandLineRunner 接口既可运行&quot;</span>        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行run方法主要进行了下列工作</p><p><strong>createApplicationContext()创建了上下文，并且同时注册spring的核心组件</strong></p><p><strong>refreshContext()启动Spring容器和内置的Servlet容器（tomcat）</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、SpringBoot启动的时候，会构造一个SpringApplication的实例，然后调用这个实例的run方法，在run方法调用之前，也就是构造SpringApplication的时候会进行初始化的工作，初始化的时候会做以下几件事：</p><p>(1)把参数sources设置到SpringApplication属性中，这个sources可以是任何类型的参数.<br>(2)判断是否是web程序，并设置到webEnvironment的boolean属性中.<br>(3)创建并初始化ApplicationInitializer，设置到initializers属性中 。<br>(4)创建并初始化ApplicationListener，设置到listeners属性中 。<br>(5)初始化主类mainApplicatioClass。</p><p>2、SpringApplication构造完成之后调用run方法，启动SpringApplication，run方法执行的时候会做以下几件事：</p><p>(1)构造一个计时器，观察SpringApplication的执行 。<br>(2)获取SpringApplicationRunListeners并封装到SpringApplicationRunListeners中启动，用于监听run方法的执行。<br>(3)创建并初始化ApplicationArguments,获取run方法传递的args参数。<br>(4)创建并初始化ConfigurableEnvironment（环境配置）。<br>(5)打印banner（只用在Classpath下添加字符文件图标，就可以在启动时候打印）。<br>(3)构造Spring容器(ApplicationContext)上下文。<br>(4)SpringApplicationRunListeners发布finish事件。<br>(5)计时器停止计时。</p><p><a href="https://blog.csdn.net/weixin_44947701/article/details/124055713">参考1</a></p><p><a href="https://www.jianshu.com/p/943650ab7dfd">参考2</a></p>]]></content>
      
      
      <categories>
          
          <category> Java框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot的启动流程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring上下文</title>
      <link href="/2023/01/01/Spring%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
      <url>/2023/01/01/Spring%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
      
        <content type="html"><![CDATA[<p>Spring 框架带有两个 IOC 容器：BeanFactory和ApplicationContext，BeanFactory是 IOC 容器的最基本版本，ApplicationContext扩展了BeanFactory的特性。</p><p><strong>BeanFactory</strong>：是Spring的最核心接口，提供了高级的<strong>IoC</strong>配置机制（IOC控制反转又称为DI依赖注入:注入依赖时将某一接口的具体实现的选择控制权从调用类中移除，转交给Spring容器借助Bean配置来实现），使管理不同类型的Bean成为可能。</p><p><strong>ApplicationContext：</strong>建立在BeanFactory基础上，提供了更多面向应用的功能。一般称BeanFactory为IoC容器，ApplicationContext为应用上线文。<strong>BeanFactory在初始化容器时没有实例化Bean,只有具体访问某个Bean时才会实例化目标Bean，而ApplicationContext在初始化应用上下文的时候就会实例化所有的单例Bean,并且将实例化的Bean放在一个map结构的缓存中，下次再使用该Bean的时候，直接从这个缓存中取。如果bean的scope是singleton的，并且lazy-init为true，则该Bean的实例化是在第一次使用该Bean的时候进行实例化；</strong></p><p><strong>核心接口包括：</strong></p><ul><li>ApplicationEventPublisher：让容器拥有发布应用上下文事件的功能，包括容器启动事件、关闭事件等。实现了ApplicationListener 事件监听接口的Bean 可以接收到容器事件， 并对事件进行响应处理。在ApplicationContext 抽象实现类AbstractApplicationContext 中，我们可以发现存在一个ApplicationEventMulticaster，它负责保存所有监听器，以便在容器产生上下文事件时通知这些事件监听 者。</li><li>MessageSource：为应用提供i18n 国际化消息访问的功能；</li><li>ResourcePatternResolver ： 所有ApplicationContext 实现类都实现了类似于PathMatchingResourcePatternResolver 的功能，可以通过带前缀的Ant 风格的资源文件路径装载Spring 的配置文件。</li><li>LifeCycle：该接口是Spring 2.0 加入的，该接口提供了start()和stop()两个方法，主要用于控制异步处理过程。在具体使用时，该接口同时被 ApplicationContext 实现及具体Bean 实现，ApplicationContext 会将start&#x2F;stop 的信息传递给容器中所有实现了该接口的Bean，以达到管理和控制JMX、任务调度等目的。</li><li><strong>ConfigurableApplicationContext</strong> 扩展于ApplicationContext，它新增加了两个主要的方法：refresh()和close()，让ApplicationContext 具有启动、刷新和关闭应用上下文的能力。在应用上下文关闭的情况下调用refresh()即可启动应用上下文，在已经启动的状态下，调用 refresh()则清除缓存并重新装载配置信息，而调用close()则可关闭应用上下文。这些接口方法为容器的控制管理带来了便利.<strong>启动类中一般定义ConfigurableApplicationContext来进行应用上下文的管理。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ConfigurableApplicationContext CONTEXT;</span><br><span class="line">CONTEXT = SpringApplication.run(UtApplication.class);</span><br></pre></td></tr></table></figure><h1 id="ApplicationContextAware用法"><a href="#ApplicationContextAware用法" class="headerlink" title="ApplicationContextAware用法"></a>ApplicationContextAware用法</h1><p>当一个类实现了这个接口之后，这个类就可以方便获得ApplicationContext中所有的Bean对象（spring上下文），Spring发现某个Bean实现了ApplicationContextAware接口，Spring容器会在创建该Bean之后，自动调用该Bean的setApplicationContext（参数）方法，调用该方法时，会将容器本身ApplicationContext对象作为参数传递给该方法。<br><strong>举例如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextUtil</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext context;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        context = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ApplicationContext <span class="title function_">getContext</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过name获取 Bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name beanName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getBean</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getApplicationContext().getBean(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException&#123;</span><br><span class="line">        <span class="keyword">return</span> getApplicationContext().getBean(requiredType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>用法如下</strong></p><p>根据class获得bean<br>    Xxx xxx &#x3D; ApplicationContextUtil.getContext().getBean(Xxx.class);<br>根据名字获得代理后的bean（常用）<br>    Xxx xxx &#x3D; ApplicationContextUtil.getContext().getBean(“userService”);<br>根据名字获得未代理的bean（即FactoryBean）（不常用）<br>    Xxx xxx &#x3D; ApplicationContextUtil.getContext().getBean(“&amp;userService”);</p><p><strong>注意：</strong>尽量不要在对象初始化过程中使用ApplicationContextHolder.getContext()，因为此时有可能ApplicationContextHolder还没注入到容器中，会导致获取到的context为null。</p><p>例如，以下场景使用ApplicationContextHolder可能导致context为null：</p><ul><li>@PostConstruct标记的方法：在方法上加该注解会在项目启动的时候执行该方法，也可以理解为在spring容器初始化的时候执行该方法。执行顺序：自身Constructor &gt;&gt; 依赖注入的成员变量@Autowired &gt;&gt; @PostConstruct注解标注的方法。</li><li>某个bean的static{}</li></ul><h2 id="ApplicationContext的getBean-与-Autowired的对比"><a href="#ApplicationContext的getBean-与-Autowired的对比" class="headerlink" title="ApplicationContext的getBean()与@Autowired的对比"></a><strong>ApplicationContext的getBean()与@Autowired的对比</strong></h2><p><strong>getBean()：</strong> </p><ul><li>没有依赖注入:如果注入的对象还未注册到容器，不会去注册它，只会获得一个null。</li><li>默认是单例。但可将bean加注解改为多例，此时getBean()获取即为多例。</li></ul><p><strong>@Autowired</strong></p><ul><li>有依赖注入：如果注入的对象还未注册到容器，则会先注册它。</li><li>默认是单例。就算是将bean加注解改为多例，此时注入仍为单例。</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>setApplicationContext是Spring框架预留的一个关键的钩子方法，spring详细加载全过程如下：</p><ol><li>调用 BeanNameAware 的 setBeanName 方法</li><li>调用 BeanFactoryAware 的 setBeanFactory 方法</li><li>调用 ApplicationContextAware 的 setApplicationContext</li><li>调用 BeanPostProcessor 的 postProcessBeforeInitialization 方法</li><li>调用 InitializingBean 的 afterPropertiesSet 或者没有实现这个接口，但指定了@Bean(initMethod&#x3D;”不加括号的方法名”)，会执行这个方法</li><li>调用 BeanPostProcessor 的 postProcessAfterInitialization 方法</li><li>Bean 初始化完成，可以被使用</li><li>容器关闭前，调用 DisposableBean 的 destroy 方法</li></ol><p>加载Spring配置文件时，如果Spring配置文件中所定义的Bean类实现了ApplicationContextAware 接口，那么在加载Spring配置文件时，会自动调用ApplicationContextAware  接口中的setApplicationContext，自动的将ApplicationContext注入进来。</p><p>在ApplicationContextAware的实现类中，就可以通过这个上下文环境对象得到Spring容器中的Bean。</p><h1 id="InitialzingBean用法"><a href="#InitialzingBean用法" class="headerlink" title="InitialzingBean用法"></a>InitialzingBean用法</h1><p>当一个类实现这个接口之后，Spring启动后，初始化Bean时，若该Bean实现InitialzingBean接口，会自动调用afterPropertiesSet()方法，完成一些用户自定义的初始化操作。</p><p><strong>举例：</strong></p><p>下面是一个简单的POJO类，实现了 InitializingBean 接口，所以可以通过 afterPropertiesSet() 方法后处理account。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> <span class="keyword">implements</span>  <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="built_in">this</span>.setName(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BeanPostProcessor实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span>(beanName.equals(<span class="string">&quot;account&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> (Account) bean;</span><br><span class="line">            account.setName(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> account;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确的给account的赋值顺序为先是 first， 再是 second。</p><p>把上面的Bean注入到容器中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">config</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> BfProcessor <span class="title function_">bfProcessor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BfProcessor</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyBeanPostProcessor <span class="title function_">beanPostProcessor</span><span class="params">()</span>&#123;</span><br><span class="line">        MyBeanPostProcessor myBeanPostProcessor=<span class="keyword">new</span> <span class="title class_">MyBeanPostProcessor</span>();</span><br><span class="line">        <span class="keyword">return</span> myBeanPostProcessor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Account <span class="title function_">account</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="string">&quot;fff&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest(classes = SpringdemoApplication.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span>  Account account;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tt</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(account.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">测试结果如我们所料：输出second</span><br></pre></td></tr></table></figure><h2 id="DisposableBean"><a href="#DisposableBean" class="headerlink" title="DisposableBean"></a>DisposableBean</h2><p> 当bean使用完毕后，容器将检查<strong>singleton</strong>类型的bean，看其是否实现了DisposableBean接口，接口中有一个destroy()方法提供了singleton类型的对象实例销毁之前执行的销毁逻辑。</p><p>如：重新定义Account：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> <span class="keyword">implements</span>  <span class="title class_">InitializingBean</span>, DisposableBean &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter setter constructor</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;exit...##############################################&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上面测试代码会出现exit…############## ，说明成功的在容器关闭时间执行了destroy方法。</p>]]></content>
      
      
      <categories>
          
          <category> Java框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring上下文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring事件机制</title>
      <link href="/2023/01/01/Spring%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
      <url>/2023/01/01/Spring%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="观察者模式："><a href="#观察者模式：" class="headerlink" title="观察者模式："></a>观察者模式：</h1><p>事件监听机制也可以看做是一种对传统观察者模式的具体实现，不同的框架对其实现方式会有些许差别，Spring的事件监听机制可以说是在典型观察者模式基础上的进一步抽象和改进。</p><p>观察者模式是一个典型的订阅-发布模型，其主要涉及到四种角色：</p><ul><li><strong>抽象被观察者角色</strong>：内部持有所有观察者角色的引用，并对外提供新增、移除观察者角色、通知所有观察者的功能；</li><li><strong>具体被观察者角色</strong>：当状态变更时，会通知到所有的观察者角色；</li><li><strong>抽象观察者角色</strong>：抽象具体观察者角色的一些共性方法，如状态变更方法；</li><li><strong>具体观察者角色</strong>：实现抽象观察者角色的方法；</li></ul><p>我们可以把被观察者替换成**事件(event)<strong>，把对被观察者进行观察的观察者(Observer)替换成对特定事件进行监听的</strong>监听器(EventListener)<strong>，而把原有主题中负责维护被观察者与观察者映射关系以及在自身状态改变时通知观察者的职责从中抽出，放入一个新的角色</strong>事件发布器(EventPublisher)**中，这就是一个事件监听机制的基本构成。</p><p>Spring框架对事件的发布与监听提供了相对完整的支持，它<strong>扩展了JDK中对自定义事件监听提供的基础框架</strong>，并与Spring的IOC特性作了整合，使得用户可以根据自己的业务特点进行相关的自定义，并依托Spring容器方便的实现监听器的注册和事件的发布。因为Spring的事件监听依托于JDK提供的底层支持，为了更好的理解，先来看下JDK中为用户实现自定义事件监听提供的基础框架。</p><h1 id="JDK事件监听机制"><a href="#JDK事件监听机制" class="headerlink" title="JDK事件监听机制"></a>JDK事件监听机制</h1><p>JDK为用户实现自定义事件监听提供了两个基础的类。</p><p>一个是代表所有可<strong>被监听事件</strong>的事件基类java.util.EventObject，所有自定义事件类型都必须继承该类，类结构如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventObject</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">5516075349620653480L</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">transient</span> Object  source;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EventObject</span><span class="params">(Object source)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (source == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;null source&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.source = source;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> source;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;[source=&quot;</span> + source + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类内部有一个Object类型的source变量，逻辑上表示发生该事件的事件源，实际中可以用来存储包含该事件的一些相关信息。</p><p>另一个则是对所有<strong>事件监听器</strong>进行抽象的接口java.util.EventListener，这是一个标记接口，内部没有任何抽象方法，所有自定义事件监听器都必须实现该标记接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A tagging interface that all event listener interfaces must extend.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK1.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EventListener</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外我们还要定义一个事件发布器来管理事件监听器并提供发布事件的功能。</p><h1 id="Spring容器的事件监听机制"><a href="#Spring容器的事件监听机制" class="headerlink" title="Spring容器的事件监听机制"></a>Spring容器的事件监听机制</h1><p>Spring容器，具体而言是ApplicationContext接口定义的容器提供了一套相对完善的事件发布和监听框架，其遵循了JDK中的事件监听标准，并使用容器来管理相关组件，使得用户不用关心事件发布和监听的具体细节，降低了开发难度也简化了开发流程。面看看对于事件监听机制中的各主要角色</p><h2 id="事件（ApplicationEvent）"><a href="#事件（ApplicationEvent）" class="headerlink" title="事件（ApplicationEvent）"></a><strong>事件（ApplicationEvent）</strong></h2><p>Spring为容器内事件定义了一个抽象类ApplicationEvent，该类继承了JDK中的事件基类EventObject。因而自定义容器内事件除了需要继承ApplicationEvent之外，还要传入事件源作为构造参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ApplicationEvent</span> <span class="keyword">extends</span> <span class="title class_">EventObject</span> &#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/** use serialVersionUID from Spring 1.2 for interoperability. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7099057708183571937L</span>;</span><br><span class="line"><span class="comment">/** System time when the event happened. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> timestamp;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new ApplicationEvent.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> source the object on which the event initially occurred (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ApplicationEvent</span><span class="params">(Object source)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(source);</span><br><span class="line"><span class="built_in">this</span>.timestamp = System.currentTimeMillis();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the system time in milliseconds when the event happened.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">long</span> <span class="title function_">getTimestamp</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.timestamp;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring内置事件介绍"><a href="#Spring内置事件介绍" class="headerlink" title="Spring内置事件介绍"></a>Spring内置事件介绍</h2><p>在Spring容器中已经内置了一些常用的事件，如IOC容器刷新开始、结束、关闭等事件，如下图：<img src="1.png"></p><p><strong>1、ContextRefreshedEvent</strong></p><p>ApplicationContext 被初始化或刷新时，该事件被发布。这也可以在 ConfigurableApplicationContext接口中使用 refresh() 方法来发生。此处的初始化是指：<strong>所有的Bean被成功装载，后处理Bean被检测并激活，所有Singleton Bean  被预实例化，ApplicationContext容器已就绪可用</strong></p><p><strong>2、ContextStartedEvent</strong></p><p>当使用 ConfigurableApplicationContext （ApplicationContext子接口）接口中的  start()  方法启动 ApplicationContext 时，该事件被发布。你可以调查你的数据库，或者你可以在接受到这个事件后重启任何停止的应用程序</p><p><strong>3、ContextStoppedEvent</strong></p><p>当使用 ConfigurableApplicationContext 接口中的 stop() 停止 ApplicationContext 时，发布这个事件。你可以在接受到这个事件后做必要的清理的工作</p><p><strong>4、ContextClosedEvent</strong></p><p>当使用 ConfigurableApplicationContext 接口中的 close() 方法关闭 ApplicationContext 时，该事件被发布。一个已关闭的上下文到达生命周期末端；它不能被刷新或重启</p><p><strong>5、RequestHandledEvent</strong></p><p>这是一个 web-specific 事件，告诉所有 bean HTTP 请求已经被服务。只能应用于使用DispatcherServlet的Web应用。在使用Spring作为前端的MVC控制器时，当Spring处理用户请求结束后，系统会自动触发该事件</p><h2 id="事件监听器（ApplicationListener）"><a href="#事件监听器（ApplicationListener）" class="headerlink" title="事件监听器（ApplicationListener）"></a><strong>事件监听器（ApplicationListener）</strong></h2><p>事件监听器（ApplicationListener）对应于观察者模式中的具体观察者角色，当事件发布之后，就会执行事件监听器的逻辑。通过实现ApplicationListener接口，并重写onApplicationEvent()方法，我们可以监听到事件发布器发布的事件。Spring定义了一个ApplicationListener接口作为事件监听器的抽象，其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationListener</span>&lt;E <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span>&gt; <span class="keyword">extends</span> <span class="title class_">EventListener</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听具体的事件</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(E event)</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事件发布器（ApplicationEventPublisher）"><a href="#事件发布器（ApplicationEventPublisher）" class="headerlink" title="事件发布器（ApplicationEventPublisher）"></a><strong>事件发布器（ApplicationEventPublisher）</strong></h2><p>我们可以直接使用ApplicationEventPublisher的publishEvent(Event)方法进行事件的发布，也可以通过ApplicationEventPublisher接口，并重写publishEvent()方法，我们可以自定义事件发布的逻辑。其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationEventPublisher</span> &#123;</span><br><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">publishEvent</span><span class="params">(ApplicationEvent event)</span> &#123;</span><br><span class="line">publishEvent((Object) event);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">publishEvent</span><span class="params">(Object event)</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以直接使用ApplicationContext上下文类进行事件发布。因为ApplicationContext继承了ApplicationEventPublisher接口，因此，我们可以通过实现ApplicationContextAware接口，注入ApplicationContext，然后通过ApplicationContext的publishEvent()方法来实现事件发布功能。</p><p><img src="blog\source_posts\Spring事件机制\2.png"></p><p><strong>注意</strong>，ApplicationContext容器本身仅仅是对外提供了事件发布的接口仅仅是对外提供了事件发布的接口publishEvent()，真正的工作其实是委托给了具体容器内部一个ApplicationEventMulticaster对象如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractApplicationContext#applicationEventMulticaster</span></span><br><span class="line"><span class="keyword">private</span> ApplicationEventMulticaster applicationEventMulticaster;</span><br></pre></td></tr></table></figure><p> 所以，真正的事件发布器其实是ApplicationEventMulticaster，ApplicationEventMulticaster可以类比成观察者模式的抽象被观察者角色</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a><strong>举例</strong></h3><p>比如在等所有bean加载完之后执行某些操作注意的是**先有 InitializingBean，后有 ApplicationListener&lt; ContextRefreshedEvent&gt;**，也就是在IOC将所有的bean 都处理完成后会触发的时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;ContextRefreshedEvent&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">//由于在 WEB （spring mvc）项目中存在两个context，即一个 root application context 和自己项目的 projectName-servlet context（projectName-servlet context 会作为 root application context 的子容器），会导致实现了此接口的方法被执行两次，加入以下判断解决</span></span><br><span class="line">        <span class="keyword">if</span> (event.getApplicationContext().getParent() == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;do something&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="EventListener-注解"><a href="#EventListener-注解" class="headerlink" title="@EventListener 注解"></a>@EventListener 注解</h3><p>除了通过实现接口，还可以使用注解@EventListener（Event）其中Event为指定 classes，即需要处理的事件类型，一般就是 ApplicationEven 及其子类，可以设置多项。</p><p><strong>原理</strong></p><p>  使用EventListenerMethodProcessor处理器解析@EventListener注解</p><h3 id="Async注解"><a href="#Async注解" class="headerlink" title="@Async注解"></a>@Async注解</h3><p>如果要使用异步启动类上加上<code>@EnableAsync</code>注解，方法上加<code>@Async</code>注解。@Async注解来表示该方法是一个异步任务。当其它线程调用这个方法时，就会使用Spring默认的线程池为<strong>SimpleAsyncTaskExecutor</strong>开启一个新的子线程去异步处理该业务逻辑。</p><h2 id="使用Spring事件监听实现点赞异步业务案例"><a href="#使用Spring事件监听实现点赞异步业务案例" class="headerlink" title="使用Spring事件监听实现点赞异步业务案例"></a>使用Spring事件监听实现点赞异步业务案例</h2><h3 id="自定义ApplicationEvent事件对象"><a href="#自定义ApplicationEvent事件对象" class="headerlink" title="自定义ApplicationEvent事件对象"></a><strong>自定义ApplicationEvent事件对象</strong></h3><p>自定义事件对象必须继承ApplicationEvent类，并提供对应的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LikesEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> LikesTypeEnum likesTypeEnum;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LikesEvent</span><span class="params">(Object source, Long id, LikesTypeEnum likesTypeEnum)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(source);</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.likesTypeEnum = likesTypeEnum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义ApplicationListener事件监听器"><a href="#自定义ApplicationListener事件监听器" class="headerlink" title="自定义ApplicationListener事件监听器"></a>自定义ApplicationListener事件监听器</h3><p><strong>使用@EventListener注解</strong>实现监听方法，在监听方法中依据传进来的LikesEvent信息机型业务逻辑处理，其中使用@Async注解异步处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor(onConstructor = @__(@Autowired))</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LikesEventListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PostCommentsService postCommentsService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PostsService postsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlerLikesEvent</span><span class="params">(LikesEvent likesEvent)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> likesEvent.getId();</span><br><span class="line">        <span class="type">LikesTypeEnum</span> <span class="variable">likesTypeEnum</span> <span class="operator">=</span> likesEvent.getLikesTypeEnum();</span><br><span class="line">        <span class="keyword">switch</span> (likesTypeEnum) &#123;</span><br><span class="line">            <span class="keyword">case</span> LIKE_POST:</span><br><span class="line">                postsService.incrementLikesCount(id, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LIKE_COMMENT:</span><br><span class="line">                postCommentsService.incrementLikesCount(id, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> UN_LIKE_POST:</span><br><span class="line">                postsService.incrementLikesCount(id, -<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> UN_LIKE_COMMENT:</span><br><span class="line">                postCommentsService.incrementLikesCount(id, -<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="事件发布器发布事件："><a href="#事件发布器发布事件：" class="headerlink" title="事件发布器发布事件："></a>事件发布器发布事件：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eventPublisher.publishEvent(<span class="keyword">new</span> <span class="title class_">LikesEvent</span>(<span class="built_in">this</span>, postId, LikesTypeEnum.LIKE_POST));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ApplicationListener </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-Scanner类处理输入</title>
      <link href="/2022/12/28/Java-Scanner%E7%B1%BB%E5%A4%84%E7%90%86%E8%BE%93%E5%85%A5/"/>
      <url>/2022/12/28/Java-Scanner%E7%B1%BB%E5%A4%84%E7%90%86%E8%BE%93%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="Scanner类常用方法"><a href="#Scanner类常用方法" class="headerlink" title="Scanner类常用方法"></a>Scanner类常用方法</h2><p><strong>使用Scanner类：通过new一个Scanner对象，从控制台输入语句：Scanner s &#x3D; new Scanner(System.in)；</strong></p><ul><li>hasNext() 是检测还有没有下一个输入；</li><li>next() 是指针移动到当前下标，并取出下一个输入；</li><li>nextLine() 把指针移动到下一行 让然后取出当前这一行的输入；</li><li>hasNextLine() 是检测下一行有没有输入。</li></ul><span id="more"></span><h3 id="hasNext-和-hasNextLine"><a href="#hasNext-和-hasNextLine" class="headerlink" title="hasNext 和 hasNextLine"></a>hasNext 和 hasNextLine</h3><p>当执行到 hasNext() 时，它会先扫描缓冲区中是否有字符，有则返回 true，继续扫描。直到扫描为空，<strong>这时并不返回 false，而是将方法阻塞</strong>，等待你输入内容然后继续扫描。</p><p>换而言之，使用了 hasNext() 方法程序永远不会结束，我们如果想达到没有输入程序停止的效果，需要使用带正则表达式参数的 <code>hasNext(Pattern pattern)</code> or <code>hasNext(String pattern)</code>；hasNextLine() 与 hasNext() 用法类似，也是阻塞式的判断，而且 hasNextLine 并没有正则表达式参数的形式，所以一般只能用于文件的读取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="keyword">while</span>(!sc.hasNext(<span class="string">&quot;#&quot;</span>)) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;输入为: &quot;</span> + sc.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="next-方法"><a href="#next-方法" class="headerlink" title="next 方法"></a>next 方法</h3><p>next 方法在缓存区读取内容时，会过滤掉有效字符前面的无效字符，对输入有效字符之前遇到的空格键、Tab键或Enter键等结束符，next 方法会自动将其过滤掉；只有在读取到有效字符之后，next 方法才将其后的空格键、Tab键或Enter键等视为结束符；<strong>所以next 方法不能得到带空格的字符串。</strong>主要方法如下：</p><p><img src="1.png"></p><h3 id="nextLine-方法"><a href="#nextLine-方法" class="headerlink" title="nextLine 方法"></a>nextLine 方法</h3><p>nextLine 方法字面上有扫描一整行的意思，<strong>它不会过滤掉无效字符</strong>，它的结束符只能是<code>Enter键</code>即换行键，即nextLine 方法返回的是换行之前没有被读取的所有字符，它是可以得到带空格的字符串的。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Scanner类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM逃逸分析</title>
      <link href="/2022/12/28/JVM%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/"/>
      <url>/2022/12/28/JVM%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="逃逸分析概述："><a href="#逃逸分析概述：" class="headerlink" title="逃逸分析概述："></a>逃逸分析概述：</h1><p>逃逸分析的基本行为就是分析<strong>对象动态作用域</strong>：</p><p><strong>方法逃逸：</strong>当一个对<strong>象在方法中被定义后，它可能被外部方法引用，例如作为调用参数传递到其他方法中，称为方法逃逸</strong>。</p><p>线程逃逸：一个对象除了被当前线程访问还可能<strong>被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸</strong>。</p><p>如果能证明<strong>一个对象不会逃逸到方法或线程之外</strong>，也就是<strong>别的方法或线程无法通过任何途径访问到这个对象</strong>，则可能为这个变量进行一些高效的优化：</p><span id="more"></span><h2 id="1-栈上分配"><a href="#1-栈上分配" class="headerlink" title="1. 栈上分配"></a>1. 栈上分配</h2><p>Java虚拟机中，对象一般是在堆中分配内存空间，当对象的生命周期结束后，需要等到GC开启才会进行垃圾收集<strong>如果确定一个对象不会逃逸出方法之外，那让这个对象在栈上分配内存</strong>将会是一个很不错的主意，<strong>对象所占用的内存空间就可以随栈帧出栈而销毁</strong>。在一般应用中，不会逃逸的局部对象所占的比例很大，如果能使用栈上分配，那<strong>大量的对象就会随着方法的结束而自动销毁了</strong>，垃圾收集系统的压力将会小很多。</p><h2 id="2-同步消除"><a href="#2-同步消除" class="headerlink" title="2. 同步消除"></a>2. 同步消除</h2><p><strong>线程同步本身是一个相对耗时的过程</strong>，<strong>如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问</strong>，那这个变量的<strong>读写肯定就不会有竞争</strong>，对这个变量实施的同步措施也就可以消除。</p><h2 id="3-标量替换"><a href="#3-标量替换" class="headerlink" title="3. 标量替换"></a>3. 标量替换</h2><p>标量是指一<strong>个数据已经无法再分解成更小的数据来表示了</strong>，Java虚拟机的原始数据类型都不能再进一步分解，它们就可以称为标量。如果逃逸分析证明<strong>一个对象不会被外部访问</strong>，并且<strong>这个对象可以被拆散的话</strong>，那程序真正执行的时候将<strong>可能不创建这个对象</strong>，而改<strong>为直接创建它的若干个被这个方法使用的成员变量来代替</strong>。除了可以让对象的成员变量在栈上（栈上存储的数据，有很大的概率会被虚拟机分配到物理机器高速寄存器中存储）分配和读写之外，还可以为后续进一步的优化手段创建条件。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM逃逸分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-GCRoot检测算法和垃圾收集器</title>
      <link href="/2022/12/27/JVM-GCRoot%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%E5%92%8C%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
      <url>/2022/12/27/JVM-GCRoot%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%E5%92%8C%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="可达性分析中根节点检测算法"><a href="#可达性分析中根节点检测算法" class="headerlink" title="可达性分析中根节点检测算法:"></a>可达性分析中根节点检测算法:</h1><h2 id="根节点枚举（必须STW）"><a href="#根节点枚举（必须STW）" class="headerlink" title="根节点枚举（必须STW）:"></a>根节点枚举（必须STW）:</h2><p>可达性分析算法来进行GC的第一步必定是找出所有的GC Roots（根节点枚举），尽管我们已经知道GC Roots大约是什么类型的对象，但想要高效的找到它们并非易事。迄今为止，所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的，<strong>因为要避免出现在根节点枚举时根节点集合的对象引用关系还在不断变化的情况，否则结果准确性也就无法保证。</strong>这是导致垃圾收集过程必须停顿所有用户线程的其中一个重要原因，即使是号称停顿时间可控，或者（几乎）不会发生停顿的CMS、G1、 ZGC等收集器，枚举根节点时也是必须要停顿的。因此毫无疑问根节点枚举与之前提及的整理内存碎片一样会面临相似的STW的困扰。</p><span id="more"></span><h2 id="OopMap（Ordinary-object-pointer-Map）："><a href="#OopMap（Ordinary-object-pointer-Map）：" class="headerlink" title="OopMap（Ordinary object pointer Map）："></a>OopMap（Ordinary object pointer Map）：</h2><p>要准确地进行GC就需要判断出所有位置上的数据是不是指向GC堆里的引用，HotSpot的实现方案就是从外部记录下类型信息，存成<strong>映射表</strong>也就是<code>OopMap</code>（Ordinary object pointer Map）。</p><p><strong>OopMap原理</strong>：</p><p>垃圾收集时，收集线程会对栈上的内存进行扫描，看看哪些位置存储了 Reference 类型。如果发现某个位置确实存的是 Reference 类型，就意味着它所引用的对象这一次不能被回收。但问题是，栈上的本地变量表里面只有一部分数据是 Reference 类型的（它们是我们所需要的），那些非 Reference 类型的数据对我们而言毫无用处，但我们还是不得不对整个栈全部扫描一遍，这是对时间和资源的一种浪费。OopMap是一种数据结构，<strong>HotSpot会在类加载动作完成时把对象内什么偏移量上是什么类型的数据计算出来，也会在特定的位置记录下栈里和寄存器里哪些位置是引用，</strong>最终会存在本地代码（Native Code）中。这样收集器在扫描时就可以直接在 GC Roots 枚举时，只需要遍历每个栈桢的 OopMap，通过 OopMap 存储的信息，快捷地找到 GC Roots。，并不需要真正一个不漏地从方法区等GC Roots开始查找。</p><p><strong>OopMap优点：</strong></p><ul><li>高效：正如上述所言，借助OopMap可以大大提高扫描的速度（空间换速度）；</li><li>准确式垃圾收集：相对于全部扫描再判断时的“误差”，因为OopMap是在类加载时计算出的，它是完全准确的，所以可以实现准确式垃圾收集。</li></ul><p><strong>OopMap记录信息的时机：</strong></p><p>可能导致引用关系变化的指令非常多，会消耗大量的额外存储空间，所以HotSpot只在“特定的位置”记录了这些信息，这些位置被称为<strong>安全点（Safepoint）</strong>，即安全点一定是OopMap存放的位置，或者说因为这里有OopMap，所以是Safepoint。</p><p><img src="1.jpg"></p><h2 id="Safepoint："><a href="#Safepoint：" class="headerlink" title="Safepoint："></a>Safepoint：</h2><p><strong>安全点的定义</strong><br>在JIT编译过程中，在<strong>特定的位置记录下栈和寄存器哪些位置是引用,以及栈中保存的对象引用</strong>，实际上这些位置就是<strong>安全点</strong>，可以理解为用户线程执行过程中的一些特殊位置。线程执行到 Safe Point 的时候，OopMap 保存了当前线程的上下文，当线程执行到这些位置的时候，说明线程当前的状态是确定的，线程有哪些对象、使用了哪些内存。意思就是说，<strong>程序执行时并非在所有地方都能停顿下来开始GC，只有在达到安全点时才能暂停</strong>。</p><p><strong>安全点（OopMap）位置的选取</strong></p><ol><li>所有的非计数循环的末尾（防止循环体的执行时间太长，一直进入不了 Safe Point）</li><li>方法临返回前，调用方法的call指令后；</li><li>可能抛异常的位置。</li></ol><p><strong>在GC触发时，如何让所有线程到最近的安全点停下（STW）</strong></p><p>主动式中断（Voluntary Suspension）：当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。<strong>轮询标志的地方和安全点是重合的</strong>，另外还要加上所有创建对象和其他需要在Java堆上分配内存的地方，这是为了检查是否即将要发生垃圾收集，避免没有足够内存分配新对象。</p><h2 id="Safe-Region"><a href="#Safe-Region" class="headerlink" title="Safe Region"></a><strong>Safe Region</strong></h2><p><strong>处于Sleep和Blocked状态的线程无法接受主动式中断请求：</strong></p><p>不能再走到安全的地方去中断挂起自己，这两种情况归属于线程在执行<code>native函数</code>，当线程在执行 Native 方法时，此时线程在执行JVM管理之外的代码，根本就不能对JVM的执行状态做任何修改，因而JVM要进入 Safepoint 时不需要关心它。所以也可以把正在执行 native函数 的线程看作“已经进入了Safepoint”，或者把这种情况叫做“在Safe Region里”。当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要暂停用户线程的阶段），如果完成了，那线程就当作没事发生过，继续执行；否则它就必须一直等待，直到收到可以离开安全区域的信号。</p><p><strong>通过 Safepoint 检查保证 Safe Region 的安全性</strong><br><strong>JVM外部要对JVM执行状态做修改必须要通过JNI（Java Native Interface）</strong>，所有能修改JVM执行状态的JNI函数在入口处都有Safepoint检查，一旦JVM已经发出通知说此时线程已经到达了Safepoint，那么外部想要通过JNI修改JVM状态的程序就会在这些检查的地方停下来，即在Safepoint时不会允许任何对JVM执行状态的修改。</p><h2 id="可达性分析之-Tri-color-Marking"><a href="#可达性分析之-Tri-color-Marking" class="headerlink" title="可达性分析之 Tri-color Marking"></a>可达性分析之 Tri-color Marking</h2><p>在根节点枚举这个步骤中，由于GC Roots相比起整个Java堆中全部的对象毕竟还算是极少数，且在各种优化技巧（如OopMap）的加持下，它带来的停顿已经是非常短暂且相对固定（不随堆容量而增长）的了。可从GC Roots再继续往下遍历对象图，这一步骤的停顿时间就必定会与Java堆容量直接成正比例关系了：堆越大，存储的对象越多，对象图结构越复杂，要标记更多对象而产生的停顿时间自然就更长。这对与延迟敏感的用户显然是不可承受的，那么可否进行<code>并发标记</code>？我们先从不并发的标记开始看起，借助三色标记（Tri-color Marking）作为工具辅助推导，把对象标记成下面三种</p><ul><li>白色：表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，<strong>若在分析结束的阶段，仍然是白色的对象，即代表不可达</strong>。</li><li>灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。<strong>灰色只是黑色和白色的分界线，或者说是扫描的一个中间状态，在扫描完成后，一定不存在灰色的对象，只剩黑白了</strong>。</li><li>黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象，即<strong>被黑色对象指向的对象要么是灰色中间状态，要么是黑色最终状态</strong>。</li></ul><p>在不并发标记的过程中显然没有任何问题，因为对象之间的引用不变（快照），当并发标记时，就会出现问题了，这时用户线程也在执行，很可能改变了引用关系，这样可能出现两种后果：</p><ul><li>产生浮动垃圾（错标）：即把原本消亡的对象错误标记为存活（删除了指向它的引用，但JVM不知道），这不是好事，但其实是可以容忍的，只不过产生了一点逃过本次收集的浮动垃圾而已，下次收集清理掉就好。</li><li>对象消失（漏标）：即标记漏掉了原本存活的对象（新增了指向它的引用，但JVM不知道），这些对象会被垃圾回收，这就是非常致命的后果了，程序肯定会因此发生错误。</li></ul><p>Wilson于1994年在理论上证明了，当且仅当以下两个条件同时满足时，会产生“对象消失”的问题：</p><ol><li>赋值器插入了一条或多条从黑色对象到白色对象W的新引用；</li><li>赋值器删除了全部从灰色对象到该白色对象W的直接或间接引用；</li></ol><p>因为黑色对象不会再被扫描，所以即使插入了新引用，不会从黑色扫描到对象W，如果本来W就没有灰色对象指向它，那么不用管，W本应该被回收，只是新增了一个指向垃圾的引用（或者说这种情况很难出现）；但如果W此前有灰色对象引用，并且被用户线程全部删掉了，这个时候就出问题了，本应该被标记为存活的对象就被当成了垃圾，会被回收。</p><p>因此，我们要解决并发扫描时的对象消失问题，只需破坏这两个条件的任意一个即可。由此分别产生了两种解决方案：</p><ol><li>增量更新（Incremental Update）<br>增量更新要破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来（通过写屏障），等并发扫描结束之后，再以这些记录过的引用关系中的黑色对象为根，重新扫描一次。这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。</li><li>原始快照（Snapshot At The Beginning， SATB）<br>原始快照要破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来（通过写屏障），在并发扫描结束之后，再以这些记录过的引用关系中的灰色对象为根，重新扫描一次。这也可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。</li></ol><p><strong>CMS是基于增量更新来做并发标记的，G1则是用原始快照来实现。</strong></p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="串行组合"><a href="#串行组合" class="headerlink" title="串行组合"></a>串行组合</h3><ul><li><p>组合：Serial（标记复制） + Serial Old (标记清除)，开启参数：<code>-XX:+UseSerialGC = Serial + SerialOld</code></p></li><li><p>优点：单线程，简单而高效，额外消耗内存最小。</p></li><li><p>适用场景：堆内存较小的场景，例如个人电脑和部分微服务场景。</p></li></ul><p><img src="1.png"></p><h3 id="吞吐量优先组合"><a href="#吞吐量优先组合" class="headerlink" title="吞吐量优先组合"></a>吞吐量优先组合</h3><p>Parallel Scavenge + Paralledl Old，开启参数： <code>-XX:+UseParallelGC -XX:+UseParallelOldGC</code>，jdk1.8的默认组合方式。<strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p>Parallel Scavenge 收集器采用多线程进行垃圾收集，提供了很多参数供用户找到最合适的停顿时间或最大吞吐量</p><p><strong>吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。</strong></p><ul><li>Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量：<ul><li><code>-XX:GCTimeRatio=ratioInt</code> ，GC_time_ratio &#x3D; 1 &#x2F; (1 + ratioInt)，例如 ratioInt &#x3D; 19, GC_time_ratio &#x3D; 1&#x2F;(1+19) &#x3D; 5%；</li><li><code>-XX:MaxGCPauseMillis=ms</code> , 垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的，即时间越小、新生代就设置的越小，但这也直接导致垃圾收集发生得更频繁，原来10秒收集一次、每次停顿100毫秒，现在变成5秒收集一次、每次停顿70毫秒，停顿时间的确在下降，但吞吐量也降下来了。</li></ul></li><li><code>-XX：+UseAdaptiveSizePolicy</code>，当这个参数被激活之后，就不需要人工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX：SurvivorRatio）、晋升老年代对象大小（-XX：PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。这种调节方式称为垃圾收集的自适应的调节策略（GC Ergonomics）。</li><li><code>-XX:ParallelGCThreads=n</code>，设置垃圾回收并行线程的个数，默认情况下，当 CPU 数量小于8， ParallelGCThreads 的值等于 CPU 数量，当 CPU 数量大于 8 时，则使用公式：ParallelGCThreads &#x3D; 8 + ((N - 8) * 5&#x2F;8) &#x3D; 3 +（（5 * CPU）&#x2F; 8），这个参数只要是并行垃圾收集器都可以使用。</li></ul><h3 id="响应时间优先组合"><a href="#响应时间优先组合" class="headerlink" title="响应时间优先组合"></a>响应时间优先组合</h3><p>ParNew （标记复制）+ CMS (Serial Old作为后备)（标记清除），开启参数：<code>-XX:+UseConcMarkSweepGC -XX:+UseParNewGC ~ SerialOld</code> ，开启CMS后若不指定新生代垃圾收集器则默认开启ParNew</p><p>其中ParNew 跟Parallel Scavenge差不多就是 Serial 收集器的多线程版本，</p><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器（但是GC次数可能频繁，吞吐量可能不高）。</strong>它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。运行过程分为以下四个步骤。</p><ul><li><strong>初始标记（STW）：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快。</li><li><strong>并发标记：</strong> 同时开启 GC 和用户线程，记录可达对象。但在这个阶段结束，并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li><li><strong>重新标记（STW）：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，是通过<strong>增量更新</strong>算法实现的。这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li><li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li></ul><p><img src="2.png"></p><p>优点：</p><ul><li><strong>并发收集、低停顿</strong></li></ul><p>缺点：</p><ul><li><p><strong>对 CPU 资源敏感；</strong>当处理器核心数量很少时， CMS对用户程序的影响就可能变得很大。如果应用本来的处理器负载就很高，还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然大幅降低。</p></li><li><p><strong>无法处理浮动垃圾；</strong>在CMS的并发清理阶段，用户线程是还在继续运行的并会产生浮动垃圾占用内存，并且这一部分浮动垃圾出现在标记之后，CMS无法在当次回收它们，只好等待下次再回收它们。因此CMS收集器不能像其他收集器那样等待到老年代几乎完全被填满了再进行收集，必须预留一部分空间供并发清理时的程序运作使用。可以通过设置参数<code>-XX:CMSInitiatingOccupancyFraction=percent</code>，预留 percent% 的老年代空间给浮动垃圾，也意味着一旦老年代达到 (100-percent)% 的空间就要触发Full GC，如果在实际应用中老年代增长并不是太快，可以适当调高这个参数的值来提高CMS的触发百分比，降低内存回收频率，获取更好的性能，但这个参数设置的太高又面临另一种风险：要是CMS运行期间预留的内存无法满足程序分配新对象的需要，就会出现一次“并发失败”（Concurrent Mode Failure），这时候虚拟机将不得不启动后备预案：冻结用户线程的执行，临时启用<code>Serial Old</code>收集器来重新进行老年代的垃圾收集， 但这样停顿时间就很长了。所以参数设置得太高将会很容易导致大量的并发失败产生，性能反而降低，用户应在生产环境中根据实际应用情况来权衡设置。</p></li><li><p><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></p></li></ul><h3 id="G1-Garbage-First"><a href="#G1-Garbage-First" class="headerlink" title="G1 (Garbage First)"></a>G1 (Garbage First)</h3><ul><li><p><strong>开启参数</strong>：<code>-XX:+UseG1GC</code></p></li><li><p><strong>G1是“停顿时间模型”（PausePrediction Model）的收集器</strong>：意思是能够支持指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标。在G1收集器出现之前的所有其他收集器，包括CMS在内，垃圾收集的目标范围要么是整个新生代（Minor GC），要么就是整个老年代（Major GC），再要么就是整个Java堆（Full GC）。而G1跳出了这个樊篱，它可以面向堆内存任何部分来组成回收集（Collection Set，简称CSet）进行回收，<strong>衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式。</strong></p></li><li><p><strong>基于Region的内存布局</strong>：G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），<strong>每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间或者老年代空间</strong>。虽然G1仍然保留新生代和老年代的概念，但新生代和老年代不再是固定的了，它们都是一系列区域（不需要连续）的动态集合。G1收集器之所以能建立可预测的停顿时间模型，是因为它<strong>将Region作为单次回收的最小单元，即每次收集到的内存空间都是Region大小的整数倍</strong>，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集。<br>Region中还有一类特殊的Humongous区域，专门用来存储大对象。G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。每个Region的大小可以通过参数<code>-XX：G1HeapRegionSize</code>设定，取值范围为1MB～32MB，且应为2的N次幂。而对于那些超过了整个Region容量的超级大对象， 将会被存放在N个连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待。</p></li><li><p><strong>Garbage First 优先收集：</strong>G1收集器会跟踪各个Region里面的垃圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间（使用参数<code>-XX：MaxGCPauseMillis</code>指定，默认值是200毫秒），<strong>优先处理回收价值收益最大的那些Region（Mixed GC）</strong>，这也就是“Garbage First”名字的由来。这种使用Region划分内存空间，以及具有优先级的区域回收方式，保证了G1收集器在有限的时间内获取尽可能高的收集效率。</p></li><li><p><strong>G1的跨代引用：</strong>在G1收集器中，<strong>Region之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用</strong>，虚拟机都是使用<strong>Remembered Set（RS）**来避免全堆扫描的。**G1中每个Region都有一个与之对应的RS**，虚拟机发现程序**对Reference类型的数据进行写操作**时，会产生</strong>一个Write Barrier暂时中断操作<strong>，</strong>检查Reference引用的对象是否处于不同的Region之间<strong>（在分代的例子中就是检查是否老年代中的对象引用了新生代中方的对象）如果是，便</strong>通过CardTable（每个Region块又细分了2000多个卡表，记录一波我引用了哪个对象）把相关引用信息记录到被引用对象所属的Region的RS之中<strong>。当进行内存回收时，</strong>在GC根节点的枚举范围中加入RS即可保证不对全堆扫描，也不会又遗漏**。</p></li><li><p><strong>适用场景</strong></p><ul><li>同时注重吞吐量（Throughput）和低延迟（Low latency），默认的暂停目标是 200 ms</li><li>超大堆内存，会将堆划分为多个大小相等的 Region</li><li><strong>整体上是 标记-整理 算法，两个区域之间是 复制算法</strong></li></ul></li><li><p><strong>G1的工作过程：</strong></p></li></ul><ol><li>初始标记：需要STW，仅仅只是标记一下GC Roots能直接关联到的对象，耗时很短，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。该阶段是在进行Minor GC的时候同步完成的，没有额外的停顿 。</li><li>并发标记：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理SATB（原始快照）记录下的在并发时有引用变动的对象。</li><li>最终标记：需要STW，对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。</li><li>筛选回收：需要STW。负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region 构成回收集（Young GC or Mixed GC），然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间（<strong>标记-整理和复制算法都有运用</strong>）。这里的操作涉及存活对象的移动，是必须STW，由多条收集器线程并行完成的。</li></ol><p>​<strong>同CMS一样G1也会产生浮动垃圾：</strong></p><p>​只要是并发标记的收集器，增量复制和SATB（原始快照）算法都会产生浮动垃圾，而且SATB还会产生更多的浮动垃圾，但 G1 不需要像 CMS 那样 remark，再走一遍 root trace 这种相当耗时的流程。而且 CMS 在清理阶段用的是 标记-清除算法 所以可以和用户线程并发执行，但这一阶段用户线程产生的浮动垃圾是在标记阶段之后，所以必须等到下一轮 GC 才能回收，即产生了无法处理的浮动垃圾，而 G1 由于在筛选回收阶段STW，所以不存在这种问题。</p><h3 id="CMS和G1的比较："><a href="#CMS和G1的比较：" class="headerlink" title="CMS和G1的比较："></a>CMS和G1的比较：</h3><ol><li>CMS收集器是<strong>获取最短回收停顿时间</strong>为目标的收集器，因为CMS工作时，GC工作线程与用户线程可以并发执行，以此来达到降低收集停顿时间的目的（只有初始标记和重新标记会STW）。但<strong>是CMS收集器对CPU资源非常敏感。在并发阶段，虽然不会导致用户线程停顿，但是会占用CPU资源而导致引用程序变慢，总吞吐量下降</strong>。</li><li>CMS仅作用于老年代，是基于<strong>标记清除算法</strong>，所以清理的过程中<strong>会有大量的空间碎片</strong>。</li><li>CMS收集器<strong>无法处理浮动垃圾</strong>，<strong>由于CMS并发清理阶段用户线程还在运行</strong>，伴随程序的运行自然会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在本次收集中处理它们，只好留在下一次GC时将其清理掉。</li><li>G1是一款面向服务端应用的垃圾收集器，<strong>适用于多核处理器、大内存容量的服务端系统</strong>。G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU或核心来缩短STW的停顿时间，它满足短时间停顿的同时达到一个高的吞吐量。</li><li><strong>从JDK 9开始，G1成为默认的垃圾回收器</strong>。当应用有以下任何一种特性时非常适合用G1：Full GC持续时间太长或者太频繁；对象的创建速率和存活率变动很大；应用不希望停顿时间长(长于0.5s甚至1s)。</li><li>G1将空间划分成很多块（Region），然后他们各自进行回收。堆比较大的时候可以采用，并且G1采用复制算法，碎片化问题不严重。整体上看属于标记整理算法,局部(region之间)属于复制算法。</li><li>G1 需要记忆集 (具体来说是卡表)来记录新生代和老年代之间的引用关系，这种数据结构在 G1 中需要占用大量的内存，可能达到整个堆内存容量的 20% 甚至更多。而且 <strong>G1 中维护记忆集的成本较高</strong>，带来了更高的执行负载，影响效率。<strong>所以 CMS 在小内存应用上的表现要优于 G1，而大内存应用上 G1 更有优势，大小内存的界限是6GB到8GB</strong>。</li></ol>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GCRoot检测算法 </tag>
            
            <tag> 垃圾收集器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM垃圾回收</title>
      <link href="/2022/12/26/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
      <url>/2022/12/26/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
      
        <content type="html"><![CDATA[<p>Java 自动内存管理最核心的功能是 <strong>堆</strong> 内存中对象的分配与回收。由上文的介绍可以知道，java1.8版本之后堆主要由4部分组成：<strong>Eden区，两个Survivor区S0和S1</strong>，这些都属于新生代。Tenured属于老年代。</p><h1 id="对象内存分配原则"><a href="#对象内存分配原则" class="headerlink" title="对象内存分配原则"></a>对象内存分配原则</h1><p><strong>对象优先在 Eden 区分配</strong>：最开始对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。</p><p>在发生Minor GC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间或者历次晋升的平均大小，如果这个条件成立，那这一次Minor GC可以确保是安全的，就会进行 Minor GC，否则将进行Full GC。</p><span id="more"></span><p>Minor GC时会依据空间分配担保机制进行：<strong>空间分配担保</strong>指的是：在Minor GC的过程中，如果<strong>Eden区的存活对象大于Survivor区的大小</strong>，但小于老年代大小，则会直接从Eden晋升到老年代；否则继续待在Eden。这个情况注意跟下面大对象直接进入老年代区分，空间分配担保机制是在Minor GC的过程中出现的，而大对象直接晋升根本不会出现Minor GC。</p><p><strong>大对象直接晋升到老年代</strong>：大对象就是指需要大量连续内存空间的Java对象，HotSpot虚拟机提供了<code>-XX：PretenureSizeThreshold</code>参数（只对Serial和ParNew两款新生代收集器有效，默认是Eden区大小），指定大于该设置值的对象直接在老年代分配，这样做的目的就是避免分配担保机制在Eden区及两个Survivor区之间来回复制，产生大量的内存复制操作。</p><p><strong>长期存活的对象晋升到老年代：</strong>虚拟机给每个对象定义了一个对象分代年龄（Age）计数器，存储在对象头中。对象通常在Eden区里诞生，如果经过第一次 Minor GC后仍然存活，并且能被Survivor容纳的话，该对象会被移动到Survivor空间中，并且将其对象年龄设为1岁。对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15，最大也是15），就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数<code>-XX：MaxTenuringThreshold</code>设置，同时这个阈值也是动态变化的：如果在<strong>Survivor空间中相同年龄所有对象大小的总和大于 Survivor空间的一半</strong>，年龄大于或等于该年龄（年龄不包括0）的对象就可以直接进入老年代，无须等到<code>-XX：MaxTenuringThreshold</code>中要求的年龄。</p><h1 id="死亡对象判断方法："><a href="#死亡对象判断方法：" class="headerlink" title="死亡对象判断方法："></a>死亡对象判断方法：</h1><p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）判断对象的死亡有两种策略，其一为<strong>引用计数法</strong>，其二为<strong>可达性分析</strong>。</p><h3 id="引用计数法："><a href="#引用计数法：" class="headerlink" title="引用计数法："></a>引用计数法：</h3><p>这个算法的基本思路是在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。<strong>缺点是很难解决相互引用的问题</strong>。</p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。</p><p><strong>可以作为 GC Roots 的对象（引用）</strong></p><p>实际上GC Roots只是一组活跃对象的引用，并不是对象本身。</p><ul><li>在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的<br>参数、局部变量、临时变量等。</li><li>在本地方法栈中JNI（即通常所说的Native方法）引用的对象。</li><li>在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。</li><li>在方法区中常量引用的对象，譬如字符串常量池里的引用或声明为final的常量。</li><li>所有被同步锁（synchronized关键字）持有的对象。</li><li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如<br>NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。</li></ul><p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，要真正宣告一个对象死亡，至少要经历两次标记过程；</p><p><strong>第一次标记：</strong>可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 <code>finalize</code> 方法。当对象没有覆盖 <code>finalize</code> 方法，或 <code>finalize</code> 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行，则可以直接回收。</p><p><strong>第二次标记</strong>：被判定为需要执行的对象将会被放在一个队列中进行第二次标记，<strong>在 finalize() 方法中没有重新与引用链建立关联关系的会被回收</strong>，如果对象在 finalize() 方法中重新与引用链建立了关联关系，那么将会逃离本次回收，继续存活。JDK9 版本及后续版本中各个类中的 <code>finalize</code> 方法会被逐渐弃用移除）</p><h1 id="引用类型总结"><a href="#引用类型总结" class="headerlink" title="引用类型总结"></a>引用类型总结</h1><p>无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。</p><p><strong>1．强引用（StrongReference）</strong></p><p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p><p><strong>2．软引用（SoftReference）</strong></p><p>如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><p><strong>3．弱引用（WeakReference）</strong></p><p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p><p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><p><strong>4．虚引用（PhantomReference）</strong></p><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p><p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p><p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p><h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法:"></a>标记-清除算法:</h3><p>该算法分为“标记”和“清除”阶段：首先<strong>标记出所有不需要回收的对象</strong>，在标记完成后<strong>统一回收掉所有没有被标记的对象</strong>。把标记为垃圾的起始结束地址记录到空闲列表(Free List)中，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。</p><ul><li>优点：速度快，只需要记录垃圾对象的起始结束地址；</li><li>缺点：容易产生内存碎片，空间不连续，大对象无法存放，造成内存浪费。</li></ul><h3 id="标记-复制算法（新生代）："><a href="#标记-复制算法（新生代）：" class="headerlink" title="标记-复制算法（新生代）："></a>标记-复制算法（新生代）：</h3><p>将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p><ul><li>优点：没有内存碎片；</li><li>缺点：需要占用双倍内存空间，即总有50%的内存空间无法利用。但适用于对象频繁更新的场景，即每次垃圾回收时存活对象很少，这样就不需要划分给FROM和TO太多空间，例如新生代就是使用的复制算法，新生代内存默认划分为<code>80%Eden + 10%Survivor From + 10%Survivor To</code>，后面会详细介绍。</li></ul><h3 id="标记-整理算法（老年代）："><a href="#标记-整理算法（老年代）：" class="headerlink" title="标记-整理算法（老年代）："></a>标记-整理算法（老年代）：</h3><p>根据老年代的特点提出的一种标记算法，首先进行标记：标记垃圾，但后续步骤不是直接对可回收对象回收，而是整理：把所有的存活的对象都向一端移动，让内存更为连续和紧凑，然后清理掉端边界以外的内存。</p><ul><li>优点：没有内存碎片，内存连续；</li><li>缺点：速度慢，需要移动大量对象。</li></ul><h1 id="分代GC机制"><a href="#分代GC机制" class="headerlink" title="分代GC机制:"></a>分代GC机制:</h1><p>由于堆可以被分为新生代和老年代两个部分，不同乃村区域有各个年代的特点，需要选用适当的GC算法，就有了分代收集算法。在新生代中，每次垃圾收集时都发现有<strong>大批对象死去</strong>，只有少量存活，那就选用<strong>复制算法</strong>，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用<strong>标记-清除或者标记-整理</strong> 算法来进行回收。</p><h3 id="不同的GC方式："><a href="#不同的GC方式：" class="headerlink" title="不同的GC方式："></a>不同的GC方式：</h3><p>分代收集（Generation Collection）</p><ul><li>新生代（Young Generation）</li><li>老年代（Tenured&#x2F;Old Generation）</li></ul><p>部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：</p><ul><li>新生代收集（Minor GC&#x2F;Young GC）：指目标只是新生代的垃圾收集</li><li>老年代收集（Major GC&#x2F;Old GC）：指目标只是老年代的垃圾收集。目前只有<code>CMS收集器</code>会有单独收集老年代的行为。</li><li>混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为</li></ul><p>整堆收集（Full GC）：收集整个Java堆（新生代+老年代）和方法区的垃圾收集</p><h3 id="堆中新生代的内存分配："><a href="#堆中新生代的内存分配：" class="headerlink" title="堆中新生代的内存分配："></a>堆中新生代的内存分配：</h3><p>由于新生代在对象分配时采用的TLAB（thread-local allocation buffer）（对象创建章节详解）对象分配较为容易，大部分对象用过即死。堆将新生代分区如下：Eden + 幸存区（Survivor From） + 幸存区（Survivor To），默认比例是8:1:1，可以通过参数<code>-XX:SurvivorRatio=ratio </code>调整，默认为8，即Eden的占比，其他二等分，From 和 To用于复制算法，即To要保证一直为空；</p><h3 id="Minor-GC与Full-GC："><a href="#Minor-GC与Full-GC：" class="headerlink" title="Minor GC与Full GC："></a>Minor GC与Full GC：</h3><h4 id="Minor-GC过程："><a href="#Minor-GC过程：" class="headerlink" title="Minor GC过程："></a><strong>Minor GC过程</strong>：</h4><p>​第一次当Eden内存不足以放新对象时（这时幸存区为空），采用<code>复制</code>算法，将Eden区所有存活的对象复制到幸存区To，让幸存的对象分代年龄+1，然后交换From和To的位置（指针交换）；继续放对象，当第二次Eden内存不足时，将Eden和幸存区From所有存活的对象复制到幸存区To，让幸存的对象分代年龄再+1，然后交换From和To的位置（指针交换）；当分代年龄达到限制时（默认15）幸存区的对象会晋升到老年代，或者大对象直接进入老年代，这个对象的大小阈值可通过参数<code>-XX:PretenureSizeThreshold=size</code>设置（只对Serial和ParNew两款新生代收集器有效），或者经过<strong>动态对象年龄判定</strong>的对象也会晋升到老年代，或者通过<strong>空间分配担保机制</strong>晋升到老年代；当老年代的内存不足以放晋升新对象，就会触发Full GC，采用<strong>标记-清除算法或标记-整理</strong>算法。</p><ul><li><p>Minor GC 会引发 <strong>stop the world（STW）</strong>，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</p></li><li><p>当老年代空间不足，会触发 Full GC，STW的时间更长，如果Full GC后空间仍不足，会抛出<code>OutOfMemoryError: Java heap space</code></p></li></ul><h4 id="Minor-GC触发时机："><a href="#Minor-GC触发时机：" class="headerlink" title="Minor GC触发时机："></a><strong>Minor GC触发时机：</strong></h4><ul><li><p>Eden区域满了，即新创建的对象大小大于Eden所剩空间</p></li><li><p>虚拟机在进行Minor GC之前会判断老年代的最大连续可用连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行Full GC</p></li></ul><h4 id="Full-GC触发时机："><a href="#Full-GC触发时机：" class="headerlink" title="Full GC触发时机："></a><strong>Full GC触发时机</strong>：</h4><ul><li><p>老年代空间不足，例如晋升到老年代的对象大于老年代剩余内存，就会触发Full GC，一般在Full GC之前会先执行Minor GC：原因是：在对老一代空间进行垃圾收集之前先对年轻一代空间进行垃圾收集，通常会导致垃圾收集器的工作量更少，并且垃圾收集的对象更多，因为老一代空间中的对象可能持有对年轻一代空间中对象的对象引用。如果年轻代空间没有被垃圾收集，那么老代空间中任何持有年轻代空间中对象引用的对象都不能被垃圾收集。</p></li><li><p>空间分配担保时，老年代的最大可用连续空间小于新生代对象总大小和历次晋升的平均大小，就会触发Full GC</p></li><li><p>显式调用 System.gc() 或者Heap dump时也会触发 Full GC</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> JVM垃圾回收 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM对象创建流程</title>
      <link href="/2022/12/26/JVM%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B/"/>
      <url>/2022/12/26/JVM%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="对象创建流程"><a href="#对象创建流程" class="headerlink" title="对象创建流程"></a>对象创建流程</h1><p><img src="4.png"></p><h3 id="1-类加载检查："><a href="#1-类加载检查：" class="headerlink" title="1.类加载检查："></a>1.类加载检查：</h3><p>​遇到new时先去常量池中看能不能定位到这个类的符号引用并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p><h3 id="2-分配内存"><a href="#2-分配内存" class="headerlink" title="2.分配内存:"></a>2.分配内存:</h3><p>​类加载检查完成后就知道了占用内存大小，从java堆中找出内存，方法有两种：主要取决于堆内存是否规整，而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”）</p><span id="more"></span><p><strong>指针碰撞：</strong>适用场合 ：堆内存规整（即没有内存碎片）的情况下。</p><ul><li>原理 ：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。</li><li>使用该分配方式的 GC 收集器：Serial, ParNew</li></ul><p><strong>空闲列表：</strong>适用场合 ： 堆内存不规整的情况下。</p><ul><li>原理 ：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。</li><li>使用该分配方式的 GC 收集器：CMS</li></ul><p><strong>内存分配并发问题：</strong></p><p>CAS+失败重试： CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></p><p>TLAB（Thread local allocation buffer）线程本地分配缓存区，是一个线程专用的内存分配区域。： 为每一个线程预先在 Eden 区分配一块儿内存1%，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配。</p><p>通常情况下对象是分配在堆上的，因为堆是线程共享的，所以同一时间可能会有很多线程申请空间分配，在这种情况下要加锁处理，如此一来就会造成分配效率下降。而TLAB是每个线程独有的，它可以避免这种开销，直接分配空间</p><h3 id="3-初始化零值："><a href="#3-初始化零值：" class="headerlink" title="3.初始化零值："></a>3.初始化零值：</h3><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><h3 id="4-设置对象头："><a href="#4-设置对象头：" class="headerlink" title="4.设置对象头："></a>4.设置对象头：</h3><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><h3 id="5-执行init方法："><a href="#5-执行init方法：" class="headerlink" title="5. 执行init方法："></a>5. 执行init方法：</h3><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<strong>方法还没有执行，所有的字段都还为零</strong>，执行 new 指令之后会接执行init方法把对象按照程序的设计进行初始化。这样一个真正可用的对象才算完全产生出来。</p><h1 id="新建对象的内存布局"><a href="#新建对象的内存布局" class="headerlink" title="新建对象的内存布局"></a>新建对象的内存布局</h1><p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p><p><strong>对象头：包括两部分信息</strong>，<strong>第一部分用于存储对象自身的运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等）官方称它为“Mark Word”。<strong>另一部分是类型指针</strong>，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><p><strong>实例数据</strong>部分是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。</p><p><strong>对齐填充</strong>部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是<strong>对象的大小必须是 8 字节的整数倍</strong>。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。 </p><h1 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h1><p>对象的实例数据部分是存储在java堆中的，而对象的类型数据存储在方法区中（存储着对象的方法表（例如执行student.sayName()时，JVM 根据 student 的引用找到 student 对象，然后根据 student 对象持有的引用定位到方法区中 student 类的类型信息的方法表，获得 sayName() 的字节码地址。））</p><p>我们的 Java 程序通过<strong>栈上的 reference 数据来操作堆上的具体对象</strong>。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：<strong>使用句柄</strong>、<strong>直接指针</strong>。</p><h3 id="句柄方式："><a href="#句柄方式：" class="headerlink" title="句柄方式："></a>句柄方式：</h3><p>reference 中存储的就是对象的句柄地址，Java <strong>堆中将会划分出一块内存来作为句柄池</strong>，句柄中包含了对象<strong>实例数据与类型数据各自的具体地址信息</strong>。</p><p>使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。</p><p><img src="1.png"></p><h3 id="直接指针："><a href="#直接指针：" class="headerlink" title="直接指针："></a>直接指针：</h3><p> reference 中存储的直接就是对象的地址。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</p><p><img src="2.png"></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 对象创建流程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx详解</title>
      <link href="/2022/12/22/Nginx%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/12/22/Nginx%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx性能高的原因："><a href="#Nginx性能高的原因：" class="headerlink" title="Nginx性能高的原因："></a>Nginx性能高的原因：</h1><p>​Nginx的事件处理截止是异步非阻塞事件处理机制，运用了epoll模型提供了一个队列，排队解决。</p><h1 id="Nginx接收请求的过程："><a href="#Nginx接收请求的过程：" class="headerlink" title="Nginx接收请求的过程："></a>Nginx接收请求的过程：</h1><p>​nginx接收一个请求后，首先由listen和server_name指令匹配server模块，再匹配server模块里的location，location就是实际地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;            # 第一个Server区块开始，表示一个独立的虚拟主机站点</span><br><span class="line">        listen       80；      # 提供服务的端口，默认80</span><br><span class="line">        server_name  localhost；       # 提供服务的域名主机名</span><br><span class="line">        location / &#123;            # 第一个location区块开始</span><br><span class="line">            root   html；       # 站点的根目录，相当于Nginx的安装目录</span><br><span class="line">            index  index.html index.htm；      # 默认的首页文件，多个用空格分开</span><br><span class="line">        &#125;          # 第一个location区块结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="正向代理和反向代理"><a href="#正向代理和反向代理" class="headerlink" title="正向代理和反向代理:"></a>正向代理和反向代理:</h1><p>​<strong>正向代理</strong>是一个位于客户端和目标服务器之间的代理服务器（中间服务器）。为了从目标服务器取得内容，客户端向代理服务器发送一个请求，<strong>并且指定目标服务器</strong>，之后代理向目标服务器转发请求，将获得的内容返回给客户端。</p><p>​正向代理是<strong>代理客户端</strong>，为客户端收发请求，使真实客户端对服务器不可见。我们常常使用的科学上网就是正向代理。</p><p>​<strong>反向代理</strong>是指以代理服务器来接收客户端的请求，然后将请求转发给内部网络上的服务器，将从服务器上得到的结果返回给客户端，此时代理服务器对外表现为一个反向代理服务器。</p><p>对于客户端来说，反向代理就相当于目标服务器，只需要将反向代理当作目标服务器一样发送请求就可以了，并且客户端不需要进行任何设置。</p><p>​反向代理是代理服务端，可以为后端的多台服务器提供负载均衡，或者为后端较慢的服务器提供缓冲服务。并且隐藏服务器的存在和特征比如不可见服务端IP地址。</p><h1 id="Nginx的配置文件nginx-conf"><a href="#Nginx的配置文件nginx-conf" class="headerlink" title="Nginx的配置文件nginx.conf"></a><strong>Nginx的配置文件nginx.conf</strong></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">worker_processes  <span class="number">1</span>；                # worker进程的数量</span><br><span class="line">events &#123;                              # 事件区块开始</span><br><span class="line">    worker_connections  <span class="number">1024</span>；            # 每个worker进程支持的最大连接数</span><br><span class="line">&#125;                                    # 事件区块结束</span><br><span class="line">http &#123;                               # HTTP区块开始</span><br><span class="line">    include       mime.types；            # Nginx支持的媒体类型库文件</span><br><span class="line">    default_type  application/octet-stream；     # 默认的媒体类型</span><br><span class="line">    sendfile        on；       # 开启高效传输模式</span><br><span class="line">    keepalive_timeout  <span class="number">65</span>；       # 连接超时</span><br><span class="line">    </span><br><span class="line">    upstream myapp1 &#123;                                    # 多个服务器配置的负载均衡</span><br><span class="line">        server <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span>;</span><br><span class="line">        server <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8081</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    server &#123;            # 第一个Server区块开始，表示一个独立的虚拟主机站点</span><br><span class="line">        listen       <span class="number">80</span>；      # 提供服务的端口，默认<span class="number">80</span></span><br><span class="line">        server_name  localhost；       # 提供服务的域名主机名</span><br><span class="line">        location / &#123;            # 第一个location区块开始</span><br><span class="line">            root   html；       # 站点的根目录，相当于Nginx的安装目录</span><br><span class="line">            index  index.html index.htm；      # 默认的首页文件，多个用空格分开</span><br><span class="line">        &#125;          # 第一个location区块结果</span><br><span class="line">        error_page   <span class="number">500502503504</span>  /50x.html；     # 出现对应的http状态码时，使用50x.html回应客户</span><br><span class="line">        location = /50x.html &#123;          # location区块开始，访问50x.html</span><br><span class="line">            root   html；      # 指定对应的站点目录为html</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    .....</span><br></pre></td></tr></table></figure><p><strong>全局块：</strong>从配置文件开始到events块之间的内容，主要会设置一些影响Nginx服务器整体运行的配置指令，配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process数等。<br><strong>events块：</strong>配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。<br>http块：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。<br><strong>server块</strong>：配置虚拟主机的相关参数，一个http中可以有多个server。server其实就是host，比如<a href="http://www.csdn.com/">www.csdn.com</a><br><strong>location块：</strong>配置请求的路由，以及各种页面的处理情况。<strong>location指令的作用是根据用户请求的URI来执行不同的应用，也就是根据用户请求的网站URL进行匹配，匹配成功即进行相关的操作</strong>。<a href="https://editor.csdn.net/md/%EF%BC%8C/md/%E5%B0%B1%E6%98%AFlocation%E3%80%82%E5%86%8D%E5%A6%82www.csdn.com/index.html,/index.html%E5%B0%B1%E6%98%AFlocation%E3%80%82%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E6%98%AF%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E8%BE%93%E5%85%A5location%EF%BC%8C%E5%A6%82www.csdn.com%EF%BC%8C%E9%82%A3%E4%B9%88%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%B8%AE%E6%88%91%E4%BB%AC%E5%8A%A0%E4%B8%8A/">https://editor.csdn.net/md/，/md/就是location。再如www.csdn.com/index.html,/index.html就是location。需要注意的是，如果没有输入location，如www.csdn.com，那么浏览器会自动帮我们加上/</a> , &#x2F;<a href="http://www.csdn.com/%E3%80%82">www.csdn.com/。</a><br>PS:但是，如果我们访问的是<a href="http://www.csdn.com/a">www.csdn.com/a</a> 则不会自动帮我们加上&#x2F; 因为这里不只是host了</p><h3 id="server虚拟主机详细配置"><a href="#server虚拟主机详细配置" class="headerlink" title="server虚拟主机详细配置"></a>server虚拟主机详细配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">       listen       80;</span><br><span class="line">       server_name  www.jinghao.com;</span><br><span class="line">       location / &#123;</span><br><span class="line">           root   data/www;</span><br><span class="line">           index  index.html index.htm;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="listen指令："><a href="#listen指令：" class="headerlink" title="listen指令："></a>listen指令：</h4><p>该指令用于配置网络监听。具体使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> listen *:<span class="number">80</span> | *:<span class="number">8080</span> #监听所有<span class="number">80</span>端口和<span class="number">8080</span>端口</span><br><span class="line"><span class="number">2</span> listen  IP_address:port   #监听指定的地址和端口号</span><br><span class="line"><span class="number">3</span> listen  IP_address     #监听指定ip地址所有端口</span><br><span class="line"><span class="number">4</span> listen port     #监听该端口的所有IP连接</span><br></pre></td></tr></table></figure><h4 id="server-name指令"><a href="#server-name指令" class="headerlink" title="server_name指令"></a>server_name指令</h4><p>该指令用于虚拟主机的配置。通常分为以下三种：</p><p><strong>1、基于域名的虚拟主机，通过域名来区分虚拟主机——应用：外部网站</strong></p><p>需要建立&#x2F;data&#x2F;www &#x2F;data&#x2F;bbs目录，windows本地hosts添加虚拟机ip地址对应的域名解析；对应域名网站目录下新增index.html文件；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#当客户端访问www.jinghao.com,监听端口号为<span class="number">80</span>,直接跳转到data/www目录下文件</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       <span class="number">80</span>;</span><br><span class="line">        server_name  www.jinghao.com;</span><br><span class="line">        location / &#123;</span><br><span class="line">            root   data/www;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">#当客户端访问bbs.jinghao.com,监听端口号为<span class="number">80</span>,直接跳转到data/bbs目录下文件</span><br><span class="line">    server &#123;</span><br><span class="line">    listen       <span class="number">80</span>;</span><br><span class="line">    server_name  bbs.jinghao.com;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root   data/bbs;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>2、基于端口的虚拟主机，通过端口来区分虚拟主机——应用：公司内部网站，外部网站的管理后台</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> #当客户端访问www.jinghao.com,监听端口号为<span class="number">8080</span>,直接跳转到data/www目录下文件</span><br><span class="line"> server &#123;</span><br><span class="line">       listen       <span class="number">8080</span>;</span><br><span class="line">       server_name  <span class="number">8080.</span>jinghao.com;</span><br><span class="line">       location / &#123;</span><br><span class="line">           root   data/www;</span><br><span class="line">           index  index.html index.htm;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">#当客户端访问www.jinghao.com,监听端口号为<span class="number">80</span>直接跳转到真实ip服务器地址 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span></span><br><span class="line">server &#123;</span><br><span class="line">       listen       <span class="number">80</span>;</span><br><span class="line">       server_name  www.jinghao.com;</span><br><span class="line">       location / &#123;</span><br><span class="line"> proxy_pass http:<span class="comment">//127.0.0.1:8080;</span></span><br><span class="line">           index  index.html index.htm;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="location块内部指令"><a href="#location块内部指令" class="headerlink" title="location块内部指令"></a>location块内部指令</h4><p><strong>index：</strong></p><p>​<strong>该指令用于设置网站的默认首页。语法为：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">index  filename ...; <span class="comment">#后面的文件名称可以有多个，中间用空格隔开。</span></span><br><span class="line">index  index.html index.jsp;</span><br></pre></td></tr></table></figure><p>​通常该指令有两个作用：第一个是用户在请求访问网站时，请求地址可以不写首页名称；第二个是可以对一个请求，根据请求内容而设置不同的首页。</p><p><strong>try_files：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">            try_files $uri $uri/ /index.php?$query_string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当用户请求 <a href="http://localhost/example">http://localhost/example</a> 时，这里的 $uri 就是 &#x2F;example。try_files 会到硬盘里尝试找这个文件。如果存在名为 &#x2F;$root&#x2F;example（其中 $root 是server快定义的）的文件，就直接把这个文件的内容发送给用户。显然，目录中没有叫 example 的文件。然后就看 $uri&#x2F;，增加了一个 &#x2F;，也就是看有没有名为 &#x2F;$root&#x2F;example&#x2F; 的目录。又找不到，就会 fall back 到 try_files 的最后一个选项 &#x2F;index.php，发起一个内部 “子请求”，也就是相当于 nginx 发起一个 HTTP 请求到 <a href="http://localhost/index.php">http://localhost/index.php</a></p><p><strong>proxy_pass</strong></p><p>该指令用于设置被代理服务器的地址。可以是主机名称、IP地址加端口号的形式。</p><h2 id="反向代理详细设置"><a href="#反向代理详细设置" class="headerlink" title="反向代理详细设置"></a>反向代理详细设置</h2><p>nginx 中常见的反向代理指令有两个：proxy_pass 和 fastcgi_pass，前者使用标准的 HTTP 协议转发，后者使用 FastCGI 协议转发，用于 PHP 等架构的环境。</p><p>proxy_pass后有两种写法</p><ul><li>直接接要代理的地址，可以是一台具体的主机（ip），也可以是一个具体的网址</li><li>可以配成一组服务器（负载均衡）</li></ul><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用 Nginx 反向代理，根据访问的路径跳转到不同端口的服务中，Nginx 监听端口为 9001</span></span><br><span class="line"><span class="comment">#访问http://192.168.17.129/edu/直接跳转到 127.0.0.1:8080(内网ip，本机的8080端口)</span></span><br><span class="line"><span class="comment">#访问http://192.168.17.129/vod/直接跳转到 127.0.0.1:8081(内网ip，本机的8081端口)</span></span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">listen       9001;</span><br><span class="line">server_name  192.168.17.129;</span><br><span class="line"></span><br><span class="line">location ~ /edu/ &#123;</span><br><span class="line">proxy_pass  http://127.0.0.1:8080</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~ /vod/ &#123;</span><br><span class="line">proxy_pass  http://127.0.0.1:8081</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line"> location / &#123;</span><br><span class="line"> proxy_pass   http://127.0.0.1:8080;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>负载均衡方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream myapp1 &#123;</span><br><span class="line">        server 127.0.0.1:8080;</span><br><span class="line">        server 127.0.0.1:8081;</span><br><span class="line">    &#125;</span><br><span class="line">server &#123;</span><br><span class="line">    ....</span><br><span class="line">    location  ~*^.+$ &#123;         </span><br><span class="line">        proxy_pass  http://mysvr;  <span class="comment">#请求转向mysvr 定义的服务器列表         </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Nginx的限流"><a href="#Nginx的限流" class="headerlink" title="Nginx的限流"></a>Nginx的限流</h1><p>Nginx限流就是限制用户请求速度，有三种方式，Nginx的限流都是基于漏桶流算法：</p><ol><li>正常限制访问频率（正常流量）</li><li>突发限制访问频率（突发流量）</li><li>限制并发连接数</li></ol><h3 id="1、正常限制访问频率（正常流量）："><a href="#1、正常限制访问频率（正常流量）：" class="headerlink" title="1、正常限制访问频率（正常流量）："></a><strong>1、正常限制访问频率（正常流量）：</strong></h3><p>限制一个用户发送的请求，表示Nginx多久接收一个请求。</p><p>Nginx中使用ngx_http_limit_req_module模块来限制的访问频率，限制的原理实质是基于漏桶算法原理来实现的。在nginx.conf配置文件中可以使用limit_req_zone命令及limit_req命令限制单个IP的请求处理频率。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义限流维度，一个用户一分钟一个请求进来，多余的全部漏掉</span></span><br><span class="line">limit_req_zone <span class="variable">$binary_remote_addr</span> zone=one:10m rate=1r/m;</span><br><span class="line"><span class="comment">#绑定限流维度</span></span><br><span class="line">server&#123;</span><br><span class="line">   location/seckill.html&#123;</span><br><span class="line">      limit_req zone=zone;</span><br><span class="line">      proxy_pass http://lj_seckill;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个参数：$binary_remote_addr 表示通过remote_addr这个标识来做限制，“binary_”的目的是缩写内存占用量，是限制同一客户端ip地址。<br>第二个参数：zone&#x3D;one:10m表示生成一个大小为10M，名字为one的内存区域，用来存储访问的频次信息。<br>第三个参数：rate&#x3D;10r&#x2F;s表示允许同一个客户端的访问频次是每秒10次，还可以有比如30r&#x2F;m的。</p><h3 id="2、突发限制访问频率（突发流量）："><a href="#2、突发限制访问频率（突发流量）：" class="headerlink" title="2、突发限制访问频率（突发流量）："></a><strong>2、突发限制访问频率（突发流量）：</strong></h3><p>上面的配置一定程度可以限制访问频率，但是也存在着一个问题：如果突发流量超出请求被拒绝处理，无法处理活动时候的突发流量，这时候应该如何进一步处理呢？Nginx提供burst参数结合nodelay参数可以解决流量突发的问题，<strong>可以设置能处理的超过设置的请求数外能额外处理的请求数</strong>。我们可以将之前的例子添加burst参数以及nodelay参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义限流维度，一个用户一分钟一个请求进来，多余的全部漏掉</span></span><br><span class="line">limit_req_zone <span class="variable">$binary_remote_addr</span> zone=one:10m rate=1r/m;</span><br><span class="line"> </span><br><span class="line"><span class="comment">#绑定限流维度</span></span><br><span class="line">server&#123;</span><br><span class="line">location/seckill.html&#123;</span><br><span class="line">limit_req zone=zone burst=5 nodelay;</span><br><span class="line">proxy_pass http://lj_seckill;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>burst&#x3D;5，重点说明一下这个配置，burst爆发的意思，这个配置的意思是<strong>设置一个大小为5的缓冲区当有大量请求（爆发）过来时，超过了访问频次限制的请求可以先放到这个缓冲区内</strong>。假设配置的rate&#x3D;1r&#x2F;s，则QPS超过6时，后面的请求才可能会失败</p><p>nodelay，如果设置，超过访问频次而且缓冲区也满了的时候就会直接返回limit_req_status指定的状态码，我们设置的是429，如果没有设置，则所有请求会等待排队。建议配置，否则占用太多内存</p><h1 id="漏桶算法和令牌桶算法"><a href="#漏桶算法和令牌桶算法" class="headerlink" title="漏桶算法和令牌桶算法"></a>漏桶算法和令牌桶算法</h1><h2 id="1-漏桶算法"><a href="#1-漏桶算法" class="headerlink" title="1.漏桶算法"></a><strong>1.漏桶算法</strong></h2><p>突发流量会进入到一个漏桶，漏桶会按照我们定义的速率依次处理请求，如果水流过大也就是突发流量过大就会直接溢出，则多余的请求会被拒绝。所以漏桶算法能控制数据的传输速率。</p><p><img src="blog\source_posts\Nginx详解\1.jpg"></p><h2 id="2-令牌桶算法"><a href="#2-令牌桶算法" class="headerlink" title="2.令牌桶算法"></a><strong>2.令牌桶算法</strong></h2><p>令牌桶算法的机制如下：存在一个大小固定的令牌桶，会以恒定的速率源源不断产生令牌。如果令牌消耗速率小于生产令牌的速度，令牌就会一直产生直至装满整个令牌桶。请求获取令牌后才能进行业务处理。令牌桶的好处就是请求稀疏的时候，会有大量等待使用的令牌，这样等请求密集的时候就避免阻塞时间过长。</p><h1 id="Nginx动静分离"><a href="#Nginx动静分离" class="headerlink" title="Nginx动静分离"></a><strong>Nginx动静分离</strong></h1><p>动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们则根据静态资源的特点将其做缓存操作。让静态的资源只走静态资源服务器，动态的走动态的服务器</p><h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><ul><li>为了避免服务器崩溃，大家会通过负载均衡的方式来分担服务器压力。将对台服务器组成一个集群，当用户访问时，先访问到一个转发服务器，再由转发服务器将访问分发到压力更小的服务器。</li><li>Nginx负载均衡实现的策略有以下五种：</li></ul><p> 轮询(默认)</p><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端某个服务器宕机，能自动剔除故障系统。</p><pre><code>upstream backserver &#123;  server 192.168.0.12;  server 192.168.0.13; &#125; </code></pre><p>2 权重 weight</p><p>weight的值越大分配<br>到的访问概率越高，主要用于后端每台服务器性能不均衡的情况下。其次是为在主从的情况下设置不同的权值，达到合理有效的地利用主机资源。权重越高，在被访问的概率越大，如上例，分别是20%，80%。</p><pre><code>upstream backserver &#123;  server 192.168.0.12 weight=2;  server 192.168.0.13 weight=8; &#125; </code></pre><p>3 ip_hash( IP绑定)</p><p>每个请求按访问IP的哈希结果分配，使来自同一个IP的访客固定访问一台后端服务器，并且可以有效解决动态网页存在的session共享问题</p><pre><code>upstream backserver &#123;  ip_hash;  server 192.168.0.12:88;  server 192.168.0.13:80; &#125; </code></pre><p>4 fair(第三方插件)</p><p>必须安装upstream_fair模块。对比 weight、ip_hash更加智能的负载均衡算法，fair算法可以根据页面大小和加载时间长短智能地进行负载均衡，响应时间短的优先分配。哪个服务器的响应速度快，就将请求分配到那个服务器上。</p><pre><code>upstream backserver &#123;  server server1;  server server2;  fair; &#125; </code></pre><p>5、url_hash(第三方插件)</p><p>必须安装Nginx的hash软件包<br>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，可以进一步提高后端缓存服务器的效率。</p><pre><code>upstream backserver &#123;  server squid1:3128;  server squid2:3128;  hash $request_uri;  hash_method crc32; &#125; </code></pre>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx详解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty的handler不是单例的！</title>
      <link href="/2022/12/17/Netty%E7%9A%84handler%E4%B8%8D%E6%98%AF%E5%8D%95%E4%BE%8B%E7%9A%84%EF%BC%81/"/>
      <url>/2022/12/17/Netty%E7%9A%84handler%E4%B8%8D%E6%98%AF%E5%8D%95%E4%BE%8B%E7%9A%84%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>​在使用Netty实现用户之间的即时聊天功能时，采用在Redis中记录IP加有效时间内访问次数，并添加一个CountHandler在Pipline中，这样每次不同channelactive的时候都将经过CountHandler这样就会得到当前在线的用户人数。具体实现如下：</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">super</span>.channelActive(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            count--;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">super</span>.channelInactive(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketRateLimitHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedisService redisService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EXPIRE_TIME</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">insocket</span> <span class="operator">=</span> (InetSocketAddress) ctx.channel().remoteAddress();<span class="comment">//获取客户端的IP</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> insocket.getAddress().getHostAddress();</span><br><span class="line">        <span class="comment">// Generates key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> String.format(<span class="string">&quot;ut_wss_limit_rate_%s&quot;</span>, ip);</span><br><span class="line">        <span class="comment">// Checks</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">over</span> <span class="operator">=</span> redisService.overRequestRateLimit(key, MAX, EXPIRE_TIME, TimeUnit.SECONDS, <span class="string">&quot;websocket&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (over) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;IP: &#123;&#125; 触发限流了 &quot;</span>,ip);</span><br><span class="line">            ctx.channel().close();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ctx.fireChannelRead(msg);<span class="comment">//将消息传递给下一个处理器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​因为在Netty中要保证代码串行执行，不必考虑并发同步的问题，采用将每一个channel都有自己绑定的eventloop和channelHandler。如下ServerBootstrap.java的源码所示，每次新消息来的时候都有一个新的Popeline被添加this.childHandler中定义的handler，在具体实现的时候我们是写一个类继承<strong>ChannelInitializer</strong>并重写initChannel方法，ChannelInitializer这个类比较特殊，你可以把它想象成是很多channelhandler的集合体，而且这个类就是@Shareable的，继承了这个类之后你可以为每一个channel单独创建handler，甚至是多个handler。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="type">Channel</span> <span class="variable">child</span> <span class="operator">=</span> (Channel)msg;</span><br><span class="line">    <span class="comment">//下面这一行就可以看看出每次有新channel来的时候</span></span><br><span class="line">           child.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelHandler</span>[]&#123;<span class="built_in">this</span>.childHandler&#125;);</span><br><span class="line">           AbstractBootstrap.setChannelOptions(child, <span class="built_in">this</span>.childOptions, ServerBootstrap.logger);</span><br><span class="line">           AbstractBootstrap.setAttributes(child, <span class="built_in">this</span>.childAttrs);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="built_in">this</span>.childGroup.register(child).addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() &#123;</span><br><span class="line">                   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                       <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                           ServerBootstrap.ServerBootstrapAcceptor.forceClose(child, future.cause());</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable var5) &#123;</span><br><span class="line">               forceClose(child, var5);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>是要记录所有的channel连接个数，所以CountHandler必须是单例存在的，也就是加上@ChannelHandler.Sharable注解，他在整个生命周期中就是以单例的形式存在。这样才能得到正确的channel的在线数量。那么问题来了，在实际测试中，发现每次得到的channel数都是小于设定值的，也就是说count++的时候产生了并发问题。这不对啊。明明是已经标注了单例注解，netty应该会知道标注了Sharable注解直接将缓存的handler拿出来再次放进这个channel中不就完了。现实其实不是这样的。如下netty addlast的源码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title function_">addLast</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            checkMultiplicity(handler);</span><br><span class="line"> </span><br><span class="line">            newCtx = newContext(group, filterName(name, handler), handler);</span><br><span class="line"> </span><br><span class="line">            addLast0(newCtx);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// If the registered is false it means that the channel was not registered on an eventLoop yet.</span></span><br><span class="line">            <span class="comment">// In this case we add the context to the pipeline and add a task that will call</span></span><br><span class="line">            <span class="comment">// ChannelHandler.handlerAdded(...) once the channel is registered.</span></span><br><span class="line">            <span class="keyword">if</span> (!registered) &#123;</span><br><span class="line">                newCtx.setAddPending();</span><br><span class="line">                callHandlerCallbackLater(newCtx, <span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="type">EventExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> newCtx.executor();</span><br><span class="line">            <span class="keyword">if</span> (!executor.inEventLoop()) &#123;</span><br><span class="line">                callHandlerAddedInEventLoop(newCtx, executor);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        callHandlerAdded0(newCtx);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中的checkMultiplicity只是简单的检查了一下handler是不是标注了Sharable或者是不是还没添加，否则就排除异常，防止没有@sharable注解的实例被当成单例使用，<strong>也就是说handler的单例需要自己实现。</strong></p><p><strong>解决办法:<strong>在继承ChannelInitializer的类中将CountHandler作为成员变量，利用</strong>所有的channel都共享了ChannelInitializerImpl这个实例</strong>这样所有的channe都有相同的一个成员变量，保证了CountHandler的单例性质。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">CountHandler</span> <span class="variable">countHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountHandler</span>();</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel nioSocketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       System.out.println(<span class="built_in">this</span>);</span><br><span class="line">       nioSocketChannel.pipeline()</span><br><span class="line">               .addLast(<span class="keyword">new</span> <span class="title class_">TimeoutHandler</span>(<span class="number">5</span>,<span class="number">1000</span>,<span class="number">1000</span>))</span><br><span class="line">               .addLast(<span class="keyword">new</span> <span class="title class_">MessageHandler</span>())</span><br><span class="line">               .addLast(countHandler)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty的handler不是单例的！ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty的Attribute用法</title>
      <link href="/2022/12/16/Netty%E7%9A%84Attribute%E7%94%A8%E6%B3%95/"/>
      <url>/2022/12/16/Netty%E7%9A%84Attribute%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Attribute"><a href="#Attribute" class="headerlink" title="Attribute"></a>Attribute</h1><p><strong>Attribute</strong>是一个属性对象，这个属性的名称为AttributeKey<T> key，而属性的值为T value。 <strong>AttributeKey</strong>是Constant的一个扩展，因此也有一个ConstantPool来管理和创建，这和ChannelOption是类似的。</T></p><p>Channel类本身继承了AttributeMap类，而AttributeMap它持有多个Attribute，这些Attribute可以通过AttributeKey来访问的。所以，才可以通过<code>channel.attr(key).set(value)</code>的方式将属性设置到channel中了(即，这里的attr方法实际上是AttributeMap接口中的方法)。</p><span id="more"></span><p><strong>AttributeKey、Attribute、AttributeMap间的关系：</strong><br>AttributeMap相对于一个map，AttributeKey相当于map的key，Attribute是一个持有key(AttributeKey)和value的对象。因此在map中我们可以通过AttributeKey key获取Attribute，从而获取Attribute中的value(即,属性值)。</p><h1 id="关于ChannelHandlerContext-attr-和-Channel-attr"><a href="#关于ChannelHandlerContext-attr-和-Channel-attr" class="headerlink" title="关于ChannelHandlerContext.attr(..) 和 Channel.attr(..)"></a>关于ChannelHandlerContext.attr(..) 和 Channel.attr(..)</h1><p>Q：ChannelHandlerContext和Channel都提供了attr方法，那么它们设置的属性作用域有什么不同了？<br> A：在Netty 4.1版本之前，它们两设置的属性作用域确实存在着不同，但从Netty 4.1版本开始，它们两设置的属性的作用域已经完全相同了。</p><p>使用举例：</p><p>写示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AttributeKey&lt;<span class="type">byte</span>[]&gt; srcdataAttrKey = AttributeKey.valueOf(<span class="string">&quot;srcdata&quot;</span>);</span><br><span class="line"><span class="type">byte</span>[] mydata=<span class="keyword">new</span> <span class="title class_">byte</span>[msg.readableBytes()];</span><br><span class="line">Attribute&lt;<span class="type">byte</span>[]&gt; srcdataAttr = ctx.channel().attr(CloudConstants.srcdataAttrKey);</span><br><span class="line">srcdataAttr.set(mydata);</span><br></pre></td></tr></table></figure><p>读示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AttributeKey&lt;String&gt; nameAttrKey = AttributeKey.valueOf(<span class="string">&quot;nameattr&quot;</span>);</span><br><span class="line">Attribute&lt;String&gt; attr = ctx.channel().attr(nameAttrKey);</span><br><span class="line">String name= attr.get();</span><br></pre></td></tr></table></figure><p><strong>使用attr查找channel</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.group.ChannelMatcher;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.Attribute;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MatcherByName</span>  <span class="keyword">implements</span> <span class="title class_">ChannelMatcher</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MatcherByName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找某个channel，找自己所在channel，不是找peer</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(Channel ch)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Attribute&lt;String&gt; nameAttr= ch.attr(ChannelConstants.ChannelAttribute);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> nameAttr.get();</span><br><span class="line">        <span class="keyword">if</span>(name==<span class="literal">null</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.name.equals(name))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过matcher找channel list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> matcher</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Channel&gt; <span class="title function_">getChannelsFromMatcher</span><span class="params">(ChannelMatcher matcher)</span>&#123;</span><br><span class="line">    Object[] channels =NettyService.allChannels.toArray();</span><br><span class="line">    List&lt;Channel&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Channel&gt;();</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span>(Object ch : channels) &#123;</span><br><span class="line">        <span class="keyword">if</span>(matcher.matches((Channel)ch)) &#123;</span><br><span class="line">            channel = (Channel)ch;</span><br><span class="line">            list.add(channel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Channel <span class="title function_">getChannelByName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">     MatcherByName matcher=<span class="keyword">new</span> <span class="title class_">MatcherByName</span>(name);</span><br><span class="line">     List&lt;Channel&gt; list= getChannelsFromMatcher(matcher);</span><br><span class="line">    <span class="keyword">if</span>(list!=<span class="literal">null</span> &amp;&amp; list.size()&gt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ChannelInboundHandlerAdapter和SimpleChannelInboundHandler区别"><a href="#ChannelInboundHandlerAdapter和SimpleChannelInboundHandler区别" class="headerlink" title="ChannelInboundHandlerAdapter和SimpleChannelInboundHandler区别"></a>ChannelInboundHandlerAdapter和SimpleChannelInboundHandler区别</h1><p>在客户端的业务Handler继承的是SimpleChannelInboundHandler，而在服务器端继承的是ChannelInboundHandlerAdapter。</p><p>ChannelInboundHandlerAdapter是ChannelInboundHandler一个简单实现，默认情况下不会做任何处理。只是简单的将操作通过fire方法传到ChannelPipeline中的下一个ChannelHandler中让链中的下一个ChannelHandler去处理。<br>但是需要注意的是信息经过channelRead方法处理之后不会自动释放(是因为信息不会被自动释放所以能将信息传给下一个ChannelHandler处理。其次，在实现类Handler中，你仍然需要将传入消息回送给发送者，而 write() 操作是异步的，直到 channelRead() 方法返回后可能仍然没有完成。为此，实现类Handler扩展了  ChannelInboundHandlerAdapter ，其在这个时间点上不会释放消息。)</p><p>SimpleChannelInboundHandler支持泛型的消息处理，默认情况下消息处理完之后将会自动释放，无法提供fire*方法传递给ChannelPipeline中的下一个ChannelHandler.在客户端，<strong>当 channelRead0()  方法完成时，你已经有了传入消息，并且已经处理完它了</strong>。当该方法返回时，SimpleChannelInboundHandler负责释放指向保存该消息的ByteBuf的内存引用(自动调用Bytebuffer.release())。而为何服务器端不能用呢，因为我们想让服务器把客户端请求的数据发送回去，而服务器端有可能在channelRead方法返回前还没有写完数据，因此不能让它自动release。</p>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty的Attribute用法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty详解</title>
      <link href="/2022/12/15/Netty%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/12/15/Netty%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Netty线程模型"><a href="#Netty线程模型" class="headerlink" title="Netty线程模型"></a>Netty线程模型</h1><p>根据 <code>Reactor</code> 的数量和处理资源池线程的数量不同，有 <code>3</code> 种典型的实现</p><ul><li>单 <code>Reactor</code> 单线程；</li><li>单 <code>Reactor</code>多线程；</li><li>主从 <code>Reactor</code>多线程</li></ul><p><code>Netty</code> 线程模式：基于主从 <code>Reactor</code>多线程的改进版，将主从 <code>Reactor</code>多线程模型中设置多个 <code>Reactor</code></p><span id="more"></span><h2 id="I-O-复用模型"><a href="#I-O-复用模型" class="headerlink" title="I/O 复用模型"></a><code>I/O</code> 复用模型</h2><ol><li>基于线程池复用线程资源：不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理，一个线程可以处理多个连接的业务。（解决了当并发数很大时，会创建大量线程，占用很大系统资源。</li><li>基于 <code>I/O</code> 复用模型：多个客户端进行连接，先把连接请求给<code>ServiceHandler</code>。多个连接共用一个阻塞对象<code>ServiceHandler</code>。假设，当C1连接没有数据要处理时，C1客户端只需要阻塞于<code>ServiceHandler</code>，C1之前的处理线程便可以处理其他有数据的连接，不会造成线程资源的浪费。当C1连接再次有数据时，<code>ServiceHandler</code>根据线程池的空闲状态，将请求分发给空闲的线程来处理C1连接的任务。</li></ol><p>如下图所示就是IO复用结合线程池的Reactor设计思想：</p><ol><li><code>Reactor</code> 模式，通过一个或多个输入同时传递给服务处理器（ServiceHandler）的模式（基于事件驱动）</li><li>服务器端程序处理传入的多个请求,并将它们同步分派到相应的处理线程，因此 <code>Reactor</code> 模式也叫 <code>Dispatcher</code> 模式</li><li><code>Reactor</code> 模式使用 <code>IO</code> 复用监听事件，收到事件后，分发给某个线程（进程），这点就是网络服务器高并发处理关键</li></ol><blockquote><p>原先有多个Handler阻塞，现在只用一个ServiceHandler阻塞</p></blockquote><p><img src="Netty%E8%AF%A6%E8%A7%A3%5C2.jpg"></p><h2 id="单-Reactor-单线程"><a href="#单-Reactor-单线程" class="headerlink" title="单 Reactor 单线程"></a>单 Reactor 单线程</h2><p><img src="Netty%E8%AF%A6%E8%A7%A3%5C3.jpg"></p><ol><li><code>Select</code> 是前面 <code>I/O</code> 复用模型介绍的标准网络编程 <code>API</code>，可以实现应用程序通过一个阻塞对象监听多路连接请求</li><li><code>Reactor</code> 对象通过 <code>Select</code> 监控客户端请求事件，收到事件后通过 <code>Dispatch</code> 进行分发</li><li>如果是建立连接请求事件，则由 <code>Acceptor</code> 通过 <code>Accept</code> 处理连接请求，然后创建一个 <code>Handler</code> 对象处理连接完成后的后续业务处理</li><li>如果不是建立连接事件，则 <code>Reactor</code> 会分发调用连接对应的 <code>Handler</code> 来响应</li><li><code>Handler</code> 会完成 <code>Read</code> → 业务处理 → <code>Send</code> 的完整业务流程</li></ol><h2 id="单-Reactor-多线程"><a href="#单-Reactor-多线程" class="headerlink" title="单 Reactor 多线程"></a>单 Reactor 多线程</h2><p><img src="Netty%E8%AF%A6%E8%A7%A3%5C4.jpg"></p><ol><li><code>Reactor</code> 对象通过 <code>Select</code> 监控客户端请求事件，收到事件后，通过 <code>Dispatch</code> 进行分发</li><li>如果是建立连接请求，则由 <code>Acceptor</code> 通过 <code>accept</code> 处理连接请求，然后创建一个 <code>Handler</code> 对象处理完成连接后的各种事件</li><li>如果不是连接请求，则由 <code>Reactor</code> 分发调用连接对应的 <code>handler</code> 来处理（也就是说连接已经建立，后续客户端再来请求，那基本就是数据请求了，直接调用之前为这个连接创建好的handler来处理）</li><li><code>handler</code> 只负责响应事件，不做具体的业务处理（这样不会使handler阻塞太久），通过 <code>read</code> 读取数据后，会分发给后面的 <code>worker</code> 线程池的某个线程处理业务。【业务处理是最费时的，所以将业务处理交给线程池去执行】</li><li><code>worker</code> 线程池会分配独立线程完成真正的业务，并将结果返回给 <code>handler</code></li><li><code>handler</code> 收到响应后，通过 <code>send</code> 将结果返回给 <code>client</code></li></ol><h2 id="主从-Reactor-多线程"><a href="#主从-Reactor-多线程" class="headerlink" title="主从 Reactor 多线程"></a>主从 Reactor 多线程</h2><p>​针对单 <code>Reactor</code> 多线程模型中，<code>Reactor</code> 在单线程中运行，高并发场景下容易成为性能瓶颈，可以让 <code>Reactor</code> 在多线程中运行。</p><p><img src="Netty%E8%AF%A6%E8%A7%A3%5C5.jpg"></p><blockquote><p>SubReactor是可以有多个的。</p></blockquote><ol><li><code>Reactor</code> 主线程 <code>MainReactor</code> 对象通过 <code>select</code> 监听连接事件，收到事件后，通过 <code>Acceptor</code> 处理连接事件</li><li>当 <code>Acceptor</code> 处理连接事件后，<code>MainReactor</code> 将连接分配给 <code>SubReactor</code></li><li><code>subreactor</code> 将连接加入到连接队列进行监听，并创建 <code>handler</code> 进行各种事件处理</li><li>当有新事件发生时，<code>subreactor</code> 就会调用对应的 <code>handler</code> 处理</li><li><code>handler</code> 通过 <code>read</code> 读取数据，分发给后面的 <code>worker</code> 线程处理</li><li><code>worker</code> 线程池分配独立的 <code>worker</code> 线程进行业务处理，并返回结果</li><li><code>handler</code> 收到响应的结果后，再通过 <code>send</code> 将结果返回给 <code>client</code></li><li><code>Reactor</code> 主线程可以对应多个 <code>Reactor</code> 子线程，即 <code>MainRecator</code> 可以关联多个 <code>SubReactor</code></li></ol><h2 id="Netty线程模型详细介绍"><a href="#Netty线程模型详细介绍" class="headerlink" title="Netty线程模型详细介绍"></a>Netty线程模型详细介绍</h2><p><img src="Netty%E8%AF%A6%E8%A7%A3%5C6.jpg"></p><ol><li><code>BossGroup</code> 线程维护 <code>Selector</code>，只关注 <code>Accecpt</code></li><li>当接收到 <code>Accept</code> 事件，获取到对应的 <code>SocketChannel</code>，封装成 <code>NIOScoketChannel</code> 并注册到 <code>Worker</code> 线程（事件循环），并进行维护</li><li>当 <code>Worker</code> 线程监听到 <code>Selector</code> 中通道发生自己感兴趣的事件后，就进行处理（就由 <code>handler</code>），注意 <code>handler</code> 已经加入到通道</li></ol><p>详细步骤如下：</p><ol><li><code>Netty</code> 抽象出两组线程池 ，<code>BossGroup</code> <strong>专门负责接收客户端的连接</strong>，<code>WorkerGroup</code> <strong>专门负责网络的读写</strong></li><li><code>BossGroup</code> 和 <code>WorkerGroup</code> 类型都是 <code>NioEventLoopGroup</code></li><li><code>NioEventLoopGroup</code> 相当于一个事件循环组，这个组中含有多个事件循环，每一个事件循环是 <code>NioEventLoop</code></li><li><code>NioEventLoop</code> 表示一个不断循环的执行处理任务的线程，每个 <code>NioEventLoop</code> 都有一个 <code>Selector</code>，用于监听绑定在其上的 <code>socket</code> 的网络通讯</li><li><code>NioEventLoopGroup</code> 可以有多个线程，即可以含有多个 <code>NioEventLoop</code></li><li>每个 BossGroup下面的NioEventLoop循环执行的步骤有 3 步<ul><li>轮询 <code>accept</code> 事件</li><li>处理 <code>accept</code> 事件，与 <code>client</code> 建立连接，生成 <code>NioScocketChannel</code>，并将其注册到某个 <code>workerGroup</code> <code>NIOEventLoop</code> 上的 <code>Selector</code></li><li>继续处理任务队列的任务，即 <code>runAllTasks</code></li></ul></li><li>每个 WorkerGroup NIOEventLoop循环执行的步骤<ul><li>轮询 <code>read</code>，<code>write</code> 事件</li><li>处理 <code>I/O</code> 事件，即 <code>read</code>，<code>write</code> 事件，在对应 <code>NioScocketChannel</code> 处理</li><li>处理任务队列的任务，即 <code>runAllTasks</code></li></ul></li><li>每个 <code>Worker</code> <code>NIOEventLoop</code> 处理业务时，会使用 <code>pipeline</code>（管道），<code>pipeline</code> 中包含了 <code>channel（通道）</code>，即通过 <code>pipeline</code> 可以获取到对应通道，管道中维护了很多的处理器。（这个点目前只是简单的讲，后面重点说）</li></ol><h1 id="Netty的异步模型"><a href="#Netty的异步模型" class="headerlink" title="Netty的异步模型"></a>Netty的异步模型</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><ol><li>异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的组件在完成后，通过状态、通知和回调来通知调用者。</li><li><code>Netty</code> 中的 <code>I/O</code> 操作是异步的，包括 <code>Bind、Write、Connect</code> 等操作会首先简单的返回一个 <code>ChannelFuture</code>。</li><li>调用者并不能立刻获得结果，而是通过 <code>Future-Listener</code> 机制，用户可以方便的主动获取或者通过通知机制获得 <code>IO</code> 操作结果。</li><li><code>Netty</code> 的异步模型是建立在 <code>future</code> 和 <code>callback</code> 的之上的。<code>callback</code> 就是回调。重点说 <code>Future</code>，它的核心思想是：假设一个方法 <code>fun</code>，计算过程可能非常耗时，等待 <code>fun</code> 返回显然不合适。那么可以在调用 <code>fun</code> 的时候，立马返回一个 <code>Future</code>，后续可以通过 <code>Future</code> 去监控方法 <code>fun</code> 的处理过程（即：<code>Future-Listener</code> 机制）</li></ol><h2 id="Feture"><a href="#Feture" class="headerlink" title="Feture"></a>Feture</h2><ol><li>表示异步的执行结果,可以通过它提供的方法来检测执行是否完成，比如检索计算等等。</li><li><code>ChannelFuture</code> 是一个接口：<code>public interface ChannelFuture extends Future&lt;Void&gt;</code> 我们可以添加监听器，当监听的事件发生时，就会通知到监听器。</li><li>常见有如下操作<ul><li>通过 <code>isDone</code> 方法来判断当前操作是否完成；</li><li>通过 <code>isSuccess</code> 方法来判断已完成的当前操作是否成功；</li><li>通过 <code>getCause</code> 方法来获取已完成的当前操作失败的原因；</li><li>通过 <code>isCancelled</code> 方法来判断已完成的当前操作是否被取消；</li><li>通过 <code>addListener</code> 方法来注册监听器，当操作已完成（<code>isDone</code>方法返回完成），将会通知指定的监听器；如果 <code>Future</code> 对象已完成，则通知指定的监听器</li></ul></li></ol><h1 id="Netty核心组件"><a href="#Netty核心组件" class="headerlink" title="Netty核心组件"></a>Netty核心组件</h1><h2 id="Bootstrap、ServerBootstrap"><a href="#Bootstrap、ServerBootstrap" class="headerlink" title="Bootstrap、ServerBootstrap"></a>Bootstrap、ServerBootstrap</h2><p><code>Bootstrap</code> 意思是引导，一个 <code>Netty</code> 应用通常由一个 <code>Bootstrap</code> 开始，主要作用是配置整个 <code>Netty</code> 程序，串联各个组件，<code>Netty</code> 中 <code>Bootstrap</code> 类是客户端程序的启动引导类，<code>ServerBootstrap</code> 是服务端启动引导类。</p><h2 id="Future、ChannelFuture"><a href="#Future、ChannelFuture" class="headerlink" title="Future、ChannelFuture"></a>Future、ChannelFuture</h2><p><code>Netty</code> 中所有的 <code>IO</code> 操作都是异步的，不能立刻得知消息是否被正确处理。但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过 <code>Future</code> 和 <code>ChannelFutures</code>，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件</p><p>常见的方法有</p><ul><li><code>Channel channel()</code>，返回当前正在进行 <code>IO</code> 操作的通道</li><li><code>ChannelFuture sync()</code>，等待异步操作执行完毕</li></ul><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p><code>Netty</code> 网络通信的组件，能够用于执行网络 <code>I/O</code> 操作。</p><p>通过 <code>Channel</code> 可获得当前网络连接的通道的状态</p><p>通过 <code>Channel</code> 可获得网络连接的配置参数（例如接收缓冲区大小）</p><p><code>Channel</code> 提供异步的网络 <code>I/O</code> 操作(如建立连接，读写，绑定端口)，异步调用意味着任何 <code>I/O</code> 调用都将立即返回，并且不保证在调用结束时所请求的 <code>I/O</code> 操作已完成</p><p>调用立即返回一个 <code>ChannelFuture</code> 实例，通过注册监听器到 <code>ChannelFuture</code> 上，可以 <code>I/O</code> 操作成功、失败或取消时回调通知调用方</p><p>支持关联 <code>I/O</code> 操作与对应的处理程序</p><p>不同协议、不同的阻塞类型的连接都有不同的 <code>Channel</code> 类型与之对应，常用的 <code>Channel</code> 类型：</p><ul><li><code>NioSocketChannel</code>，异步的客户端 <code>TCP</code> <code>Socket</code> 连接。</li><li><code>NioServerSocketChannel</code>，异步的服务器端 <code>TCP</code> <code>Socket</code> 连接。</li><li><code>NioDatagramChannel</code>，异步的 <code>UDP</code> 连接。</li></ul><h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><ol><li><code>Netty</code> 基于 <code>Selector</code> 对象实现 <code>I/O</code> 多路复用，通过 <code>Selector</code> 一个线程可以监听多个连接的 <code>Channel</code> 事件。</li><li>当向一个 <code>Selector</code> 中注册 <code>Channel</code> 后，<code>Selector</code> 内部的机制就可以自动不断地查询（<code>Select</code>）这些注册的 <code>Channel</code> 是否有已就绪的 <code>I/O</code> 事件（例如可读，可写，网络连接完成等），这样程序就可以很简单地使用一个线程高效地管理多个 <code>Channel</code></li></ol><p>​<strong>Epoll Bug：</strong>这里需要注意的是原生NIO的会产生Epoll Bug：正常情况下，select()方法在没有事件时，程序一直阻塞在该方法，但是在没有任何事件的情况下，该方法被唤醒，但是在程序对seclectionKey进行遍历时，却没有任何key，导致程序一直在循环中不能执行下去，从而导致CPU100%。</p><p>​<strong>Netty的解决办法是</strong>：对Selector的select操作周期进行统计，每完成一次空的select操作进行一次计数。<br> 若在某个周期内连续发生N次空轮询，则触发了<a href="https://so.csdn.net/so/search?q=epoll&spm=1001.2101.3001.7020">epoll</a>死循环bug。<br> 重建Selector，判断是否是其他线程发起的重建请求，若不是则将原SocketChannel从旧的Selector上去除注册，重新注册到新的Selector上，并将原来的Selector关闭。</p><h2 id="ChannelHandler-及其实现类"><a href="#ChannelHandler-及其实现类" class="headerlink" title="ChannelHandler 及其实现类"></a>ChannelHandler 及其实现类</h2><ol><li><code>ChannelHandler</code> 是一个接口，处理 <code>I/O</code> 事件或拦截 <code>I/O</code> 操作，并将其转发到其 <code>ChannelPipeline</code>（业务处理链）中的下一个处理程序。</li><li><code>ChannelHandler</code> 本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类</li><li>我们经常需要自定义一个 <code>Handler</code> 类去继承 <code>ChannelInboundHandlerAdapter</code>，然后通过重写相应方法实现业务逻辑，我们接下来看看一般都需要重写哪些方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChannellnboundHandlerAdapter</span> extendsChannelHandlerAdapter <span class="keyword">implements</span> <span class="title class_">ChannellnboundHandler</span> &#123;<span class="keyword">public</span> ChannellnboundHandlerAdapter) &#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> throwsException &#123;ctx.fireChannelRegistered);&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelUnregistered</span><span class="params">(ChannelHandlerContext ctx)</span> throwsException &#123;ctx.fireChannelUnregistered0);&#125;</span><br><span class="line"><span class="comment">//通道就绪事件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exceptionctx.fireChannelActive);&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channellnactive</span><span class="params">(ChannelHandlerContext ctx)</span> throwsException &#123;ctx.fireChannellnactive();</span><br><span class="line"><span class="comment">//通道读取数据事件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span><span class="keyword">throws</span> Exception &#123;ctx.fireChannelRead(msg);&#125;</span><br><span class="line"><span class="comment">//数据读取完毕事件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> throwsException &#123;</span><br><span class="line">ctx.fireChannelReadComplete(;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContextctx,Object evt)</span><span class="keyword">throws</span> Exception &#123;</span><br><span class="line">ctx.fireUserEventTriggered(evt);&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelWritabilityChanged</span><span class="params">(ChannelHandlerContext ctx)</span><span class="keyword">throws</span> Exception &#123;</span><br><span class="line">ctx.fireChannelWritabilityChanged);</span><br><span class="line"><span class="comment">//通道发生异常事件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx,Throwablecause)</span> <span class="keyword">throws</span> Exception &#123;ctx.fireExceptionCaught(cause);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Pipeline-和-ChannelPipeline"><a href="#Pipeline-和-ChannelPipeline" class="headerlink" title="Pipeline 和 ChannelPipeline"></a>Pipeline 和 ChannelPipeline</h2><p><code>ChannelPipeline</code> 是一个重点：</p><ol><li><code>ChannelPipeline</code> 是一个 <code>Handler</code> 的集合，它负责处理和拦截 <code>inbound</code> 或者 <code>outbound</code> 的事件和操作，相当于一个贯穿 <code>Netty</code> 的链。（也可以这样理解：<code>ChannelPipeline</code> 是保存 <code>ChannelHandler</code> 的 <code>List</code>，用于处理或拦截 <code>Channel</code> 的入站事件和出站操作）</li><li><code>ChannelPipeline</code> 实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及 <code>Channel</code> 中各个的 <code>ChannelHandler</code> 如何相互交互</li><li>在 <code>Netty</code> 中每个 <code>Channel</code> 都有且仅有一个 <code>ChannelPipeline</code> 与之对应。具体组成与执行顺序如下所述。</li><li>常用方法 <code>ChannelPipeline addFirst(ChannelHandler... handlers)</code>，把一个业务处理类（<code>handler</code>）添加到链中的第一个位置<code>ChannelPipeline addLast(ChannelHandler... handlers)</code>，把一个业务处理类（<code>handler</code>）添加到链中的最后一个位置</li></ol><h2 id="ChannelHandlerContext"><a href="#ChannelHandlerContext" class="headerlink" title="ChannelHandlerContext"></a>ChannelHandlerContext</h2><ol><li><p>保存 <code>Channel</code> 相关的所有上下文信息，同时关联一个 <code>ChannelHandler</code> 对象</p></li><li><p>即 <code>ChannelHandlerContext</code> 中包含一个具体的事件处理器 <code>ChannelHandler</code>，同时 <code>ChannelHandlerContext</code> 中也绑定了对应的 <code>pipeline</code> 和 <code>Channel</code> 的信息，方便对 <code>ChannelHandler</code> 进行调用。</p></li><li><p>常用方法</p><ul><li><p><code>ChannelFuture close()</code>，关闭通道</p></li><li><p><code>ChannelOutboundInvoker flush()</code>，刷新</p></li><li><p><code>ChannelFuture writeAndFlush(Object msg)</code>，将数据写到<code>ChannelPipeline</code> 中当前 <code>ChannelHandler</code> 的下一个 <code>ChannelHandler</code> 开始处理（出站）</p></li></ul></li></ol><h2 id="Unpooled-类"><a href="#Unpooled-类" class="headerlink" title="Unpooled 类"></a>Unpooled 类</h2><ol><li><code>Netty</code> 提供一个专门用来操作缓冲区（即 <code>Netty</code> 的数据容器）的工具类</li><li>常用方法如下所示</li></ol><h1 id="Netty示例："><a href="#Netty示例：" class="headerlink" title="Netty示例："></a>Netty示例：</h1><p>Netty服务器在6668端口监听，浏览器发出请求<a href="http://localhost:6668/">http://localhost:6668/</a></p><p>服务器可以回复消息给客户端”Hello!我是服务器”,并对特定请求资源进行过滤。</p><p>目的：<code>Netty</code> 可以做 <code>Http</code> 服务开发，并且理解 <code>Handler</code> 实例和客户端及其请求的关系。</p><p><strong>服务端启动Netty：Server</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">mport io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line"></span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class).childHandler(<span class="keyword">new</span> <span class="title class_">TestServerInitializer</span>());</span><br><span class="line"></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> serverBootstrap.bind(<span class="number">6668</span>).sync();</span><br><span class="line">            </span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>连接通道初始化构造Channel对应的pipeline：ServerInitializer</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpServerCodec;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestServerInitializer</span> <span class="keyword">extends</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向管道加入处理器</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到管道</span></span><br><span class="line">        <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加入一个netty 提供的httpServerCodec codec =&gt;[coder - decoder]</span></span><br><span class="line">        <span class="comment">//HttpServerCodec 说明</span></span><br><span class="line">        <span class="comment">//1. HttpServerCodec 是netty 提供的处理http的 编-解码器</span></span><br><span class="line">        pipeline.addLast(<span class="string">&quot;MyHttpServerCodec&quot;</span>,<span class="keyword">new</span> <span class="title class_">HttpServerCodec</span>());</span><br><span class="line">        <span class="comment">//2. 增加一个自定义的handler</span></span><br><span class="line">        pipeline.addLast(<span class="string">&quot;MyTestHttpServerHandler&quot;</span>, <span class="keyword">new</span> <span class="title class_">TestHttpServerHandler</span>());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;ok~~~~&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>自定义Handler</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">说明</span></span><br><span class="line"><span class="comment">1. SimpleChannelInboundHandler 是 ChannelInboundHandlerAdapter</span></span><br><span class="line"><span class="comment">2. HttpObject 客户端和服务器端相互通讯的数据被封装成 HttpObject</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestHttpServerHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;HttpObject&gt; &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//channelRead0 读取客户端数据</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, HttpObject msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;对应的channel=&quot;</span> + ctx.channel() + <span class="string">&quot; pipeline=&quot;</span> + ctx</span><br><span class="line">        .pipeline() + <span class="string">&quot; 通过pipeline获取channel&quot;</span> + ctx.pipeline().channel());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;当前ctx的handler=&quot;</span> + ctx.handler());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断 msg 是不是 httprequest请求</span></span><br><span class="line">        <span class="keyword">if</span>(msg <span class="keyword">instanceof</span> HttpRequest) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;ctx 类型=&quot;</span>+ctx.getClass());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;pipeline hashcode&quot;</span> + ctx.pipeline().hashCode() + <span class="string">&quot; TestHttpServerHandler hash=&quot;</span> + <span class="built_in">this</span>.hashCode());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;msg 类型=&quot;</span> + msg.getClass());</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端地址&quot;</span> + ctx.channel().remoteAddress());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取到</span></span><br><span class="line">            <span class="type">HttpRequest</span> <span class="variable">httpRequest</span> <span class="operator">=</span> (HttpRequest) msg;</span><br><span class="line">            <span class="comment">//获取uri, 过滤指定的资源</span></span><br><span class="line">            <span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URI</span>(httpRequest.uri());</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;/favicon.ico&quot;</span>.equals(uri.getPath())) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;请求了 favicon.ico, 不做响应&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//回复信息给浏览器 [http协议]</span></span><br><span class="line"></span><br><span class="line">            <span class="type">ByteBuf</span> <span class="variable">content</span> <span class="operator">=</span> Unpooled.copiedBuffer(<span class="string">&quot;hello, 我是服务器&quot;</span>, CharsetUtil.UTF_8);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//构造一个http的相应，即 httpresponse</span></span><br><span class="line">            <span class="type">FullHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultFullHttpResponse</span>(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, content);</span><br><span class="line"></span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_TYPE, <span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_LENGTH, content.readableBytes());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将构建好 response返回</span></span><br><span class="line">            ctx.writeAndFlush(response);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ChannelPipeline的执行过程"><a href="#ChannelPipeline的执行过程" class="headerlink" title="ChannelPipeline的执行过程"></a>ChannelPipeline的执行过程</h1><p>​<code>Selector</code>轮询到网络IO事件了，则会调用该<code>Channel</code>对应的<code>ChannelPipeline</code>来依次执行对应的<code>ChannelHandler</code>。</p><p><img src="Netty%E8%AF%A6%E8%A7%A3%5C1.jpg"></p><p>​<code>ChannelHandler</code>在加入<code>ChannelPipline</code>之前会被封装成一个<code>ChannelHandlerContext</code>节点类加入到一个双向链表结构中。除了头尾两个特殊的<code>ChannelHandlerContext</code>实现类，我们自定义加入的<code>ChannelHandler</code>最终都会被封装成一个<code>DefaultChannelHandlerContext</code>类。</p><p><strong>执行流程：</strong></p><ol><li>NioEventLoop触发<strong>读事件</strong>，会调用SocketChannel所关联的ChannelPipline</li><li>由上一步读取到的消息会在<code>ChannelPipline</code>中依次被多个<code>ChannelHandler</code>处理</li><li>处理完消息会调用<code>ChannelHandlerContext</code>的<code>write</code>方法<strong>写事件</strong>发送消息，发送的消息同样也会经过<code>ChannelPipline</code>中的多个<code>ChannelHandler</code>处理</li></ol><p><strong>执行顺序：</strong></p><p>​当有读事件被触发时，<code>ChannelHandler</code>(会筛选类型为<code>ChannelInboundHandler</code>的Handler) 的触发顺序是 <code>HeaderContext</code> -&gt; <code>TailContext</code>。<br>​ 当有写事件被触发时，<code>ChannelHandler</code>(会筛选类型为<code>ChannelOutboundHandler</code>的Handler) 的触发顺序与读事件相反是 <code>TailContext</code> -&gt; <code>HeaderContext</code>。</p><h1 id="Netty-应用实例-群聊系统"><a href="#Netty-应用实例-群聊系统" class="headerlink" title="Netty 应用实例-群聊系统"></a>Netty 应用实例-群聊系统</h1><ol><li>编写一个 <code>Netty</code> 群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞）</li><li>实现多人群聊</li><li>服务器端：可以监测用户上线，离线，并实现消息转发功能</li><li>客户端：通过 <code>channel</code> 可以无阻塞发送消息给其它所有用户，同时可以接受其它用户发送的消息（有服务器转发得到）</li><li>目的：进一步理解 <code>Netty</code> 非阻塞网络编程机制</li></ol><p><strong>GroupChatServer</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupChatServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port; <span class="comment">//监听端口</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupChatServer</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写run方法，处理客户端的请求</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span>  Exception&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建两个线程组</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(); <span class="comment">//8个NioEventLoop</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line"></span><br><span class="line">            b.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//获取到pipeline</span></span><br><span class="line">                            <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">                            <span class="comment">//向pipeline加入解码器</span></span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;decoder&quot;</span>, <span class="keyword">new</span> <span class="title class_">StringDecoder</span>());</span><br><span class="line">                            <span class="comment">//向pipeline加入编码器</span></span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;encoder&quot;</span>, <span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">                            <span class="comment">//加入自己的业务处理handler</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">GroupChatServerHandler</span>());</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;netty 服务器启动&quot;</span>);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> b.bind(port).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//监听关闭</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">GroupChatServer</span>(<span class="number">7000</span>).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>GroupChatServerHandler</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.group.ChannelGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.group.DefaultChannelGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.concurrent.GlobalEventExecutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupChatServerHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这样写还要自己遍历Channel</span></span><br><span class="line">    <span class="comment">//public static List&lt;Channel&gt; channels = new ArrayList&lt;Channel&gt;();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用一个hashmap 管理私聊（私聊本案例并未实现，只是提供个思路）</span></span><br><span class="line">    <span class="comment">//public static Map&lt;String, Channel&gt; channels = new HashMap&lt;String,Channel&gt;();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个channle 组，管理所有的channel</span></span><br><span class="line">    <span class="comment">//GlobalEventExecutor.INSTANCE) 是全局的事件执行器，是一个单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ChannelGroup</span>  <span class="variable">channelGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultChannelGroup</span>(GlobalEventExecutor.INSTANCE);</span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//handlerAdded 表示连接建立，一旦连接，第一个被执行</span></span><br><span class="line">    <span class="comment">//将当前channel 加入到  channelGroup</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> ctx.channel();</span><br><span class="line">        <span class="comment">//将该客户加入聊天的信息推送给其它在线的客户端</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//该方法会将 channelGroup 中所有的channel 遍历，并发送消息，我们不需要自己遍历</span></span><br><span class="line"></span><br><span class="line">        channelGroup.writeAndFlush(<span class="string">&quot;[客户端]&quot;</span> + channel.remoteAddress() + <span class="string">&quot; 加入聊天&quot;</span> + sdf.format(<span class="keyword">new</span> <span class="title class_">java</span>.util.Date()) + <span class="string">&quot; \n&quot;</span>);</span><br><span class="line">        channelGroup.add(channel);</span><br><span class="line"></span><br><span class="line"><span class="comment">//私聊如何实现</span></span><br><span class="line"><span class="comment">//         channels.put（&quot;userid100&quot;,channel）;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//断开连接, 将xx客户离开信息推送给当前在线的客户</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> ctx.channel();</span><br><span class="line">        channelGroup.writeAndFlush(<span class="string">&quot;[客户端]&quot;</span> + channel.remoteAddress() + <span class="string">&quot; 离开了\n&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;channelGroup size&quot;</span> + channelGroup.size());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示channel 处于活动状态, 提示 xx上线</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//这个是给服务端看的，客户端上面已经提示xxx加入群聊了</span></span><br><span class="line">        System.out.println(ctx.channel().remoteAddress() + <span class="string">&quot; 上线了~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示channel 处于不活动状态, 提示 xx离线了</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(ctx.channel().remoteAddress() + <span class="string">&quot; 离线了~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取数据，转发给在线的每一个客户端</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取到当前channel</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> ctx.channel();</span><br><span class="line">        <span class="comment">//这时我们遍历channelGroup, 根据不同的情况，回送不同的消息</span></span><br><span class="line"></span><br><span class="line">        channelGroup.forEach(ch -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(channel != ch) &#123; <span class="comment">//不是当前的channel,转发消息</span></span><br><span class="line">                ch.writeAndFlush(<span class="string">&quot;[客户]&quot;</span> + channel.remoteAddress() + <span class="string">&quot; 发送了消息&quot;</span> + msg + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//回显自己发送的消息给自己</span></span><br><span class="line">                ch.writeAndFlush(<span class="string">&quot;[自己]发送了消息&quot;</span> + msg + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//关闭通道</span></span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>GroupChatClient</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupChatClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupChatClient</span><span class="params">(String host, <span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.host = host;</span><br><span class="line">        <span class="built_in">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">                .group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//得到pipeline</span></span><br><span class="line">                        <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">                        <span class="comment">//加入相关handler</span></span><br><span class="line">                        pipeline.addLast(<span class="string">&quot;decoder&quot;</span>, <span class="keyword">new</span> <span class="title class_">StringDecoder</span>());</span><br><span class="line">                        pipeline.addLast(<span class="string">&quot;encoder&quot;</span>, <span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">                        <span class="comment">//加入自定义的handler</span></span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> <span class="title class_">GroupChatClientHandler</span>());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(host, port).sync();</span><br><span class="line">        <span class="comment">//得到channel</span></span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> channelFuture.channel();</span><br><span class="line">            System.out.println(<span class="string">&quot;-------&quot;</span> + channel.localAddress()+ <span class="string">&quot;--------&quot;</span>);</span><br><span class="line">            <span class="comment">//客户端需要输入信息，创建一个扫描器</span></span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                <span class="comment">//通过channel 发送到服务器端</span></span><br><span class="line">                channel.writeAndFlush(msg + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">GroupChatClient</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">7000</span>).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>GroupChatClientHandler</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupChatClientHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从服务器拿到的数据</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(msg.trim());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Netty-心跳检测机制案例"><a href="#Netty-心跳检测机制案例" class="headerlink" title="Netty 心跳检测机制案例"></a>Netty 心跳检测机制案例</h1><ol><li>编写一个 <code>Netty</code> 心跳检测机制案例,当服务器超过 <code>3</code> 秒没有读时，就提示读空闲</li><li>当服务器超过 <code>5</code> 秒没有写操作时，就提示写空闲</li><li>实现当服务器超过 <code>7</code> 秒没有读或者写操作时，就提示读写空闲</li></ol><h3 id="MyServer"><a href="#MyServer" class="headerlink" title="MyServer"></a>MyServer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LogLevel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LoggingHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.timeout.IdleStateHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建两个线程组</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(); <span class="comment">//8个NioEventLoop</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line"></span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup);</span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">            <span class="comment">//在bossGroup增加一个日志处理器</span></span><br><span class="line">            serverBootstrap.handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO));</span><br><span class="line">            serverBootstrap.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">                    <span class="comment">//加入一个netty 提供 IdleStateHandler</span></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    说明</span></span><br><span class="line"><span class="comment">                    1. IdleStateHandler 是netty 提供的处理空闲状态的处理器</span></span><br><span class="line"><span class="comment">                    2. long readerIdleTime : 表示多长时间没有读, 就会发送一个心跳检测包检测是否连接</span></span><br><span class="line"><span class="comment">                    3. long writerIdleTime : 表示多长时间没有写, 就会发送一个心跳检测包检测是否连接</span></span><br><span class="line"><span class="comment">                    4. long allIdleTime : 表示多长时间没有读写, 就会发送一个心跳检测包检测是否连接</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                    5. 文档说明</span></span><br><span class="line"><span class="comment">                    triggers an &#123;@link IdleStateEvent&#125; when a &#123;@link Channel&#125; has not performed</span></span><br><span class="line"><span class="comment">                   read, write, or both operation for a while.</span></span><br><span class="line"><span class="comment">                    6. 当 IdleStateEvent 触发后 , 就会传递给管道 的下一个handler去处理，通过调用(触发)</span></span><br><span class="line"><span class="comment">                   下一个handler 的 userEventTiggered , 在该方法中去处理 IdleStateEvent(读空闲，写空闲，读写空闲)</span></span><br><span class="line"><span class="comment">                    7.handlerRemoved有时候是无法感知连接断掉，所以还是需要心跳包的检测来判断连接是否还有效</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>, TimeUnit.SECONDS));</span><br><span class="line">                    <span class="comment">//加入一个对空闲检测进一步处理的handler(自定义)</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">MyServerHandler</span>());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//启动服务器</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> serverBootstrap.bind(<span class="number">7000</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MyServerHandler"><a href="#MyServerHandler" class="headerlink" title="MyServerHandler"></a>MyServerHandler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.timeout.IdleStateEvent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServerHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx 上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evt 事件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将  evt 向下转型 IdleStateEvent</span></span><br><span class="line">            <span class="type">IdleStateEvent</span> <span class="variable">event</span> <span class="operator">=</span> (IdleStateEvent) evt;</span><br><span class="line">            <span class="type">String</span> <span class="variable">eventType</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">switch</span> (event.state()) &#123;</span><br><span class="line">                <span class="keyword">case</span> READER_IDLE:</span><br><span class="line">                  eventType = <span class="string">&quot;读空闲&quot;</span>;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> WRITER_IDLE:</span><br><span class="line">                    eventType = <span class="string">&quot;写空闲&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ALL_IDLE:</span><br><span class="line">                    eventType = <span class="string">&quot;读写空闲&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(ctx.channel().remoteAddress() + <span class="string">&quot;--超时时间--&quot;</span> + eventType);</span><br><span class="line">            System.out.println(<span class="string">&quot;服务器做相应处理..&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果发生空闲，我们关闭通道</span></span><br><span class="line">           <span class="comment">// ctx.channel().close();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Netty通过WebSocket实现服务器和客户端长连接"><a href="#Netty通过WebSocket实现服务器和客户端长连接" class="headerlink" title="Netty通过WebSocket实现服务器和客户端长连接"></a>Netty通过WebSocket实现服务器和客户端长连接</h1><p><code>Http</code>是无状态的，浏览器每次请求，都是创建一个新连接，传输完毕即断开。双方并不能感知对方的状态。<br> 而<code>WebSocket</code>是长连接，一次<code>TCP</code>握手，即可建立持久性的连接，并且双方能感知到对方的状态。</p><h3 id="MyServer-1"><a href="#MyServer-1" class="headerlink" title="MyServer"></a>MyServer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.atguigu.netty.heartbeat.MyServerHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpObjectAggregator;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpServerCodec;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LogLevel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LoggingHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.stream.ChunkedWriteHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.timeout.IdleStateHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建两个线程组</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(); <span class="comment">//8个NioEventLoop</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line"></span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup);</span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">            serverBootstrap.handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO));</span><br><span class="line">            serverBootstrap.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//因为基于http协议，使用http的编码和解码器</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">HttpServerCodec</span>());</span><br><span class="line">                    <span class="comment">//http是以块方式写，添加ChunkedWriteHandler处理器</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">ChunkedWriteHandler</span>());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    说明</span></span><br><span class="line"><span class="comment">                    1. http数据在传输过程中是分段, HttpObjectAggregator ，就是可以将多个段聚合</span></span><br><span class="line"><span class="comment">                    2. 这就就是为什么，当浏览器发送大量数据时，就会发出多次http请求</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">HttpObjectAggregator</span>(<span class="number">8192</span>));<span class="comment">//这里将多个段聚合起来，最大长度8192</span></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    说明</span></span><br><span class="line"><span class="comment">                    1. 对应websocket ，它的数据是以 帧(frame) 形式传递</span></span><br><span class="line"><span class="comment">                    2. 可以看到WebSocketFrame 下面有六个子类</span></span><br><span class="line"><span class="comment">                    3. 浏览器请求时 ws://localhost:7000/hello 表示请求的uri</span></span><br><span class="line"><span class="comment">                    4. WebSocketServerProtocolHandler 核心功能是将 http协议升级为 ws协议 , 保持长连接，是通过一个 状态码 101</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">WebSocketServerProtocolHandler</span>(<span class="string">&quot;/hello&quot;</span>));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//自定义的handler ，处理业务逻辑</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">MyTextWebSocketFrameHandler</span>());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//启动服务器</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> serverBootstrap.bind(<span class="number">7000</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id><a href="#" class="headerlink" title></a></h3><h3 id="MyTextWebSocketFrameHandler"><a href="#MyTextWebSocketFrameHandler" class="headerlink" title="MyTextWebSocketFrameHandler"></a>MyTextWebSocketFrameHandler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.websocketx.TextWebSocketFrame;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里 TextWebSocketFrame 类型，表示一个文本帧(frame)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTextWebSocketFrameHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;TextWebSocketFrame&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;服务器收到消息 &quot;</span> + msg.text());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//回复消息</span></span><br><span class="line">        ctx.channel().writeAndFlush(<span class="keyword">new</span> <span class="title class_">TextWebSocketFrame</span>(<span class="string">&quot;服务器时间&quot;</span> + LocalDateTime.now() + <span class="string">&quot; &quot;</span> + msg.text()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当web客户端连接后， 触发方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//id 表示唯一的值，LongText 是唯一的 ShortText 不是唯一</span></span><br><span class="line">        System.out.println(<span class="string">&quot;handlerAdded 被调用&quot;</span> + ctx.channel().id().asLongText());</span><br><span class="line">        System.out.println(<span class="string">&quot;handlerAdded 被调用&quot;</span> + ctx.channel().id().asShortText());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;handlerRemoved 被调用&quot;</span> + ctx.channel().id().asLongText());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异常发生 &quot;</span> + cause.getMessage());</span><br><span class="line">        ctx.close(); <span class="comment">//关闭连接</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="-1"><a href="#-1" class="headerlink" title></a></h3><h3 id="hello-html"><a href="#hello-html" class="headerlink" title="hello.html"></a>hello.html</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> socket;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//判断当前浏览器是否支持websocket</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span>(<span class="variable language_">window</span>.<span class="property">WebSocket</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//go on</span></span></span><br><span class="line"><span class="language-javascript">        socket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://localhost:7000/hello2&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//相当于channelReado, ev 收到服务器端回送的消息</span></span></span><br><span class="line"><span class="language-javascript">        socket.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">ev</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> rt = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;responseText&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            rt.<span class="property">value</span> = rt.<span class="property">value</span> + <span class="string">&quot;\n&quot;</span> + ev.<span class="property">data</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//相当于连接开启(感知到连接开启)</span></span></span><br><span class="line"><span class="language-javascript">        socket.<span class="property">onopen</span> = <span class="keyword">function</span> (<span class="params">ev</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> rt = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;responseText&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            rt.<span class="property">value</span> = <span class="string">&quot;连接开启了..&quot;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//相当于连接关闭(感知到连接关闭)</span></span></span><br><span class="line"><span class="language-javascript">        socket.<span class="property">onclose</span> = <span class="keyword">function</span> (<span class="params">ev</span>) &#123;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> rt = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;responseText&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            rt.<span class="property">value</span> = rt.<span class="property">value</span> + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;连接关闭了..&quot;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&quot;当前浏览器不支持websocket&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//发送消息到服务器</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">send</span>(<span class="params">message</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(!<span class="variable language_">window</span>.<span class="property">socket</span>) &#123; <span class="comment">//先判断socket是否创建好</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(socket.<span class="property">readyState</span> == <span class="title class_">WebSocket</span>.<span class="property">OPEN</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//通过socket 发送消息</span></span></span><br><span class="line"><span class="language-javascript">            socket.<span class="title function_">send</span>(message)</span></span><br><span class="line"><span class="language-javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&quot;连接没有开启&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">onsubmit</span>=<span class="string">&quot;return false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;message&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height: 300px; width: 300px&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;发生消息&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;send(this.form.message.value)&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">&quot;responseText&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height: 300px; width: 300px&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;清空内容&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;document.getElementById(&#x27;responseText&#x27;).value=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/youthlql/JavaYouth/blob/main/docs/netty/Netty%E5%85%A5%E9%97%A8-%E7%AC%AC%E4%BA%8C%E8%AF%9D.md#future-%E8%AF%B4%E6%98%8E">参考</a></p>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty详解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaIO与零拷贝</title>
      <link href="/2022/12/12/JavaIO%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/"/>
      <url>/2022/12/12/JavaIO%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<h1 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h1><h2 id="零拷贝定义："><a href="#零拷贝定义：" class="headerlink" title="零拷贝定义："></a>零拷贝定义：</h2><p>​零拷贝是指计算机执行IO操作时，CPU不需要将数据从一个存储区域复制到另一个存储区域，从而可以减少上下文切换以及CPU的拷贝时间。它是一种<code>I/O</code>操作优化技术。</p><h2 id="虚拟内存与物理内存"><a href="#虚拟内存与物理内存" class="headerlink" title="虚拟内存与物理内存"></a>虚拟内存与物理内存</h2><p>​操作系统为每个进程分配了独立的虚拟地址空间，也就是虚拟内存，<strong>虚拟地址空间又分为用户空间和内核空间</strong>，操作系统的位数不同，虚拟地址空间的大小也不同，32位操作系统虚拟地址内核空间为1G(2的32次方)，用户空间大小为3G，64位操作系统用户空间和内核空间大小各为128T：</p><span id="more"></span><ul><li>虚拟内存空间可以远远大于物理内存空间</li><li>多个虚拟内存可以指向同一个物理地址</li></ul><p>正是多个虚拟内存可以指向同一个物理地址，可以把内核空间和用户空间的虚拟地址映射到同一个物理地址，这样的话，就可以减少IO的数据拷贝次数啦，如mmap内存映射方式</p><h2 id="内核空间与用户空间"><a href="#内核空间与用户空间" class="headerlink" title="内核空间与用户空间"></a>内核空间与用户空间</h2><p><strong>用户空间：</strong>是运行用户程序代码的地方，为了保证系统内核的安全，它不能直接访问内存等硬件设备，必须通过系统调用进入到内核空间来访问那些受限的资源。</p><p><strong>内核空间：</strong>是运行内核代码的地方，可以执行任意的指令访问系统资源，既可以访问内核空间也可以访问用户空间。</p><h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p><strong>上下文</strong> CPU 寄存器，是CPU内置的，容量小、但速度极快的内存。而程序计数器，则是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。它们都是 CPU 在运行任何任务前，必须的依赖环境，因此叫做CPU上下文。</p><p><strong>上下文切换</strong> 先把前一个任务的CPU上下文（也就是CPU寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。一般我们说的上下文切换，就是指内核（操作系统的核心）在CPU上对进程或者线程进行切换。进程从<strong>用户态到内核态的转变</strong>，需要通过系统调用来完成。系统调用的过程，会发生CPU上下文的切换。</p><h2 id="普通的文件缓存I-x2F-O"><a href="#普通的文件缓存I-x2F-O" class="headerlink" title="普通的文件缓存I&#x2F;O"></a>普通的文件缓存I&#x2F;O</h2><p>​因为磁盘I&#x2F;O是比较耗时的操作,每次读文件的时候不能总是去磁盘中读，可以增加一层内核空间内存Page Cache，用于缓存读取的文件数据，用户空间进行系统调用读取文件内容时，首先会判断Page Cache中是否缓存了文件的内容，如果缓存了直接读取即可，否则再从磁盘读取。</p><p>读取过程如下：</p><ol><li>应用程序调用read函数发起系统调用，此时由用户空间切换到内核空间;</li><li>内核通过DMA从磁盘拷贝数据到内核缓冲区（DMA复制，CPU耗时很少）;</li><li>将内核缓冲区的数据拷贝到用户空间的缓冲区（CPU复制），切换回用户空间;</li></ol><p><img src="1.jpg"></p><h2 id="JVM的堆内内存与堆外内存"><a href="#JVM的堆内内存与堆外内存" class="headerlink" title="JVM的堆内内存与堆外内存"></a>JVM的堆内内存与堆外内存</h2><p>​在JAVA中，JVM划分了堆内存，平时创建的对象基本都在堆中，不过也可以通过NIO包下的<code>ByteBuffer</code>申请堆外内存<code>DirectByteBuffer</code>:也就是在堆内放了块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer.allocateDirect(size);</span><br></pre></td></tr></table></figure><p>​无论是普通IO或者是NIO，在进行文件读写的时候一般都会创建一个buffer作为数据的缓冲区，读写相关方法底层是通过调用native函数（JNI调用）来实现的，在进行读写时将buffer传递给JNI。<br>​ JNI一般使用C&#x2F;C++代码实现，JNI底层调用C函数库时，要求buffer所在内存地址上的内容不能失效，但是<strong>JVM在进行垃圾回收的时候有可能对对象进行移动</strong>，导致地址发生变化，所以通过NIO进行文件读取的时候，从源码中可以明显看到对buffer的对象类型进行了判断，如果buffer是<code>DirectByteBuffer</code>类型，使用的是堆外内存，直接使用即可，反之则认为使用的是堆内内存，此时需要先申请一块堆外内存作为堆外内存buffer，然后进行系统调用，进行数据读取，读取完毕后将堆外内存buffer的内容再拷回JVM堆内内存buffer中。</p><p><img src="2.jpg"></p><p>详细过程：</p><ol><li>发起JNI调用，创建堆外缓冲区；</li><li>JNI中发起read系统调用，此时需要由用户空间切换到内核空间；</li><li>进入到内核空间，DMA读取文件数据到内核缓冲区；</li><li>将内核缓冲区的数据拷贝到用户缓冲区，切换回用户空间；</li><li>将堆外缓冲区的数据拷贝到JVM堆内缓冲区中；</li></ol><p>实际中发生了三次拷贝。其中DMA一次，CPU两次</p><h2 id="内存映射原理（mmap）"><a href="#内存映射原理（mmap）" class="headerlink" title="内存映射原理（mmap）"></a>内存映射原理（mmap）</h2><p>​内存映射就是将<strong>内核空间和用户空间的虚拟地址</strong>映射到物理空间地址，每个进程维护了一张页表，记录<strong>虚拟地址和物理地址之间的映射关系</strong>，当进程访问的虚拟地址在页表中无法查到映射关系时，系统产生缺页异常，<strong>进入内核空间为虚拟地址分配物理内存</strong>，并更新页表，记录映射关系。</p><p><img src="3.jpg"></p><ol><li>进行mmap系统调用，将文件和虚拟地址空间建立映射，注意此时还没有分配物理内存空间，只是在逻辑上建立了虚拟地址和文件之间的映射关系，物理内存只有真正使用的时候才会分配。</li><li>应用程序访问用户空间虚拟内存中的某个地址，发现无法在页表中查到数据，产生缺页异常，此时进入内核空间</li><li><strong>因为不能直接使用物理地址，所以需要使用内核的虚拟地址临时建立与物理内存的映射关系，将文件内容读取到物理内存中，待数据读取完毕之后取消临时映射即可。</strong></li><li>缺页异常处理完毕，物理内存中已经加载了文件的数据，此时用户空间就可以通过虚拟地址直接访问物理内存中映射的文件数据。</li></ol><p>从内存映射整个过程看，与缓存I&#x2F;O相比，少了从内核缓冲区将数据拷贝到用户缓冲区的步骤，减少了一次拷贝。</p><h2 id="传统服务端文件下载IO执行流程"><a href="#传统服务端文件下载IO执行流程" class="headerlink" title="传统服务端文件下载IO执行流程"></a>传统服务端文件下载IO执行流程</h2><p>接收前端请求将服务daunt主机磁盘中的文件从已连接的socket发出去，实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>((n = read(diskfd, buf, BUF_SIZE)) &amp;gt; <span class="number">0</span>)</span><br><span class="line">    write(sockfd, buf , n);</span><br></pre></td></tr></table></figure><p>传统的IO流程，包括read和write的过程。</p><ul><li><code>read</code>：把数据从磁盘读取到内核缓冲区，再拷贝到用户缓冲区</li><li><code>write</code>：先把数据写入到socket缓冲区，最后写入网卡设备。</li></ul><p><img src="4.jpg"></p><p>j具体实现流程：</p><ul><li>用户应用进程调用read函数，向操作系统发起IO调用， 上下文从用户态转为内核态（切换1）</li><li>DMA控制器把数据从磁盘中，读取到内核缓冲区。</li><li>CPU把内核缓冲区数据，拷贝到用户应用缓冲区， 上下文从内核态转为用户态（切换2），read函数返回</li><li>用户应用进程通过write函数，发起IO调用， 上下文从用户态转为内核态（切换3）</li><li>CPU将用户缓冲区中的数据，拷贝到socket缓冲区</li><li>DMA控制器把数据从socket缓冲区，拷贝到网卡设备， 上下文从内核态切换回用户态（切换4），write函数返回</li></ul><p>从流程图可以看出，传统IO的读写流程，包括了4次上下文切换（4次用户态和内核态的切换），4次数据拷贝（两次CPU拷贝以及两次的DMA拷贝)，</p><h2 id="零拷贝实现方式"><a href="#零拷贝实现方式" class="headerlink" title="零拷贝实现方式"></a>零拷贝实现方式</h2><p>首先零拷贝并不是没有拷贝数据，而是减少用户态&#x2F;内核态的切换次数以及CPU拷贝的次数。零拷贝实现有多种方式，分别是</p><ul><li>mmap</li><li>sendfile</li><li>带有DMA收集拷贝功能的sendfile</li></ul><h3 id="mmap实现的零拷贝"><a href="#mmap实现的零拷贝" class="headerlink" title="mmap实现的零拷贝"></a>mmap实现的零拷贝</h3><p>​mmap实现零拷贝是基于虚拟内存原理，即把内核空间和用户空间的虚拟地址映射到同一个物理地址，节省一次将内核缓存区数据拷贝到用户空间。</p><p><img src="5.jpg"></p><ul><li>用户进程通过 <code>mmap方法</code>向操作系统内核发起IO调用， 上下文从用户态切换为内核态。</li><li>CPU利用DMA控制器，把数据从硬盘中拷贝到内核缓冲区，这里用户空间就可以访问到数据。</li><li>上下文从内核态切换回用户态，mmap方法返回。</li><li>用户进程通过 <code>write</code>方法向操作系统内核发起IO调用， 上下文从用户态切换为内核态。</li><li>CPU将内核缓冲区的数据拷贝到的socket缓冲区。</li><li>CPU利用DMA控制器，把数据从socket缓冲区拷贝到网卡， 上下文从内核态切换回用户态，write调用返回。</li></ul><p>可以发现，<code>mmap</code>实现的零拷贝，I&#x2F;O发生了4次用户空间与内核空间的上下文切换，以及3次数据拷贝。其中3次数据拷贝中，包括了2次DMA拷贝和1次CPU拷贝。</p><p><code>mmap</code>是将读缓冲区的地址和用户缓冲区的地址进行映射，内核缓冲区和应用缓冲区共享，所以节省了一次CPU拷贝‘’并且用户进程内存是虚拟的，只是映射到内核的读缓冲区，可以<strong>节省一半的内存空间</strong>。</p><h3 id="sendfile实现的零拷贝"><a href="#sendfile实现的零拷贝" class="headerlink" title="sendfile实现的零拷贝"></a>sendfile实现的零拷贝</h3><p><code>sendfile</code>是Linux2.1内核版本后引入的一个系统调用函数，API如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);</span><br></pre></td></tr></table></figure><ul><li>out_fd:为待写入内容的文件描述符（文件描述符就是内核为了高效管理已被打开的文件所创建的索引，用来指向被打开的文件），一个socket描述符。，</li><li>in_fd:为待读出内容的文件描述符，必须是真实的文件，不能是socket和管道。</li><li>offset：指定从读入文件的哪个位置开始读，如果为NULL，表示文件的默认起始位置。</li><li>count：指定在fdout和fdin之间传输的字节数。</li></ul><p>​sendfile表示在两个文件描述符之间传输数据，它是在操作系统内核中操作的，<strong>避免了数据从内核缓冲区和用户缓冲区之间的拷贝操作</strong>，因此可以使用它来实现零拷贝。</p><p><img src="6.jpg"></p><h3 id="sendfile-gather实现的零拷贝"><a href="#sendfile-gather实现的零拷贝" class="headerlink" title="sendfile+gather实现的零拷贝"></a>sendfile+gather实现的零拷贝</h3><p>linux 2.4版本之后，对<code>sendfile</code>做了优化升级，引入SG-DMA技术，其实就是对DMA拷贝加入了<code>scatter/gather</code>操作，它可以直接从内核空间缓冲区中将数据读取到网卡。使用这个特点，即还可以多省去一次CPU拷贝。</p><p><img src="7.jpg"></p><p>详细流程：</p><ul><li>用户进程发起sendfile系统调用， 上下文（切换1）从用户态转向内核态</li><li>DMA控制器，把数据从硬盘中拷贝到内核缓冲区。</li><li>CPU把内核缓冲区中的 文件描述符信息（包括内核缓冲区的内存地址和偏移量）发送到socket缓冲区</li><li>DMA控制器根据文件描述符信息，直接把数据从内核缓冲区拷贝到网卡</li><li>上下文（切换2）从内核态切换回用户态，sendfile调用返回。</li></ul><p>可以发现，<code>sendfile+DMA scatter/gather</code>实现的零拷贝，I&#x2F;O发生了2次用户空间与内核空间的上下文切换，以及2次数据拷贝。其中2次数据拷贝都是包DMA拷贝。这<strong>就是真正的 零拷贝（Zero-copy) 技术，全程都没有通过CPU来搬运数据，所有的数据都是通过DMA来进行传输的</strong>。</p><h2 id="java提供的零拷贝方式"><a href="#java提供的零拷贝方式" class="headerlink" title="java提供的零拷贝方式"></a>java提供的零拷贝方式</h2><ul><li>Java NIO对mmap的支持</li><li>Java NIO对sendfile的支持</li></ul><h3 id="Java-NIO对mmap的支持"><a href="#Java-NIO对mmap的支持" class="headerlink" title="Java NIO对mmap的支持"></a>Java NIO对mmap的支持</h3><p><strong>MappedByteBuffer</strong>：Java NIO有一个<code>MappedByteBuffer</code>的类，可以用来实现内存映射。它的底层是调用了Linux内核的mmap的API。</p><p>使用<code>MappedByteBuffer</code>向网络中发送数据的过程如下：</p><ol><li>使用MappedByteBuffer建立文件映射，用户空间可以通过虚拟地址直接访问映射的文件数据；</li><li>将映射的文件数据拷贝到socket网络缓冲区（CPU复制）；</li><li>DMA将socket缓冲区的数据拷贝到网卡（DMA复制）；</li></ol><p><img src="8.jpg"></p><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MmapTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">readChannel</span> <span class="operator">=</span> FileChannel.open(Paths.get(<span class="string">&quot;./jay.txt&quot;</span>), StandardOpenOption.READ);</span><br><span class="line">            <span class="type">MappedByteBuffer</span> <span class="variable">data</span> <span class="operator">=</span> readChannel.map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">40</span>);</span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">writeChannel</span> <span class="operator">=</span> FileChannel.open(Paths.get(<span class="string">&quot;./siting.txt&quot;</span>), StandardOpenOption.WRITE, StandardOpenOption.CREATE);</span><br><span class="line">            <span class="comment">//数据传输</span></span><br><span class="line">            writeChannel.write(data);</span><br><span class="line">            readChannel.close();</span><br><span class="line">            writeChannel.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java-NIO对sendfile的支持（真正的零拷贝）"><a href="#Java-NIO对sendfile的支持（真正的零拷贝）" class="headerlink" title="Java NIO对sendfile的支持（真正的零拷贝）"></a>Java NIO对sendfile的支持（真正的零拷贝）</h3><p>FileChannel的<code>transferTo()/transferFrom()</code>，底层就是sendfile() 系统调用函数。<strong>Kafka 这个开源项目就用到它</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">transferFrom</span><span class="params">(FileChannel fileChannel, <span class="type">long</span> position, <span class="type">long</span> count)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   <span class="keyword">return</span> fileChannel.transferTo(position, count, socketChannel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendFileTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">readChannel</span> <span class="operator">=</span> FileChannel.open(Paths.get(<span class="string">&quot;./jay.txt&quot;</span>), StandardOpenOption.READ);</span><br><span class="line">            <span class="type">long</span> <span class="variable">len</span> <span class="operator">=</span> readChannel.size();</span><br><span class="line">            <span class="type">long</span> <span class="variable">position</span> <span class="operator">=</span> readChannel.position();</span><br><span class="line">            </span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">writeChannel</span> <span class="operator">=</span> FileChannel.open(Paths.get(<span class="string">&quot;./siting.txt&quot;</span>), StandardOpenOption.WRITE, StandardOpenOption.CREATE);</span><br><span class="line">            <span class="comment">//sendfile方式的数据传输 真正的零拷贝，即不需要CPU进行数据的复制</span></span><br><span class="line">            readChannel.transferTo(position, len, writeChannel);</span><br><span class="line">            readChannel.close();</span><br><span class="line">            writeChannel.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaIO与零拷贝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaIO详解</title>
      <link href="/2022/11/20/JavaIO%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/11/20/JavaIO%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-IO详解"><a href="#Java-IO详解" class="headerlink" title="Java IO详解"></a>Java IO详解</h1><h2 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h2><h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><ul><li>同步：是应用程序要直接参与 IO 读写的操作。同步方式在处理 IO 事件的时候，必须阻塞在某个方法上面等待我们的 IO 事件完成(阻塞 IO 事件或者通过轮询 IO事件的方式)</li><li>异步：所有的 IO 读写交给操作系统去处理，应用程序只需要等待通知。所有的 IO 读写都交给了操作系统。这个时候，我们可以去做其他的事情，并不需要去完成真正的 IO 操作，当操作完成 IO 后，会给我们的应用程序一个通知。</li></ul><h3 id="阻塞与非阻塞："><a href="#阻塞与非阻塞：" class="headerlink" title="阻塞与非阻塞："></a>阻塞与非阻塞：</h3><ul><li>阻塞：Java BIO 的各种流是阻塞的。这意味着，当一个线程调用 read() 或 write()时，<strong>该线程被阻塞</strong>，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。</li><li>非阻塞：Java NIO 的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。<strong>而不是保持线程阻塞</strong>， 所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将<strong>非阻塞 IO 的空闲时间用于在其它通道上执行 IO 操作</strong>，所以一个单独的线程现在可以管理多个输入和输出通道（channel）</li></ul><span id="more"></span><h3 id="面向流与面向缓冲区"><a href="#面向流与面向缓冲区" class="headerlink" title="面向流与面向缓冲区"></a>面向流与面向缓冲区</h3><ul><li>面向流:Java BIO 面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。</li><li>Java NIO  的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有你需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</li></ul><h3 id="字节流与字符流"><a href="#字节流与字符流" class="headerlink" title="字节流与字符流"></a>字节流与字符流</h3><ul><li>字节流：字节流在操作时本身不会用到缓冲区，是文件本身直接操作的。字节流以字节（8bit）为单位。</li><li>字符流：而字符流在操作时使用了缓冲区，通过缓冲区再操作文件。字符流以字符为单位。</li></ul><p>字节流可以处理任何类型的数据，如图片、avi等，而字符流只能处理字符类型的数据</p><p><img src="1.jpg"></p><p><a href="https://zhuanlan.zhihu.com/p/25418336">图片来源</a></p><h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><p>同步阻塞io：进程系统调用获取数据后，没有等到数据，则陷入阻塞状态。等到IO获取数据后，进程才就绪状态，经典模式为Acceptor模式：即每当一个client线程访问，服务器创建一个线程来回答。可以采用线程池进行优化。</p><p>每个客户端的Socket连接请求，服务端都会对应有个处理线程与之对应，对于没有分配到处理线程的连接就会被阻塞或者拒绝。相当于是一个连接一个线程。</p><p><img src="2.jpg"></p><p><strong>特点：</strong></p><ol><li>使用一个独立的线程维护一个socket连接，随着连接数量的增多，对虚拟机造成一定压力。</li><li>使用流来读取数据，流是阻塞的，当没有可读／可写数据时，线程等待，会造成资源的浪费。</li></ol><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>同步非阻塞多路复用io.：非阻塞的延伸，进程和IO进程不再是一对一而是一对多的关系，会一次性循环，不再创建线程去IO，而是需要是发出请求给acceptor，acceptor不断去轮询多个 socket 的状态，只有当 socket 真正有读写事件时，才真正<strong>调用实际的 IO 读写操作</strong>。因为在多路复用 IO 模型中，只需要使用一个线程就可以管理多个 socket，系统不需要建立新的进程或者线程，并且只有在真正有 socket 读写事件进行时，才会使用 IO 资源，所以它大大减少了资源占用率（select,poll,epoll）</p><p>(1)select&#x3D;&#x3D;&gt;时间复杂度O(n)<br>返回的是所有存放socket标志位fd_set的数据结构，实际上是一个long类型的数组。<br>它仅仅知道了，有I&#x2F;O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流</p><p>缺点：</p><ul><li>select只能监控1024个连接</li><li>select 不是线程安全的，如果你把一个socket加入到select, 然后突然另外一个线程发现这个socket不用，要收回，这个select 不支持的。</li><li>每次调用select，都需要把fd_set集合从用户态拷贝到内核态，如果fd_set集合很大时，那这个开销也很大。</li></ul><p>(2)poll&#x3D;&#x3D;&gt;时间复杂度O(n)<br>没有最大连接数的限制，原因是它是基于链表来存储的.<br>(3)epoll&#x3D;&#x3D;&gt;时间复杂度O(1)<br>返回的是具体某个handler标识</p><p>把原先的select&#x2F;poll调用分成了3个部分：</p><ol><li>调用epoll_create()建立一个epoll对象(在epoll文件系统中为这个句柄对象分配资源)</li><li>调用epoll_ctl向epoll对象中添加这100万个连接的套接字</li><li>调用epoll_wait收集发生的事件的连接</li></ol><p><strong>epoll支持的最大连接数是进程最大可打开的文件的数目</strong></p><p>空闲的Socket调用回调函数，会把哪个流发生了怎样的I&#x2F;O事件通知我们。所以我们说epoll实际上是事件驱动（每个事件关联上fd（文件描述符））的，此时我们对这些流的操作都是有意义的。（复杂度降低到了O(1)）<br><img src="3.png"></p><p>详细的<a href="https://blog.csdn.net/qq_41563912/article/details/120139213">多路复用底层原理</a></p><p><strong>NIO 主要有:Channel(通道)，Buffer(缓冲区), Selector。</strong></p><ol><li>selector：Selector 允许单线程处理多个Channel。如果你的应用打开了多个连接（通道），但每个连接的流量都很低，使用Selector就会很方便。要使用Selector，得向Selector注册Channel，然后调用他的select方法，这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子如有新连接接进来，数据接收等。</li><li>Channel：基本上所有的IO在NIO中都从一个Channel开始。Channel有点像流，只不过 Stream 是单向的而 Channel 是双向 的，既可以用来进行读操作，又可以用来进行写操作。面向缓冲区。数据可以从channel读到buffer，也可以从buffer写到channel。</li><li>Buffer：缓冲区本质上是一个可以读写数据的内存块，可以理解成是一个容器对象(含数组)，该对象提供了一组方法，可以更轻松的使用内存块，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变换情况，Channel提供从文件，网络读取数据的渠道，但是读取或者写入的数据都必须经由Buffer。</li></ol><p><img src="4.png"></p><p>每个线程中包含一个Selector对象，它相当于一个通道管理器，可以实现在一个线程中处理多个通道的目的，减少线程的创建数量。</p><p>远程连接对应一个channel，数据的读写通过buffer均在同一个channel中完成，并且数据的读写是非阻塞的。</p><p>通道创建后需要注册在selector中，同时需要为该通道注册感兴趣事件（客户端连接服务端事件、服务端接收客户端连接事件、读事件、写事件），selector线程需要采用轮训的方式调用selector的select函数，直到所有注册通道中有兴趣的事件发生，则返回，否则一直阻塞。</p><h2 id="NIO使用举例"><a href="#NIO使用举例" class="headerlink" title="NIO使用举例"></a>NIO使用举例</h2><h3 id="Java-io-包下需要掌握的流有16个"><a href="#Java-io-包下需要掌握的流有16个" class="headerlink" title="Java.io 包下需要掌握的流有16个:"></a>Java.io 包下需要掌握的流有16个:</h3><p>文件专属<br>java.io.FileinputStream   (用得最多)<br>java.io.FileOutputStream  (用得最多)<br>java.io.FileReader<br>java.io.FileWriter</p><p>转换流:(将字节流转换成字符流)<br>java.io.InputStreamReader<br>java.io.outputStreamWriter</p><p>缓冲流专属:<br>java.io.BufferedReader<br>java.io.BufferedWriter<br>java.io.BufferedInputStream<br>java.io.BufferedOutputStream</p><p>数据流专属:<br>java.io.DataInpoutStream<br>java.io.DataOutputStream</p><p>标准输出流:<br>java.io.PrintWriter<br>java.io.PrintStream</p><p>对象专属流:<br>java.io.ObjectInputStream<br>java.io.ObjectOutputStream</p><p>1）使用NIO读取数据<br>在前面我们说过，任何时候读取数据，都不是直接从通道读取，而是从通道读取到缓冲区。所以使用NIO读取数据可以分为下面三个步骤：<br>FileInputStream fin &#x3D; new FileInputStream(“c:\test.txt”);<br>从FileInputStream获取Channel ——FileChannel fc &#x3D; fin.getChannel();<br>创建Buffer ——ByteBuffer buffer &#x3D; ByteBuffer.allocate(1024);<br>文本将数据从Channel写入到Buffer中——fc.read(buffer);<br>用户从Buffer中直接读数据——byte b &#x3D; buffer.get();</p><p>2）使用NIO写入数据<br>FileOutputStream fout &#x3D; new FileOutputStream( “e:\test.txt” );<br>从FileOutputStream获取Channel——FileChannel fc &#x3D; fout.getChannel();<br>创建Buffer—— ByteBuffer buffer &#x3D; ByteBuffer.allocate( 1024 );<br>用户将数据直接写入Buffer——buffer.put( message[i] );<br>文本从Channel中读入Buffer数据—— fc.write( buffer );<br>综上所述，用户都是直接与Buffer接触。而文本才利用channel与Buffer接触</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="NIO-非阻塞网络编程过程"><a href="#NIO-非阻塞网络编程过程" class="headerlink" title="NIO 非阻塞网络编程过程"></a>NIO 非阻塞网络编程过程</h4><ol><li>当客户端连接时，会通过 <code>ServerSocketChannel</code> 得到 <code>SocketChannel</code>。</li><li><code>Selector</code> 进行监听 <code>select</code> 方法，返回有事件发生的通道的个数。</li><li>将 <code>socketChannel</code> 注册到 <code>Selector</code> 上，<code>register(Selector sel, int ops)</code>，一个 <code>Selector</code> 上可以注册多个 <code>SocketChannel</code>。</li><li>注册后返回一个 <code>SelectionKey</code>，会和该 <code>Selector</code> 关联（集合）。</li><li>进一步得到各个 <code>SelectionKey</code>（有事件发生）。</li><li>在通过 <code>SelectionKey</code> 反向获取 <code>SocketChannel</code>，方法 <code>channel()</code>。</li><li>可以通过得到的 <code>channel</code>，完成业务处理。</li></ol><p><strong>SelectionKey</strong></p><ol><li><code>SelectionKey</code>，表示 <code>Selector</code> 和网络通道的注册关系，共四种：</li></ol><ul><li><code>int OP_ACCEPT</code>：有新的网络连接可以 <code>accept</code>，值为 <code>16</code></li><li><code>int OP_CONNECT</code>：代表连接已经建立，值为 <code>8</code></li><li><code>int OP_READ</code>：代表读操作，值为 <code>1</code></li><li><code>int OP_WRITE</code>：代表写操作，值为 <code>4</code></li></ul><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SelectionKey</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Selector <span class="title function_">selector</span><span class="params">()</span>;<span class="comment">//得到与之关联的Selector对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> SelectableChannel <span class="title function_">channel</span><span class="params">()</span>;<span class="comment">//得到与之关联的通道</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">attachment</span><span class="params">()</span>;<span class="comment">//得到与之关联的共享数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> SelectionKey <span class="title function_">interestOps</span><span class="params">(<span class="type">int</span> ops)</span>;<span class="comment">//设置或改变监听事件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isAcceptable</span><span class="params">()</span>;<span class="comment">//是否可以accept</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isReadable</span><span class="params">()</span>;<span class="comment">//是否可以读</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isWritable</span><span class="params">()</span>;<span class="comment">//是否可以写</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端建立连接之前监听的是一个Accept通道这个通道的作用就是监听是否有客户端要建立链接，实际建立连接了还会有一个客户端真正通信的通道。如果有其它客户端还想要建立链接，这个Accept监听端口监听到了，就会再创建几个真正的通信通道。也就是Server的一个端口可以建立多个TCP连接，因为IP层协议通过目标地址+端口+源地址+源端口四个信息识别一个上下文。</p><h4 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h4><p><code>ServerSocketChannel</code> 在服务器端监听新的客户端 <code>Socket</code> 连接，负责监听，不负责实际的读写操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ServerSocketChannel</span> <span class="keyword">extends</span> <span class="title class_">AbstractSelectableChannel</span> <span class="keyword">implements</span> <span class="title class_">NetworkChannel</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ServerSocketChannel <span class="title function_">open</span><span class="params">()</span><span class="comment">//得到一个ServerSocketChannel通道</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ServerSocketChannel <span class="title function_">bind</span><span class="params">(SocketAddress local)</span><span class="comment">//设置服务器端端口号</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> SelectableChannel <span class="title function_">configureBlocking</span><span class="params">(<span class="type">boolean</span> block)</span><span class="comment">//设置阻塞或排非阻塞模式,取值false表示采用非阻塞模式</span></span><br><span class="line">    <span class="keyword">public</span> SocketChannel <span class="title function_">accept</span><span class="params">()</span><span class="comment">//接受一个连接，返回代表这个连接的通道对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title function_">register</span><span class="params">(Selector sel, <span class="type">int</span> ops)</span><span class="comment">//注册一个选择器并设置监听事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h4><p><code>SocketChannel</code>，网络 <code>IO</code> 通道，<strong>具体负责进行读写操作</strong>。<code>NIO</code> 把缓冲区的数据写入通道，或者把通道里的数据读到缓冲区。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SocketChannel</span> <span class="keyword">extends</span> <span class="title class_">AbstractSelectableChannel</span> <span class="keyword">implements</span> <span class="title class_">ByteChannel</span>, ScatteringByteChannel, GatheringByteChannel,NetworkChannel&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SocketChannel <span class="title function_">open</span><span class="params">()</span>;<span class="comment">//得到一个 SocketChannel通道</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> SelectableChannel <span class="title function_">configureBlocking</span><span class="params">(<span class="type">boolean</span> block)</span>;<span class="comment">//设置阻塞或非阻塞模式,取值false表示采用非阻塞模式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connect</span><span class="params">(SocketAddress remote)</span>;<span class="comment">//连接服务器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">finishConnect</span><span class="params">()</span>;<span class="comment">//如果上面的方法连接失败，接下来就要通过该方法完成连接操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">write</span><span class="params">( ByteBuffer src)</span>:<span class="comment">//往通道里写数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(ByteBuffer dst)</span>;/I从通道里读数据</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title function_">register</span><span class="params">(Selector sel, <span class="type">int</span> ops, Object att)</span>;<span class="comment">//注册一个选择器并设置监听事件，最后一个参数可以设置共享数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;<span class="comment">//关闭通道</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>编写一个 <code>NIO</code> 群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞）实现多人群聊。服务器端：可以监测用户上线，离线，并实现消息转发功能。客户端：通过 <code>Channel</code> 可以无阻塞发送消息给其它所有用户，同时可以接受其它用户发送的消息（有服务器转发得到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="keyword">package</span> com.qifei.group;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupChatServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ServerSocketChannel serverSocketChannel;</span><br><span class="line">    <span class="keyword">public</span> Selector selector;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> port=<span class="number">6666</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupChatServer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//新建serversocketchannel</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverSocketChannel=ServerSocketChannel.open();</span><br><span class="line">            selector=Selector.open();</span><br><span class="line">            <span class="comment">//非阻塞</span></span><br><span class="line">            serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            serverSocketChannel.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(port));</span><br><span class="line">            <span class="comment">//注册到selector上面</span></span><br><span class="line">            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="type">int</span> count=selector.select();</span><br><span class="line">                <span class="keyword">if</span> (count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//获取相关的selectionKeys集合</span></span><br><span class="line">                    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">                    <span class="keyword">if</span> (iterator.hasNext())&#123;</span><br><span class="line">                        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                        <span class="keyword">if</span> (key.isAcceptable())&#123;</span><br><span class="line">                            <span class="comment">//接收到的channel</span></span><br><span class="line">                            System.out.println(<span class="string">&quot;接受消息线程：&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">                            <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">                            <span class="comment">//非阻塞式</span></span><br><span class="line">                            socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                            <span class="comment">//把服务端的socketchanne注册到selector上面</span></span><br><span class="line">                            socketChannel.register(selector,SelectionKey.OP_READ, ByteBuffer.allocate(<span class="number">1024</span>));</span><br><span class="line">                            <span class="comment">//提示</span></span><br><span class="line">                            System.out.println(socketChannel.getRemoteAddress() + <span class="string">&quot; 上线 &quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//假设是可读的状态</span></span><br><span class="line">                        <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">                            <span class="comment">//读取socketchannel里面的数据</span></span><br><span class="line">                            <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> (ByteBuffer) key.attachment();</span><br><span class="line">                            <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> channel.read(buffer);</span><br><span class="line">                            <span class="keyword">if</span> (read&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array());</span><br><span class="line">                                System.out.println(<span class="string">&quot;来自客户端的信息：&quot;</span>+msg);</span><br><span class="line">                                readWrite(channel,msg);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    iterator.remove();</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;服务器等待1秒，无连接&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(serverSocketChannel.getLocalAddress()+<span class="string">&quot;已下线&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioException) &#123;</span><br><span class="line">                ioException.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readWrite</span><span class="params">(SocketChannel self, String msg)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消息转发的线程：&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器转发消息中...&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历所有注册到 selector 上的 SocketChannel,并排除 self</span></span><br><span class="line">        <span class="keyword">for</span> (SelectionKey key : selector.keys()) &#123;</span><br><span class="line">            <span class="comment">//通过 key 取出对应的 SocketChannel</span></span><br><span class="line">            <span class="type">Channel</span> <span class="variable">targetChannel</span> <span class="operator">=</span> key.channel();</span><br><span class="line">            <span class="comment">//排除自己</span></span><br><span class="line">            <span class="keyword">if</span> (targetChannel <span class="keyword">instanceof</span> SocketChannel &amp;&amp; targetChannel != self) &#123;</span><br><span class="line">                <span class="comment">//转型</span></span><br><span class="line">                <span class="type">SocketChannel</span> <span class="variable">dest</span> <span class="operator">=</span> (SocketChannel) targetChannel;</span><br><span class="line">                <span class="comment">//将 msg 存储到 buffer</span></span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(msg.getBytes());</span><br><span class="line">                <span class="comment">//将 buffer 的数据写入通道</span></span><br><span class="line">                dest.write(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        GroupChatServer groupChatServer=<span class="keyword">new</span> <span class="title class_">GroupChatServer</span>();</span><br><span class="line">        groupChatServer.listen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">package</span> com.qf.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.Buffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NioClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户端的socketChannel</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置为非阻塞</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        InetSocketAddress inetSocketAddress=<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!socketChannel.connect(inetSocketAddress))&#123;</span><br><span class="line">            <span class="keyword">while</span> (!socketChannel.finishConnect())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;因为连接需要时间，客户端不会阻塞，可以做其他的工作&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ByteBuffer byteBuffer=ByteBuffer.wrap(<span class="string">&quot;hello ,尚硅谷&quot;</span>.getBytes());</span><br><span class="line">        socketChannel.write(byteBuffer);</span><br><span class="line">        <span class="comment">//卡住</span></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h1><p>在异步非阻塞 IO 模型中，用户线程发起 read 操作，立刻就可以开始去做其它的事。然后，内核线程会等待数据准备完成，然后内核线程将数据拷贝到用户线程的缓冲区（磁盘等位置），当这一切都完成之后，内核会给用户线程发送一个信号，告诉它 read 操作完成</p><p><strong>多路复用IO和AIO的区别：多路复用IO用户线程需要主动去读取数据，而AIO内核线程已经帮用户读区数据，用户直接使用</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaIO详解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java值传递</title>
      <link href="/2022/11/18/Java%E5%80%BC%E4%BC%A0%E9%80%92/"/>
      <url>/2022/11/18/Java%E5%80%BC%E4%BC%A0%E9%80%92/</url>
      
        <content type="html"><![CDATA[<p>​<strong>Java中只有一种参数传递方法：值传递。</strong>Java中没有指针，所以也没有引用传递了，仅仅有值传递。不过，可以通过对象的方式来实现引用传递。类似java没有多继承，但可以用多次implements接口实现多继承的功能。</p><p>值传递总结：</p><ul><li>一个方法<strong>不能修改一个基本数据类型的参数</strong>（即数值型或布尔型）。</li></ul><p>基本数据类型：是值传递。内存来说，基本数据类型的值是存放在栈空间，作为方法形参时，这个变量和值会被复制出一份也就是<strong>深拷贝</strong>，在此方法栈中对该变量的改变不会对其他方法栈的变量产生任何影响。</p><ul><li>一个方法可以改变<strong>一个对象参数的状态</strong>。</li></ul><span id="more"></span><p>传递对象的实例：引用传递。引用类型的值是对象，<strong>存放在堆空间中</strong>，作为方法形参时，<strong>在栈空间中复制了一个变量副本</strong>，值传递的是该对象的<strong>内存地址</strong>，而方法中的变量相当于方法栈中指向堆内存的一个指针。直接对变量赋值相当于是改变指针的指向，而对应内存地址里面的值并没有改变，所以上层方法变量指向的对象不会改变。但是，如果对内存地址里面的值进行了赋值，就是改变了堆内存对象本身的值了，上层方法变量指向的对象本身的值就不一样了。</p><p>String。String是final类型的，也就是不可变类型。作为方法形参时，跟引用类型一样，都是通过指针变量副本指向内存地址。 如果在方法内赋予新的值时，其实是在堆内存创建了新的对象，并将指针变量指向了新对象的内存地址。</p><ul><li>一个方法<strong>不能让对象参数引用一个新的对象</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 有些程序员认为 Java 程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。也是采用的值传递，只不过传递的是对象引用的副本</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;wang&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;hao&quot;</span>);</span><br><span class="line">        swap2(s1, s2);</span><br><span class="line">        System.out.println(<span class="string">&quot;s1:&quot;</span> + s1.getName()); <span class="comment">// wang</span></span><br><span class="line">        System.out.println(<span class="string">&quot;s2:&quot;</span> + s2.getName()); <span class="comment">// hao</span></span><br><span class="line">        <span class="comment">// 方法并没有改变存储在变量 s1 和 s2 中的对象引用。</span></span><br><span class="line">        <span class="comment">// swap 方法的参数 x 和 y 被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap2</span><span class="params">(Student x, Student y)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">temp</span> <span class="operator">=</span> x;</span><br><span class="line">        x = y;</span><br><span class="line">        y = temp;</span><br><span class="line">        System.out.println(<span class="string">&quot;x:&quot;</span> + x.getName()); <span class="comment">// hao</span></span><br><span class="line">        System.out.println(<span class="string">&quot;y:&quot;</span> + y.getName()); <span class="comment">// wang</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// x:hao</span></span><br><span class="line"><span class="comment">// y:wang</span></span><br><span class="line"><span class="comment">// s1:wang</span></span><br><span class="line"><span class="comment">// s2:hao</span></span><br><span class="line"><span class="comment">//这里也就是说明没有让原本的对象重新指向一个新的对象，而是传递给方法时候复制了一个引用的内存地址，交换的是方法内部对象引用。</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 值传递 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch依赖异常</title>
      <link href="/2022/11/10/ElasticSearch%E4%BE%9D%E8%B5%96%E5%BC%82%E5%B8%B8/"/>
      <url>/2022/11/10/ElasticSearch%E4%BE%9D%E8%B5%96%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<p>正常使用redis项目的POM中引入elasticsearch包就导致使用redis的时候报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>ERROR 41100 — [         task-7] .a.i.SimpleAsyncUncaughtExceptionHandler : Unexpected exception occurred invoking async method: public void run.ut.app.schedule.TestTask.adminLoginCache()</p><p>org.springframework.data.redis.RedisSystemException: Unknown redis exception; nested exception is io.netty.handler.codec.EncoderException: java.lang.IncompatibleClassChangeError: Class io.netty.util.Recycler$DefaultHandle does not implement the requested interface io.netty.util.internal.ObjectPool$Handle</p><p>at org.springframework.data.redis.FallbackExceptionTranslationStrategy.getFallback(FallbackExceptionTranslationStrategy.java:53 ~[spring-data-redis-2.5.3.jar:2.5.3]<br>at org.springframework.data.redis.FallbackExceptionTranslationStrategy.translate(FallbackExceptionTranslationStrategy.java:43) ~[spring-data-redis-2.5.3.jar:2.5.3]</p><p>Caused by: io.netty.handler.codec.EncoderException: java.lang.IncompatibleClassChangeError: Class io.netty.util.Recycler$DefaultHandle does not implement the requested interface io.netty.util.internal.ObjectPool$Handle</p><p>at io.lettuce.core.protocol.CommandHandler.writeSingleCommand(CommandHandler.java:421) ~[lettuce-core-6.1.4.RELEASE.jar:6.1.4.RELEASE]</p><p>at io.lettuce.core.protocol.CommandHandler.write(CommandHandler.java:387) ~[lettuce-core-6.1.4.RELEASE.jar:6.1.4.RELEASE]</p><p>添加依赖后可以正常启动redis可以正常使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.elasticsearch.plugin&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;transport-netty4-client&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;7.1.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://www.oschina.net/question/4111490_2312057?sort=time">https://www.oschina.net/question/4111490_2312057?sort=time</a></p><p>时间报错，最开始Elastic中使用的是LocalDate报错之后参考下面文章:</p><p>参考：<a href="https://www.cnblogs.com/code-duck/p/13775207.html?ivk_sa=1024320u">https://www.cnblogs.com/code-duck/p/13775207.html?ivk_sa=1024320u</a></p><p>空指针报错。</p><p>本地开发连接云服务器的reids隔一段时间不连接就会报错：</p><p>Redis exception; nested exception is io.lettuce.core.RedisException: java.io.IOException: 远程主机强迫关闭了一个现有的连接。</p><p>io.lettuce.core.RedisException: java.io.IOException: 远程主机强迫关闭了一个现有的连接。</p><p><a href="https://blog.csdn.net/sebeefe/article/details/126488503">https://blog.csdn.net/sebeefe/article/details/126488503</a></p><p><a href="https://www.dandelioncloud.cn/article/details/1392446825725767681">https://www.dandelioncloud.cn/article/details/1392446825725767681</a></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch依赖异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本数据类型与包装类</title>
      <link href="/2022/11/08/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
      <url>/2022/11/08/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8C%85%E8%A3%85%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Java的数据类型分为：基本类型、引用类型。引用类型可以赋值为null。</p><p> String不是基本数据类型，是引用类型，是lang包下的类。所以比较字符串时用<strong>equals(),不能用</strong>“&#x3D;&#x3D;”**</p><p>“&#x3D;&#x3D;”比较<strong>引用数据类型，</strong>比较的是<strong>地址</strong>是否相等；&#x3D;&#x3D;”比较<strong>基本数据类型</strong>，比较的是<strong>值</strong>是否相等</p><h2 id="基本数据类型及对应包装类"><a href="#基本数据类型及对应包装类" class="headerlink" title="基本数据类型及对应包装类"></a>基本数据类型及对应包装类</h2><p>Java提供了八种基本数据类型：byte、short、int、long、float、double、boolean、char，以及其对应的包装类：Byte，Short，Integer，Long，Flout，Double，Boolean，Character。</p><span id="more"></span><h2 id="包装类与基本数据类型的区别"><a href="#包装类与基本数据类型的区别" class="headerlink" title="包装类与基本数据类型的区别"></a>包装类与基本数据类型的区别</h2><p>包装类是对象，而基本数据类型不是。所以包装类的引用存放在stack中，实例存放在heap中；而基本数据类型直接存放在stack中。包装类需要先初始化再赋值，而基本数据类型可以直接赋值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Integer</span> n1 = <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1145</span>);<span class="comment">//需要先用new初始化</span></span><br><span class="line">int n2 = <span class="number">1145</span>;<span class="comment">//可以直接赋值</span></span><br></pre></td></tr></table></figure><h2 id="使用包装类的好处"><a href="#使用包装类的好处" class="headerlink" title="使用包装类的好处"></a>使用包装类的好处</h2><p>首先Java 是基于面向对象设计的，每创建一次包装类型就会放到堆里，然后通过栈中的地址来找寻堆中的对象。那么像经常使用的 int、double、float 等基础类型，每次都创建为对象会变的效率低下。因此就出现了基本类型，直接将变量值存在栈中，就不用在去堆中浪费空间去创建一个对象了。但是基本类型不具有对象性质，当我们使用集合的时候，又可以使用其包装类型。当然，我们每次使用的时候，例如往集合中添加基本类型，Java 会自动装箱为包装类。并且包装类提供了一些常用方法。例如，要使用int的最大值，可以直接使用Integer.MAX_VALUE方法；</p><p>其次，有些类型，如集合类型，要求容器的数据类型必须是Object，所以无法直接使用int或者double等，我们可以直接使用Integer、Double等代替。</p><p>并且Java类型间的转换可以通过包装类的方法实现，基本数据类型没有类的属性方法。</p><h3 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h3><p>缓存池：在类中预先创建频繁使用的包装类对象。<br>1、包装器类提供了对象的缓存，String类提供了常量池，都有final修饰，对象一经创建后不可修改。<br>2、节省创建对象的时间开销。对象可以自由共享。<br>3、缓存范围：<br>数字类型（Byte、Short、Integer、Long）都是-128<del>127；<br>Character类：0</del>127；<br>Boolean类：true和false都有；<br>浮点类型（Float、Double）：没有缓存值。<br>4、缓存池的概念是针对包装类的，不同包装类的对象比较要用equals()，基本数据类型没有类的方法，比较用&#x3D;&#x3D;</p><h2 id="String类的不可变性质"><a href="#String类的不可变性质" class="headerlink" title="String类的不可变性质"></a>String类的不可变性质</h2><p>String类是final类型的，String一旦创建，其内容和长度是不可改变的，String不可变的原因并不仅仅是因为字符数组被final修饰。</p><p>因为final修饰引用类型，它保存的仅仅是一个引用，final只保证这个引用类型变量所引用的地址不会改变，也就是一直引用同一个对象，但这个对象内的内容完全可以发生改变。比如一直指向一个数组，但是可以改变数组内的内容。真正的原因是因为<strong>存储String的字符数组被private修饰。而且String也没有提供可以修改字符数组的api，外界不可访问value[]，自然String就不能被修改。</strong></p><h4 id="为什么String要设计成不可变"><a href="#为什么String要设计成不可变" class="headerlink" title="为什么String要设计成不可变"></a>为什么String要设计成不可变</h4><p><strong>1、方便实现字符串对象池</strong></p><p>我们使字面量进行创建字符串时，会在常量池中查找是否有相同值的字符串，如果有则会返回其引用，否则会创建新的字符串，并返回新字符串的引用。所以字符串设计成不可变，可以保证数据的准确性。如果String可变的话，会导致别人在使用时，出现结果不一致的情况。<strong>字符串常量池本来就是提供字符串复用的</strong>，如果字符串可变，那么复用也就是无稽之谈了。</p><p><strong>2、更方便缓存hashCode</strong> </p><p>只有String是不可变的，在它创建的时候<strong>HashCode</strong>就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。</p><p><strong>3、线程安全</strong></p><p>只有String是不可变的，同一个字符串实例可以被多个线程共享。这样便不用因为线程安全问题而使用同步。字符串自己便是线程安全的。</p><h3 id="String-s1-x3D-“hhh”-和String-s1-x3D-new-String-“hhh”-在内存中的区别"><a href="#String-s1-x3D-“hhh”-和String-s1-x3D-new-String-“hhh”-在内存中的区别" class="headerlink" title="String s1 &#x3D; “hhh”;和String s1 &#x3D; new String(“hhh”);在内存中的区别"></a>String s1 &#x3D; “hhh”;和String s1 &#x3D; new String(“hhh”);在内存中的区别</h3><p><strong>一、String s1 &#x3D; “hhh”;</strong></p><p>1.在编译期，JVM会去常量池查找是否存在”hhh”</p><p>2.如果不存在，就在常量池开辟一个空间来存储”hhh”，把地址赋给栈指针</p><p>3.如果存在，就不用开辟新的空间，直接把地址赋给栈指针</p><p>4.然后在栈内存中开辟一个名为s1的空间，来存储”hhh”在常量池中的地址</p><p>总结：因此无论是”&#x3D;&#x3D;”还是equals()判断都相等，&#x3D;&#x3D;：因为在常量池中只有一份内存空间，地址全部相同。</p><pre><code>//以下方法创建字符串对象，可能创建了一个对象，也可能一个对象也没有创建String s1 = &quot;hhh&quot;;String s2 = &quot;hhh&quot;;System.out.println(s1 == s2);//trueSystem.out.println(s1.equals(s2));//true</code></pre><p><strong>二、String s1 &#x3D; new String(“hhh”);</strong></p><p>1.在编译期，JVM会去常量池查找是否存在”hhh”</p><p>2.如果不存在，就在常量池开辟一个空间来存储”hhh”</p><p>3.如果存在，就不用开辟新的空间</p><p>4.在运行期，通过String的构造器在<strong>堆内存</strong>中new了一个新的空间（new Sring(“hhh”)）</p><p>5.然后将常量池中的”hhh”对象的地址复制一份到该堆内存的空间中</p><p>6.在<strong>栈内存中</strong>开辟一个名为s1的空间，存放<strong>堆内存中</strong>新空间的地址</p><p>总结：只要是new String()，则，栈中的地址都是指向最新new出来的堆中的地址，”&#x3D;&#x3D;”判断的是地址，当然不等的。</p><p>至于equals，String类重写了equals，判断内容是否相同，明显相同，因此equals是相等的。</p><pre><code>//以下方法创建字符串对象，至少创建了一个对象，也可能创建两个对象String s3 = new String(&quot;yyy&quot;);String s4 = new String(&quot;yyy&quot;);System.out.println(s3 == s4);//falseSystem.out.println(s3.equals(s4));//true</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基本数据类型与包装类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringAOP用法</title>
      <link href="/2022/10/30/SpringAOP%E7%94%A8%E6%B3%95/"/>
      <url>/2022/10/30/SpringAOP%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="proceedingjoinpoint和joinpoint区别"><a href="#proceedingjoinpoint和joinpoint区别" class="headerlink" title="proceedingjoinpoint和joinpoint区别"></a>proceedingjoinpoint和joinpoint区别</h1><p>在增强(advice) 方法中可以声明一个JoinPoint 类型的参数，通过JoinPoint可以访问连接点的细节。</p><p>AspectJ使用org.aspectj.lang.JoinPoint 接口表示目标类连接点对象，如果是环绕增强时，使用org.aspecij.lang.ProceedingJoinPoint表示连接点对象，该类是JoinPoint的子接口。任何一个增强方法都可以通过将第1个入参声明为JoinPoint访问到连接点上下文的信息。</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.reflect.SourceLocation;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">JoinPoint</span> &#123;  </span><br><span class="line">   String <span class="title function_">toString</span><span class="params">()</span>;         <span class="comment">//连接点所在位置的相关信息  </span></span><br><span class="line">   String <span class="title function_">toShortString</span><span class="params">()</span>;     <span class="comment">//连接点所在位置的简短相关信息  </span></span><br><span class="line">   String <span class="title function_">toLongString</span><span class="params">()</span>;     <span class="comment">//连接点所在位置的全部相关信息  </span></span><br><span class="line">   Object <span class="title function_">getThis</span><span class="params">()</span>;         <span class="comment">//返回AOP代理对象  </span></span><br><span class="line">   Object <span class="title function_">getTarget</span><span class="params">()</span>;       <span class="comment">//返回目标对象  </span></span><br><span class="line">   Object[] getArgs();       <span class="comment">//返回被通知方法参数列表  </span></span><br><span class="line">   Signature <span class="title function_">getSignature</span><span class="params">()</span>;  <span class="comment">//返回当前连接点签名  </span></span><br><span class="line">   SourceLocation <span class="title function_">getSourceLocation</span><span class="params">()</span>;<span class="comment">//返回连接点方法所在类文件中的位置  </span></span><br><span class="line">   String <span class="title function_">getKind</span><span class="params">()</span>;        <span class="comment">//连接点类型  </span></span><br><span class="line">   StaticPart <span class="title function_">getStaticPart</span><span class="params">()</span>; <span class="comment">//返回连接点静态部分  </span></span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProceedingJoinPoint</span> <span class="keyword">extends</span> <span class="title class_">JoinPoint</span> &#123;  </span><br><span class="line">       <span class="keyword">public</span> Object <span class="title function_">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable;  </span><br><span class="line">       <span class="keyword">public</span> Object <span class="title function_">proceed</span><span class="params">(Object[] args)</span> <span class="keyword">throws</span> Throwable;  </span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure><p> Proceedingjoinpoint 继承了 JoinPoint 。是在JoinPoint的基础上暴露出 proceed 这个方法。proceed很重要，这个是aop代理链执行的方法。  环绕通知 ProceedingJoinPoint 执行proceed方法的作用是让目标方法执行，这也是环绕通知和前置、后置通知方法的一个最大区别。</p><h1 id="通过joinPoint获取方法有关信息"><a href="#通过joinPoint获取方法有关信息" class="headerlink" title="通过joinPoint获取方法有关信息"></a>通过joinPoint获取方法有关信息</h1><h2 id="获取切入点方法的名字"><a href="#获取切入点方法的名字" class="headerlink" title="获取切入点方法的名字"></a>获取切入点方法的名字</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName()</span><br></pre></td></tr></table></figure><h2 id="获取方法上的注解"><a href="#获取方法上的注解" class="headerlink" title="获取方法上的注解"></a>获取方法上的注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line"><span class="type">MethodSignature</span> <span class="variable">methodSignature</span> <span class="operator">=</span> (MethodSignature) signature;</span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> methodSignature.getMethod();</span><br><span class="line"><span class="keyword">if</span> (method != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    注解名字xxxxxx annoObj= method.getAnnotation(注解名字xxxxxx.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>或者在已知方法名和类的对象的情况下，可以通过反射可以获取类的内部任何信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 切面所在类</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> joinPoint.getTarget();</span><br><span class="line"> <span class="comment">// 切点所在方法名字</span></span><br><span class="line"><span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line"></span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">for</span> (Method m : target.getClass().getMethods()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (m.getName().equals(methodName)) &#123;</span><br><span class="line">        method = m;</span><br><span class="line">        <span class="comment">//  xxxxxx annoObj= method.getAnnotation(xxxxxx.class);同上</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="获取方法的参数"><a href="#获取方法的参数" class="headerlink" title="获取方法的参数"></a>获取方法的参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object[] args = joinPoint.getArgs();</span><br></pre></td></tr></table></figure><h1 id="Spring-AOP使用方法"><a href="#Spring-AOP使用方法" class="headerlink" title="Spring AOP使用方法"></a>Spring AOP使用方法</h1><p>Aspect有两个很常用的表达式:</p><ol><li>execution，它的作用，就是指定你要切入的一个地方，比如具体的方法，或者是接口，对于这个表达式也有一定的规范，直接给大家上代码如下。</li></ol><p>这个是我在项目中实现的一个controller方法调用log</p><p><img src="blog\source_posts\SpringAOP用法\1.png"></p><ol start="2"><li>annotation：作用：项目中的方法，凡是带有被这个annotation修饰的注解，然后这个注解所修饰的方法或是接口都会被拦截进行AOP增强。</li></ol><p>示例代码为结合AOP和Redis实现的限流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span><span class="comment">//限流切面类</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor(onConstructor = @__(@Autowired))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpRequestRateLimitAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedisService redisService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.http-request.rate-limit&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> enable;</span><br><span class="line"><span class="comment">//标注增强HttpRequestRateLimit注解标注的方法</span></span><br><span class="line">    <span class="meta">@Around(&quot;@annotation(run.ut.app.cache.lock.HttpRequestRateLimit)&quot;)</span></span><br><span class="line">    <span class="comment">//执行以下增强逻辑</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">requestRateLimit</span><span class="params">(ProceedingJoinPoint point)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!enable) &#123;</span><br><span class="line">            <span class="keyword">return</span> point.proceed();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Gets request URI</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">requestURI</span> <span class="operator">=</span> ServletUtils.getRequestURI();</span><br><span class="line">        <span class="comment">// Gets user-agent from header</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userAgent</span> <span class="operator">=</span> ServletUtils.getHeaderIgnoreCase(<span class="string">&quot;user-agent&quot;</span>);</span><br><span class="line">        <span class="comment">// Gets IP</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">requestIp</span> <span class="operator">=</span> ServletUtils.getRequestIp();</span><br><span class="line">        <span class="comment">// Gets method</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> ((MethodSignature) point.getSignature()).getMethod();</span><br><span class="line">        <span class="comment">// Gets annotation</span></span><br><span class="line">        <span class="type">HttpRequestRateLimit</span> <span class="variable">requestRateLimit</span> <span class="operator">=</span> method.getAnnotation(HttpRequestRateLimit.class);</span><br><span class="line">        <span class="comment">// Gets annotation params</span></span><br><span class="line">        <span class="type">RateLimitEnum</span> <span class="variable">limitEnum</span> <span class="operator">=</span> requestRateLimit.limit();</span><br><span class="line">        <span class="type">TimeUnit</span> <span class="variable">timeUnit</span> <span class="operator">=</span> requestRateLimit.timeUnit();</span><br><span class="line">        <span class="type">int</span>[] limitParams = getLimitParams(limitEnum);</span><br><span class="line">        <span class="comment">// Generates key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> String.format(<span class="string">&quot;ut_api_request_limit_rate_%s_%s_%s&quot;</span>, requestIp, method.getName(), requestURI);</span><br><span class="line">        <span class="comment">// Checks</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">over</span> <span class="operator">=</span> redisService.overRequestRateLimit(key, limitParams[<span class="number">0</span>], limitParams[<span class="number">1</span>], timeUnit, userAgent);</span><br><span class="line">        <span class="comment">//这里返回true就表示请求次数超过了规定时间内的请求次数</span></span><br><span class="line">        <span class="keyword">if</span> (over) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FrequentAccessException</span>(<span class="string">&quot;请求过于频繁，请稍后重试。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里调用被增强的方法 也就是被@HttpRequestRateLimit注解修饰下的方法</span></span><br><span class="line">        <span class="keyword">return</span> point.proceed();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>还有进行登录验证、权限校验的功能也是自定义注解使用AOP实现。</p>]]></content>
      
      
      <categories>
          
          <category> Java框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringAOP用法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stream流用法</title>
      <link href="/2022/10/30/Stream%E6%B5%81%E7%94%A8%E6%B3%95/"/>
      <url>/2022/10/30/Stream%E6%B5%81%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Stream详解"><a href="#Stream详解" class="headerlink" title="Stream详解"></a>Stream详解</h1><h2 id="Stream概述"><a href="#Stream概述" class="headerlink" title="Stream概述"></a>Stream概述</h2><p>​Stream流是JDK8新增的成员，允许以声明性方式处理数据集合，<strong>可以把Stream流看作是遍历数据集合的一个高级迭代器</strong>。Stream 是  Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的<strong>查找&#x2F;筛选&#x2F;过滤、排序、聚合和映射</strong>数据等操作。使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。简而言之，Stream API 提供了一种高效且易于使用的处理数据的方式。</p><p>​与集合不同的是数据流不存储数据值; 流的目的是处理数据,它是关于算法与计算的。如果把集合作为流的数据源,创建流时不会导致数据流动; 如果流的终止操作需要值时,流会从集合中获取值; 流只使用一次。</p><span id="more"></span><h2 id="Stream使用"><a href="#Stream使用" class="headerlink" title="Stream使用"></a>Stream使用</h2><p>Stream可以由数组或集合创建，对流的操作分为两种：</p><ol><li><strong>中间操作</strong>，每次返回一个新的流，可以有多个。<ul><li>无状态：指元素的处理不受之前元素的影响；<ul><li>unordered() filter() map() mapToInt() mapToLong() mapToDouble() flatMap()  flatMapToInt() flatMapToLong() flatMapToDouble() peek()</li></ul></li><li>有状态：指该操作只有拿到所有元素之后才能继续下去。<ul><li>distinct() sorted() sorted() limit() skip()</li></ul></li></ul></li><li><strong>结束操作</strong>：每个流只能进行一次结束操作，结束操作结束后流无法再次使用。结束操作会产生一个新的集合或值。<ul><li>非短路操作：指必须处理所有元素才能得到最终结果；<ul><li>forEach() forEachOrdered() toArray() reduce() collect() max() min() count()</li></ul></li><li>短路操作：指遇到某些符合条件的元素就可以得到最终结果</li></ul></li></ol><p><strong>创建：</strong></p><ol><li>java.util.Collection.stream() 方法用集合创建:</li></ol><ul><li>Stream<String> stream &#x3D; list.stream();</String></li></ul><ol start="2"><li>java.util.Arrays.stream(T[]array)用数组创建流</li></ol><ul><li>Arrays.stream(array);</li></ul><p><strong>方法</strong>：</p><p>1.stram()方法：将集合装为流<br>2.collect()方法：将流转为集合<br>3.filter()方法：将转为流的集合过滤出满足要求的流<br>4.map()方法：将每个元素映射成新元素<br>5.limit(n)：获取n个元素<br>6.skip(n)：跳过n元素<br>7.skip和limit组合实现分页（对数据库的压力没有减轻，只是看着分页了）<br>8.distinct：去除重复元素<br>举例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> List&lt;Person&gt; personList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initPerson</span><span class="params">()</span> &#123;</span><br><span class="line">    personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">8</span>, <span class="number">3000</span>));</span><br><span class="line">    personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">18</span>, <span class="number">5000</span>));</span><br><span class="line">    personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">28</span>, <span class="number">7000</span>));</span><br><span class="line">    personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;孙六&quot;</span>, <span class="number">38</span>, <span class="number">9000</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="遍历-x2F-匹配（foreach-x2F-find-x2F-match）"><a href="#遍历-x2F-匹配（foreach-x2F-find-x2F-match）" class="headerlink" title="遍历&#x2F;匹配（foreach&#x2F;find&#x2F;match）"></a>遍历&#x2F;匹配（foreach&#x2F;find&#x2F;match）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class StreamTest &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(7, 6, 9, 3, 8, 2, 1);</span><br><span class="line">        // 遍历输出符合条件的元素</span><br><span class="line">        list.stream().filter(x -&gt; x &gt; 6).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="过滤筛选"><a href="#过滤筛选" class="headerlink" title="过滤筛选"></a>过滤筛选</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">initPerson();</span><br><span class="line">List&lt;Person&gt; collect = personList.stream().filter(x -&gt; x.getAge()&gt;=18).collect(Collectors.toList());</span><br><span class="line">System.out.println(collect);</span><br></pre></td></tr></table></figure><h3 id="聚合max、min、count"><a href="#聚合max、min、count" class="headerlink" title="聚合max、min、count"></a>聚合max、min、count</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(1, 17, 27, 7);</span><br><span class="line">   Optional&lt;Integer&gt; max = list.stream().max(Integer::compareTo);</span><br><span class="line">   // 自定义排序</span><br><span class="line">   Optional&lt;Integer&gt; max2 = list.stream().max(new Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">       @Override</span><br><span class="line">       public int compare(Integer o1, Integer o2) &#123;</span><br><span class="line">           return o1.compareTo(o2);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">System.out.println(max2);</span><br></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map：<strong>接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">17</span>, <span class="number">27</span>, <span class="number">7</span>);</span><br><span class="line">List&lt;Integer&gt; collect = list.stream().map(x -&gt; x + <span class="number">3</span>).collect(Collectors.toList());</span><br><span class="line">System.out.println(collect);</span><br></pre></td></tr></table></figure><h3 id="Collectors收集（toList、toSet、toMap）"><a href="#Collectors收集（toList、toSet、toMap）" class="headerlink" title="Collectors收集（toList、toSet、toMap）"></a><strong>Collectors收集（toList、toSet、toMap）</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">initPerson();</span><br><span class="line">Map&lt;String, Person&gt; collect = personList.stream().filter(x -&gt; x.getAge() &gt; <span class="number">18</span>).collect(Collectors.toMap(Person::getName, y -&gt; y));</span><br><span class="line">System.out.println(collect);</span><br></pre></td></tr></table></figure><h3 id="collect-Collector-Collectors区别与关联"><a href="#collect-Collector-Collectors区别与关联" class="headerlink" title="collect\Collector\Collectors区别与关联"></a>collect\Collector\Collectors区别与关联</h3><ol><li>collect是Stream流的一个 <strong>终止方法</strong>，会使用传入的收集器（入参）对结果执行相关的操作，这个收集器必须是Collector接口的某个具体实现类。</li><li>Collector是一个 接口，collect方法的收集器是Collector接口的 具体实现类</li><li>Collectors是一个 工具类，提供了很多的静态工厂方法， 提供了很多Collector接口的具体实现类，是为了方便程序员使用而预置的一些较为通用的收集器（如果不使用Collectors类，而是自己去实现Collector接口，也可以）。</li></ol><p><img src="blog\source_posts\Stream流用法\1.jpg"></p><h3 id="Collectors主要方法"><a href="#Collectors主要方法" class="headerlink" title="Collectors主要方法"></a>Collectors主要方法</h3><p>测试数据实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String grade;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> chineseScore;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> mathScore;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> englishScore;</span><br></pre></td></tr></table></figure><p>1、toCollection(collectionFactory)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将学生年级放入集合</span></span><br><span class="line">TreeSet&lt;String&gt; grades = students.stream().map(Student::getGrade).collect(Collectors.toCollection(TreeSet::<span class="keyword">new</span>));</span><br><span class="line">System.out.println(grades.toString());</span><br></pre></td></tr></table></figure><p>2、toList()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将学生名字放入集合</span></span><br><span class="line">List&lt;String&gt; names = students.stream().map(Student::getName).collect(Collectors.toList());</span><br><span class="line">System.out.println(names.toString());</span><br></pre></td></tr></table></figure><p>3、toSet()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将学生语文成绩放入集合</span></span><br><span class="line">Set&lt;Double&gt; chineseScores = students.stream().map(Student::getChineseScore).collect(Collectors.toSet());</span><br><span class="line">System.out.println(chineseScores.toString());</span><br></pre></td></tr></table></figure><p>4、toMap(keyMapper, valueMapper)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将学生学号和姓名放入map，当出现相同key时，会抛异常</span></span><br><span class="line"><span class="comment">//这里可以有两种表达方式第一种是:: 第二种是-&gt;</span></span><br><span class="line">Map&lt;Long, String&gt; map = students.stream().collect(Collectors.toMap(Student::getid, student -&gt; student.getName()));</span><br><span class="line">System.out.println(map.toString());</span><br></pre></td></tr></table></figure><p>5、toMap(keyMapper, valueMapper, mergeFunction)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将学生学号和班级放入map，当出现相同key时，用新值替换旧值</span></span><br><span class="line">Map&lt;Long, String&gt; map = students.stream().collect(Collectors.toMap(student -&gt; student.getId(), student -&gt; student.getGrade(), (oldValue, newValue) -&gt; newValue));</span><br><span class="line">System.out.println(map.toString());</span><br></pre></td></tr></table></figure><p>6、toMap(keyMapper, valueMapper, mergeFunction, mapSupplier)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将学生学号和班级放入自定义的LinkedHashMap</span></span><br><span class="line">LinkedHashMap&lt;Long, String&gt; map = students.stream().collect(Collectors.toMap(</span><br><span class="line">    student -&gt; student.getId(),</span><br><span class="line">    student -&gt; student.getGrade(),</span><br><span class="line">    (oldValue, newValue) -&gt; newValue,</span><br><span class="line">    LinkedHashMap::<span class="keyword">new</span>)</span><br><span class="line">    );</span><br><span class="line">System.out.println(map.toString());</span><br></pre></td></tr></table></figure><p>7、toConcurrentMap(keyMapper, valueMapper)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将学生学号和班级放入ConcurrentMap</span></span><br><span class="line">ConcurrentMap&lt;Long, String&gt; concurrentMap = students.stream().collect(Collectors.toConcurrentMap(student -&gt; student.getId(), student -&gt; student.getGrade()));</span><br><span class="line">System.out.println(concurrentMap.toString());</span><br></pre></td></tr></table></figure><p>8、joining(delimiter, prefix, suffix)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将学生姓名用逗号连接成一个字符串,并在字符串前加上^^^,在字符串后加上$$$</span></span><br><span class="line"><span class="type">String</span> <span class="variable">names</span> <span class="operator">=</span> students.stream().map(Student::getName).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>,<span class="string">&quot;^^^&quot;</span>,<span class="string">&quot;$$$&quot;</span>));</span><br><span class="line">System.out.println(names);</span><br></pre></td></tr></table></figure><p>9、mapping( mapper, downstream)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将学生映射成学生名字,并收集到list中</span></span><br><span class="line">List&lt;String&gt; names = students.stream().collect(Collectors.mapping(Student::getName, Collectors.toList()));</span><br><span class="line">System.out.println(names.toString());</span><br></pre></td></tr></table></figure><p>10、collectingAndThen(downstream, finisher)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先将学生年级收集到set中，再计算set的大小</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> students.stream().map(Student::getGrade).collect(Collectors.collectingAndThen(Collectors.toSet(), grade -&gt; grade.size()));</span><br><span class="line">System.out.println(count);</span><br></pre></td></tr></table></figure><p>11、counting()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算学生的数量</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> students.stream().collect(Collectors.counting());</span><br><span class="line">System.out.println(count);</span><br></pre></td></tr></table></figure><p>12、maxBy(comparator)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取语文成绩最高分</span></span><br><span class="line">Optional&lt;Double&gt; max = students.stream().map(Student::getChineseScore).collect(Collectors.maxBy(Double::compare));</span><br><span class="line">System.out.println(max.get());</span><br></pre></td></tr></table></figure><p>13、minBy(comparator)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integers = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>);</span><br><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;alpha&quot;</span>,<span class="string">&quot;beta&quot;</span>,<span class="string">&quot;gamma&quot;</span>);</span><br><span class="line">integers</span><br><span class="line">    .stream()</span><br><span class="line">    .collect(Collectors.minBy(Comparator.naturalOrder()))</span><br><span class="line">    .get();</span><br><span class="line"><span class="comment">// output: 1</span></span><br><span class="line">strings</span><br><span class="line">   .stream()</span><br><span class="line">   .collect(Collectors.minBy(Comparator.naturalOrder()))</span><br><span class="line">   .get();</span><br><span class="line"><span class="comment">// output: alpha</span></span><br></pre></td></tr></table></figure><p>14、summingDouble(mapper)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取所有学生语文成绩总得分</span></span><br><span class="line">        <span class="type">Double</span> <span class="variable">summing</span> <span class="operator">=</span> students.stream().map(Student::getChineseScore).collect(Collectors.summingDouble(a -&gt; a));</span><br><span class="line">        System.out.println(summing);</span><br></pre></td></tr></table></figure><p>15、averagingDouble(mapper)<br>16、summarizingDouble(mapper)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DoubleSummaryStatistics</span> <span class="variable">statistics</span> <span class="operator">=</span> students.stream().map(Student::getChineseScore).collect(Collectors.summarizingDouble(a -&gt; a));</span><br><span class="line">        System.out.println(<span class="string">&quot;数量：&quot;</span> + statistics.getCount() +</span><br><span class="line">                <span class="string">&quot;\r\n总成绩：&quot;</span> + statistics.getSum() +</span><br><span class="line">                <span class="string">&quot;\n最大成绩&quot;</span> + statistics.getMax() +</span><br><span class="line">                <span class="string">&quot;\n最小成绩&quot;</span> + statistics.getMin() +</span><br><span class="line">                <span class="string">&quot;\n平均成绩&quot;</span> + statistics.getAverage()</span><br><span class="line">        );</span><br></pre></td></tr></table></figure><p>17、reducing(identity,mapper, op)<br>18、 groupingBy(classifier)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照年级分组</span></span><br><span class="line">Map&lt;String, List&lt;Student&gt;&gt; groupByGrade = students.stream().collect(Collectors.groupingBy(Student::getGrade));</span><br><span class="line">System.out.println(groupByGrade);</span><br></pre></td></tr></table></figure><p>19、groupingBy(classifier,downstream)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照年级分组后统计每组中每个学生的总成绩</span></span><br><span class="line">        Map&lt;String, Map&lt;Long, Double&gt;&gt; map = students.stream().collect(</span><br><span class="line">                Collectors.groupingBy(</span><br><span class="line">                        Student::getGrade,</span><br><span class="line">                        Collectors.toMap(</span><br><span class="line">                                student -&gt; student.getId(),</span><br><span class="line">                                student -&gt; student.getChineseScore() + student.getEnglishScore() + student.getMathScore()</span><br><span class="line">                        )));</span><br><span class="line"></span><br><span class="line">        map.forEach((grade, idTotalScore) -&gt; &#123;</span><br><span class="line">            idTotalScore.forEach((id, totalScore) -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;grade: &quot;</span> + grade + <span class="string">&quot; id: &quot;</span> + id + <span class="string">&quot; totalScore: &quot;</span> + totalScore);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>20、partitioningBy(predicate, downstream)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照年级分组后,再根据学生总成绩是否大于300分组</span></span><br><span class="line">        Map&lt;String, Map&lt;Boolean, List&lt;Student&gt;&gt;&gt; map = students.stream().collect(</span><br><span class="line">                Collectors.groupingBy(Student::getGrade,</span><br><span class="line">                        Collectors.partitioningBy(</span><br><span class="line">                                student -&gt; student.getChineseScore() + student.getEnglishScore() + student.getMathScore() &gt; <span class="number">300</span></span><br><span class="line">                        )</span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">        map.forEach((grade, map1) -&gt; map1.forEach((b, list) -&gt;</span><br><span class="line">                list.stream().forEach(student -&gt; System.out.println(<span class="string">&quot;grade: &quot;</span> + grade + <span class="string">&quot; 是否大于300分: &quot;</span> + b + <span class="string">&quot; id: &quot;</span> + student.getId())))</span><br><span class="line">        );</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/RenshenLi/article/details/114226075">Collectors参考1</a></p><p><a href="https://blog.csdn.net/dandandeshangni/article/details/109706151?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-109706151-blog-114226075.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-109706151-blog-114226075.pc_relevant_default&utm_relevant_index=5">Collectors参考2</a></p><p>将数组转换为List：这里有boxed()的装箱操作将int基本数据类型转换为Integer包装数据类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; intList= Arrays.stream(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, &#125;).boxed().collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>String数组转换为list</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] arrays = &#123;<span class="string">&quot;tom&quot;</span>, <span class="string">&quot;jack&quot;</span>, <span class="string">&quot;kate&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; stringList= Stream.of(arrays).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>将List转换为数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result.stream().mapToDouble(Double::doubleValue).toArray();</span><br></pre></td></tr></table></figure><h1 id="Java中-的用法详解"><a href="#Java中-的用法详解" class="headerlink" title="Java中::的用法详解"></a>Java中::的用法详解</h1><p>“::”是Java 8 引入的新特性之一，常常被称作为方法引用，提供了一种不执行方法的方法，其实就是类方法的句柄，是lambda表达式的一种简写。</p><p>Lambda表达式的形式有两种：</p><p><strong>单独表达式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.forEach(item -&gt; System.out.println(item));</span><br></pre></td></tr></table></figure><p><strong>代码块：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list.forEach(item -&gt; &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">numA</span> <span class="operator">=</span> item.getNumA();</span><br><span class="line"><span class="type">int</span> <span class="variable">numB</span> <span class="operator">=</span> item.getNumB();</span><br><span class="line">System.out.println(numA + numB);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用双冒号可以省略第一种Lambda表达式中的参数部分，即item -&gt;和调用方法的参数这两部分</p><p>如：把 x -&gt; System.out.println(x) 简化为 System.out::println</p><p>将方法调用：person -&gt; person.getAge();替换成Person::getAge</p><p>将对象创建() -&gt; new ArrayList&lt;&gt;();替换成ArrayList::new</p>]]></content>
      
      
      <categories>
          
          <category> Java新特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stream流用法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring中的设计模式</title>
      <link href="/2022/10/26/Spring%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/10/26/Spring%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p>双重检验锁创建Bean代码</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the (raw) singleton object registered under the given name.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Checks already instantiated singletons and also allows for an early</span></span><br><span class="line"><span class="comment"> * reference to a currently created singleton (resolving a circular reference).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean to look for</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> allowEarlyReference whether early references should be created or not</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the registered singleton object, or &#123;<span class="doctag">@code</span> null&#125; if none found</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line">   <span class="comment">// Quick check for existing instance without full singleton lock</span></span><br><span class="line">   <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">   <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">      singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">      <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">// Consistent creation of early reference within full singleton lock</span></span><br><span class="line">            singletonObject = <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">               singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);<span class="comment">//先从二级缓冲中看一看有没有</span></span><br><span class="line">               <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;<span class="comment">//如果还不存在就直接现场创建</span></span><br><span class="line">                  ObjectFactory&lt;?&gt; singletonFactory = <span class="built_in">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                  <span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">                     singletonObject = singletonFactory.getObject();</span><br><span class="line">                     <span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                     <span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/xujingyiss/article/details/119351800">https://blog.csdn.net/xujingyiss/article/details/119351800</a></p>]]></content>
      
      
      <categories>
          
          <category> Java框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring中的设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringAOP源码详解</title>
      <link href="/2022/10/26/SpringAOP%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/10/26/SpringAOP%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="AOP简介"><a href="#AOP简介" class="headerlink" title="AOP简介"></a>AOP简介</h2><p>AOP的全称是Aspect Oriented  Programming，即面向切面编程，AOP是通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。AOP  是一种编程思想，是面向对象编程（OOP）的一种延续和补充。面向对象编程将程序抽象成各个层次的对象，而面向切面编程是将程序抽象成各个切面（Aspect）。</p><p>​AOP采取横向抽取机制，将一整套功能代码抽离出来，形成切面（Aspect），然后通过拦截等方式穿插到对象中去执行。</p><p>在 Spring AOP 中动态代理的实现方式可分为 JDK 动态代理和 CGLIB 字节码提升，JDK 动态代理只能对接口进行代理，而 CGLIB 字节码提升对类也是可以进行代理的。也就是说：</p><ul><li>如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>，</li><li>而对于没有实现接口的对象，这时候Spring AOP会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理。</li></ul><p><img src="1.jpeg"></p><h2 id="Spring-AOP-和-AspectJ-AOP-的区别"><a href="#Spring-AOP-和-AspectJ-AOP-的区别" class="headerlink" title="Spring AOP 和 AspectJ AOP 的区别"></a>Spring AOP 和 AspectJ AOP 的区别</h2><p>AOP实现的关键就在于AOP框架自动创建的AOP代理，AOP代理则可分为<strong>静态代理（例如：原生AspectJ）</strong>和<strong>动态代理（例如：spring aop）两大类，</strong>其中静态代理是指使用AOP框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；而动态代理则在运行时借助于JDK动态代理、CGLIB等在内存中“临时”生成AOP动态代理类，因此也被称为运行时增强。</p><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p><p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p><p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多。</p><p><a href="https://blog.csdn.net/liuxiao723846/article/details/123600162">AspectJ参考</a></p><span id="more"></span><h2 id="Spring-AOP的具体实现："><a href="#Spring-AOP的具体实现：" class="headerlink" title="Spring AOP的具体实现："></a>Spring AOP的具体实现：</h2><p>AOP相关定义：</p><ul><li>Aspect（切面）：封装用于横向插入的系统功能（如事务、日志等）的类</li><li>Joinpoint（连接点）：在程序执行过程中的某个阶段点，在Spring中通常指方法</li><li>Pointcut（切入点）：JoinPoint的集合，是程序中需要注入Advice的位置的集合，指明Advice要在什么样的条件下才能被触发，在程序中主要体现为书写切入点表达式。切面与程序流程的交叉点，即用于匹配那些需要处理的连接点</li><li>Advice（通知&#x2F;增强处理）：AOP框架在特定的切入点执行的增强处理，即在定义好的切入点处所要执行的程序代码</li></ul><p>​@Before： 标识一个前置增强方法，相当于BeforeAdvice的功能.<br>​@After： final增强，不管是抛出异常或者正常退出都会执行.<br>​@AfterReturning： 后置增强，似于AfterReturningAdvice, 方法正常退出时执行.<br>​@AfterThrowing： 异常抛出增强，相当于ThrowsAdvice.<br>​@Around： 环绕增强，相当于MethodInterceptor.</p><ul><li>Target Object（目标对象）：指所有被通知的对象，也被称为被增强对象</li><li>Proxy（代理）：将通知应用到目标对象之后，被动态创建的对象，即被增强对象之后的对象</li><li>Weaving（织入）：将切面代码插入到目标对象上，从而生成代理对象的过程</li><li>Introduction（引入）：允许我们向现有的类添加新的方法或者属性</li></ul><h3 id="Joinpoint"><a href="#Joinpoint" class="headerlink" title="Joinpoint"></a>Joinpoint</h3><p>​Joinpoint（连接点） 在 AOP 中是指在程序执行过程中的某个阶段点，简而言之就是指类中的方法、构造器、字段。</p><p><img src="1.jpg"></p><p>​Joinpoint 接口表示一个通用的运行时连接点，是具有一定业务逻辑的，其接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Joinpoint</span> &#123;</span><br><span class="line">    <span class="comment">// 执行连接点的业务逻辑，并进入下一个拦截器</span></span><br><span class="line">Object <span class="title function_">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line"></span><br><span class="line">Object <span class="title function_">getThis</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">AccessibleObject <span class="title function_">getStaticPart</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​Invocation 接口表示对程序的调用。对于 AOP 而言，是通过拦截程序中连接点，然后对连接点进行增强，但增强的阶段可能发生在连接点之前，也可能发生在连接点之后，所以对连接点原有的业务逻辑进行调用也是至关重要的。其接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Invocation</span> <span class="keyword">extends</span> <span class="title class_">Joinpoint</span> &#123;</span><br><span class="line">    <span class="comment">// 返回调用的参数</span></span><br><span class="line">Object[] getArguments();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​MethodInvocation 接口表示对方法的调用，由于 Spring AOP 仅支持方法级别的连接点，所以 Spring 对 AOP 的实现基本都是基于 MethodInvocation 的。其接口的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MethodInvocation</span> <span class="keyword">extends</span> <span class="title class_">Invocation</span> &#123;</span><br><span class="line">    <span class="comment">// 被调用的方法</span></span><br><span class="line">Method <span class="title function_">getMethod</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReflectiveMethodInvocation 和 CglibMethodInvocation 都是 MethodInvocation  的子类，<strong>ReflectiveMethodInvocation 是 Spring 基于 JDK 动态代理实现的 Joinpoint ，而  CglibMethodInvocation 是Spring 基于 CGLIB 实现的 Joinpoint。</strong></p><h4 id="Pointcut"><a href="#Pointcut" class="headerlink" title="Pointcut"></a>Pointcut</h4><p>Pointcut（切入点）在 AOP 中是指切面与程序流程的交叉点，即用于匹配那些需要增强的连接点，简而言之就是充当过滤器的角色。</p><p><img src="2.jpg"></p><p>Pointcut 接口是 Spring AOP 中切入点的抽象，由ClassFilter和MethodMatcher组成，其接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Pointcut</span> &#123;</span><br><span class="line">    </span><br><span class="line">ClassFilter <span class="title function_">getClassFilter</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">MethodMatcher <span class="title function_">getMethodMatcher</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">Pointcut</span> <span class="variable">TRUE</span> <span class="operator">=</span> TruePointcut.INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ClassFilter 接口表示限制 Pointcut （切入点）或Introduction（引入）与给定目标类集的匹配的过滤器，ClassFilter 中定义了用于匹配类的逻辑条件，其接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ClassFilter</span> &#123;</span><br><span class="line">    <span class="comment">// 匹配的逻辑条件</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(Class&lt;?&gt; clazz)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">ClassFilter</span> <span class="variable">TRUE</span> <span class="operator">=</span> TrueClassFilter.INSTANCE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MethodMatcher 接口用于检查目标方法是否符合通知的条件 ，MethodMatcher 中定义了了用于匹配方法的逻辑条件，其接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MethodMatcher</span> &#123;</span><br><span class="line">    <span class="comment">// 匹配的逻辑条件，静态检查，AspectJ</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否是运行时检查</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isRuntime</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 匹配的逻辑条件，动态检查，Spring AOP</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass, Object... args)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">MethodMatcher</span> <span class="variable">TRUE</span> <span class="operator">=</span> TrueMethodMatcher.INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​Pointcut 接口的实现类有很多，但最为常见的实现类是  AspectJExpressionPointcut，AspectJExpressionPointcut 类会对 @Pointcut 注解或者  aop:pointcut 标签中定义的表达式进行解析，然后来匹配连接点。</p><h4 id="Advice"><a href="#Advice" class="headerlink" title="Advice"></a>Advice</h4><p>​Advice（通知&#x2F;增强处理）表示 AOP 框架在特定的切入点执行的增强处理，即<strong>在定义好的切入点处所要执行的程序代码。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Advice</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Interceptor 接口表示一个通用的拦截器，继承了 Advice 接口，相当于一个标记接口，其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Interceptor</span> <span class="keyword">extends</span> <span class="title class_">Advice</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MethodInterceptor 接口是 Interceptor 接口的子类，在 Spring AOP 内部，Advice  的子接口（如：BeforeAdvice、AfterAdvice等）都会转换成 MethodInterceptor 来使用，其接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MethodInterceptor</span> <span class="keyword">extends</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line">    <span class="comment">// 在执行连接点的业务逻辑（ Joinpoint.proceed() ）前后，进行额外的处理</span></span><br><span class="line">Object <span class="title function_">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 AOP 中根据 Advice 在 Jointpoint 的位置，可将 Advice 分为5种类型，分别为：</p><ul><li>前置通知（Before Advice）：在连接点（Join point）之前执行的通知。</li><li>后置通知（After Advice）：当连接点退出的时候执行的通知（不论是正常返回还是异常退出）。</li><li>环绕通知（Around Advice）：包围一个连接点的通知，这是最强大的一种通知类型。 环绕通知可以在方法调用前后完成自定义的行为。它也可以选择是否继续执行连接点或直接返回它们自己的返回值或抛出异常来结束执行。</li><li>返回后通知（AfterReturning Advice）：在连接点正常完成后执行的通知（如果连接点抛出异常，则不执行）</li><li>抛出异常后通知（AfterThrowing advice）：在方法抛出异常退出时执行的通知</li></ul><p>执行顺序：</p><p>没有异常情况下的执行顺序：</p><p>around before advice<br>before advice<br>target method 执行<br>around after adviceafter advice<br>afterReturning advice</p><p>出现异常情况下的执行顺序：</p><p>around before advice<br>before advice<br>target method 执行<br>around after advice<br>after advice<br>afterThrowing advice<br>java.lang.RuntimeException：异常发生</p><h4 id="AopProxy"><a href="#AopProxy" class="headerlink" title="AopProxy"></a>AopProxy</h4><p>AopProxy 接口用于创建代理对象，其接口定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AopProxy</span> &#123;</span><br><span class="line">    </span><br><span class="line">Object <span class="title function_">getProxy</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">Object <span class="title function_">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AopProxy 接口有两种类型的实现，一种是基于 JDK 动态代理实现的 JdkDynamicAopProxy，另一种是基于 CGLIB 字节码提升实现的 CglibAopProxy 和 ObjenesisCglibAopProxy。</p><p>AopProxyFactory 接口是 AopProxy 的抽象接口工厂，它会根据 AdvisedSupport（AOP的配置类）创建 AopProxy 接口的实现类，其接口定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AopProxyFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">AopProxy <span class="title function_">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AopProxyFactory 接口的默认的实现类是 DefaultAopProxyFactory。</p><h4 id="TargetSource"><a href="#TargetSource" class="headerlink" title="TargetSource"></a>TargetSource</h4><p>TargetSource 接口用于获取AOP调用的目标对象，其接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TargetSource</span> <span class="keyword">extends</span> <span class="title class_">TargetClassAware</span> &#123;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; getTargetClass();</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isStatic</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">Object <span class="title function_">getTarget</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">releaseTarget</span><span class="params">(Object target)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常见的实现类有：</p><ul><li>HotSwappableTargetSource：允许热交换的 TargetSource 实现</li><li>SingletonTargetSource：单例的 TargetSource 实现，是 TargetSource 的默认实现</li><li>AbstractPoolingTargetSource：基于池（比如：CommonsPool ）技术实现的 TargetSource</li><li>ThreadLocalTargetSource：基于 ThreadLocal 技术实现的 TargetSource</li><li>PrototypeTargetSource：基于 IoC 容器技术实现的 TargetSource</li></ul><p>​其中  AbstractPoolingTargetSource、ThreadLocalTargetSource、PrototypeTargetSource 都是AbstractPrototypeBasedTargetSource的子类，是原型的 TargetSource 实现。</p><h4 id="Advisor"><a href="#Advisor" class="headerlink" title="Advisor"></a>Advisor</h4><p>​Advisor 接口是 Advice 的连接器，用于连接 Advice 和 Pointcut 或者连接 Advice 和 Introduction，其接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Advisor</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">Advice</span> <span class="variable">EMPTY_ADVICE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Advice</span>() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Advice <span class="title function_">getAdvice</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isPerInstance</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​Advisor 的作用类似于 AOP 中 Aspect，它们都是封装用于横向插入的系统功能（Advice）。</p><h4 id="AdvisorAdapter"><a href="#AdvisorAdapter" class="headerlink" title="AdvisorAdapter"></a>AdvisorAdapter</h4><p>AdvisorAdapter 接口用于将指定的 Advice 转换为 Interceptor，其接口定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AdvisorAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">supportsAdvice</span><span class="params">(Advice advice)</span>;</span><br><span class="line"></span><br><span class="line">MethodInterceptor <span class="title function_">getInterceptor</span><span class="params">(Advisor advisor)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常见的实现类有：</p><ul><li>MethodBeforeAdviceAdapter：用于将 MethodBeforeAdvice 转换成 MethodInterceptor</li><li>ThrowsAdviceAdapter：用于将 ThrowsAdvice  转换成 MethodInterceptor</li><li>AfterReturningAdviceAdapter：用于将 AfterReturningAdvice  转换成 MethodInterceptor</li></ul><p>AdvisorAdapterRegistry 接口是 AdvisorAdapter 的注册中心，其接口定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AdvisorAdapterRegistry</span> &#123;</span><br><span class="line"></span><br><span class="line">Advisor <span class="title function_">wrap</span><span class="params">(Object advice)</span> <span class="keyword">throws</span> UnknownAdviceTypeException;</span><br><span class="line"></span><br><span class="line">MethodInterceptor[] getInterceptors(Advisor advisor) <span class="keyword">throws</span> UnknownAdviceTypeException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">registerAdvisorAdapter</span><span class="params">(AdvisorAdapter adapter)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AdvisorAdapterRegistry 接口的默认实现是 DefaultAdvisorAdapterRegistry</strong>，AdvisorAdapterRegistry 可以根据给定的的 Advisor 获取对应的 MethodInterceptor。</p><p>参考：</p><p><a href="https://www.yht7.com/news/152919">https://www.yht7.com/news/152919</a></p><p><a href="https://blog.csdn.net/baidu_37366055/article/details/109989145">https://blog.csdn.net/baidu_37366055/article/details/109989145</a></p><p><a href="http://events.jianshu.io/p/7cd5fe194e77">SpringAOP源码参考：</a></p><p><a href="http://events.jianshu.io/p/7cd5fe194e77">Spring事务源码参考</a></p>]]></content>
      
      
      <categories>
          
          <category> Java框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AOP源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringIOC源码详解</title>
      <link href="/2022/10/24/SpringIOC%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/10/24/SpringIOC%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="IOC介绍"><a href="#IOC介绍" class="headerlink" title="IOC介绍"></a>IOC介绍</h2><p>IoC（Inverse of Control:控制反转）是一种<strong>设计思想</strong>，就是 <strong>将原本在程序中手动创建对象的控制权，交由Spring框架来管理。IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。</strong></p><p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 <strong>IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件&#x2F;注解即可，完全不用考虑对象是如何被创建出来的。</strong></p><h2 id="加载BeanDefinition"><a href="#加载BeanDefinition" class="headerlink" title="加载BeanDefinition"></a>加载BeanDefinition</h2><p>我对BeanDefinition的理解：首先Bean未实例化前在容器中的形式是BeanDefinition，BeanDefinition实例中包括了对象的所有信息，当被注入类向容器请求依赖对象时候，BeanFactory就会通过对应BeanDefinition中的信息返回一个实例。可以把BeanFactory看成是图书馆，BeanDefinitionRegistry就是图书馆里边的书架，书就在书架上存放着，这里也就要求我们的图书馆只能有一个书架。每个BeanDefinition都要被放在BeanDefinitionRegistry中才能被容器管理。至于BeanDefinition，一般是通过BeanDefinitionReader读取配置文件或者注解并映射成对应的BeanDefinition来生成的。</p><p><strong>IOC 的精髓是 AbstractApplicationContext 的 refresh() 方法。我们在springboot启动类中调用 SpringApplication.run 方法，run 方法中调用 refreshContext 方法，就会进入到 AbstractApplicationContext 的 refresh() 方法。</strong>之前我们讲过BeanFactory是较为轻量的容器，这个容器启动时会通过BeanDefinitionReader来加载配置文件获得对应BeanDefinition，然后将BeanDefinition注册到BeanDefinitionRegistry。</p><span id="more"></span><h2 id="Spring-IOC容器的启动流程："><a href="#Spring-IOC容器的启动流程：" class="headerlink" title="Spring IOC容器的启动流程："></a>Spring IOC容器的启动流程：</h2><p>spring IOC 容器管理Bean主要分为两个步骤</p><p>第一：加载bean的配置文件，从而在内存中生成BeanDefinition对象，并将BeanDefinition对象在BeanDefinitionRegistry中注册（其实也可以算作是SpringBean生命周期的准备阶段）</p><p>第二：根据第一步生成的BeanDefinition对象创建bean的实例（Spring Bean的生命周期详解）</p><p>具体步骤如下：</p><p>（1）初始化Spring容器，注册内置的BeanPostProcessor的BeanDefinition到容器中：</p><p>​① 实例化BeanFactory【DefaultListableBeanFactory】工厂，用于生成Bean对象<br>​② 实例化BeanDefinitionReader注解配置读取器，用于对特定注解（如@Service、@Repository）的类进行读取转化成  BeanDefinition 对象，（BeanDefinition 是 Spring 中极其重要的一个概念，它存储了 bean  对象的所有特征信息，如是否单例，是否懒加载，factoryBeanName 等）<br>​③ 实例化ClassPathBeanDefinitionScanner路径扫描器，用于对指定的包目录进行扫描查找 bean 对象</p><p>（2）将配置类的BeanDefinition注册到容器中：</p><p>（3）调用refresh()方法刷新容器：</p><p>​① prepareRefresh()刷新前的预处理：<br>​② obtainFreshBeanFactory()：获取在容器初始化时创建的BeanFactory：<br>​③ prepareBeanFactory(beanFactory)：BeanFactory的预处理工作，向容器中添加一些组件：<br>​④ postProcessBeanFactory(beanFactory)：子类重写该方法，可以实现在BeanFactory创建并预处理完成以后做进一步的设置<br>​⑤ invokeBeanFactoryPostProcessors(beanFactory)：在BeanFactory标准初始化之后执行BeanFactoryPostProcessor的方法，即BeanFactory的后置处理器：<br>​⑥ registerBeanPostProcessors(beanFactory)：向容器中注册Bean的后置处理器BeanPostProcessor，它的主要作用是干预Spring初始化bean的流程，从而完成代理、自动注入、循环依赖等功能<br>​⑦ initMessageSource()：初始化MessageSource组件，主要用于做国际化功能，消息绑定与消息解析：<br>​⑧ initApplicationEventMulticaster()：初始化事件派发器，在注册监听器时会用到：<br>​⑨ onRefresh()：留给子容器、子类重写这个方法，在容器刷新的时候可以自定义逻辑<br>​⑩ registerListeners()：注册监听器：将容器中所有的ApplicationListener注册到事件派发器中，并派发之前步骤产生的事件：<br>​⑪ finishBeanFactoryInitialization(beanFactory)：初始化所有剩下的单实例bean，核心方法是preInstantiateSingletons()，会调用getBean()方法创建对象；（这里就开始Bean的实例化了，具体如下面Bean的生命周期）<br>​⑫ finishRefresh()：发布BeanFactory容器刷新完成事件：</p><h2 id="Spring-IoC容器的源码过程"><a href="#Spring-IoC容器的源码过程" class="headerlink" title="Spring IoC容器的源码过程"></a>Spring IoC容器的源码过程</h2><ol><li><p>new AnnotationConfigApplicationContext实例化容器入口（ApplicationContext容器的注解常用实现类）</p></li><li><p>调用本身无参构造函数this()</p><ol><li><p>会调用父类的无参构造函数创建Bean工厂，然后创建读取注解的BeanDefinitionReader</p></li><li><p>在创建BeanDefinitionReader时，会注册一些Spring内置的原始BeanDefinition：</p><ul><li><p>ConfigurationClassPostProcessor： 解析我们配置类的处理器</p></li><li><p>AutowiredAnnotationBeanPostProcessor： 处理@Autowired注解的后置处理器</p></li><li><p>RequiredAnnotationBeanPostProcessor：处理@Required属性注解的后置处理器</p></li><li><p>这些Spring内置的原始Bean定义通过DefaultListableBeanFactory把这些Bean定义放入BeanDefinitionMap（一个ConcurrentHashMap，beanName作为Key，beanDefinition作为Value）中以及beanDefinitionNames（一个List，里面存放了beanName）。</p></li></ul></li><li><p>再创建Bean定义扫描器（仅仅是为了设计程序时可以手动调用）</p></li></ol></li><li><p>调用register(annotatedClasses);</p><ol><li><p>会循环传进来的配置类数组执行doRegisterBean方法</p></li><li><p>把当前配置类封装成Bean定义</p></li><li><p>判断是否需要跳过注解，Spring中有一个@Condition注解，当不满足条件，这个bean就不会被解析</p></li><li><p>解析Bean的作用域，如果没有设置的话，默认为单例</p></li><li><p>获得BeanName</p></li><li><p>解析通用注解，填充到Bean定义中，解析的通用注解：</p><ul><li><p>​    Lazy</p></li><li><p>​    Primary</p></li><li><p>​    DependsOn</p></li><li><p>​    Role</p></li><li><p>​    Description</p></li></ul></li><li><p>把Bean定义和beanName封装并调用DefaultListableBeanFactory中的registerBeanDefinition方法去注册</p></li><li><p>此时只是实例化了一个工厂、把Spring内置的原始Bean定义，还有我们传进来的Bean定义（配置类）注册到BeanDefinitionMap、beanDefinitionNames两个变量中</p></li></ol></li><li><p>调用refresh();</p><ol><li><p>prepareRefresh()刷新前准备工作，主要是保存了容器的启动时间，启动标志等。</p></li><li><p>ConfigurableListableBeanFactory beanFactory &#x3D; obtainFreshBeanFactory(); 拿到Bean工厂</p></li><li><p>prepareBeanFactory(beanFactory); 对bean工厂进行填充属性</p><ul><li><p>​    设置了一个类加载器</p></li><li><p>​    设置了bean表达式解析器</p></li><li><p>​    设置了一些忽略自动装配的接口</p></li><li><p>​    设置了一些允许自动装配的接口，并且进行了赋值操作</p></li><li><p>​    注册bean工厂的内部的Bean</p></li></ul></li><li><p>nvokeBeanFactoryPostProcessors(beanFactory);调用Bean工厂和调用addBeanFactoryPostProcessor添加的Bean工厂后置处理器</p></li><li><p>registerBeanPostProcessors(beanFactory); 注册和实例化<strong>Bean后置处理器</strong></p></li><li><p>finishBeanFactoryInitialization(beanFactory); （<strong>开始Bean的实例化</strong>）</p><ul><li>实例化所有剩余的（非懒加载）单例，比如invokeBeanFactoryPostProcessors方法中根据各种注解解析出来的类，在这个时候都会被初始化。</li><li>实例化的过程各种BeanPostProcessor开始起作用。</li></ul></li></ol></li></ol><h2 id="Spring-Bean的生命周期："><a href="#Spring-Bean的生命周期：" class="headerlink" title="Spring Bean的生命周期："></a><strong>Spring Bean的生命周期：</strong></h2><p>对于普通的 Java 对象，当 new 的时候创建对象（java源码被编译为被编译为class文件,等到类需要被初始化时（比如说new、反射等）class文件被虚拟机通过类加载器加载到JVM），然后该对象就能够使用了。一旦该对象不再被使用，则由 Java 自动进行垃圾回收。</p><p>而 Spring 中的对象是 bean，bean 和普通的 Java 对象没啥大的区别，只不过 Spring 不再自己去 new 对象了，而是由  IoC 容器去帮助我们实例化对象并且管理它。我们需要哪个对象，去问 IoC 容器要即可。IoC 其实就是解决对象之间的耦合问题，Spring  Bean 的生命周期完全由容器控制。</p><p><strong>除了Class对象之外，还会使用BeanDefinition的实例来描述对象的信息，Spring的BeanDefinition存储着我们日常给Spring Bean定义的元数据@Scope、@Lazy、@DependsOn等等）</strong>Spring在启动的时候需要「扫描」在XML&#x2F;注解&#x2F;JavaConfig 中需要被Spring管理的Bean信息，随后，会将这些信息封装成BeanDefinition，最后会把这些信息放到一个beanDefinitionMap（key是beanName，value则是BeanDefinition对象）中到这里其实就是把定义的元数据加载起来，目前真实对象还没实例化。这里其实是Spring容器启动时做的工作，（这里有区别BeanFactory轻量级容器懒加载等调用getBean时才实例化，而常用的ApplicationContext启动就全部将Bean实例化）下面就是Bean实例化到销毁的整个生命周期</p><p>简单来说，Spring Bean的生命周期只有四个阶段：<strong>实例化 Instantiation –&gt; 属性赋值 Populate –&gt; 初始化 Initialization –&gt; 销毁 Destruction</strong>主要逻辑都在doCreate()方法中，逻辑很清晰，就是顺序调用以下三个方法：</p><ol><li>createBeanInstance() -&gt; 实例化</li><li>populateBean() -&gt; 属性赋值</li><li>initializeBean() -&gt; 初始化</li></ol><p>流程图如下所示：</p><p><img src="1.png"></p><h3 id="1-实例化Bean"><a href="#1-实例化Bean" class="headerlink" title="1. 实例化Bean"></a>1. 实例化Bean</h3><p>对于BeanFactory容器，当客户向容器请求一个尚未初始化的bean时，或初始化bean的时候需要注入另一个尚未初始化的依赖时，容器就会调用createBeanInstance()进行实例化。 对于ApplicationContext容器，当容器启动结束后，便实例化所有的bean。 容器通过获取BeanDefinition对象中的信息进行实例化。并且这一步仅仅是简单的实例化，并未进行依赖注入。在这一步是通过反射来实现的，一般情况下会通过<strong>反射选择合适的构造器来把对象实例化</strong>，但这里把对象实例化，只是把对象给创建出来，而对象具体的属性是还没注入的。</p><h3 id="2-属性赋值："><a href="#2-属性赋值：" class="headerlink" title="2. 属性赋值："></a>2. 属性赋值：</h3><p>这一步根据BeanDefinition中的信息把对象的相关属性给注入。</p><p>顺序：1、静态属性：static 开头定义的属性 2、静态方法块： static {} 圈起来的方法块 3、普通属性： 未带static定义的属性 4、普通方法块： {} 圈起来的方法块 5、构造函数： 类名相同的方法 6、方法： 普通方法</p><h3 id="3-1-注入Aware接口"><a href="#3-1-注入Aware接口" class="headerlink" title="3.1 注入Aware接口"></a>3.1 注入Aware接口</h3><p>Aware类型的接口的作用就是让我们能够拿到Spring容器中的一些资源。</p><p>BeanFactory容器提供的 Aware 接口有：</p><ol><li>BeanNameAware：注入当前 bean 对应 beanName；</li><li>BeanClassLoaderAware：注入加载当前 bean 的 ClassLoader；</li><li>BeanFactoryAware：注入 当前BeanFactory容器 的引用。</li></ol><p>而对于 ApplicationContext 类型的容器，也提供了 Aware 接口，只不过这些 Aware 接口的注入实现，是通过 BeanPostProcessor 的方式注入的，但其作用仍是注入依赖。</p><ol><li>EnvironmentAware：注入 Enviroment，一般用于获取配置属性；</li><li>EmbeddedValueResolverAware：注入 EmbeddedValueResolver（Spring EL解析器），一般用于参数解析；</li><li>ApplicationContextAware：会调用setApplicationContext(ApplicationContext)方法，注入 ApplicationContext 容器本身。</li></ol><h3 id="3-2-BeanPostProcessor"><a href="#3-2-BeanPostProcessor" class="headerlink" title="3.2 BeanPostProcessor"></a>3.2 BeanPostProcessor</h3><p>千万不要把这个和 <strong>BeanFactoryProcessor</strong> 混淆，他们是不同的阶段，BeanFactoryProcessor 作用于容器启动阶段将所有Bean加载到BeanDefinition 的尾部(<strong>Spring允许在Bean创建之前，读取Bean的元属性，并根据自己的需求对元属性进行改变，比如将Bean的scope从singleton改变为prototype，最典型的应用应当是PropertyPlaceholderConfigurer，替换xml文件中的占位符，替换为properties文件中相应的key对应的value</strong>)，BeanPostProcessor则作用域Bean的初始化阶段。</p><p>当经过上述几个步骤后，bean对象已经被正确构造，但如果你想要对象被使用前再进行一些自定义的处理，就可以通过BeanPostProcessor接口实现。 该接口提供了两个函数：</p><p><strong>postProcessBeforeInitialzation</strong>( Object bean, String beanName ) 当前正在初始化的bean对象会被传递进来，我们就可以对这个bean作任何处理。 这个函数会先于<strong>InitialzationBean</strong>执行，因此称为<strong>前置处理</strong>。 所有Aware接口的注入就是在这一步完成的。</p><p><strong>postProcessAfterInitialzation</strong>( Object bean, String beanName ) 当当前正在初始化的bean对象会被传递进来，我们就可以对这个bean作任何处理。 这个函数会在InitialzationBean（3.3）完成后执行，因此称为<strong>后置处理</strong>。</p><p>使用方法见（Spring上下文）</p><p>另InstantiationAwareBeanPostProcessor跟BeanPostProcessor差不多只不过是作用在实例化的前后。</p><h3 id="3-3-InitializingBean与init-method"><a href="#3-3-InitializingBean与init-method" class="headerlink" title="3.3 InitializingBean与init-method"></a>3.3 InitializingBean与init-method</h3><p>InitializingBean：如果Bean实现了InitializingBean接口，执行afeterPropertiesSet()方法。但它与前置处理不同，由于该函数并不会把当前bean对象传进来，因此在这一步没办法处理对象本身，只能增加一些额外的逻辑。<br>若要使用它，我们需要让bean实现该接口，并把要增加的逻辑写在该函数中。然后Spring会在前置处理完成后检测当前bean是否实现了该接口，并执行afterPropertiesSet函数。</p><p>init-method：如果Bean在Spring配置文件中配置了 init-method 属性，则会自动调用其配置的初始化方法。Spring为了降低对客户代码的侵入性，给bean的配置提供了init-method属性，该属性指定了在这一阶段需要执行的函数名。Spring便会在初始化阶段执行我们设置的函数。init-method本质上仍然使用了InitializingBean接口。</p><p>实现方式：1. @PostConstruct、2. 实现InitializingBean接口、3. 定义init-method方法</p><p><a href="https://blog.csdn.net/qq_38826019/article/details/117387398">使用举例</a></p><h3 id="4-DisposableBean和destroy-method"><a href="#4-DisposableBean和destroy-method" class="headerlink" title="4 DisposableBean和destroy-method"></a>4 DisposableBean和destroy-method</h3><p>和init-method一样，通过给destroy-method指定函数，就可以在bean销毁前执行指定的逻辑。</p><h3 id="代码举例-（创建UserBean）"><a href="#代码举例-（创建UserBean）" class="headerlink" title="代码举例:（创建UserBean）"></a>代码举例:（创建UserBean）</h3><p><strong>1 UserBean 类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserBean</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span>, BeanNameAware, DisposableBean, ApplicationContextAware &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserBean</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        System.out.println(<span class="string">&quot;2. 调用构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        System.out.println(<span class="string">&quot;5. 属性注入 id&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        System.out.println(<span class="string">&quot;5. 属性注入 name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;6. 调用 BeanNameAware.setBeanName() 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="type">UserBean</span> <span class="variable">userBean</span> <span class="operator">=</span> (UserBean) applicationContext.getBean(<span class="string">&quot;userBean&quot;</span>);</span><br><span class="line">        System.out.println(userBean);</span><br><span class="line">        System.out.println(<span class="string">&quot;7. 调用 BeanNameAware.setBeanName() 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;9. 调用 InitializingBean.afterPropertiesSet() 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myInit</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;10. 调用 init-method 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;12. 调用 DisposableBean.destroy() 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;13. 调用 destroy-method 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;UserBean&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2 InstantiationAwareBeanPostProcessor 接口实现类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInstantiationAwareBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">InstantiationAwareBeanPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;userBean&quot;</span>.equals(beanName)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;1. 调用 InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation() 方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;userBean&quot;</span>.equals(beanName)) &#123;</span><br><span class="line">            <span class="type">UserBean</span> <span class="variable">userBean</span> <span class="operator">=</span> (UserBean) bean;</span><br><span class="line">            System.out.println(<span class="string">&quot;3. 调用 InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation() 方法&quot;</span>);</span><br><span class="line">            System.out.println(userBean);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PropertyValues <span class="title function_">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;userBean&quot;</span>.equals(beanName)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;4. 调用 InstantiationAwareBeanPostProcessor.postProcessProperties() 方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3 BeanPostProcessor 接口实现类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;userBean&quot;</span>.equals(beanName)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;8. 调用 BeanPostProcessor.postProcessBeforeInitialization() 方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;userBean&quot;</span>.equals(beanName)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;11. 调用 BeanPostProcessor.postProcessAfterInitialization() 方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4 BeanFactoryPostProcessor 接口实现类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;0. 调用 BeanFactoryPostProcessor.postProcessBeanFactory() 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5 applicationContext.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.riemann.test.MyInstantiationAwareBeanPostProcessor&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.riemann.test.UserBean&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;myInit&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;myDestroy&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 构造函数注入 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>微信公众号【老周聊架构】<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- setter方法注入 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;riemann&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.riemann.test.MyBeanPostProcessor&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.riemann.test.MyBeanFactoryPostProcessor&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>6 测试类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanLifeCycleTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;classpath:applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserBean</span> <span class="variable">user</span> <span class="operator">=</span> (UserBean) applicationContext.getBean(<span class="string">&quot;userBean&quot;</span>);</span><br><span class="line">        ((AbstractApplicationContext) applicationContext).close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>7 控制台结果打印</strong></p><p><img src="2.png"></p><h2 id="Spring-循环依赖问题"><a href="#Spring-循环依赖问题" class="headerlink" title="Spring 循环依赖问题"></a>Spring 循环依赖问题</h2><p>循环依赖问题在Spring中主要有三种情况：</p><p>（1）通过构造方法进行依赖注入时产生的循环依赖问题。<br>（2）通过setter方法进行依赖注入且是在多例（原型）模式下产生的循环依赖问题。<br>（3）<strong>通过setter方法进行依赖注入且是在单例模式下产生的循环依赖问题。</strong><br>在Spring中，只有第（3）种方式的循环依赖问题被解决了，其他两种方式在遇到循环依赖问题时都会产生异常。这是因为：</p><p>第一种构造方法注入的情况下，在new对象的时候就会堵塞住了，其实也就是”先有鸡还是先有蛋“的历史难题。<br>第二种setter方法（多例）的情况下，每一次getBean()时，都会产生一个新的Bean，如此反复下去就会有无穷无尽的Bean产生了，最终就会导致OOM问题的出现。<br>Spring在单例模式下的setter方法依赖注入引起的循环依赖问题，主要是通过二级缓存和三级缓存来解决的，其中三级缓存是主要功臣。解决的核心原理就是：在对象实例化之后，依赖注入之前，Spring提前暴露的Bean实例的引用在第三级缓存中进行存储。</p><p><strong>解决办法：三级缓存解决</strong>   </p><p>所谓的三级缓存其实就是三个Map</p><ul><li>singletonObjects 一级缓存（一级，日常实际获取成品Bean的地方）</li><li>earlySingletonObjects 二级缓存（二级，还没进行属性注入的半成品Bean，由三级缓存放进来t）</li><li>singletonFactories 三级缓存（放ObjectFactory是一个对象工厂，函数接口实现回调函数）</li></ul><ol><li>一级缓存中取A对象，如果为空并且不是正在创建状态就加锁成功后再次尝试从一级缓存中获取（此处是为了防止其他线程已经创建完成之后另一个线程获取锁，这个时候判断之前创建有的话这里就不用再创建了），如果还是没有则进行创建；</li><li>标记A对象正在创建（放入set中），把A对象完成实例化，此时没有完成初始化；</li><li>往三级缓存中放入一个函数接口（用于其他对象依赖A对象时动态代理生成A对象并注入），此时三级缓存中有A对象；</li><li>对A对象进行属性赋值，发现要注入B对象，然后去获取B对象</li><li>从一级缓存中取B对象，如果为空并且不是正在创建状态就加锁再次尝试从一级缓存中获取（由于此时获取锁为同一线程可重入），如果还是没有则进行创建；</li><li>标记B对象正在创建（放入set中），把A对象完成实例化，此时没有完成初始化；</li><li>往三级缓存中放入一个函数接口（用于其他对象依赖A对象时动态代理生成B对象并注入），此时三级缓存中有A、B对象；</li><li>对B对象进行属性赋值，发现要注入A对象，然后去获取A对象；</li><li>此时一级缓存没有，但是A对象正在创建，然后加锁（此时加锁是为了防止其他线程获取半成品对象）从二级缓存中取，<strong>没有就从三级缓存中取回调函数调用动态代理生成对象，取到后放入二级缓存中并从三级缓存中去除</strong>，此时二级缓存中有A对象，三级缓存中有B对象；</li><li>然后把A对象注入到B对象，B对象初始化完成，撤销B对象的正在缓存标记，加锁把B放入一级缓存从二三级缓存中去除，此时二级缓存中有A对象，三级缓存中没有对象；</li><li>此时能取到B对象，然后把B对象注入A对象中，A初始化完成，把A放入一级缓存从二三级缓存移除；</li><li>完成A对象、B对象创建；</li></ol><h3 id="多线程环境下加锁原因"><a href="#多线程环境下加锁原因" class="headerlink" title="多线程环境下加锁原因"></a>多线程环境下加锁原因</h3><p>防止多线程情况下，一个线程在实例化Bean后，未初始化前，其他线程拿到不完整的Bean。</p><h3 id="二级缓存的意义"><a href="#二级缓存的意义" class="headerlink" title="二级缓存的意义"></a>二级缓存的意义</h3><p>​如果只有一级缓存，那么完整Bean和不完整Bean都放在一级缓存中，并发情况下，有可能取到半成品（未属性赋值、初始化），属性都是null。<br>​二级缓存只要是为了分离完整Bean和不完整Bean（未属性赋值、初始化）的存放， 防止多线程中在Bean还未创建完成时读取到的Bean时不完整的。所以也是为了保证我们getBean是完整最终的Bean，不会出现不完整的情况。</p><h3 id="三级缓存的意义"><a href="#三级缓存的意义" class="headerlink" title="三级缓存的意义"></a>三级缓存的意义</h3><p>主要用来<strong>去生成原始对象进行了 AOP之后得到的代理对象，</strong>方法职责单一、方便后期维护。</p><h3 id="构造函数循环依赖问题"><a href="#构造函数循环依赖问题" class="headerlink" title="构造函数循环依赖问题"></a>构造函数循环依赖问题</h3><ul><li><strong>Spring没有解决构造函数的循环依赖</strong></li><li>解决循环依赖主要是三级缓存的实现（三个Map），在Bean调用构造器实例化之前，三级缓存（三个Map）并没有Bean的任何相关信息，在实例化之后才放入三级缓存中，因此当getBean的时候缓存并没有命中，这样就抛出了循环依赖的异常了。</li></ul><h3 id="多例Bean循环依赖问题"><a href="#多例Bean循环依赖问题" class="headerlink" title="多例Bean循环依赖问题"></a>多例Bean循环依赖问题</h3><ul><li>单例Bean：我们是从一级缓存中获取Bean，只需要创建一次对象，后面就可以从缓存中取出来；</li><li>多例Bean：每次都要去创建对象，无法利用缓存，就无法解决循环依赖问题；</li></ul><h3 id="BeanFactory和FactoryBean的区别"><a href="#BeanFactory和FactoryBean的区别" class="headerlink" title="BeanFactory和FactoryBean的区别"></a>BeanFactory和FactoryBean的区别</h3><p><strong>BeanFactory</strong></p><p>​BeanFactory是个Factory，也就是IOC容器或对象工厂，  BeanFactory定义了IOC容器的最基本形式，并提供了IOC容器应遵守的的最基本的接口，也就是Spring IOC所遵守的最底层和最基本的编程规范。在Spring代码中，BeanFactory只是个接口，并不是IOC容器的具体实现，但是Spring容器给出了很多种实现，如 DefaultListableBeanFactory、XmlBeanFactory、ApplicationContext等，都是附加了某种功能的实现。</p><p>BeanFactory和ApplicationContext是Spring中的两种容器。</p><p>BeanFactory默认采用延迟初始化策略，所以相对来说，容器启动较快，所需资源不多。<br> ApplicationContext间接继承自BeanFactory，增加国际化等高级功能，其管理的对象在容器启动后默认全部初始化完成，所以启动所需要资源较多，所需时间长。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanFactory</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">FACTORY_BEAN_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;&amp;&quot;</span>;</span><br><span class="line">    <span class="comment">// 返回bean</span></span><br><span class="line">    Object <span class="title function_">getBean</span><span class="params">(String var1)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">    &lt;T&gt; T <span class="title function_">getBean</span><span class="params">(String var1, Class&lt;T&gt; var2)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">    Object <span class="title function_">getBean</span><span class="params">(String var1, Object... var2)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">    &lt;T&gt; T <span class="title function_">getBean</span><span class="params">(Class&lt;T&gt; var1)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">    &lt;T&gt; T <span class="title function_">getBean</span><span class="params">(Class&lt;T&gt; var1, Object... var2)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">containsBean</span><span class="params">(String var1)</span>;</span><br><span class="line">    <span class="comment">// 是否是单例bean</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">(String var1)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line">    <span class="comment">// 是否是原型bean</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isPrototype</span><span class="params">(String var1)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isTypeMatch</span><span class="params">(String var1, ResolvableType var2)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isTypeMatch</span><span class="params">(String var1, Class&lt;?&gt; var2)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line">    <span class="comment">// bean的类</span></span><br><span class="line">    Class&lt;?&gt; getType(String var1) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line">    <span class="comment">// bean的别名，XML种的id</span></span><br><span class="line">    String[] getAliases(String var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="BeanFactory使用场景"><a href="#BeanFactory使用场景" class="headerlink" title="BeanFactory使用场景"></a>BeanFactory使用场景</h4><ul><li>从Ioc容器中获取Bean(byName or byType)</li><li>检索Ioc容器中是否包含指定的Bean</li><li>判断Bean是否为单例</li></ul><p>实际上，BeanFactory只负责定义如何访问查看容器内Bean的状态，那么Bean从哪里来的呢？这些比较复杂的问题就交给底下人去办好啦，DefaultListableBeanFactory是BeanFactory的一个间接子类，它实现了BeanFactory的一个子接口。同时，他还实现了BeanDefinitionRegistry，这个接口定义了Bean的注册逻辑。</p><p>这里首先要知道Bean在容器中的形式是BeanDefinition，BeanDefinition实例中包括了对象的所有信息，当被注入类向容器请求依赖对象时候，BeanFactory就会通过对应BeanDefinition中的信息返回一个实例。</p><p>可以把BeanFactory看成是图书馆，BeanDefinitionRegistry就是图书馆里边的书架，书就在书架上存放着，这里也就要求我们的图书馆只能有一个书架。每个BeanDefinition都要被放在BeanDefinitionRegistry中才能被容器管理。</p><p>至于BeanDefinition，一般是通过BeanDefinitionReader读取配置文件并映射成对应的BeanDefinition来生成的。</p><p>​一般情况下，Spring通过反射机制利用<bean>的class属性指定实现类实例化Bean，FactoryBean就是个Bean。在Spring中，所有的Bean都是由BeanFactory（IOC容器）来进行管理的。FactoryBean是一个能生产或者修饰对象生成的工厂Bean，我们可以通过实现该接口来定制实例化Bean的逻辑。</bean></p><p><strong>FactoryBean</strong></p><p>​BeanFactory和FactoryBean都可以用来创建对象，只不过创建的流程和方式不同，当使用BeanFactory的时候，必须要严格的遵守bean的生命周期，经过一系列繁杂的步骤之后可以创建出单例对象，<strong>是流水线式的创建过程</strong>，而FactoryBean是用户可以自定义bean对象的创建流程，不需要按照bean的生命周期来创建，它生成的以及提供给容器管理的正是它的getObject()方法所返回的bean，在此接口中包含了三个方法：<br>​isSingleton:判断是否是单例对象</p><p>​getObjectType:获取对象的类型<br>​getObject:在此方法中可以自己创建对象，<strong>使用new的方式或者使用代理的方式都可以，用户可以按照自己的需要随意去创建对象</strong>，在很多框架继承的时候都会实现FactoryBean接口，比如Feign</p><h4 id="FactoryBean使用场景"><a href="#FactoryBean使用场景" class="headerlink" title="FactoryBean使用场景"></a>FactoryBean使用场景</h4><p>​FactoryBean在Spring中最为典型的一个应用就是用来创建AOP的代理对象。</p><p>​我们知道AOP实际上是Spring在运行时创建了一个代理对象，也就是说这个对象，是我们在运行时创建的，而不是一开始就定义好的，这很符合工厂方法模式。更形象地说，AOP代理对象通过Java的反射机制，在运行时创建了一个代理对象，在代理对象的目标方法中根据业务要求织入了相应的方法。这个对象在Spring中就是——ProxyFactoryBean。</p><p>​所以，FactoryBean为我们实例化Bean提供了一个更为灵活的方式，我们可以通过FactoryBean创建出更为复杂的Bean实例。、</p><p><strong>举例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>,<span class="string">&quot;FactoryBeanValue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> User.class;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// setter // getter // constructor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上边这个User实现FactoryBean，可以用来生产名字为 FactoryBeanValue的user，接着把这个工厂Bean交给Spring管理。假设我们接着向容器中注册另一个user：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">config</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">100</span>,<span class="string">&quot;OurUser&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest(classes = SpringdemoApplication.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span>  User user;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tt</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(user.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：FactoryBeanValue</span><br></pre></td></tr></table></figure><p>最后可以看到，容器提供的user的名字其实还是FactoryBeanValue，即我们的工厂bean中提供的，<strong>因为我们从工厂方法中获得的bean一定是从getObject()这个方法中获得的</strong></p><p><strong>BeanFactory是容器，而FactoryBean则是工厂Bean，帮助我们定制实例化Bean，其实这何尝不是代理模式的一个应用，我们可以在getObject()那里再加一些别的逻辑，相当于搞了一层代理~</strong></p><p>参考：<a href="https://blog.csdn.net/weixin_43738764/article/details/124966670">https://blog.csdn.net/weixin_43738764/article/details/124966670</a></p><p>​<a href="https://blog.csdn.net/xujingyiss/article/details/119683335">https://blog.csdn.net/xujingyiss/article/details/119683335</a></p><h2 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h2><p>ApplicationContext代表IOC容器，在SpringIOC容器中读取Bean配置创建Bean实例之前，必须对它进行实例化，只有在容器实例化后才可以从IOC容器里获取Bean实例并使用。</p><p><strong>Spring IOC容器实现方式</strong></p><p>Spring 提供了两种类型的IOC容器实现：</p><ul><li><p><strong>BeanFactory</strong>：IOC容器的基本实现。</p></li><li><p><strong>ApplicationContext</strong>：提供了更多的高级特性，是BeanFactory的子接口。</p></li></ul><p>ApplicationContext主要实现类<strong>：</strong></p><ul><li><p><strong>ClassPathXmlApplicationContext</strong>：可以加载类路径下的配置文件，要求配置文件必须在类路径之下。</p></li><li><p><strong>FileSystemXmlApplicationContext</strong>：可以加载磁盘中任意路径下的配置文件，要求具有访问权限。</p></li><li><p><strong>AnnotationConfigApplicationContext</strong>：该类继承自 GenericApplicationContext ，提供了注解配置（例如：@Configuration、@Component等）和类路径扫描（scan方法）的支持。，用于读取注解创建容器。</p></li></ul><p><strong>getBeansOfType</strong>。可通过接口获取其实现类（前提是这些实现类由spring容器管理）</p><p>采用ApplocationContext和getBeansOfType可以根据不同的业务类型切换接口的实现列，使用getBeansOfType取出所有的接口实现类存入Map中，使用的时候根据业务名字来取出实现示例就可以。</p>]]></content>
      
      
      <categories>
          
          <category> Java框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringIOC源码详解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot常用注解</title>
      <link href="/2022/09/25/SpringBoot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"/>
      <url>/2022/09/25/SpringBoot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Web-MVC-注解"><a href="#Spring-Web-MVC-注解" class="headerlink" title="Spring Web MVC 注解"></a>Spring Web MVC 注解</h2><h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a><strong>@RequestMapping</strong></h3><p>@RequestMapping注解的主要用途是将Web请求与请求处理类中的方法进行映射。Spring MVC和Spring WebFlux都通过<code>RquestMappingHandlerMapping</code>和<code>RequestMappingHndlerAdapter</code>两个类来提供对@RequestMapping注解的支持。</p><p><code>@RequestMapping</code>注解对请求处理类中的请求处理方法进行标注；<code>@RequestMapping</code>注解拥有以下的六个配置属性：</p><span id="more"></span><ul><li><code>value</code>:映射的请求URL或者其别名</li><li><code>method</code>:兼容HTTP的方法名</li><li><code>params</code>:根据HTTP参数的存在、缺省或值对请求进行过滤</li><li><code>header</code>:根据HTTP Header的存在、缺省或值对请求进行过滤</li><li><code>consume</code>:设定在HTTP请求正文中允许使用的媒体类型</li><li><code>product</code>:在HTTP响应体中允许使用的媒体类型</li></ul><p>提示：在使用@RequestMapping之前，请求处理类还需要使用@Controller或@RestController进行标记</p><p>@RequestMapping还可以对类进行标记，这样类中的处理方法在映射请求路径时，会自动将类上@RequestMapping设置的value拼接到方法中映射路径之前，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/home&quot;,method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">home</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/home&quot;</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a><strong>@RequestBody</strong></h3><p>​@RequestBody在处理请求方法的参数列表中使用，它可以将请求主体中的参数绑定到一个对象中，请求主体参数是通过<code>HttpMessageConverter</code>传递的，根据请求主体中的参数名与对象的属性名进行匹配并绑定值。此外，还可以通过@Valid注解对请求主体中的参数进行校验。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot; /api/v1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/users&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">createUser</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.save(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="GetMapping"><a href="#GetMapping" class="headerlink" title="@GetMapping"></a><strong>@GetMapping</strong></h3><p><code>GetMapping</code>注解用于处理HTTP GET请求，并将请求映射到具体的处理方法中。具体来说，@GetMapping是一个组合注解，它相当于是<code>@RequestMapping(method=RequestMethod.GET)</code>的快捷方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot; /api/v1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/users&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAllUser</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;User&gt; users = userService.findAll();</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PostMapping"><a href="#PostMapping" class="headerlink" title="@PostMapping"></a><strong>@PostMapping</strong></h3><p><code>@PostMapping</code>注解用于处理HTTP POST请求，并将请求映射到具体的处理方法中。@PostMapping与@GetMapping一样，也是一个组合注解，它相当于是<code>@RequestMapping(method=HttpMethod.POST)</code>的快捷方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot; /api/v1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/users&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">createUser</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.save(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DeleteMapping"><a href="#DeleteMapping" class="headerlink" title="@DeleteMapping"></a><strong>@DeleteMapping</strong></h3><p>@DeleteMapping(“&#x2F;users&#x2F;{userId}”)等价@RequestMapping(value&#x3D;”&#x2F;users&#x2F;{userId}”,method&#x3D;RequestMethod.DELETE)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DeleteMapping(&quot;/users/&#123;userId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity <span class="title function_">deleteUser</span><span class="params">(<span class="meta">@PathVariable(value = &quot;userId&quot;)</span> Long userId)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PatchMapping"><a href="#PatchMapping" class="headerlink" title="@PatchMapping"></a><strong>@PatchMapping</strong></h3><p>一般实际项目中，我们都是 PUT 不够用了之后才用 PATCH 请求去更新数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@PatchMapping(&quot;/profile&quot;)</span>  </span><br><span class="line">  <span class="keyword">public</span> ResponseEntity <span class="title function_">updateStudent</span><span class="params">(<span class="meta">@RequestBody</span> StudentUpdateRequest studentUpdateRequest)</span> &#123;        </span><br><span class="line">studentRepository.updateDetail(studentUpdateRequest);        </span><br><span class="line"><span class="keyword">return</span> ResponseEntity.ok().build();    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a><strong>@PathVariable</strong></h3><p><code>@PathVariable</code>注解是将方法中的参数<strong>绑定到请求URI中的模板变量上</strong>。可以通过<code>@RequestMapping</code>注解来指定URI的模板变量，然后使用<code>@PathVariable</code>注解将方法中的参数绑定到模板变量上。</p><p>特别地，<code>@PathVariable</code>注解允许我们<strong>使用value或name属性来给参数取一个别名</strong>。下面是使用此注解的一个示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/users/&#123;id&#125;/roles/&#123;roleId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Role <span class="title function_">getUserRole</span><span class="params">(<span class="meta">@PathVariable(name=&quot;id&quot; )</span><span class="type">long</span> id,<span class="meta">@PathVariable(value=&quot;roleId&quot;)</span><span class="type">long</span> roleId)</span><span class="keyword">throws</span> ResourceNotFoundException&#123;</span><br><span class="line"><span class="keyword">return</span> userRoleService.findByUserIdAndRoleId(id,roleId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板变量名需要使用<code>&#123; &#125;</code>进行包裹，如果方法的参数名与URI模板变量名一致，则在<code>@PathVariable</code>中就可以省略别名的定义。如果参数是一个非必须的，可选的项，则可以在<code>@PathVariable</code>中设置<code>require = false</code></p><h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a><strong>@RequestParam</strong></h3><p>注解用于将方法的参数与Web请求的传递的参数进行绑定.</p><p>该注解的其他属性配置与<code>@PathVariable</code>的配置相同，特别的，如果传递的参数为空，还可以通过defaultValue设置一个默认值。示例代码如下</p><p>@RequestParam</p><p>String a &#x3D;request.getParameter(“a”)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据id查询一个数据 get请求</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/getById&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;?&gt; getById(<span class="meta">@RequestParam</span> String id) &#123;</span><br><span class="line">    <span class="keyword">return</span> Result.success(dataProMapper.selectById(id));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a><strong>@ResponseBody</strong></h3><p>作用是<strong>将controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON数据或者是XML数据</strong>，需要注意的呢，在使用此注解之后不会再走视图处理器，而是直接将数据写入到输入流中，他的效果等同于通过response对象输出指定格式的数据。特别的，<code>@ResponseBody</code>注解<strong>只能用在被<code>@Controller</code>注解标记的类中。如果在被<code>@RestController</code>标记的类中，则方法不需要使用<code>@ResponseBody</code>注解进行标注。</strong><code>@RestController</code>相当于是<code>@Controller</code>和<code>@ResponseBody</code>的组合注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@GetMaping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">findByUserId</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">long</span> id)</span> <span class="keyword">public</span> User <span class="title function_">findByUserId</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">long</span> id )</span><span class="keyword">throws</span> UserNotFoundException&#123;</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findone( id);</span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a><strong>@Controller</strong></h3><p><code>@Controller</code>是<code>@Component</code>注解的一个延伸，Spring 会自动扫描并配置被该注解标注的类。此注解用于标注Spring MVC的控制器。</p><h3 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a><strong>@RestController</strong></h3><p><code>@RestController</code>是在Spring 4.0开始引入的，这是一个特定的控制器注解。此注解相当于<code>@Controller</code>和<code>@ResponseBody</code>的快捷方式。当使用此注解时，不需要再在方法上使用<code>@ResponseBody</code>注解。</p><h3 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a><strong>@ModelAttribute</strong></h3><p>通过此注解，可以通过模型索引名称来访问已经存在于控制器中的model。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping( &quot;/users&quot; )</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUser</span><span class="params">(<span class="meta">@ModelAttribute( &quot;user&quot; )</span> User user)</span>&#123;</span><br><span class="line">userService.save(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中括号中的为参数名的索引名称，如果参数名与模型具有相同的名字，则括号的内容可以省略。在Spring调用具体的处理方法之前，被<code>@ModelAttribute</code>注解标注的所有方法都将被执行。</p><h3 id="CrossOrigin"><a href="#CrossOrigin" class="headerlink" title="@CrossOrigin"></a><strong>@CrossOrigin</strong></h3><p><code>@CrossOrigin</code>注解将为请求处理类或请求处理方法提供跨域调用支持。如果我们将此注解标注类，那么类中的所有方法都将获得支持跨域的能力。使用此注解的好处是可以微调跨域行为。</p><h2 id="Spring-Bean-注解"><a href="#Spring-Bean-注解" class="headerlink" title="Spring Bean 注解"></a>Spring Bean 注解</h2><h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a><strong>@ComponentScan</strong></h3><p><code>@ComponentScan</code>注解用于配置Spring需要扫描的被组件注解注释的类所在的包。可以通过配置其basePackages属性或者value属性来配置需要扫描的包路径。value属性是basePackages的别名。</p><h3 id="Component"><a href="#Component" class="headerlink" title="@Component"></a><strong>@Component</strong></h3><p>@Component注解用于标注一个普通的组件类，它没有明确的业务范围，只是通知Spring被此注解的类需要被纳入到Spring Bean容器中并进行管理。</p><h3 id="Service"><a href="#Service" class="headerlink" title="@Service"></a><strong>@Service</strong></h3><p><code>@Service</code>注解是<code>@Component</code>的一个延伸（特例），它用于标注业务逻辑类。与<code>@Component</code>注解一样，被此注解标注的类，会自动被Spring所管理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    User <span class="title function_">createUser</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service(&quot;userService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">createUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.save(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">createUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.createUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@Repository</strong></p><p><code>@Repository</code>注解也是<code>@Component</code>注解的延伸，与<code>@Component</code>注解一样，被此注解标注的类会被Spring自动管理起来，<code>@Repository</code>注解用于标注DAO层的数据持久化类。</p><h2 id="Spring-Dependency-Inject注解"><a href="#Spring-Dependency-Inject注解" class="headerlink" title="Spring Dependency Inject注解"></a>Spring Dependency Inject注解</h2><h3 id="DependsOn"><a href="#DependsOn" class="headerlink" title="@DependsOn"></a><strong>@DependsOn</strong></h3><p><code>@DependsOn</code>注解可以配置Spring IoC容器在初始化一个Bean之前，先初始化其他的Bean对象。下面是此注解使用示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstBean</span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SecondBean secondBean;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ThirdBean thirdBean;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FirstBean</span><span class="params">()</span>&#123; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecondBean</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SecondBean</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThirdBean</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThirdBean</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomBeanConfig</span>&#123;</span><br><span class="line">    <span class="meta">@Bean( &quot;firstBean&quot;)</span></span><br><span class="line">    <span class="meta">@Dependson(value=&#123; &quot;secondBean&quot;,&quot;thirdBean&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> FirstBean <span class="title function_">firstBean</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FirstBean</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean(&quot;secondBean&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> SecondBean <span class="title function_">secondBean</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SecondBean</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean( &quot;thirdBean&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ThirdBean <span class="title function_">thirdBean</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThirdBean</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a><strong>@Bean</strong></h3><p>@Bean注解主要的作用是告知Spring，被此注解所标注的类将需要纳入到Bean管理工厂中。@Bean注解的用法很简单。</p><h3 id="Lazy注解"><a href="#Lazy注解" class="headerlink" title="@Lazy注解"></a>@Lazy注解</h3><p>@Lazy注解用于标识bean是否需要延迟加载。</p><p><strong>单实例Bean，默认在容器启动的时候创建对象。</strong></p><p><strong>懒加载：容器启动不创建对象，第一次使用（获取）Bean创建对象，并初始化</strong></p><h3 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a><strong>@Scope</strong></h3><p>@Scope注解可以用来定义@Component标注的类的作用范围以及@Bean所标记的类的作用范围。@Scope所限定的作用范围有：<code>singleton</code>、<code>prototype</code>、<code>request</code>、<code>session</code>、<code>globalSession</code>或者其他的自定义范围。这里以prototype为例子进行讲解。</p><p>当一个Spring Bean被声明为prototype（原型模式）时，<strong>在每次需要使用到该类的时候，Spring IoC容器都会初始化一个新的改类的实例。</strong>在定义一个Bean时，可以设置Bean的scope属性为<code>prototype：scope=“prototype”</code>,也可以使用@Scope注解设置，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope(value=ConfigurableBeanFactory. SCOPE_PROPTOTYPE)</span></span><br></pre></td></tr></table></figure><p><strong>@Scope 单例模式</strong></p><p>当@Scope的作用范围设置成Singleton时，被此注解所标注的类只会被Spring IoC容器初始化一次。<strong>在默认情况下，Spring IoC容器所初始化的类实例都为singleton</strong>。</p><h3 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h3><p>@Autowired注解用于标记Spring将要解析和注入的依赖项。<strong>此注解可以作用在构造函数、字段（fileid注入方式）和setter方法上</strong>。</p><h3 id="Primary"><a href="#Primary" class="headerlink" title="@Primary"></a>@Primary</h3><p>当系统中需要配置多个具有相同类型的bean时，@Primary可以定义这些Bean的优先级。下面将给出一个实例代码来说明这一特性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Messageservice</span> &#123;</span><br><span class="line">string <span class="title function_">sendMessage</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailMessageserviceImpl</span> <span class="keyword">implements</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> string <span class="title function_">sendMessage</span><span class="params">(o)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;this is send email method message.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WechatMessageImpl</span> <span class="keyword">implements</span> <span class="title class_">Messageservice</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> string <span class="title function_">sendMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;this is send wechat method message.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Primary</span> <span class="comment">//相同类型的Bean优先注入当前实现</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DingDingMessageImple</span> <span class="keyword">implements</span> <span class="title class_">Messageservice</span>&#123;</span><br><span class="line">    @0verride</span><br><span class="line">    <span class="keyword">public</span> string <span class="title function_">sendMessage</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;this is send DingDing method message.&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Messagecontroller</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Messageservice messageservice;<span class="comment">//这里注入的是上面标注有@Primary的Bean</span></span><br><span class="line">    <span class="meta">@GetMapping( &quot; /info&quot; )</span></span><br><span class="line">    <span class="keyword">public</span> string <span class="title function_">info</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> messageservice.sendMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="PostConstruct与-PreDestroy"><a href="#PostConstruct与-PreDestroy" class="headerlink" title="@PostConstruct与@PreDestroy"></a>@PostConstruct与@PreDestroy</h3><p>值得注意的是，这两个注解不属于Spring,它们是源于JSR-250中的两个注解，位于<code>common-annotations.jar</code>中。@PostConstruct注解用于标注在Bean被Spring初始化之前需要执行的方法。@PreDestroy注解用于标注Bean被销毁前需要执行的方法，都是使用在定义Bean的class文件中。</p><h3 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h3><p>当系统中存在同一类型的多个Bean时，@Autowired在进行依赖注入的时候就不知道该选择哪一个实现类进行注入。此时，我们可以使用@Qualifier注解来微调，帮助@Autowired选择正确的依赖项。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">@Qualifier(&quot;emailservice&quot; )</span><br></pre></td></tr></table></figure><h2 id="Spring-Boot注解"><a href="#Spring-Boot注解" class="headerlink" title="Spring Boot注解"></a>Spring Boot注解</h2><h3 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a><strong>@SpringBootApplication</strong></h3><p><code>@SpringBootApplication</code>注解是一个快捷的配置注解，在被它标注的类中，可以定义一个或多个Bean，并自动触发自动配置Bean和自动扫描组件。此注解相当于<code>@Configuration</code>、<code>@EnableAutoConfiguration</code>和<code>@ComponentScan</code>的组合。在Spring Boot应用程序的主类中，就使用了此注解。</p><h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a><strong>@EnableAutoConfiguration</strong></h3><p>@EnableAutoConfiguration注解用于通知Spring，根据当前类路径下引入的依赖包，自动配置与这些依赖包相关的配置项。</p><h3 id="ConditionalOnClass与-ConditionalOnMissingClass"><a href="#ConditionalOnClass与-ConditionalOnMissingClass" class="headerlink" title="@ConditionalOnClass与@ConditionalOnMissingClass"></a><strong>@ConditionalOnClass与@ConditionalOnMissingClass</strong></h3><p>这两个注解属于类条件注解，它们根据是否存在某个类作为判断依据来决定是否要执行某些配置。下面是一个简单的示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ConditionalOnClass(DataSource.class)</span><br><span class="line">class MySQLAutoConfiguration &#123;</span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="1.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot常用注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring依赖注入的循环依赖</title>
      <link href="/2022/09/25/Spring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
      <url>/2022/09/25/Spring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
      
        <content type="html"><![CDATA[<h1 id="循环依赖简介"><a href="#循环依赖简介" class="headerlink" title="循环依赖简介"></a>循环依赖简介</h1><p>A对象创建时依赖了B对象，B对象创建时依赖了A对象，如下举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">       <span class="meta">@Autowired</span></span><br><span class="line">       <span class="keyword">private</span> B b;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">       <span class="meta">@Autowired</span></span><br><span class="line">       <span class="keyword">private</span> A a;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在 Spring 中，一个对象并不是简单 new 出来了，而是会经过一系列的 Bean 的生命周期，因为 Bean 的生命周期才会出现循环依赖问题。</p><span id="more"></span><h1 id="结合依赖注入的Bean-生成步骤"><a href="#结合依赖注入的Bean-生成步骤" class="headerlink" title="结合依赖注入的Bean 生成步骤"></a>结合依赖注入的Bean 生成步骤</h1><p>被 Spring 管理的对象叫做 Bean 。Bean的生成步骤如下：</p><ol><li>Spring 扫描 class 得到 BeanDefinition；</li><li>根据得到的 BeanDefinition 去生成 bean；</li><li>首先根据 class 推断构造方法；</li><li>根据推断出来的构造方法，反射，得到一个对象（暂时叫做原始对象）；</li><li>填充原始对象中的属性（依赖注入）；</li><li>如果原始对象中的某个方法被 AOP 了，那么则需要根据原始对象生成一个代理对象；</li><li>把最终生成的代理对象放入单例池（源码中叫做 singletonObjects）中，下次 getBean 时就直接从单例池拿即可；</li></ol><p>上面例子中的依赖注入过程中A 类存在一个 B 类的 b 属性，所以，当 A 类生成了一个原始对象之后，就会去给 b 属性去赋值，此时就会根据 b 属性的类型和属性名去 BeanFactory 中去获取 B 类所对应的单例bean。</p><ol><li>如果此时 BeanFactory 中存在 B 对应的 Bean，那么直接拿来赋值给 b 属性；</li><li>如果此时 BeanFactory 中不存在 B 对应的 Bean，则需要生成一个 B 对应的 Bean，然后赋值给 b属性。</li></ol><p>但是如果此时 B 类在 BeanFactory 中还没有生成对应的 Bean，那么就需要去生成，就会经过 B 的 Bean 的生命周期。那么在创建 B 类的 Bean 的过程中，如果 B 类中存在一个 A 类的 a 属性，那么在创建 B 的 Bean 的过程中就需要 A 类对应的 Bean，但是，触发 B 类 Bean 的创建的条件是 A 类 Bean 在创建过程中的依赖注入，所以这里就出现了循环依赖：</p><p><strong>从而导致 A Bean 创建不出来，B Bean 也创建不出来。</strong></p><h1 id="三级缓存解决部分循环依赖问题"><a href="#三级缓存解决部分循环依赖问题" class="headerlink" title="三级缓存解决部分循环依赖问题"></a>三级缓存解决部分循环依赖问题</h1><p>在 Spring 中，通过三级缓存机制帮开发者解决了部分循环依赖的问题。</p><ul><li><strong>一级缓存为</strong>：singletonObjects；</li><li><strong>二级缓存为</strong>：earlySingletonObjects；</li><li><strong>三级缓存为</strong>：singletonFactories；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Cache of singleton objects: bean name –&gt; bean instance */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Map</span> <span class="variable">singletonObjects</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name –&gt; ObjectFactory */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name –&gt; bean instance */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Map</span> <span class="variable">earlySingletonObjects</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>(<span class="number">16</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>「singletonObjects」中缓存的是已经经历了完整生命周期的bean对象。</p><p>「earlySingletonObjects」比 singletonObjects 多了一个 early ，表示缓存的是早期的 bean对象。早期指的是 Bean 的生命周期还没走完就把这个 Bean 放入了 earlySingletonObjects。</p><p>「singletonFactories」中缓存的是 ObjectFactory，表示对象工厂，用来创建某个对象的。</p><p><strong>解决循环依赖问题原理：</strong></p><p>​A 的 Bean 在创建过程中，在进行依赖注入之前，先把 A 的原始 Bean 放入缓存（提早暴露，只要放到缓存了，其他 Bean 需要时就可以从缓存中拿了），放入缓存后，再进行依赖注入，此时 A 的Bean 依赖了 B 的 Bean 。</p><p>​如果 B 的 Bean 不存在，则需要创建 B 的 Bean，而创建 B 的 Bean 的过程和 A 一样，也是先创建一个 B 的原始对象，然后把 B 的原始对象提早暴露出来放入缓存中，然后在对 B 的原始对象进行依赖注入 A，此时能从缓存中拿到 A 的原始对象（虽然是 A 的原始对象，还不是最终的 Bean），B 的原始对象依赖注入完了之后，B 的生命周期结束，那么 A 的生命周期也能结束。</p><p>​因为整个过程中，都只有一个 A 原始对象，所以对于 B 而言，就算在属性注入时，注入的是 A 原始对<br>象，也没有关系，因为A 原始对象在后续的生命周期中在堆中没有发生变化。</p><h2 id="带有AOP的循环依赖问题："><a href="#带有AOP的循环依赖问题：" class="headerlink" title="带有AOP的循环依赖问题："></a>带有AOP的循环依赖问题：</h2><p>​如果 A 的原始对象注入给 B 的属性之后，<strong>A 的原始对象进行了 AOP 产生了一个代理对象</strong>，此时就会出现，对于 A 而言，它的 Bean 对象其实应该是 AOP 之后的代理对象，而 B 的 a 属性对应的并不是 AOP 之后的代理对象，这就产生了冲突。</p><p><strong>B 依赖的 A 和最终的 A 不是同一个对象。</strong></p><p>在一个 Bean 的生命周期最后，Spring提供了 BeanPostProcessor 可以去对 Bean 进行加工，这个加工不仅仅只是能修改 Bean 的属性值，也可以替换掉当前 Bean 。</p><p>在BeanPostProcessor 中可以完全替换掉某个 beanName 对应的 bean 对象。</p><p>而 BeanPostProcessor 的执行在 Bean 的生命周期中是处于属性注入之后的，循环依赖是发生在属性注入过程中的，所以很有可能导致，注入给 B 对象的 A 对象和经历过完整生命周期之后的 A 对象，不是一个对象。这就是有问题的。</p><h2 id="AOP-Bean注入原理："><a href="#AOP-Bean注入原理：" class="headerlink" title="AOP Bean注入原理："></a>AOP Bean注入原理：</h2><p>​AOP 就是通过一个 BeanPostProcessor 来实现的，在 Spring 中 AOP 利用的要么是 JDK 动态代理，要么 CGLib 的动态代理，所以如果给一个类中的某个方法设置了切面，那么这个类最终就需要生成一个代理对象。</p><p>​一般过程就是：A 类—&gt;生成一个普通对象–&gt;属性注入–&gt;基于切面生成一个代理对象–&gt;把代理对象<br>放入 singletonObjects 单例池中。<br><img src="1.jpg"></p><p>​所以在这种情况下的循环依赖，Spring 是解决不了循环依赖问题的，因为在属性注入时，Spring 也不知道 A 对象后续会经过哪些 BeanPostProcessor 以及会对 A 对象做什么处理。</p><h2 id="如何解决AOP下的循环依赖问题："><a href="#如何解决AOP下的循环依赖问题：" class="headerlink" title="如何解决AOP下的循环依赖问题："></a>如何解决AOP下的循环依赖问题：</h2><p>​首先，<strong>singletonFactories 中存的是某个 beanName 对应的 ObjectFactory，在 bean 的生命周期中，生成完原始对象之后，就会构造一个 ObjectFactory 存入 singletonFactories 中。</strong></p><p><img src="2.jpg"></p><p>​这个 ObjectFactory 是一个函数式接口，支持Lambda表达式：() -&gt;getEarlyBeanReference(beanName, mbd, bean)</p><p>​上面的Lambda表达式就是一个ObjectFactory，执行该Lambda表达式就会去执行getEarlyBeanReference方法.</p><p>图中的 ObjectFactory 就是上文说的 labmda 表达式，中间有 getEarlyBeanReference 方法。</p><p>注意存入 singletonFactories 时并不会执行 lambda 表达式，也就是不会执行getEarlyBeanReference 方法。</p><p>从 singletonFactories 根据 beanName 得到一个 ObjectFactory ，然后执行 ObjectFactory ，也就是执行 getEarlyBeanReference 方法，此时会得到一个 A 原始对象经过 AOP 之后的代理对象，然后把该代理对象放入 earlySingletonObjects 中。</p><p>此时并没有把代理对象放入 singletonObjects 中，那什么时候放入到 singletonObjects 中呢？</p><p>此时，我们只得到了 A 原始对象的代理对象，这个对象还不完整，因为 A 原始对象还没有进行属性填充，所以此时不能直接把A的代理对象放入 singletonObjects 中，所以只能把代理对象放入earlySingletonObjects 。</p><p>假设现在有其他对象依赖了 A，那么则可以从 earlySingletonObjects 中得到 A 原始对象的代理对象了，并且是A的同一个代理对象。</p><p>当 B 创建完了之后，A 继续进行生命周期，而 A 在完成属性注入后，会按照它本身的逻辑去进行AOP，而此时我们知道 A 原始对象已经经历过了 AOP ，所以对于 A 本身而言，不会再去进行 AOP了，那么怎么判断一个对象是否经历过了 AOP 呢？</p><p>会利用上文提到的 earlyProxyReferences，在 AbstractAutoProxyCreator 的 postProcessAfterInitialization 方法中，会去判断当前 beanName 是否<br>在 earlyProxyReferences，如果在则表示已经提前进行过 AOP了，无需再次进行 AOP。</p><p>对于 A 而言，进行了 AOP 的判断后，以及 BeanPostProcessor 的执行之后，就需要把 A 对应的对象放入 singletonObjects 中了，但是我们知道，应该是要 A 的代理对象放入 singletonObjects 中，所以此时需要从 earlySingletonObjects 中得到代理对象，然后入 singletonObjects 中。</p><p>至此，整个循环依赖解决完毕。</p><h2 id="总结一下三级缓存："><a href="#总结一下三级缓存：" class="headerlink" title="总结一下三级缓存："></a>总结一下三级缓存：</h2><ol><li>「singletonObjects」：缓存某个 beanName 对应的经过了完整生命周期的bean；</li><li>「earlySingletonObjects」：缓存提前拿原始对象进行了 AOP 之后得到的代理对象，原始对象还没有进行属性注入和后续的 BeanPostProcessor后置处理器增强器等生命周期；</li><li>「singletonFactories」：缓存的是一个 ObjectFactory ，主要用来<strong>去生成原始对象进行了 AOP之后得到的「代理对象」</strong>，在每个 Bean 的生成过程中，都会提前暴露一个工厂，这个工厂可能用到，也可能用不到，如果没有出现循环依赖依赖本 bean，那么这个工厂无用，本 bean 按照自己的生命周期执行，执行完后直接把本 bean 放入 singletonObjects 中即可，如果出现了循环依赖依赖了本 bean，则另外那个 bean 执行 ObjectFactory 提交得到一个 AOP 之后的代理对象（如果有 AOP 的话，如果无需 AOP ，则直接得到一个原始对象）。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring循环依赖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring介绍</title>
      <link href="/2022/09/23/Spring%E4%BB%8B%E7%BB%8D/"/>
      <url>/2022/09/23/Spring%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Spring-MVC-Spring-Boot-之间的关系"><a href="#Spring-Spring-MVC-Spring-Boot-之间的关系" class="headerlink" title="Spring,Spring MVC,Spring Boot 之间的关系"></a>Spring,Spring MVC,Spring Boot 之间的关系</h1><p>​Spring是一个开源容器框架，可以接管web层，业务层，dao层，持久层的组件，并且可以配置各种bean,和维护bean与bean之间的关系。其核心就是控制反转(IOC),和面向切面(AOP),简单的说就是一个分层的轻量级开源框架。Spring 包含了多个功能模块，其中最重要的是 Spring-Core（主要提供 IoC 依赖注入功能的支持） 模块， Spring 中的其他模块（比如 Spring MVC）的功能实现基本都需要依赖于该模块。</p><p>​Spring MVC 是 Spring 中的一个很重要的模块，主要赋予 Spring 快速构建 MVC 架构的 Web 程序的能力。MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。</p><p>​Spring Boot延续了spring框架的核心思想IOC和AOP，简化了Spring应用的创建、运行、调试、部署等，使用开发者可以专注于Spring应用的开发，而无需过多关注XML的配置。 </p><span id="more"></span><h1 id="Spring-IOC和AOP"><a href="#Spring-IOC和AOP" class="headerlink" title="Spring IOC和AOP"></a>Spring IOC和AOP</h1><p><strong>IoC（Inverse of Control:控制反转）</strong> 是一种设计思想，就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。由 IoC 容器完成对象的注入。IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件&#x2F;注解即可，完全不用考虑对象是如何被创建出来的。</p><p><strong>AOP（Aspect Oriented Programing）</strong>是面向切面编程思想，它可以统一解决一批组件的共性需求（如权限检查、记录日志、事务管理等）。在AOP思想下，我们可以将解决共性需求的代码独立出来，然后通过配置的方式，声明这些代码在什么地方、什么时机调用。当满足调用条件时，AOP会将该业务代码织入到我们指定的位置，从而统一解决了问题，又不需要修改这一批组件的代码。</p><p><strong>切</strong> ：指的是横切逻辑，原有业务逻辑代码不动，只能操作横切逻辑代码，所以面向横切逻辑</p><p><strong>面</strong> ：横切逻辑代码往往要影响的是很多个方法，每个方法如同一个点，多个点构成一个面。</p><h1 id="Spring容器简介"><a href="#Spring容器简介" class="headerlink" title="Spring容器简介"></a>Spring容器简介</h1><p>Spring主要提供了两种类型的容器：BeanFactory和ApplicationContext。</p><ul><li>BeanFactory：是基础类型的IoC容器，提供完整的IoC服务支持。如果没有特殊指定，默认采用延迟初始化策略。只有当客户端对象需要访问容器中的某个受管对象的时候，才对该受管对象进行初始化以及依赖注入操作。所以，相对来说，容器启动初期速度较快，所需要的资源有限。对于资源有限，并且功能要求不是很严格的场景，BeanFactory是比较合适的IoC容器选择。BeanFactory最主要的方法就是 getBean(String beanName)，该方法从容器中返回特定名称的Bean。</li><li>ApplicationContext：它是在BeanFactory的基础上构建的，是相对比较高级的容器实现，除了拥有BeanFactory的所有支持，ApplicationContext还提供了其他高级特性，比如事件发布、国际化信息支持等。ApplicationContext所管理的对象，在该类型容器启动之后，默认全部初始化并绑定完成。所以，相对于BeanFactory来说，ApplicationContext要求更多的系统资源，同时，因为在启动时就完成所有初始化，容 器启动时间较之BeanFactory也会长一些。在那些系统资源充足，并且要求更多功能的场景中，ApplicationContext类型的容器是比较合适的选择。</li></ul><h1 id="Spring-Bean简介"><a href="#Spring-Bean简介" class="headerlink" title="Spring Bean简介"></a>Spring Bean简介</h1><p>​Bean 代指的就是那些被 IoC 容器所管理的对象。并且，Spring中所说的Bean比JavaBean更为宽泛一些，所有可以被Spring容器实例化并管理的Java类都可以成为Bean。</p><p>​我们在使用IOC容器注入Bean时需要告诉 IoC 容器帮助我们管理哪些对象，这个是通过配置元数据来定义</p><p>的。配置元数据可以是 XML 文件、注解或者 Java 配置类。</p><h1 id="Ioc-配置的三种方式"><a href="#Ioc-配置的三种方式" class="headerlink" title="Ioc 配置的三种方式"></a>Ioc 配置的三种方式</h1><p>目前主流的配置方式主要是注解+java配置。</p><h2 id="xml-配置"><a href="#xml-配置" class="headerlink" title="xml 配置"></a>xml 配置</h2><p>将bean的信息配置.xml文件里，通过Spring加载文件为我们创建bean。这种方式出现很多早前的SSM项目中，将第三方类库或者一些配置工具类都以这种方式进行配置，主要原因是由于第三方类不支持Spring注解。</p><ul><li><strong>优点</strong>： 可以使用于任何场景，结构清晰，通俗易懂</li><li><strong>缺点</strong>： 配置繁琐，不易维护，枯燥无味，扩展性差</li></ul><p><strong>举例</strong>：</p><ol><li>配置xx.xml文件</li><li>声明命名空间和配置bean</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag"> http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- services --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;tech.pdai.springframework.service.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- more bean definitions for services go here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Java-配置"><a href="#Java-配置" class="headerlink" title="Java 配置"></a>Java 配置</h2><p>将类的创建交给我们配置的JavcConfig类来完成，Spring只负责维护和管理，采用纯Java创建方式。其本质上就是把在XML上的配置声明转移到Java配置类中。</p><ul><li><strong>优点</strong>：适用于任何场景，配置方便，因为是纯Java代码，扩展性高，十分灵活</li><li><strong>缺点</strong>：由于是采用Java类的方式，声明不明显，如果大量配置，可读性比较差</li></ul><p><strong>举例</strong>：</p><ol><li>创建一个配置类， 添加@Configuration注解声明为配置类</li><li>创建方法，方法上加上@bean，该方法用于创建实例并返回，该实例创建后会交给spring管理，方法名建议与实例名相同（首字母小写）。注：实例类不需要加任何注解</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeansConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> user dao</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;userDao&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> UserDaoImpl <span class="title function_">userDao</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> user service</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;userService&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> UserServiceImpl <span class="title function_">userService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">UserServiceImpl</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">        userService.setUserDao(userDao());</span><br><span class="line">        <span class="keyword">return</span> userService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注解配置"><a href="#注解配置" class="headerlink" title="注解配置"></a>注解配置</h3><p>通过在类上加注解的方式，来声明一个类交给Spring管理，Spring会自动扫描带有@Component，@Controller，@Service，@Repository这四个注解的类，然后帮我们创建并管理，前提是需要先配置Spring的注解扫描器。</p><ul><li><strong>优点</strong>：开发便捷，通俗易懂，方便维护。</li><li><strong>缺点</strong>：具有局限性，对于一些第三方资源，无法添加注解。只能采用XML或JavaConfig的方式配置</li></ul><p><strong>举例</strong>：</p><ol><li>对类添加@Component相关的注解，比如@Controller，@Service，@Repository</li><li>设置ComponentScan的basePackage, 比如<code>&lt;context:component-scan base-package=&#39;tech.pdai.springframework&#39;&gt;</code>, 或者<code>@ComponentScan(&quot;tech.pdai.springframework&quot;)</code>注解，或者 <code>new AnnotationConfigApplicationContext(&quot;tech.pdai.springframework&quot;)</code>指定扫描的basePackage.</li></ol><h1 id="Spring注入Bean的三种方式"><a href="#Spring注入Bean的三种方式" class="headerlink" title="Spring注入Bean的三种方式"></a>Spring注入Bean的三种方式</h1><p>​Spring 中的IOC 就是控制bean的容器，各个bean 之间会存在相互的引用，各个Bean中如何定义依赖：Spring中常见的几种注入方式主要有：setter方法注入，构造函数注入，注解注入。</p><h2 id="1-setter-方法注入"><a href="#1-setter-方法注入" class="headerlink" title="1.setter 方法注入"></a>1.setter 方法注入</h2><p>​通过setter方法，可以更改相应的对象属性。所以，当前对象只要为其<strong>依赖对象所对应的属性添加setter方法</strong>，就可以通过setter方法将相应的依赖对象设置到被注入对象中。setter方法注入虽不像构造方法注入那样，让对象构造完成后即可使用，但相对来说更宽松一些， 可以在对象构造完成后再注入。</p><p>​setter 方法注入主要是依赖于配置文件中注入，配置文件如下将userDao注入到userService中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;userService&quot;</span> class=<span class="string">&quot;com.spring.UserService&quot;</span>&gt;</span><br><span class="line">&lt;property name=<span class="string">&quot;userDao&quot;</span> ref=<span class="string">&quot;userDao&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"> </span><br><span class="line">&lt;bean id=<span class="string">&quot;userDao&quot;</span> class=<span class="string">&quot;com.spring.dao.UserDao&quot;</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>​<strong>Spring会将property中name值的每个单词首字母转换成大写，然后再在前面拼接上”set”构成一个方法名,然后去对应的类中查找该方法,通过反射调用,实现注入。</strong></p><p>Java对象代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="comment">//在当前类中添加依赖对象的set方法，在配置文件中有对应的配置会执行当前的set方法完成依赖注入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;<span class="comment">//这里必须是空参的构造方法</span></span><br><span class="line">            </span><br><span class="line"><span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注解和Java配置方式下"><a href="#注解和Java配置方式下" class="headerlink" title="注解和Java配置方式下"></a><strong>注解和Java配置方式下</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> TestService testService;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTestService</span><span class="params">(TestService testService)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.testService = testService;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-构造函数注入"><a href="#2-构造函数注入" class="headerlink" title="2.构造函数注入"></a>2.构造函数注入</h2><p>​就是被注入对象可以在它的构造方法中声明依赖对象的参数列表，让外部知道它需要哪些依赖对象。然后，IoC Service Provider会检查被注入的对象的构造方法，取得它所需要的依赖对象列表，进而为其注入相应的对象。构造方法注入方式比较直观，对象被构造完成后，即进入就绪状态，可以马上使用。</p><p>在配置文件中，通过<strong>constructor-args</strong> 标签注入到对应的bean 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;userService&quot;</span> class=<span class="string">&quot;com.spring.UserService&quot;</span>&gt;</span><br><span class="line">&lt;constructor-arg ref=<span class="string">&quot;userDao&quot;</span>&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;userDao&quot;</span> class=<span class="string">&quot;com.spring.dao.UserDaoJdbc&quot;</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>对应的java类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line"><span class="comment">//构造函数中依赖作为参数传入 </span></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">// 这里@Autowired也可以省略</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="注解和Java配置方式下-1"><a href="#注解和Java配置方式下-1" class="headerlink" title="注解和Java配置方式下"></a><strong>注解和Java配置方式下</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> TestService testService;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Autowried</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">TestController</span><span class="params">(TestService testService)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.testService = testService;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-注解注入-属性注入"><a href="#3-注解注入-属性注入" class="headerlink" title="3.注解注入(属性注入)"></a>3.注解注入(属性注入)</h2><p>这种注入方式就是在bean的变量上使用注解进行依赖注入。本质上是通过反射的方式直接注入到field。这是我平常开发中看的最多也是最熟悉的一种方式。</p><p>主要有4种注解的类可以注册bean，每种注解可以任意使用，只是语义上有所差异：</p><p>@Component 可以用于注册所有bean</p><p>@Controller 可以用于注册控制层的bean</p><p>@Service 可以用于注册服务层的bean</p><p>@Repository 可以用于注册dao层的bean</p><p><strong>描述依赖关系的的主要有2种：</strong></p><p>@Resource（java 注解）默认以byName的方式去匹配与属性名相同的bean 的id，如果没有找到就以byType的方式查找，如果byType找到多个，通过@Qualifier 注解（Spring注解）指定某个具体名称的bean。</p><p>@Autowired (Spring 注解) 先以 ByType 的方式去匹配，如果匹配到了多个再以 ByName 的方式去匹配，找到了对应的 bean 就去注入，没找到就抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> TestService testService;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Autowired，-Resource，-Inject-三个注解的区别"><a href="#Autowired，-Resource，-Inject-三个注解的区别" class="headerlink" title="@Autowired，@Resource，@Inject 三个注解的区别"></a><strong>@Autowired，@Resource，@Inject 三个注解的区别</strong></h2><p>​Spring 支持使用<code>@Autowired</code>, <code>@Resource</code>,  <code>@Inject</code> 三个注解进行依赖注入。下面来介绍一下这三个注解有什么区别。</p><p><code>@Autowired</code>为Spring 框架提供的注解，需要导入包<code>org.springframework.beans.factory.annotation.Autowired</code>。</p><p>装配顺序：</p><ol><li><p>按照<code>type</code>在上下文中查找匹配的bean，查找type为Svc的bean</p></li><li><p>如果有多个bean，则按照<code>name</code>进行匹配</p></li><li><ol><li><p>如果有<code>@Qualifier</code>注解，则按照<code>@Qualifier</code>指定的<code>name</code>进行匹配</p><p>查找name为svcA的bean</p></li><li><p>如果没有，则按照变量名进行匹配</p><p>查找name为svc的bean</p></li></ol></li><li><p>匹配不到，则报错。（<code>@Autowired(required=false)</code>，如果设置<code>required</code>为<code>false</code>(默认为<code>true</code>)，则注入失败时不会抛出异常）</p></li></ol><p>注意：使用@Qualifier 时候，如何设置的指定名称的Bean不存在，则会抛出异常，如果防止抛出异常，可以使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Qualifier(&quot;xxxxyyyy&quot;)</span></span><br><span class="line"><span class="meta">@Autowired(required = false)</span></span><br><span class="line"><span class="keyword">private</span> HelloDao helloDao;</span><br></pre></td></tr></table></figure><h3 id="Inject"><a href="#Inject" class="headerlink" title="@Inject"></a><strong>@Inject</strong></h3><p>在 Spring 的环境下，<code>@Inject</code>和<code>@Autowired</code> 是相同的，因为它们的依赖注入都是使用<code>AutowiredAnnotationBeanPostProcessor</code>来处理的。但是inject没有required &#x3D; false这个属性</p><h3 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a><strong>@Resource</strong></h3><p>@Resource有两个重要的属性：name和type，而Spring 将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。</p><p>装配顺序：</p><ol><li>如果同时指定了name和type，则从 Spring 上下文中找到唯一匹配的 bean 进行装配，找不到则抛出异常。</li><li>如果指定了name，则从上下文中查找名称（id）匹配的 bean 进行装配，找不到则抛出异常。</li><li>如果指定了type，则从上下文中找到类型匹配的唯一 bean 进行装配，找不到或是找到多个，都会抛出异常。</li><li>如果既没有指定name，又没有指定type，<strong>则默认按照byName方式进行装配；如果没有匹配，按照byType进行装配。</strong></li></ol><h2 id="推荐使用构造器注入方式"><a href="#推荐使用构造器注入方式" class="headerlink" title="推荐使用构造器注入方式"></a>推荐使用构造器注入方式</h2><p>​构造器注入的方式<strong>能够保证注入的组件不可变，并且确保需要的依赖不为空</strong>。此外，构造器注入的依赖总是能够在返回客户端（组件）代码的时候保证完全初始化的状态。</p><p><strong>依赖不可变</strong>：其实说的就是final关键字。</p><p><strong>依赖不为空</strong>（省去了我们对其检查）：当要实例化UserServiceImpl的时候，由于自己实现了有参数的构造函数，所以不会调用默认构造函数，那么就需要Spring容器传入所需要的参数，所以就两种情况：1、有该类型的参数-&gt;传入，OK 。2：无该类型的参数-&gt;报错。</p><p><strong>完全初始化的状态</strong>：这个可以跟上面的依赖不为空结合起来，向构造器传参之前，要确保注入的内容不为空，那么肯定要调用依赖组件的构造方法完成实例化。而在Java类加载实例化的过程中，构造方法是最后一步（之前如果有父类先初始化父类，然后自己的成员变量，最后才是构造方法），所以返回来的都是初始化之后的状态。</p><p><strong>避免循环依赖:</strong> 使用构造器注入, 如果存在循环依赖, 在spring项目启动的时候就会抛出异常:（关于循环依赖的介绍可以看另一篇文章）</p><p>解决办法是：</p><ol><li><p>在任意一个中构造器注入使用@Lazy</p></li><li><p>使用setter注入</p></li></ol><h3 id="field注解-注入依赖的缺点："><a href="#field注解-注入依赖的缺点：" class="headerlink" title="field注解 注入依赖的缺点："></a>field注解 注入依赖的缺点：</h3><ol><li>对于IOC容器以外的环境，除了使用反射来提供它所需要的依赖外，无法复用该实现类。且在不调用的情况下，存在将无法发现NPE的隐患。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里只是模拟一下，正常来说我们只会暴露接口给客户端，不会暴露实现。</span></span><br><span class="line"><span class="type">UserServiceImpl</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">userService.findUserList(); <span class="comment">// -&gt; NullPointerException, 潜在的隐患</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用field注入可能导致循环依赖，即A里面注入B，B里面注入A。如果使用构造器注入，在spring项目启动的时候，就会抛出BeanCurrentlyInCreationException异常，从而提醒你避免循环依赖。如果使用field注入的话，启动的时候不会报错，在使用哪个bean的时候才会报错。</li></ol><h3 id="注入方式选择："><a href="#注入方式选择：" class="headerlink" title="注入方式选择："></a>注入方式选择：</h3><p><strong>强制依赖就用构造器方式，可选、可变的依赖就用 setter 注入。</strong></p><p>​基于 setter 的注入，则只应该被用于注入非必需的依赖，同时在类中应该对这个依赖提供一个合理的默认值。如果使用 setter  注入必需的依赖，那么将会有过多的 null 检查充斥在代码中。使用 setter 注入的一个优点是，这个依赖可以很方便的被改变或者重新注入。 </p><h1 id="Spring-Bean的线程安全性："><a href="#Spring-Bean的线程安全性：" class="headerlink" title="Spring Bean的线程安全性："></a>Spring Bean的线程安全性：</h1><p>（1）对于prototype作用域的Bean，每次都创建一个新对象，也就是线程之间不存在Bean共享，因此不会有线程安全问题。</p><p>（2）对于singleton作用域的Bean，所有的线程都共享一个单例实例的Bean，因此是存在线程安全问题的。但是如果单例Bean是一个无状态Bean，也就是线程中的操作不会对Bean的成员执行查询以外的操作，那么这个单例Bean是线程安全的。比如Controller类、Service类和Dao等，这些Bean大多是无状态的，只关注于方法本身。</p><ul><li>有状态Bean(Stateful Bean) ：就是有实例变量的对象，可以保存数据，是非线程安全的。</li><li>无状态Bean(Stateless Bean)：就是没有实例变量的对象，不能保存数据，是不变类，是线程安全的。</li></ul><p><strong>解决办法</strong></p><p>对于有状态的bean（比如Model和View），就需要自行保证线程安全，最浅显的解决办法就是将有状态的bean的作用域由“singleton”改为“prototype”。</p><p>也可以采用ThreadLocal解决线程安全问题，为每个线程提供一个独立的变量副本，不同线程只操作自己线程的副本变量。</p>]]></content>
      
      
      <categories>
          
          <category> Java框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap源码分析</title>
      <link href="/2022/09/21/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2022/09/21/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>如下图所示为HashMap的继承关系：</p><p><img src="2.jpg"></p><p>​HashMap由数组+链表+红黑树构成。HashMap继承<strong>AbstractMap</strong>并实现<strong>Map</strong>,<strong>Cloneable</strong>,<strong>Serializable</strong>接口。要注意HashMap的实例有两个影响其性能的参数：<strong>初始容量</strong>和<strong>负载因子</strong>。</p><span id="more"></span><h1 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 默认数组初始值大小</span></span><br><span class="line"><span class="comment">    * 0b 0001 左移四位 0b 1000 =&gt; 0d 16</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">//16</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 数组最大长度</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 默认负载因子</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 树化阈值，Node链表长度大于8会触发树化操作 将链转化为红黑树</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 树转化为链表的阈值，TreeNode树节点数小于6会将树转化为Node链表</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 树化的条件之一：数组长度大于等于64才会树化，否则优先进行扩容操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈希桶（数组），由于TreeNode继承于Node，所以树化后也可以存放TreeNode节点（父类指针可以指向子类引用）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Holds cached entrySet(). Note that AbstractMap fields are used</span></span><br><span class="line"><span class="comment">    * for keySet() and values().</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 元素个数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当前Hash表的修改次数，元素增加或减少都会加1，替换不影响</span></span><br><span class="line"><span class="comment">    * HashMap、TreeMap、ArrayList、LinkedList等都有modCount属性</span></span><br><span class="line"><span class="comment">    * Fail-Fast 机制 </span></span><br><span class="line"><span class="comment">    * HashMap 不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了map，</span></span><br><span class="line"><span class="comment">    * 那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。</span></span><br><span class="line"><span class="comment">    * 这一策略在源码中的实现是通过 modCount 域，modCount 顾名思义就是修改次数，</span></span><br><span class="line"><span class="comment">    * 对HashMap 内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋</span></span><br><span class="line"><span class="comment">    * 给迭代器的 expectedModCount。在迭代过程中，判断 modCount 跟expectedModCount </span></span><br><span class="line"><span class="comment">    * 是否相等，如果不相等就表示已经有其他线程修改了Map</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  扩容阈值=数组长度*负载因子，元素个数超过这个阈值会触发扩容</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 负载因子</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="数据节点的构造"><a href="#数据节点的构造" class="headerlink" title="数据节点的构造"></a>数据节点的构造</h2><p><img src="3.png"></p><p><img src="3.jpg"><img src="1.png"></p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 给定数组初始长度和负载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line"><span class="comment">// 数组初始长度不能小于 0，否则抛异常</span></span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       <span class="comment">// 数组的初始长度不能大于最大值</span></span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">           initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">       <span class="comment">// 负载因子小于0，或者not a number则 抛出异常， </span></span><br><span class="line">       <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                              loadFactor);</span><br><span class="line">       <span class="comment">// 设置负载因子</span></span><br><span class="line">       <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line"><span class="comment">// 计算数组的容量，暂时存到threshold（扩容阈值）</span></span><br><span class="line">       <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 2. 给定数组容量，用默认的负载因子0.75</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 3. 使用默认的数组长度16和负载因子0.75</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  4. 用一个map集合去初始化另一个map集合</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">       putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 计算一个出一个比给定值大的2的n次方的数作为数组初始容量</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">       <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>​构造函数1.2.3都不会创建table数组（存放node节点的桶数组），HashMap会在第一次put数据时才创建table数组。默认的构造函数构造的是<strong>初始容量16，加载因子0.75</strong>的一个空的HashMap。</p><p><strong>为什么hashmap的容量为什么要是2的幂？</strong></p><p>​首先，HashMap的初始化的数组长度一定是2的n次的，每次扩容仍是原来的2倍的话，就不会破坏这个规律，每次扩容后，原数据都会进行数据迁移，根据二进制的计算，扩容后数据要么在原来位置，要么在【原来位置+扩容长度】，这样就不需要重新hash，效率上更高。 </p><p>​<strong>HashMap为提高get put效率，减少碰撞。取模算法hash%length ,hashmap将其优化成位运算hash&amp;(length1)，但hash%length等于hash&amp;(length-1)的前提是length是2的n次幂。</strong></p><h2 id="关键方法源码解析"><a href="#关键方法源码解析" class="headerlink" title="关键方法源码解析"></a>关键方法源码解析</h2><h3 id="put-方法"><a href="#put-方法" class="headerlink" title="put()方法"></a>put()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">putIfAbsent</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * onlyIfAbsent参数 </span></span><br><span class="line"><span class="comment"> * putIfAbsent方法传true，当key已经存在且value不为null时直接返回旧值，不更新</span></span><br><span class="line"><span class="comment"> * 其他情况传false，key已经存在时更新旧值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="comment">// 临时表量 tab=》table数组，p =》临时node节点， n =》table长度， i =》临时桶下标</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// 判断是否初始化table数组  table为null，长度为0 表示未初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 调用扩容方法进行初始化，后面扩容部分再分析</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 通过hash码计算出桶下标，该桶位还没有放置元素</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">    <span class="comment">// 直接构造一个node节点作为首节点</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 该桶位已经有元素了（只有一个node、node链表 或者 红黑树）</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 第一个元素就发生hash冲突</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p; <span class="comment">// 临时变量e暂时指向key值相同的node，后续根据putIfAbsent决定是否替换旧的value值</span></span><br><span class="line">        <span class="comment">// 桶位放置的是红黑树 （TreeNode继承于Node）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">        <span class="comment">// 红黑树中没有相同的key，插入成功，返回null</span></span><br><span class="line">        <span class="comment">// 红黑树中已经存在相同的key，临时变量e暂时指向key值相同的node，后续根据putIfAbsent决定是否替换旧的value值</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 链表情况</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123; <span class="comment">// 遍历到链表尾部，构造Node 完成插入</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 插入完成后检查链表长度是否超过 8</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                    <span class="comment">// 尝试树化，树化前要检查table数组的长度是否小于64，小于64时优先扩容</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 遍历链表过程中发生hash冲突，有相同的key</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 直接结束循环，e已经指向了那个key相同的Node</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e; <span class="comment">// e =&gt;遍历的当前节点， p =&gt; 上一个节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// e ==null 没有遇到相同的key，已经完成了插入</span></span><br><span class="line">        <span class="comment">// e != null 遇到相同的key值，统一处理</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value; <span class="comment">// 先保存旧值</span></span><br><span class="line">            <span class="comment">// onlyIfAbsent为false 或者 旧值为空 做更新操作</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e); <span class="comment">// 节点访问后序处理</span></span><br><span class="line">            <span class="keyword">return</span> oldValue; <span class="comment">// Hash冲突，涉及更新操作时，返回旧值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount; <span class="comment">// 插入成功（没有发生更新操作）结构修改次数加1</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold) <span class="comment">// 元素个数超过阈值，触发扩容</span></span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict); <span class="comment">// 节点插入后续处理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;  <span class="comment">// 没有发生hash冲突，插入成功返回null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>调用put方法首先调用了hash方法计算hash值：</p><p>这是一个扰动函数，将key的hashCode和该hashCode的高16为进行异或(保证对象的 hashCode 的 32 位值只要有一位发生改变，整个 hash() 返回值就会改变。尽可能的减少碰撞。)计算出hash。会通过hash和当前数组长度-1进行&amp;运算来计算出当前要put的数据放入数组哪个桶中。比如当前我们初始容量16，也就是2的4次方。（16-1）的二进制刚好低4位都是1( 0000 0000 0000 1111)，所以hash&amp;(16-1)刚好就是取低4位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​在我们往HashMap插入数据时，首先会通过(n - 1) &amp; hash计算出要插入在数组中的位置，如果该位置还没数据，就直接放入。如果已经有了，那就遍历数组该桶中所有的节点，它们以链表或者红黑树的方式存储。如果在链表中没有找到就创建新节点插入链表尾部，如果找到有相同key的节点，那就替换掉value。插入时如果链表长度大于TREEIFY_THRESHOLD此时链表会转为红黑树。<br>​每次插入数据后都会判断HashMap的size是否大于阈值（<strong>扩容阈值&#x3D;数组长度*负载因子，元素个数超过这个阈值会触发扩容</strong>），如果大于就会调用resize()方法进行扩容处理，注意size是HashMap中元素数量，扩容是扩容我们数组的长度为原来的两倍。</p><h3 id="putTreeVal"><a href="#putTreeVal" class="headerlink" title="putTreeVal"></a>putTreeVal</h3><p>在上述put方法中分过桶之后将元素插入红黑树。：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * map =&gt; HashMap对象</span></span><br><span class="line"><span class="comment"> * tab =&gt; table</span></span><br><span class="line"><span class="comment"> * h =&gt; hash值</span></span><br><span class="line"><span class="comment"> * k =&gt; key</span></span><br><span class="line"><span class="comment"> * v =&gt; value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title function_">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span><br><span class="line"><span class="params">               <span class="type">int</span> h, K k, V v)</span> &#123;</span><br><span class="line">Class&lt;?&gt; kc = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 标识是否被搜索过，后面用到再做说明</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">searched</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 查找根节点, 索引位置的头节点并不一定为红黑树的根节点</span></span><br><span class="line">TreeNode&lt;K,V&gt; root = (parent != <span class="literal">null</span>) ? root() : <span class="built_in">this</span>;</span><br><span class="line"><span class="comment">// 根节点赋值给临时变量p，二分查找</span></span><br><span class="line"><span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">    <span class="type">int</span> dir, ph; K pk;</span><br><span class="line">    <span class="comment">// 传入的hash值h小于p节点的hash值，将dir赋值为-1，代表向p的左子树查找</span></span><br><span class="line">    <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">        dir = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 传入的hash值大于p节点的hash值， 将dir赋值为1，代表向p的右子树查找</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">        dir = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 传入的hash值h等于p节点的哈希值，进一步判断key值等于p节点的key值, 如果相等就是找到与要插入的key相同的节点。将这个节点返回，在上层方法中决定是否替换value值</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="literal">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    <span class="comment">/* 走到这里说明hash相同而key不相同， ph == h，pk !=k, k.equals(pk) == false</span></span><br><span class="line"><span class="comment">     * 这意味着涉及到传入的k于当前节点key值pk之间的比较了</span></span><br><span class="line"><span class="comment">     * 判断：</span></span><br><span class="line"><span class="comment">     * 如果没有实现Comparable&lt;C&gt;接口或者 实现该接口 并且 k与pk Comparable比较结果相同</span></span><br><span class="line"><span class="comment">     * 否则就是实现了comparable接口且比较不相等，直接到插入流程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">              (kc = comparableClassFor(k)) == <span class="literal">null</span>) ||</span><br><span class="line">             (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 由于要用递归的方式在左右子树中搜索，所以如果已经搜索过，那么把searched设置为true，避免下次循环重复搜索</span></span><br><span class="line">        <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">            searched = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 在左右子树递归的寻找 是否有key的hash相同 并且equals相同的节点</span></span><br><span class="line">            <span class="keyword">if</span> (((ch = p.left) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                 (q = ch.find(h, k, kc)) != <span class="literal">null</span>) ||</span><br><span class="line">                ((ch = p.right) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                 (q = ch.find(h, k, kc)) != <span class="literal">null</span>))</span><br><span class="line">                <span class="comment">// 找到了 就直接返回</span></span><br><span class="line">                <span class="keyword">return</span> q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 说明红黑树中没有与之equals相等的 那就必须进行插入操作 必须将两个key分出大小 dir的结果必须是-1或1  </span></span><br><span class="line">        dir = tieBreakOrder(k, pk);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 如果dir &lt;= 0</span></span><br><span class="line"><span class="comment">        * p.left == null，把要添加的元素作为当前节点的左节点</span></span><br><span class="line"><span class="comment">        * p.left != null，p = p.left，下一轮循环</span></span><br><span class="line"><span class="comment">        * 如果dir&gt;0</span></span><br><span class="line"><span class="comment">        * p.right == null，把要添加的元素作为当前节点的右节点</span></span><br><span class="line"><span class="comment">        * p.right !=null，p = p.right，下一轮循环</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 到这里p已经为null，且xp为p的父节点，至少一个子树是null</span></span><br><span class="line">        Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">        <span class="comment">// 创建一个新的树节点，注意这里设置了x.next为xpn，如果xpn不为null，name插入完成后还要设置xpn.prev为x</span></span><br><span class="line">        TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">        <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">            xp.left = x; <span class="comment">// 新节点作为左孩子</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            xp.right = x; <span class="comment">// 新节点作为右孩子</span></span><br><span class="line">        <span class="comment">// 维护双链表 并设置新节点的父节点</span></span><br><span class="line">        xp.next = x; <span class="comment">// xp.next可能之前就有值，暂时保存在xpn中</span></span><br><span class="line">        x.parent = x.prev = xp;</span><br><span class="line">        <span class="comment">// 如果原来的xp.next，即xpn节点不为空时，下面操作相当于把xpn接在了x后面</span></span><br><span class="line">        <span class="keyword">if</span> (xpn != <span class="literal">null</span>) <span class="comment">//  新节点覆盖了之前xp.next 的值</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 原来的xp.next 是 xpn</span></span><br><span class="line"><span class="comment">         * 现在xp.next是x，x.prev 是 xp，xpn.prev 是 x，x.next早在创建x时就设置为xpn了</span></span><br><span class="line"><span class="comment">            ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span></span><br><span class="line"><span class="comment">        // balanceInsertion 重新平衡</span></span><br><span class="line"><span class="comment">        // 经过平衡，根节点可能已经过改变，为了查询方便需要把新的根节点放到table数组桶上</span></span><br><span class="line"><span class="comment">        moveRootToFront(tab, balanceInsertion(root, x));</span></span><br><span class="line"><span class="comment">        return null;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="resize-扩容算法："><a href="#resize-扩容算法：" class="headerlink" title="resize()扩容算法："></a>resize()扩容算法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes or doubles table size.  If null, allocates in</span></span><br><span class="line"><span class="comment"> * accord with initial capacity target held in field threshold.</span></span><br><span class="line"><span class="comment"> * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class="line"><span class="comment"> * elements from each bin must either stay at same index, or move</span></span><br><span class="line"><span class="comment"> * with a power of two offset in the new table.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line"><span class="comment">// 临时变量接收旧table</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// 旧table的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">// 旧table触发扩容的阈值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="comment">// 新数组的长度和阈值都先给0</span></span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// oldCap等于0表示初始化时调用resize，大于0就是扩容场景</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 数组长度不能超过最大值 1 &lt;&lt; 30</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        <span class="comment">// 阈值给大，防止再次触发扩容</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab; <span class="comment">// 直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 新数组长度乘2后不超过数组的最大值 且 旧数组长度大于等于16</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold 阈值翻倍</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * oldCap 等于0  初始化table场景</span></span><br><span class="line"><span class="comment">     * 在构造函数没有给定数组大小的情况下 threshold为int类型的默认值0</span></span><br><span class="line"><span class="comment">     * 在构造函数给出数组长度的情况下 threshold暂时存储计算出来的数组长度</span></span><br><span class="line"><span class="comment">     * 对应的构造函数</span></span><br><span class="line"><span class="comment">     * HashMap(int initialCapacity)</span></span><br><span class="line"><span class="comment">     * HashMap(int initialCapacity, float loadFactor)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr; <span class="comment">// 初始化前threshold存的是计算的数组长度</span></span><br><span class="line">    <span class="comment">// oldThr 等于0 对应无参构造 数组长度用默认19，阈值使用16*0.75 = 12</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 1. 旧数组长度不到16时触发扩容的场景</span></span><br><span class="line"><span class="comment">     * 2. 构造函数中给出initialCapacity时初始化table场景</span></span><br><span class="line"><span class="comment">     * 以上两个场景需要单独计算新的扩容阈值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 数组长度*负载因子</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        <span class="comment">// 判断是否到达数组长度的上限，如果到达上限直接把扩容阈值给最大值Integer.MAX_VALUE，防止再次触发扩容</span></span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr; <span class="comment">// 接收临时变量计算好的值</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    <span class="comment">// 扩容/初始化正式开始</span></span><br><span class="line">    <span class="comment">// 构建table数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab; <span class="comment">// 赋值给table成员变量，到此初始化完成</span></span><br><span class="line">    <span class="comment">// 扩容</span></span><br><span class="line">    <span class="comment">// oldTab == null为初始化场景，不执行if块里的代码</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 遍历旧数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">// 桶位不为空</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 临时变量e已经接收了这个同为的值，原来桶位置null，方便GC</span></span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 情况1 只有一个元素，则放到新数组对应下标的桶位即可</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 情况2 e是红黑树的头结点</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">// 数据迁移，后面分析</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">// 情况三 e是链表头结点</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                <span class="comment">// 低链头结点、低链尾结点</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 高链头结点、高链尾结点</span></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 低链：loHead =&gt; e1 -&gt; e2 -&gt;...-&gt; en &lt;= loTail </span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 高链：hiHead =&gt; e1 -&gt; e2 -&gt;...-&gt; en &lt;= hiTail</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>); <span class="comment">// 遍历到null为止</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 两个链表放到新数组对应的桶位，loHead和loTail只是收尾节点的引用，方法执行完生命周期结束 </span></span><br><span class="line"><span class="comment"> * loHead =&gt; e1 -&gt; e2 -&gt;...-&gt; en &lt;= loTail </span></span><br><span class="line"><span class="comment"> * newTab[j] -&gt; e1 -&gt; e2 -&gt;...-&gt; en</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * hiHead =&gt; e1 -&gt; e2 -&gt;...-&gt; en &lt;= hiTail</span></span><br><span class="line"><span class="comment"> * newTab[j + oldCap]-&gt; e1 -&gt; e2 -&gt;...-&gt; en</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        <span class="comment">// 低链桶下标不变</span></span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        <span class="comment">// 高链桶下标加旧数组的容量</span></span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​以table长度16扩容到32为例，如图，当hash码后四位为1111时，和数组长度N-1进行与操作(N-1) &amp; hash得到的下标都是(16-1) &amp; hash &#x3D; 15，扩容后这个链表的元素重新计算下标(32-1) &amp; hash，此时hash码的第五位参与计算，得到下标有两种情况：</p><p>hash码第五位为0时，下标不变，还是15，这些元素组成新的链表（低链），在新数组中桶下标不变<br>hash码第五位为1时，下标需要加上旧数组的长度16，等于31，这些元素组成新的链表（高链），在新数组中的桶下标加在原来的基础上加原数组的长度</p><p>​HashMap扩容时如果数组上的元素是单个元素没有hash冲突就直接用hashcode值与上新数组的长度重新得到hashcode值放入新链表中。如果当前位置是hash冲突的不管是<strong>链表还是红黑树上的值</strong>都通过hash &amp; <strong>旧数组长度</strong>计算得到高低链，然后分别将链表放入新的桶位中，比如：</p><p>…01111 &amp; 1000 &#x3D;&#x3D; 0 node放到低链<br>…11111 &amp; 1000 !&#x3D; 0 node放到高链<br>其中红黑树完成两个链表的转移之后还要进一步判断数否需要树化（拆分后的两个链表长度还有可能大于8）</p><p><img src="4.jpg"></p><h3 id="get、replace方法"><a href="#get、replace方法" class="headerlink" title="get、replace方法"></a>get、replace方法</h3><p>get和replace都走的是getNode方法，代码很简单(1)、先调用k的hashCode()方法得出哈希值，并通过哈希算法转换成数组的下标。 (2)、在通过数组下标快速定位到某个位置上。重点理解如果这个位置上什么都没有，则返回null。如果这个位置上有单向链表，那么它就会拿着参数K和单向链表上的每一个节点的K进行equals，如果所有equals方法都返回false，则get方法返回null。如果其中一个节点的K和参数K进行equals返回true，那么此时该节点的value就是我们要找的value了，get方法最终返回这个要找的value。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心方法：getNode</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 核心方法：getNode</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">replace</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">        e.value = value;</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="comment">// 校验table并确定桶下标</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 总是会判断第一个是不是目标，正好是就返回首节点</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 判断有没有第二个，没有就返回null，有就区分链表和红黑树两种场景找目标节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 红黑树调用getTreeNode</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123; <span class="comment">// 链表，利用next指针依次迭代</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h3><p>删除节点就是在查找节点的基础上将查找到的节点直接删除就行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object key, Object value)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> removeNode(hash(key), key, value, <span class="literal">true</span>, <span class="literal">true</span>) != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.remove and related methods.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash key的hash值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 要删除的元素的key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 要删除的元素的value，matchValue参数为true时提供，元素的值匹配上才能删除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> matchValue 是否值匹配才删除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> movable 删除后是否移动节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回删除的节点，删除失败返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,</span></span><br><span class="line"><span class="params">                           <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, index;</span><br><span class="line">    <span class="comment">// 先查</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="literal">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">// 老套路了，先看首节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p; <span class="comment">// 从这里直接跳到删除逻辑，在删除逻辑中通过 node == p 判断是不是删除的首节点 </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果没找到目标节点，下一次循环 p.next == e</span></span><br><span class="line">                    <span class="comment">// 如果找到了node，则 p.next == e, 同时p.next == node，这个关系用在删除逻辑中</span></span><br><span class="line">                    p = e; </span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 查到的目标节点node</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再删</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果不需要匹配value，直接删除</span></span><br><span class="line"><span class="comment"> * 如果需要匹配value，“==” 或者 equals了才删</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">/* 走红黑树删除流程，movable参数表示删除后是否移动节点</span></span><br><span class="line"><span class="comment">             * 参数this代指HashMap对象</span></span><br><span class="line"><span class="comment">             * 为什么参数中不传递要删除的元素node  QAQ</span></span><br><span class="line"><span class="comment">             * 因为是这样node.removeTreeNode调用的，所以在removeTreeNode里面this就是要删除的节点了</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="built_in">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p) <span class="comment">// 要删除的节点node是首节点</span></span><br><span class="line">                tab[index] = node.next; <span class="comment">// 将node.next作为首节点，方法执行完node指向的对象进入GC</span></span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//  删除前 p.next == node，删除后 p.next == node.next，方法执行完node指向的对象进入GC</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="treeifyBin树化方法"><a href="#treeifyBin树化方法" class="headerlink" title="treeifyBin树化方法"></a>treeifyBin树化方法</h3><p>table某个桶位node链表长度超过8时，会调用treeifyBin，检查table数组长度达到64的情况下，先把原来的单链表结构变成了双链表结构，然后调用TreeNode::treeify(table)进行树化。红黑树的结构同时维持着双链表的结构，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * tab：table数组</span></span><br><span class="line"><span class="comment"> * hash：hash值（增加的键值对的key的hash值）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// table数组长度不到64时，优先进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 获取首节点，判断不为空</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 定义头结点head和尾结点tail</span></span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// do-while循环 将把Node对象转换成了TreeNode对象，把单向链表转换成了双向链表:</span></span><br><span class="line">        <span class="comment">// hd =&gt; p1 &lt;=&gt; p2 &lt;=&gt; ... &lt;=&gt; pn &lt;= tl </span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 将该Node节点转换为TreeNode节点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 把转换后的双向链表，替换原来位置上的单向链表</span></span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">            hd.treeify(tab);<span class="comment">// 双向链表转红黑树，后面分析</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将该Node节点转换为TreeNode节点</span></span><br><span class="line">TreeNode&lt;K,V&gt; <span class="title function_">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结单链表变为双链表：</p><ul><li>首先将Node节点转换为TreeNode节点，TreeNode节点中的next和prev分别维护双向链表的两个指针</li><li>hd和tl分别指的是双向链表头尾两个节点的引用，给tl赋值prev和next，就等于赋值最后一个节点赋值。</li><li>方法执行完hd和tl作为局部变量生命周期结束，双链表的头结点的地址放在了table的对应桶位tab[index] &#x3D; hd</li></ul><h3 id="treeify"><a href="#treeify" class="headerlink" title="treeify"></a>treeify</h3><p>将双链表转化为红黑树：(源码参考：<a href="https://blog.csdn.net/weixin_42410658/article/details/121957690">https://blog.csdn.net/weixin_42410658/article/details/121957690</a>)</p><p>treeify的作用域是TreeNode类，调用它必然是<code>TreeNode对象.treeify</code>，<strong>那么这个方法内部的this就指代这个TreeNode对象</strong>。<br>调用链表<code>首节点.treeify</code>，<strong>则this就指代首节点了</strong>，后续节点用next指针迭代就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Forms tree of the nodes linked from this node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> &#123;</span><br><span class="line"><span class="comment">// 定义树的根节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; root = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 遍历链表，x当前节点，this为首节点，next下一个节点</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="built_in">this</span>, next; x != <span class="literal">null</span>; x = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">        <span class="comment">// 某个桶位扩容前是红黑树，扩容后还是红黑树的情况下，x的左右子树不为null。</span></span><br><span class="line">        x.left = x.right = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 第一次循环还没有设置根节点</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            x.parent = <span class="literal">null</span>; <span class="comment">// 根节点没有父节点</span></span><br><span class="line">            x.red = <span class="literal">false</span>; <span class="comment">// 根节点一定是得是黑色</span></span><br><span class="line">            root = x; <span class="comment">// 设置根节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第二次以后的循环已经存在根节点了</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前链表节点的key和hash值</span></span><br><span class="line">            <span class="type">K</span> <span class="variable">k</span> <span class="operator">=</span> x.key;</span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> x.hash;</span><br><span class="line">            <span class="comment">// 定义当前链表节点key的运行时类型</span></span><br><span class="line">            Class&lt;?&gt; kc = <span class="literal">null</span>; </span><br><span class="line">            <span class="comment">// 遍历插入红黑树</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">            <span class="comment">// dir 插入方向, ph 当前树节点的hash值</span></span><br><span class="line">                <span class="type">int</span> dir, ph;</span><br><span class="line">                <span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key; <span class="comment">// pk 当前树节点的key</span></span><br><span class="line">                <span class="comment">// 如果当前树节点hash值 &gt; 当前链表节点的hash值</span></span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    dir = -<span class="number">1</span>; <span class="comment">// 标识向左树插入</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>;  <span class="comment">// 右树</span></span><br><span class="line">                <span class="comment">/* ph = h，hash值相等 做以下判断（PS：和putTreeVal过程不同的是，这里不用判断key是否相等，因为已经形成链表了，key必然不会相等了）</span></span><br><span class="line"><span class="comment">                 * kc == null &amp;&amp;(kc = comparableClassFor(k)) == null)</span></span><br><span class="line"><span class="comment">                 * true：当前链表节点的key没有实现comparable，直接执行dir = tieBreakOrder(k, pk);</span></span><br><span class="line"><span class="comment">                 * false：实现了comparable接口，执行 || 后面的表达式</span></span><br><span class="line"><span class="comment">                 * dir = compareComparables(kc, k, pk)) == 0</span></span><br><span class="line"><span class="comment">                 * true：通过compareTo比较大小，结果为0，没办法确定dir正负值，执行dir = tieBreakOrder(k, pk);</span></span><br><span class="line"><span class="comment">                 * false：已经确定dir的正负值，即确定了插入左边还是右边</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="literal">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line"><span class="comment">// 插入逻辑，之前分析过了</span></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    x.parent = xp;</span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    <span class="comment">// 每插入一个元素就重新平衡，然后返回平衡后的根节点</span></span><br><span class="line">                    root = balanceInsertion(root, x);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 目前放在table数组桶上的是链表的第一个节点，经过多次平衡这个节点很有可能不是root节点了，为了查询方便需要把root节点放到table数组桶上</span></span><br><span class="line">    moveRootToFront(tab, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap判断元素相等原理"><a href="#HashMap判断元素相等原理" class="headerlink" title="HashMap判断元素相等原理"></a>HashMap判断元素相等原理</h2><p>​Object类中的equals方法和“&#x3D;&#x3D;”是一样的，没有区别，即俩个对象的比较是比较他们的<strong>栈内存中存储的内存地址</strong>。而String类，Integer类等等一些类，是<strong>重写了equals方法</strong>，才使得equals和“&#x3D;&#x3D;不同”，他们比较的是<strong>值相等</strong>。所以，当自己创建类时，自动继承了Object的equals方法，要想实现不同的等于比较，必须重写equals方法。所以基本数据类型使用“&#x3D;&#x3D;”，包装数据类型使用equals方法。</p><h3 id="HashCode原理"><a href="#HashCode原理" class="headerlink" title="HashCode原理"></a>HashCode原理</h3><p>​ Object中的hashCode方法返回的是对象本地内存地址的换算结果，不同的实例对象的hashCode是不相同的。</p><p>​<strong>同一个对象多次调用 hashCode() 方法应该返回相同的值。</strong></p><p>​<strong>如果两个对象相同，那么它们的hashCode值一定要相同。</strong>也告诉我们重写equals方法，一定要重写hashCode方法，也就是说hashCode值要和类中的成员变量挂上钩，对象相同-&gt;成员变量相同—-&gt;hashCode值一定相同。</p><p>​如果两个对象的hashCode相同，它们并不一定相同，这里的对象相同指的是用eqauls方法比较。</p><p>如重写一个包含id name字段的user的equals方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较同一个类型对象, 值是否一致:</span></span><br><span class="line">    <span class="comment">//一致返回 true</span></span><br><span class="line">    <span class="comment">//不一致返回 false</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;   <span class="comment">//返回true 表示对象一致,新增失败！</span></span><br><span class="line">    <span class="comment">//比较对象地址是否一致</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//判断当前对象是否为 null 或 类型一致...</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//获取对象, 比较id name 属性是否一致....</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) o;</span><br><span class="line">    <span class="keyword">if</span> (id != user.id) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> name != <span class="literal">null</span> ? name.equals(user.name) : user.name == <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同一个类型, 相同值,调用该方法返回相同的hash值！</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;         <span class="comment">//idea hashCode生成！</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> id;</span><br><span class="line">    result = <span class="number">31</span> * result + (name != <span class="literal">null</span> ? name.hashCode() : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​在Set和Map中新添加元素的时候，随着容器中节点数量的增多不可能每次增加一个元素都与其他所有的元素两两判断是不是相等，然后再插入，而是先计算该对象的hashcode，根据hashcode来找到当前元素放置的位置，因为相同的对象肯定必须要有相同的hashcode，如果产生了hash冲突，就使用equals比较两个元素是否相等，怎样就不用两两比较。</p><h3 id="重写的hashcode算法引起的内存泄漏"><a href="#重写的hashcode算法引起的内存泄漏" class="headerlink" title="重写的hashcode算法引起的内存泄漏"></a>重写的hashcode算法引起的内存泄漏</h3><p>​将HashSet中的对象进行删除前，改变了该对象实例域的值，而当前对象计算hashcode的算法有对象的成员变量参与，这样在修改了实例域之后，对象的hashcode改变了，但是对象仍然是放置在原来的位置，并没有更新到新hashcode的位置上，所以当我们用新的hashcode去找该元素去删除它的时候肯定就找不到了。</p><p>​所以如果我们将对象的属性值参与了hashCode的运算中，。在进行删除的时候，就不能对其属性值进行修改。</p><h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><p>​Hashtable是通过”拉链法”实现的哈希表。它包括几个重要的成员变量：table, count, threshold, loadFactor, modCount。</p><ul><li>table是一个 Entry[] 数组类型，而 Entry（在 HashMap 中有讲解过）实际上就是一个单向链表。哈希表的”key-value键值对”都是存储在Entry数组中的。</li><li>count 是 Hashtable 的大小，它是 Hashtable 保存的键值对的数量。</li><li>threshold 是 Hashtable 的阈值，用于判断是否需要调整 Hashtable 的容量。threshold 的值&#x3D;”容量*加载因子”。</li><li>loadFactor 就是加载因子。</li><li>modCount 是用来实现 fail-fast 机制的。</li></ul><p>​HashTable的结构和HashMap的结构是差不多的。HashTable中没有引进红黑树。所有的冲突Entry都是通过链表保存的。</p><p><img src="5.jpg"></p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>Hashtable 一共提供了 4 个构造方法：</p><ul><li><code>public Hashtable(int initialCapacity, float loadFactor)</code>： 用指定初始容量和指定加载因子构造一个新的空哈希表。useAltHashing 为 boolean，其如果为真，则执行另一散列的字符串键，以减少由于弱哈希计算导致的哈希冲突的发生。</li><li><code>public Hashtable(int initialCapacity)</code>：用指定初始容量和默认的加载因子 (0.75) 构造一个新的空哈希表。</li><li><code>public Hashtable()</code>：默认构造函数，容量为 11，加载因子为 0.75。</li><li><code>public Hashtable(Map&lt;? extends K, ? extends V&gt; t)</code>：构造一个与给定的 Map 具有相同映射关系的新哈希表。</li></ul><h3 id="HashMap，LinkedHashMap，TreeMap-的区别"><a href="#HashMap，LinkedHashMap，TreeMap-的区别" class="headerlink" title="HashMap，LinkedHashMap，TreeMap 的区别"></a>HashMap，LinkedHashMap，TreeMap 的区别</h3><p><strong>LinkedHashMap</strong> 保存了记录的插入顺序，在用 Iterator 遍历时，先取到的记录肯定是先插入的；遍历比 HashMap 慢；底层实现方式是单独的头结点和双链表.。</p><p>LinkedHashMap继承自HashMap，它的多种操作都是建立在HashMap操作的基础上的。同HashMap不同的是，LinkedHashMap维护了一个Entry的双向链表，保证了插入的Entry中的顺序。这也是Linked的含义。结构图如下：</p><p><img src="2.png"></p><p><code>LinkedHashMap</code> 的排序方式有两种：</p><ul><li>根据写入顺序排序。</li><li>根据访问顺序排序。</li></ul><p>其中根据访问顺序排序时，每次 <code>get</code> 都会将访问的值移动到链表末尾，这样重复操作就能的到一个按照访问顺序排序的链表。</p><p>构造方法：</p><p>​其中的 <code>accessOrder</code> 成员变量，默认是 <code>false</code>，默认按照插入顺序排序，为 <code>true</code> 时按照访问顺序排序，也可以调用:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public LinkedHashMap(int initialCapacity,</span><br><span class="line">                     float loadFactor,</span><br><span class="line">                     boolean accessOrder) &#123;</span><br><span class="line">    super(initialCapacity, loadFactor);</span><br><span class="line">    this.accessOrder = accessOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说 <code>LinkedHashMap</code> 其实就是对 <code>HashMap</code> 进行了拓展，使用了双向链表来保证了顺序性。因为是继承与 <code>HashMap</code> 的，所以一些 <code>HashMap</code> 存在的问题 <code>LinkedHashMap</code> 也会存在，比如不支持并发等。</p><p><strong>TreeMap</strong> 实现 SortMap 接口，能够把它保存的记录根据键排序（默认按键值升序排序，也可以指定排序的比较器）</p><h3 id="HashMap-和-HashTable-的区别。"><a href="#HashMap-和-HashTable-的区别。" class="headerlink" title="HashMap 和 HashTable 的区别。"></a>HashMap 和 HashTable 的区别。</h3><p>①、HashMap 是线程不安全的，HashTable 是线程安全的；</p><p>②、由于线程安全，所以 HashTable 的效率比不上 HashMap；</p><p>③、HashMap最多只允许一条记录的键为null，允许多条记录的值为null，而 HashTable不允许；</p><p>④、HashMap 默认初始化数组的大小为16，HashTable 为 11，前者扩容时，扩大两倍，后者扩大两倍+1；</p><p>⑤、HashMap 需要重新计算 hash 值，而 HashTable 直接使用对象的 hashCode</p><h3 id="ConcurrentHashMap-与-HashTable-效率比较"><a href="#ConcurrentHashMap-与-HashTable-效率比较" class="headerlink" title="ConcurrentHashMap 与 HashTable 效率比较"></a>ConcurrentHashMap 与 HashTable 效率比较</h3><p>HashTable 使用一把锁（锁住整个链表结构）处理并发问题，多个线程竞争一把锁，容易阻塞；</p><p>ConcurrentHashMap</p><ul><li><p>JDK 1.7 中使用分段锁（ReentrantLock + Segment + HashEntry），相当于把一个 HashMap 分成多个段，每段分配一把锁，这样支持多线程访问。锁粒度：基于 Segment，包含多个 HashEntry。</p></li><li><p>JDK 1.8 中使用 CAS + synchronized + Node + 红黑树。锁粒度：Node（首结</p><p>点）（实现 Map.Entry）。锁粒度降低了。</p></li></ul><h2 id="HashMap与HashSet的联系与区别"><a href="#HashMap与HashSet的联系与区别" class="headerlink" title="HashMap与HashSet的联系与区别"></a>HashMap与HashSet的联系与区别</h2><p>通过查看hashset的add方法源码可以发现hashset采用的是map存储结构，通过一个HashMap存储元素，元素是存放在HashMap的Key中，而Value统一使用一个Object对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>区别是：</p><p>1.HashMap实现了Map接口，而HashSet实现了Set接口。</p><p>2.HashMap用于存储键值对，而HashSet用于存储对象。</p><p>3.HashMap不允许有重复的键，可以允许有重复的值。HashSet不允许有重复元素。</p><p>4.HashMap允许有一个键为空，多个值为空，HashSet允许有一个空值。</p><p>5.HashMap中使用put()将元素加入map中，而HashSet使用add()将元素放入set中。</p><p>6.HashMap比较快，因为其使用唯一的键来获取对象。</p>]]></content>
      
      
      <categories>
          
          <category> Java容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>List源码分析</title>
      <link href="/2022/09/20/List%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2022/09/20/List%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>List存储的元素是有序的，可重复的，List接口主要有三个实现：</p><ol><li><strong>ArrayList</strong>，底层采用的是Object[]数组，故支持随机访问，插入和删除元素时间复杂度受元素位置的影响，介于O(1)~O(n-i)之间（n为列表size、i为要操作的位置），而在内存空间占用上默认预留一定的空间。它是线程不安全的。</li><li><strong>Vector</strong>，是 List 的古老实现类，底层也是使用 Object[ ]存储，与ArrayList的主要区别是它是线程安全的。</li><li><strong>LinkList</strong>，底层采用的是双向链表（JDK1.6之前是循环列表，JDK1.7之后改成了双向链表），故不支持随机访问，插入和删除元素时间复杂度介于O(1)~O(n)，在内存空间占用上每个元素相比ArrayList要消耗多一点空间，因为要存放前驱、后驱信息），线程不安全。</li></ol><span id="more"></span><h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><p>动态数组，使用的时候，只需要操作即可，内部已经实现扩容机制。</p><ul><li>线程不安全</li><li>有顺序，会按照添加进去的顺序排好</li><li>基于数组实现，随机访问速度快，插入和删除较慢一点</li><li>可以插入null元素，且可以重复</li></ul><h2 id="源码详解："><a href="#源码详解：" class="headerlink" title="源码详解："></a>源码详解：</h2><h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><p>底层维护Object数组来进行装载和管理数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>提到数组结构，潜意识的就是基于元素对应的索引查询，所以速度快，如果删除元素，可能会导致大量元素移动，所以相对于LinkedList效率较低。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>无参构造器：初始化ArrayList，声明一个空数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有参构造器：传入容量参数大于0，则设置数组的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入集合：传入一个集合，转成数组之后，复制一份形成一个ArrayList。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">       Object[] a = c.toArray();</span><br><span class="line">       <span class="keyword">if</span> ((size = a.length) != <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (c.getClass() == ArrayList.class) &#123;</span><br><span class="line">               elementData = a;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               elementData = Arrays.copyOf(a, size, Object[].class);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// replace with empty array.</span></span><br><span class="line">           elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如果没通过构造方法指定数组长度，则采用默认数组长度，在添加元素的操作中会设置数组容量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>数组是有容量限制的，但是ArrayList却可以一直装载元素，当然也是有边界值的，只是通常不会装载那么多元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure><p>超过这个限制会抛出内存溢出的错误。</p><h2 id="常用方法源码"><a href="#常用方法源码" class="headerlink" title="常用方法源码"></a>常用方法源码</h2><h4 id="装载元素："><a href="#装载元素：" class="headerlink" title="装载元素："></a><strong>装载元素</strong>：</h4><p>会判断容量是否足够；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="comment">// 确定容量是不是足够，足够就不会增加</span></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>); </span><br><span class="line">        <span class="comment">// size+1的地方，赋值为现在的e</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当容量不够时，会<strong>进行扩容操作</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//minCapacity当前需要的最小容量    </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">//判断扩展值大于0</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity &gt; <span class="number">0</span>)</span><br><span class="line">            ensureCapacityInternal(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//开始扩容</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        modCount++;<span class="comment">//修改次数加一</span></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="comment">//判断当前长度是否需要扩容！</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行扩容</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;<span class="comment">//原长度(假设2)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>); <span class="comment">//新长度 = 旧 + 旧右移1位！(二级制右移)</span></span><br><span class="line">        <span class="comment">// x = 2+(2&gt;&gt;1)=3 及一点五倍！</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果还是小于扩容的长度,直接等于改长度</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//如果新的数组容量newCapacity大于数组能容纳的最大元素个数 MAX_ARRAY_SIZE </span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//把旧数组放进新的扩容后的数组    </span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//那么再判断传入的参数minCapacity是否大于MAX_ARRAY_SIZE</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">//传入的参数必须大于0，否者报错</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">            </span><br><span class="line">         <span class="comment">//如果minCapacity大于MAX_ARRAY_SIZE</span></span><br><span class="line">         <span class="comment">//那么//newCapacity等于Integer.MAX_VALUE，否者newCapacity等于MAX_ARRAY_SIZE   </span></span><br><span class="line">        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>当重新计算的容量（x1.5那个计算）小于传入要求容量参数，则新容量以传入的比较大的容量参数为准。</li><li>当传入容量参数太大，大到超过了数组的容量限定值2^{31}-1-8却又小于整数限定值 2^{31}-1</li><li>那么新的数组容量以整数限定值 2^{31}-1为准</li><li>但是当传入的容量参数不大于数组的容量限定值时，以容量限定值2^{31}-1-8为准。</li></ol><p>在指定的位置插入一个元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        <span class="comment">// 检查插入的位置，是否合法</span></span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line">        <span class="comment">// 检查是不是需要扩容，容量是否足够</span></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        <span class="comment">// 复制index后面的元素，都往后面移动一位（这是c++实现的底层原生方法）</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                         size - index);</span><br><span class="line">        <span class="comment">// 在index处插入元素</span></span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        <span class="comment">// 实际的存储元素个数增加</span></span><br><span class="line">        size++;</span><br><span class="line">    &#125;    </span><br></pre></td></tr></table></figure><h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><p>按照元素移除，或者按照下标移除元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查下标</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="comment">// 修改次数改变</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 获取旧的元素</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">    <span class="comment">// 计算需要移动的下标（往前面移动一位）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 调用native方法将后面的元素复制，移动往前一步</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">// 将之前的元素置为空，让垃圾回收方便进行</span></span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="comment">// 为空的元素</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历，如果equals,则调用删除</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 快速删除方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fastRemove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 修改次数增加1</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 计算移动的位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 前面移动一位</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">// 置空</span></span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>克隆ArrayList对象，先拷贝ArrayList，然后再把内部的数组也拷贝一份：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用默认的拷贝</span></span><br><span class="line">        ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="built_in">super</span>.clone();</span><br><span class="line">        <span class="comment">// 将内部的数组也拷贝一份</span></span><br><span class="line">        v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">        <span class="comment">// 修改次数只为0</span></span><br><span class="line">        v.modCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="comment">// this shouldn&#x27;t happen, since we are Cloneable</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转化为数组，我们看到内部其实是复制了一份引用，所以如果我们修改数组里面的元素，也会修改到<code>ArrayList</code>元素的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将元素拷贝到指定的数组中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">        <span class="comment">// Make a new array of a&#x27;s runtime type, but my contents:</span></span><br><span class="line">        <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">    System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">        a[size] = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>​迭代器提供了一种方法来<strong>顺序访问</strong>一个聚合对象中各个元素，而不保留该对象的内部表示。它是一种用于访问集合的方法，可用于迭代   ArrayList 和 HashSet 等集合。从前到后一个个访问。</p><p>源码中一共定义了三个迭代器：</p><ul><li><code>Itr</code>:实现了<code>Iterator</code>接口，是<code>AbstractList.Itr</code>的优化版本。</li><li><code>ListItr</code>:继承了<code>Itr</code>,实现了<code>ListIterator</code>，是<code>AbstractList.ListItr</code>优化版本。</li><li><code>ArrayListSpliterator</code>:继承于<code>Spliterator</code>, Java 8 新增的迭代器，基于索引，二分的，懒加载器。</li></ul><h3 id="Itr"><a href="#Itr" class="headerlink" title="Itr"></a><strong>Itr</strong></h3><p><code>Itr</code>这是一个比较初级的迭代器，实现了<code>Iterator</code>接口，有判断<strong>是否有下一个元素，访问下一个元素，删除元素的方法以及遍历对每一个元素处理的方法</strong>。里面有两个比较重要的属性：</p><ul><li>cursor：下一个即将访问的元素下标</li><li>lastRet：上一个返回的元素下标，初始化为-1</li></ul><p>两个重要的方法：</p><ul><li>next():获取下一个元素</li><li>remove():移除当前元素，需要在next()方法调用之后，才能调用，要不会报错。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">// 下一个返回元素的下标</span></span><br><span class="line">    <span class="type">int</span> cursor;       </span><br><span class="line">    <span class="comment">// 上一个返回元素的下标，初始化为-1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>; </span><br><span class="line">    <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line">    <span class="comment">// 无参构造</span></span><br><span class="line">    Itr() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 检查是否被修改</span></span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        cursor = i + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 修改上一个返回元素的下标，返回该位置的值</span></span><br><span class="line">        <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 如果在调用next之前，调用了remove方法，此时的lastRet就是-1，就是非法的。</span></span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用数组的remove方法</span></span><br><span class="line">            ArrayList.<span class="built_in">this</span>.remove(lastRet);</span><br><span class="line">            <span class="comment">// remove的是lastRet位置的元素，那么cursor（下一个即将返回的元素下标位置）就相当于往前面移动了一位，因为之前的lastRet位置的元素被删除了，后面所有元素都往前面移动了一位</span></span><br><span class="line">            cursor = lastRet;</span><br><span class="line">            <span class="comment">// 上一个返回的元素下标没有意义了，已经被删除了，直接置为-1</span></span><br><span class="line">            lastRet = -<span class="number">1</span>;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对里面的每一个元素进行处理  可以传入lambda表达式</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; consumer)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(consumer);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> ArrayList.<span class="built_in">this</span>.size;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i != size &amp;&amp; modCount == expectedModCount) &#123;</span><br><span class="line">            consumer.accept((E) elementData[i++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// update once at end of iteration to reduce heap write traffic</span></span><br><span class="line">        cursor = i;</span><br><span class="line">        lastRet = i - <span class="number">1</span>;</span><br><span class="line">        checkForComodification();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查过程中是否被修改</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ListItr"><a href="#ListItr" class="headerlink" title="ListItr"></a><strong>ListItr</strong></h3><p>继承了<code>Itr</code>,实现了<code>ListIterator</code>，主要增加的功能有：</p><ul><li>根据index获取该位置的迭代器，从当前位置开始迭代。</li><li>判断是否有前面的元素</li><li>获取下一个返回元素的下标</li><li>获取上一个返回元素的下面</li><li>获取上一个元素</li><li>更新元素</li><li>增加元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ListItr</span> <span class="keyword">extends</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">ListIterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">// 根据index获取该位置的迭代器</span></span><br><span class="line">    ListItr(<span class="type">int</span> index) &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        cursor = index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否有前面的元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPrevious</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取下一个返回元素的下标</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cursor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取上一个返回元素的下面</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">previousIndex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cursor - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取上一个元素</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">previous</span><span class="params">()</span> &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        cursor = i;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 更新元素</span></span><br><span class="line">            ArrayList.<span class="built_in">this</span>.set(lastRet, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 增加元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="comment">// 检查是否被更改</span></span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">            ArrayList.<span class="built_in">this</span>.add(i, e);</span><br><span class="line">            <span class="comment">// 插入元素后，下一个元素的下标递增1</span></span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 上一个元素为-1</span></span><br><span class="line">            lastRet = -<span class="number">1</span>;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ArrayListSpliterator"><a href="#ArrayListSpliterator" class="headerlink" title="ArrayListSpliterator"></a><strong>ArrayListSpliterator</strong></h3><p>​这是一个用来适应<strong>多线程并行迭代</strong>的迭代器，<strong>可以将集合分成多端</strong>，进行处理，<strong>每一个线程执行一段</strong>，那么就不会相互干扰，它可以做到线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ArrayListSpliterator</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Spliterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">// 存放ArrayList对象，</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;E&gt; list;</span><br><span class="line">    <span class="comment">// 当前位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> index;</span><br><span class="line">    <span class="comment">// 结束位置,-1表示最后一个元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> fence;</span><br><span class="line">    <span class="comment">// 期待的修改次数，用于比较是不是被修改了</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> expectedModCount; <span class="comment">// initialized when fence set</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Create new spliterator covering the given  range */</span></span><br><span class="line">    ArrayListSpliterator(ArrayList&lt;E&gt; list, <span class="type">int</span> origin, <span class="type">int</span> fence,</span><br><span class="line">                         <span class="type">int</span> expectedModCount) &#123;</span><br><span class="line">        <span class="built_in">this</span>.list = list; <span class="comment">// OK if null unless traversed</span></span><br><span class="line">        <span class="built_in">this</span>.index = origin;</span><br><span class="line">        <span class="built_in">this</span>.fence = fence;</span><br><span class="line">        <span class="built_in">this</span>.expectedModCount = expectedModCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getFence</span><span class="params">()</span> &#123; <span class="comment">// initialize fence to size on first use</span></span><br><span class="line">        <span class="type">int</span> hi; <span class="comment">// (a specialized variant appears in method forEach)</span></span><br><span class="line">        ArrayList&lt;E&gt; lst;</span><br><span class="line">        <span class="keyword">if</span> ((hi = fence) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((lst = list) == <span class="literal">null</span>)</span><br><span class="line">                hi = fence = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                expectedModCount = lst.modCount;</span><br><span class="line">                hi = fence = lst.size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分割ArrayList，每调用一次，将原来的迭代器等分为两份，并返回索引靠前的那一个子迭代器。</span></span><br><span class="line">    <span class="keyword">public</span> ArrayListSpliterator&lt;E&gt; <span class="title function_">trySplit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hi</span> <span class="operator">=</span> getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (lo &gt;= mid) ? <span class="literal">null</span> : <span class="comment">// divide range in half unless too small</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ArrayListSpliterator</span>&lt;E&gt;(list, lo, index = mid,</span><br><span class="line">                                        expectedModCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回true时，表示可能还有元素未处理</span></span><br><span class="line">    <span class="comment">// 返回falsa时，没有剩余元素处理了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAdvance</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; action)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">hi</span> <span class="operator">=</span> getFence(), i = index;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; hi) &#123;</span><br><span class="line">            index = i + <span class="number">1</span>;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> (E)list.elementData[i];</span><br><span class="line">            action.accept(e);</span><br><span class="line">            <span class="keyword">if</span> (list.modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历处理剩下的元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; action)</span> &#123;</span><br><span class="line">        <span class="type">int</span> i, hi, mc; <span class="comment">// hoist accesses and checks from loop</span></span><br><span class="line">        ArrayList&lt;E&gt; lst; Object[] a;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">if</span> ((lst = list) != <span class="literal">null</span> &amp;&amp; (a = lst.elementData) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((hi = fence) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                mc = lst.modCount;</span><br><span class="line">                hi = lst.size;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mc = expectedModCount;</span><br><span class="line">            <span class="keyword">if</span> ((i = index) &gt;= <span class="number">0</span> &amp;&amp; (index = hi) &lt;= a.length) &#123;</span><br><span class="line">                <span class="keyword">for</span> (; i &lt; hi; ++i) &#123;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> (E) a[i];</span><br><span class="line">                    action.accept(e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (lst.modCount == mc)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 估算大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">estimateSize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">long</span>) (getFence() - index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回特征值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">characteristics</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="LinkedList源码"><a href="#LinkedList源码" class="headerlink" title="LinkedList源码"></a>LinkedList源码</h1><p><img src="1.jpg"></p><p>类的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​LinkedList类的继承与实现接口体系与ArrayList、Vector有些许不同，继承了AbstractSequentialList，而不是AbstractList（其实间接继承了，看图），实现了<code>List</code>,<code>Queue</code>,<code>Cloneable</code>,<code>Serializable</code>，既可以当成列表使用，也可以当成队列，堆栈使用。主要特点有：</p><ul><li>线程不安全，不同步，如果需要同步需要使用<code>List list = Collections.synchronizedList(new LinkedList());</code></li><li>实现<code>List</code>接口，可以对它进行队列操作</li><li>实现<code>Queue</code>接口，可以当成堆栈或者双向队列使用</li><li>实现Cloneable接口，可以被克隆，浅拷贝</li><li>实现<code>Serializable</code>，可以被序列化和反序列化</li></ul><p>​LinkedList使用的底层数据结构与ArraysList、Vector不同，它使用的是<strong>双向链表</strong>（JDK1.6之前是循环列表，JDK1.7之后改成了双向链表），而AbstractSequentialList、Deque则是封装了链表的一些操作以及特性。</p><h2 id="底层数据结构-1"><a href="#底层数据结构-1" class="headerlink" title="底层数据结构"></a>底层数据结构</h2><p>在LinkedList里有个私有的静态Node类，它就是双向链表每个节点的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="comment">// 元素</span></span><br><span class="line">  E item;</span><br><span class="line">  <span class="comment">// 后驱节点</span></span><br><span class="line">  Node&lt;E&gt; next;</span><br><span class="line">  <span class="comment">// 前驱节点</span></span><br><span class="line">  Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">  Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">    <span class="built_in">this</span>.item = element;</span><br><span class="line">    <span class="built_in">this</span>.next = next;</span><br><span class="line">    <span class="built_in">this</span>.prev = prev;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链表的大小</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 指向第一个节点的指针。</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="comment">// 指向最后一个节点的指针。</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 构造一个空的链表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 按照集合的迭代器返回元素的顺序构造包含指定集合元素的列表。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>();</span><br><span class="line">  addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用List方法"><a href="#常用List方法" class="headerlink" title="常用List方法"></a>常用List方法</h2><h3 id="getFirst"><a href="#getFirst" class="headerlink" title="getFirst()"></a><strong>getFirst()</strong></h3><p>获取第一个元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public E <span class="title function_">getFirst</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 保存第一个元素为f，注意是final的，</span></span><br><span class="line">    final <span class="title class_">Node</span>&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 如果没有第一个元素，那么就会抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="comment">// 返回第一个元素的item</span></span><br><span class="line">    <span class="keyword">return</span> f.<span class="property">item</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getLast"><a href="#getLast" class="headerlink" title="getLast()"></a><strong>getLast()</strong></h3><p>获取最后一个元素,和获取第一个的原理差不多</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public E <span class="title function_">getLast</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 保存最后一个元素的引用为l</span></span><br><span class="line">    final <span class="title class_">Node</span>&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">// 如果为空，抛出错误</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="comment">// 返回item</span></span><br><span class="line">    <span class="keyword">return</span> l.<span class="property">item</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="get-int-index"><a href="#get-int-index" class="headerlink" title="get(int index)"></a><strong>get(int index)</strong></h3><p>通过索引来获取元素,里面是调用了另外一个方法先获取节点，再获取该节点的<code>item</code>,在此之前，做了<code>index</code>安全性校验。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public E <span class="title function_">get</span>(<span class="params">int index</span>) &#123;</span><br><span class="line">    <span class="title function_">checkElementIndex</span>(index);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">node</span>(index).<span class="property">item</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中调用了通过索引位置查找节点位置的函数，下面我们来分析一下这个函数,由于底层是链表实现的，所以呢？遍历起来不是很方便，就考虑到位运算，如果索引位置在后面一半，就从后往前遍历查找，否则从前往后遍历。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Node</span>&lt;E&gt; <span class="title function_">node</span>(<span class="params">int index</span>) &#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"><span class="comment">// size&gt;&gt;1 表示除以2，相当于index小于size的一半</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">       <span class="comment">// 从前面开始遍历，取出first节点，因为中间过程引用会变化，所以不可直接操作first</span></span><br><span class="line">        <span class="title class_">Node</span>&lt;E&gt; x = first;</span><br><span class="line">       <span class="comment">// 通过循环计数来查找</span></span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.<span class="property">next</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 取出最后一个元素</span></span><br><span class="line">        <span class="title class_">Node</span>&lt;E&gt; x = last;</span><br><span class="line">       <span class="comment">// 从后往前遍历</span></span><br><span class="line">        <span class="keyword">for</span> (int i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.<span class="property">prev</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="indexOf-Object-o"><a href="#indexOf-Object-o" class="headerlink" title="indexOf(Object o)"></a><strong>indexOf(Object o)</strong></h3><p>查找某一个元素的索引位置,分为两种情况讨论，如果要查找的元素为空，那么就使用<code>==</code>，否则使用<code>equals()</code>，这也从侧面印证了<code>LinedList</code>实际上是可以存储<code>null</code>元素的。使用计数查找：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public int <span class="title function_">indexOf</span>(<span class="params"><span class="built_in">Object</span> o</span>) &#123;</span><br><span class="line">    int index = <span class="number">0</span>;</span><br><span class="line">   <span class="comment">// 如果需要查找null元素</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="title class_">Node</span>&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.<span class="property">next</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.<span class="property">item</span> == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 查找元素不为空</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="title class_">Node</span>&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.<span class="property">next</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.<span class="title function_">equals</span>(x.<span class="property">item</span>))</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lastIndexOf-Object-o"><a href="#lastIndexOf-Object-o" class="headerlink" title="lastIndexOf(Object o)"></a><strong>lastIndexOf(Object o)</strong></h3><p>和前面的<code>indexOf</code>差不多，区别就是这个是后面开始查找，找到第一个符合的元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public int <span class="title function_">indexOf</span>(<span class="params"><span class="built_in">Object</span> o</span>) &#123;</span><br><span class="line">    int index = <span class="number">0</span>;</span><br><span class="line">   <span class="comment">// 查找元素</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="title class_">Node</span>&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.<span class="property">next</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.<span class="property">item</span> == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="title class_">Node</span>&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.<span class="property">next</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.<span class="title function_">equals</span>(x.<span class="property">item</span>))</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a><strong>添加元素</strong></h2><h3 id="addFirst-E-e"><a href="#addFirst-E-e" class="headerlink" title="addFirst(E e)"></a><strong>addFirst(E e)</strong></h3><p>将元素e，添加到第一个节点，公有方法是<code>addFirst()</code>，但是其实内部调用是<code>linkFirst()</code>，这是<code>private</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> <span class="title function_">addFirst</span>(<span class="params">E e</span>) &#123;</span><br><span class="line">    <span class="title function_">linkFirst</span>(e);</span><br><span class="line">&#125;</span><br><span class="line">private <span class="keyword">void</span> <span class="title function_">linkFirst</span>(<span class="params">E e</span>) &#123;</span><br><span class="line">    <span class="comment">// 先保存第一个节点</span></span><br><span class="line">    final <span class="title class_">Node</span>&lt;E&gt; f = first;</span><br><span class="line">    <span class="comment">// 初始化一个新节点，prev是null，next是f（之前的首节点）</span></span><br><span class="line">    final <span class="title class_">Node</span>&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>, e, f);</span><br><span class="line">    <span class="comment">// 更新first为新节点</span></span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="comment">// 如果之前的第一个节点是空的，那么就说明里面是空的，没有元素</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 最后一个元素也是新加入的元素</span></span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// f的prev前置节点的引用更新为新的节点</span></span><br><span class="line">        f.<span class="property">prev</span> = newNode;</span><br><span class="line">    <span class="comment">// 个数增加</span></span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">// 修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="addLast-E-e"><a href="#addLast-E-e" class="headerlink" title="addLast(E e)"></a><strong>addLast(E e)</strong></h3><p>将元素添加在链表最后，其实内部也是直接调用的<code>private</code>方法<code>linkLast()</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> <span class="title function_">addLast</span>(<span class="params">E e</span>) &#123;</span><br><span class="line">    <span class="title function_">linkLast</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkLast</span>(<span class="params">E e</span>) &#123;</span><br><span class="line">    <span class="comment">// 保存最后一个节点的引用</span></span><br><span class="line">    final <span class="title class_">Node</span>&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">// 初始化一个节点，前置节点指针引用指向之前的最后一个节点，后续节点的引用是null</span></span><br><span class="line">    final <span class="title class_">Node</span>&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 将最后一个节点更新</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">// 如果之前的最后一个节点是null，说明链表是空的</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 新节点同时是第一个节点</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则之前的最后一个节点的后续节点引用更新为新的节点</span></span><br><span class="line">        l.<span class="property">next</span> = newNode;</span><br><span class="line">    <span class="comment">// 大小+1</span></span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">// 修改次数+1</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="add-E-e"><a href="#add-E-e" class="headerlink" title="add(E e)"></a><strong>add(E e)</strong></h3><p>增加元素，默认也是在链表的最后添加，完成返回true：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public boolean <span class="title function_">add</span>(<span class="params">E e</span>) &#123;</span><br><span class="line">    <span class="title function_">linkLast</span>(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="addAll-Collection-lt-extends-E-gt-c"><a href="#addAll-Collection-lt-extends-E-gt-c" class="headerlink" title="addAll(Collection&lt;? extends E&gt; c)"></a><strong>addAll(Collection&lt;? extends E&gt; c)</strong></h3><p>往链表里面批量添加元素,里面默认是在最后面批量添加，内部调用的是<code>addAll(int index, Collection&lt;? extends E&gt; c)</code>,添加之前会判断索引位置是不是合法的。然后查找需要插入的位置的前后节点，循环插入。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public boolean <span class="title function_">addAll</span>(<span class="params">Collection&lt;? <span class="keyword">extends</span> E&gt; c</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">addAll</span>(size, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean <span class="title function_">addAll</span>(<span class="params">int index, Collection&lt;? <span class="keyword">extends</span> E&gt; c</span>) &#123;</span><br><span class="line">    <span class="comment">// 检查添加位置</span></span><br><span class="line">    <span class="title function_">checkPositionIndex</span>(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将需要添加的集合转换成为数组</span></span><br><span class="line">    <span class="title class_">Object</span>[] a = c.<span class="title function_">toArray</span>();</span><br><span class="line">    <span class="comment">// 获取数组的大小</span></span><br><span class="line">    int numNew = a.<span class="property">length</span>;</span><br><span class="line">    <span class="comment">// 如果数组长度为0，说明没有需要添加的元素，返回false</span></span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入位置的前节点和后续节点</span></span><br><span class="line">    <span class="title class_">Node</span>&lt;E&gt; pred, succ;</span><br><span class="line">    <span class="comment">// 如果插入位置索引大小等于链表大小，那么就是在最后插入元素</span></span><br><span class="line">    <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">        <span class="comment">// 最后插入元素没有后续节点</span></span><br><span class="line">        succ = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 前一个节点就是之前的最后一个节点</span></span><br><span class="line">        pred = last;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 查找到索引为index 的节点</span></span><br><span class="line">        succ = <span class="title function_">node</span>(index);</span><br><span class="line">        <span class="comment">// 获取前一个节点</span></span><br><span class="line">        pred = succ.<span class="property">prev</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环插入节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="title class_">Object</span> o : a) &#123;</span><br><span class="line">        @<span class="title class_">SuppressWarnings</span>(<span class="string">&quot;unchecked&quot;</span>) E e = (E) o;</span><br><span class="line">        <span class="comment">// 初始化新节点，上一个节点是pred</span></span><br><span class="line">        <span class="title class_">Node</span>&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(pred, e, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 如果前一个节点是null，那么第一个节点就是新的节点</span></span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="literal">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 否则pred的next置为新节点</span></span><br><span class="line">            pred.<span class="property">next</span> = newNode;</span><br><span class="line">        pred = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果插入位置没有后续节点，也就是succ为null</span></span><br><span class="line">    <span class="keyword">if</span> (succ == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 最后一个节点也就是pred，刚刚插入的新节点</span></span><br><span class="line">        last = pred;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 加入所有元素之后的最后一个节点的下一个节点指向succ（后续元素）</span></span><br><span class="line">        pred.<span class="property">next</span> = succ;</span><br><span class="line">        <span class="comment">// 插入位置的后续元素的上一个节点引用指向pred</span></span><br><span class="line">        succ.<span class="property">prev</span> = pred;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// 大小改变</span></span><br><span class="line">    size += numNew;</span><br><span class="line">   <span class="comment">// 修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码调用了<code>node(index)</code>，这个在前面查找的时候已经说过了，不再解释。</p><h3 id="addAll-int-index-Collection-lt-extends-E-gt-c"><a href="#addAll-int-index-Collection-lt-extends-E-gt-c" class="headerlink" title="addAll(int index, Collection&lt;? extends E&gt; c)"></a><strong>addAll(int index, Collection&lt;? extends E&gt; c)</strong></h3><p>在指定位置批量插入节点：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public boolean <span class="title function_">addAll</span>(<span class="params">int index, Collection&lt;? <span class="keyword">extends</span> E&gt; c</span>) &#123;</span><br><span class="line">   <span class="comment">// 检查索引合法性</span></span><br><span class="line">    <span class="title function_">checkPositionIndex</span>(index);</span><br><span class="line">   <span class="comment">// 将需要插入的集合转换成为数组</span></span><br><span class="line">    <span class="title class_">Object</span>[] a = c.<span class="title function_">toArray</span>();</span><br><span class="line">   <span class="comment">// 数组的长度</span></span><br><span class="line">    int numNew = a.<span class="property">length</span>;</span><br><span class="line">   <span class="comment">// 为0则不需要插入</span></span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="comment">// 插入位置的前节点和后节点</span></span><br><span class="line">    <span class="title class_">Node</span>&lt;E&gt; pred, succ;</span><br><span class="line">   <span class="comment">// 如果在最后插入</span></span><br><span class="line">    <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">       <span class="comment">// 后节点为空</span></span><br><span class="line">        succ = <span class="literal">null</span>;</span><br><span class="line">       <span class="comment">// 前节点是最后一个</span></span><br><span class="line">        pred = last;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 获取插入位置的后节点</span></span><br><span class="line">        succ = <span class="title function_">node</span>(index);</span><br><span class="line">       <span class="comment">// 获取前节点</span></span><br><span class="line">        pred = succ.<span class="property">prev</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="title class_">Object</span> o : a) &#123;</span><br><span class="line">        @<span class="title class_">SuppressWarnings</span>(<span class="string">&quot;unchecked&quot;</span>) E e = (E) o;</span><br><span class="line">       <span class="comment">// 初始化节点，前置节点是插入位置的前节点，后续节点为null</span></span><br><span class="line">        <span class="title class_">Node</span>&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(pred, e, <span class="literal">null</span>);</span><br><span class="line">       <span class="comment">// 如果插入位置前一个节点是null，说明插入位置是链表首</span></span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="literal">null</span>)</span><br><span class="line">           <span class="comment">// 首节点就是新插入的节点</span></span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">           <span class="comment">// 前节点的next指向新节点</span></span><br><span class="line">            pred.<span class="property">next</span> = newNode;</span><br><span class="line">       <span class="comment">// 更新插入位置的前一个节点</span></span><br><span class="line">        pred = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// 如果插入位置的后一个节点为空，说明插入位置是链表尾部</span></span><br><span class="line">    <span class="keyword">if</span> (succ == <span class="literal">null</span>) &#123;</span><br><span class="line">       <span class="comment">// 最后一个元素就是插入的元素</span></span><br><span class="line">        last = pred;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 将插入的最后一个元素next指向succ</span></span><br><span class="line">        pred.<span class="property">next</span> = succ;</span><br><span class="line">       <span class="comment">// succ的上一个元素指向prev</span></span><br><span class="line">        succ.<span class="property">prev</span> = pred;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// 大小更新</span></span><br><span class="line">    size += numNew;</span><br><span class="line">   <span class="comment">// 修改次数改变</span></span><br><span class="line">    modCount++;</span><br><span class="line">   <span class="comment">// 返回成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="add-int-index-E-element"><a href="#add-int-index-E-element" class="headerlink" title="add(int index,E element)"></a><strong>add(int index,E element)</strong></h3><p>将元素插入在指定位置,先判断索引位置，如果索引位置是最后一个，那么直接调用在最后添加元素函数即可，否则需要调用另外一个函数，在某个元素前面插入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> <span class="title function_">add</span>(<span class="params">int index, E element</span>) &#123;</span><br><span class="line">   <span class="comment">// index校验</span></span><br><span class="line">    <span class="title function_">checkPositionIndex</span>(index);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 索引等于链表大小</span></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">       <span class="comment">// 直接在最后插入元素</span></span><br><span class="line">        <span class="title function_">linkLast</span>(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       <span class="comment">// 在某个节点前插入元素</span></span><br><span class="line">        <span class="title function_">linkBefore</span>(element, <span class="title function_">node</span>(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除元素-1"><a href="#删除元素-1" class="headerlink" title="删除元素"></a><strong>删除元素</strong></h2><h3 id="removeFirst"><a href="#removeFirst" class="headerlink" title="removeFirst()"></a><strong>removeFirst()</strong></h3><p>删除第一个节点，先获取首节点，判断第一个节点是不是为空，如果为空则证明没有该节点，抛出异常，内部调用的其实是<code>unlinkFirst()</code>。返回值是被移除的节点里面的数值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">  public E <span class="title function_">removeFirst</span>(<span class="params"></span>) &#123;</span><br><span class="line">      final <span class="title class_">Node</span>&lt;E&gt; f = first;</span><br><span class="line">      <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">unlinkFirst</span>(f);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 移除首节点</span></span><br><span class="line">  private E <span class="title function_">unlinkFirst</span>(<span class="params">Node&lt;E&gt; f</span>) &#123;</span><br><span class="line">      <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">     <span class="comment">// 获取里面的元素</span></span><br><span class="line">      final E element = f.<span class="property">item</span>;</span><br><span class="line">     <span class="comment">// 保存下一个节点</span></span><br><span class="line">      final <span class="title class_">Node</span>&lt;E&gt; next = f.<span class="property">next</span>;</span><br><span class="line">     <span class="comment">// 将之前的首节点前后节点引用置空，有利于GC</span></span><br><span class="line">      f.<span class="property">item</span> = <span class="literal">null</span>;</span><br><span class="line">      f.<span class="property">next</span> = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">     <span class="comment">// 首节点更新</span></span><br><span class="line">      first = next;</span><br><span class="line">     <span class="comment">// 如果首节点是空的，那么链表没有元素了，最后一个节点自然也是null</span></span><br><span class="line">      <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">          last = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">         <span class="comment">// 否则当前的第一个节点的前置节点置null</span></span><br><span class="line">          next.<span class="property">prev</span> = <span class="literal">null</span>;</span><br><span class="line">     <span class="comment">// 链表大小-1</span></span><br><span class="line">      size--;</span><br><span class="line">     <span class="comment">// 修改次数增加</span></span><br><span class="line">      modCount++;</span><br><span class="line">      <span class="keyword">return</span> element;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="removeLast"><a href="#removeLast" class="headerlink" title="removeLast()"></a><strong>removeLast()</strong></h3><p>删除最后一个节点，和上面的删除首节点差不多，先取出最后一个节点，判断是否为空，如果为空则抛出异常，否则会调用另一个解除连接的函数<code>unLinkLast()</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public E <span class="title function_">removeLast</span>(<span class="params"></span>) &#123;</span><br><span class="line">    final <span class="title class_">Node</span>&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">unlinkLast</span>(l);</span><br><span class="line">&#125;</span><br><span class="line">private E <span class="title function_">unlinkLast</span>(<span class="params">Node&lt;E&gt; l</span>) &#123;</span><br><span class="line">    <span class="comment">// assert l == last &amp;&amp; l != null;</span></span><br><span class="line">   <span class="comment">// 保存被移除的节点的item</span></span><br><span class="line">    final E element = l.<span class="property">item</span>;</span><br><span class="line">   <span class="comment">// 获取上一个节点</span></span><br><span class="line">    final <span class="title class_">Node</span>&lt;E&gt; prev = l.<span class="property">prev</span>;</span><br><span class="line">   <span class="comment">// 前后引用置空，有利于垃圾回收</span></span><br><span class="line">    l.<span class="property">item</span> = <span class="literal">null</span>;</span><br><span class="line">    l.<span class="property">prev</span> = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">   <span class="comment">// 更新最后一个节点</span></span><br><span class="line">    last = prev;</span><br><span class="line">   <span class="comment">// 如果前置节点为空，那么链表已经没有元素了</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">null</span>)</span><br><span class="line">        first = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       <span class="comment">// 否则将上一个节点的next置null</span></span><br><span class="line">        prev.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">   <span class="comment">// 大小该表</span></span><br><span class="line">    size--;</span><br><span class="line">   <span class="comment">// 修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">   <span class="comment">// 返回被移除的节点的item值</span></span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a><strong>remove(Object o)</strong></h3><p>删除某个元素分为两种情况，元素为null和非null,直接遍历判断，里面真正删除的方法其实是<code>unlink(E e)</code>，成功移除则返回true，注意这里只会移除掉第一个，后续要是还有该节点，不会移除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public boolean <span class="title function_">remove</span>(<span class="params"><span class="built_in">Object</span> o</span>) &#123;</span><br><span class="line">   <span class="comment">// 元素为null</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="title class_">Node</span>&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.<span class="property">next</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.<span class="property">item</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="title function_">unlink</span>(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 元素不为null</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="title class_">Node</span>&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.<span class="property">next</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.<span class="title function_">equals</span>(x.<span class="property">item</span>)) &#123;</span><br><span class="line">               <span class="comment">// 移除节点</span></span><br><span class="line">                <span class="title function_">unlink</span>(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>unLink(E e)</code>方法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">unlink</span>(<span class="params">Node&lt;E&gt; x</span>) &#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">   <span class="comment">// 保存被移除节点的item</span></span><br><span class="line">    final E element = x.<span class="property">item</span>;</span><br><span class="line">   <span class="comment">// 下一个节点</span></span><br><span class="line">    final <span class="title class_">Node</span>&lt;E&gt; next = x.<span class="property">next</span>;</span><br><span class="line">   <span class="comment">// 上一个节点</span></span><br><span class="line">    final <span class="title class_">Node</span>&lt;E&gt; prev = x.<span class="property">prev</span>;</span><br><span class="line">   <span class="comment">// 如果前置节点为空，那么首节点就是当前节点了</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 前一个节点的next置为下一个节点</span></span><br><span class="line">        prev.<span class="property">next</span> = next;</span><br><span class="line">       <span class="comment">// 之前的节点的前一个节点置null</span></span><br><span class="line">        x.<span class="property">prev</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// 如果next是空的，那么上一个节点就是现在最后一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// next的上一个节点引用指向prev</span></span><br><span class="line">        next.<span class="property">prev</span> = prev;</span><br><span class="line">       <span class="comment">// 被删除的元素的next置空</span></span><br><span class="line">        x.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// item置空</span></span><br><span class="line">    x.<span class="property">item</span> = <span class="literal">null</span>;</span><br><span class="line">   <span class="comment">// 大小改变</span></span><br><span class="line">    size--;</span><br><span class="line">   <span class="comment">// 修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">   <span class="comment">// 返回被删除的节点里面的item</span></span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="clear"><a href="#clear" class="headerlink" title="clear()"></a><strong>clear()</strong></h3><p>移除里面所有的元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// Clearing all of the links between nodes is &quot;unnecessary&quot;, but:</span></span><br><span class="line">    <span class="comment">// - helps a generational GC if the discarded nodes inhabit</span></span><br><span class="line">    <span class="comment">//   more than one generation</span></span><br><span class="line">    <span class="comment">// - is sure to free memory even if there is a reachable Iterator</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="title class_">Node</span>&lt;E&gt; x = first; x != <span class="literal">null</span>; ) &#123;</span><br><span class="line">       <span class="comment">// 保存下一个</span></span><br><span class="line">        <span class="title class_">Node</span>&lt;E&gt; next = x.<span class="property">next</span>;</span><br><span class="line">       <span class="comment">// 当前元素置空</span></span><br><span class="line">        x.<span class="property">item</span> = <span class="literal">null</span>;</span><br><span class="line">        x.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">        x.<span class="property">prev</span> = <span class="literal">null</span>;</span><br><span class="line">        x = next;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// 首节点和尾节点全部置null</span></span><br><span class="line">    first = last = <span class="literal">null</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remove（int-index）"><a href="#remove（int-index）" class="headerlink" title="remove（int index）"></a><strong>remove（int index）</strong></h3><p>移除指定索引的元素。先通过索引找到节点，再移除指定的节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public E <span class="title function_">remove</span>(<span class="params">int index</span>) &#123;</span><br><span class="line">   <span class="comment">// 检查合法性</span></span><br><span class="line">    <span class="title function_">checkElementIndex</span>(index);</span><br><span class="line">   <span class="comment">// 先找到节点，再移除指定节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">unlink</span>(<span class="title function_">node</span>(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更新元素"><a href="#更新元素" class="headerlink" title="更新元素"></a><strong>更新元素</strong></h2><h3 id="set-int-index-E-element"><a href="#set-int-index-E-element" class="headerlink" title="set(int index,E element)"></a><strong>set(int index,E element)</strong></h3><p>更新指定索引的位置的元素,首先通过索引查找到该元素，然后修改item值，返回旧的item值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">   <span class="comment">// 检查索引是否合法</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">   <span class="comment">// 通过索引查找到节点</span></span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">   <span class="comment">// 保存旧的值</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">oldVal</span> <span class="operator">=</span> x.item;</span><br><span class="line">   <span class="comment">// 修改</span></span><br><span class="line">    x.item = element;</span><br><span class="line">   <span class="comment">// 返回旧的元素</span></span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> List源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发-CompletableFuture</title>
      <link href="/2022/09/18/%E5%B9%B6%E5%8F%91-CompletableFuture/"/>
      <url>/2022/09/18/%E5%B9%B6%E5%8F%91-CompletableFuture/</url>
      
        <content type="html"><![CDATA[<h1 id="Future接口的局限性"><a href="#Future接口的局限性" class="headerlink" title="Future接口的局限性"></a>Future接口的局限性</h1><p>​当我们得到包含结果的Future时，我们可以使用get方法<strong>等待线程完成</strong>并获取返回值，如果任务还没有完成，Future的<strong>get()</strong> 方法会阻塞主线程直到任务完成，即使我们使用isDone()方法轮询去查看线程执行状态，但是这样也非常浪费cpu资源。</p><p>​我们异步执行一个任务时，一般是用线程池Executor去创建。如果不需要有返回值， 任务实现Runnable接口；如果需要有返回值，任务实现Callable接口，调用Executor的submit方法，再使用Future获取即可。</p><span id="more"></span><p>举例如下：假设我们有两个任务服务，一个查询用户基本信息，一个是查询用户勋章信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfoService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> UserInfo <span class="title function_">getUserInfo</span><span class="params">(Long userId)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Thread.sleep(<span class="number">300</span>);<span class="comment">//模拟调用耗时</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserInfo</span>(<span class="string">&quot;666&quot;</span>, <span class="string">&quot;捡田螺的小男孩&quot;</span>, <span class="number">27</span>); <span class="comment">//一般是查数据库，或者远程调用返回的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MedalService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MedalInfo <span class="title function_">getMedalInfo</span><span class="params">(<span class="type">long</span> userId)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Thread.sleep(<span class="number">500</span>); <span class="comment">//模拟调用耗时</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MedalInfo</span>(<span class="string">&quot;666&quot;</span>, <span class="string">&quot;守护勋章&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Future进行异步调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">UserInfoService</span> <span class="variable">userInfoService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserInfoService</span>();</span><br><span class="line">        <span class="type">MedalService</span> <span class="variable">medalService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MedalService</span>();</span><br><span class="line">        <span class="type">long</span> <span class="variable">userId</span> <span class="operator">=</span><span class="number">666L</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用用户服务获取用户基本信息</span></span><br><span class="line">        FutureTask&lt;UserInfo&gt; userInfoFutureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;UserInfo&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> UserInfo <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="keyword">return</span> userInfoService.getUserInfo(userId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.submit(userInfoFutureTask);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">300</span>); <span class="comment">//模拟主线程其它操作耗时</span></span><br><span class="line"></span><br><span class="line">        FutureTask&lt;MedalInfo&gt; medalInfoFutureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;MedalInfo&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> MedalInfo <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="keyword">return</span> medalService.getMedalInfo(userId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.submit(medalInfoFutureTask);</span><br><span class="line"><span class="comment">//这里主线程会一直阻塞直到多线程任务执行完成之后有结果返回，主线程才继续开始执行。</span></span><br><span class="line">        <span class="type">UserInfo</span> <span class="variable">userInfo</span> <span class="operator">=</span> userInfoFutureTask.get();<span class="comment">//获取个人信息结果</span></span><br><span class="line">        <span class="type">MedalInfo</span> <span class="variable">medalInfo</span> <span class="operator">=</span> medalInfoFutureTask.get();<span class="comment">//获取勋章信息结果</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;总共用时&quot;</span> + (System.currentTimeMillis() - startTime) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h1><p>还是基于以上Future的例子，改用CompletableFuture 来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">UserInfoService</span> <span class="variable">userInfoService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserInfoService</span>();</span><br><span class="line">        <span class="type">MedalService</span> <span class="variable">medalService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MedalService</span>();</span><br><span class="line">        <span class="type">long</span> <span class="variable">userId</span> <span class="operator">=</span><span class="number">666L</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用用户服务获取用户基本信息</span></span><br><span class="line">        CompletableFuture&lt;UserInfo&gt; completableUserInfoFuture = CompletableFuture.supplyAsync(() -&gt; userInfoService.getUserInfo(userId));</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">300</span>); <span class="comment">//模拟主线程其它操作耗时</span></span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;MedalInfo&gt; completableMedalInfoFuture = CompletableFuture.supplyAsync(() -&gt; medalService.getMedalInfo(userId)); </span><br><span class="line"></span><br><span class="line">        <span class="type">UserInfo</span> <span class="variable">userInfo</span> <span class="operator">=</span> completableUserInfoFuture.get(<span class="number">2</span>,TimeUnit.SECONDS);<span class="comment">//获取个人信息结果</span></span><br><span class="line">        <span class="type">MedalInfo</span> <span class="variable">medalInfo</span> <span class="operator">=</span> completableMedalInfoFuture.get();<span class="comment">//获取勋章信息结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;总共用时&quot;</span> + (System.currentTimeMillis() - startTime) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​可以发现，使用CompletableFuture，代码简洁了很多。CompletableFuture的supplyAsync方法，提供了异步执行的功能，线程池也不用单独创建了。实际上，它CompletableFuture使用了默认线程池是<strong>ForkJoinPool.commonPool</strong>。</p><p>​使用CompletableFuture的异步任务场景。这些方法包括<strong>创建异步任务、任务异步回调、多个任务组合处理</strong>等。</p><h1 id="创建异步任务"><a href="#创建异步任务" class="headerlink" title="创建异步任务"></a>创建异步任务</h1><h2 id="实例化CompletableFuture"><a href="#实例化CompletableFuture" class="headerlink" title="实例化CompletableFuture"></a>实例化CompletableFuture</h2><p>实例化方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用默认内置线程池ForkJoinPool.commonPool()，根据supplier构建执行任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span>;</span><br><span class="line"><span class="comment">//自定义线程，根据supplier构建执行任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier, Executor executor)</span>;</span><br><span class="line"><span class="comment">//使用默认内置线程池ForkJoinPool.commonPool()，根据runnable构建执行任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable)</span>;</span><br><span class="line"><span class="comment">//自定义线程，根据runnable构建执行任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable, Executor executor)</span>;</span><br></pre></td></tr></table></figure><p>有两种格式，一种是supply开头的方法，一种是run开头的方法</p><ul><li>supplyAsync执行CompletableFuture任务，支持返回值</li><li>runAsync执行CompletableFuture任务，没有返回值。</li></ul><h1 id="任务异步回调"><a href="#任务异步回调" class="headerlink" title="任务异步回调"></a>任务异步回调</h1><h2 id="1-thenRun-x2F-thenRunAsync"><a href="#1-thenRun-x2F-thenRunAsync" class="headerlink" title="1. thenRun&#x2F;thenRunAsync"></a>1. thenRun&#x2F;thenRunAsync</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenRun</span><span class="params">(Runnable action)</span>;</span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenRunAsync</span><span class="params">(Runnable action)</span>;</span><br></pre></td></tr></table></figure><p>CompletableFuture的thenRun方法，通俗点讲就是，<strong>做完第一个任务后，再做第二个任务</strong>。某个任务执行完成后，执行回调方法；但是前后两个任务<strong>没有参数传递，第二个任务也没有返回值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureThenRunTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; orgFuture = CompletableFuture.supplyAsync(</span><br><span class="line">                ()-&gt;&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;先执行第一个CompletableFuture方法任务&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;捡田螺的小男孩&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="type">CompletableFuture</span> <span class="variable">thenRunFuture</span> <span class="operator">=</span> orgFuture.thenRun(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;接着执行第二个任务&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(thenRunFuture.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">先执行第一个CompletableFuture方法任务</span><br><span class="line">接着执行第二个任务</span><br><span class="line"><span class="literal">null</span></span><br></pre></td></tr></table></figure><h3 id="thenRun-和thenRunAsync的区别"><a href="#thenRun-和thenRunAsync的区别" class="headerlink" title="thenRun 和thenRunAsync的区别"></a>thenRun 和thenRunAsync的区别</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Executor</span> <span class="variable">asyncPool</span> <span class="operator">=</span> useCommonPool ?</span><br><span class="line">        ForkJoinPool.commonPool() : <span class="keyword">new</span> <span class="title class_">ThreadPerTaskExecutor</span>();</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenRun</span><span class="params">(Runnable action)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> uniRunStage(<span class="literal">null</span>, action);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenRunAsync</span><span class="params">(Runnable action)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> uniRunStage(asyncPool, action);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果执行第一个任务的时候，传入了一个自定义线程池：</p><ul><li>调用thenRun方法执行第二个任务时，则第二个任务和第一个任务是<strong>共用同一个线程池</strong>。</li><li>调用thenRunAsync执行第二个任务时，则第一个任务使用的是自己传入的线程池，<strong>第二个任务使用的是ForkJoin线程池</strong></li></ul><p>thenAccept和thenAcceptAsync，thenApply和thenApplyAsync等，它们之间的区别也一样。</p><h2 id="2-thenAccept-x2F-thenAcceptAsync"><a href="#2-thenAccept-x2F-thenAcceptAsync" class="headerlink" title="2.thenAccept&#x2F;thenAcceptAsync"></a>2.thenAccept&#x2F;thenAcceptAsync</h2><p>ompletableFuture的thenAccept方法表示，第一个任务执行完成后，执行第二个回调方法任务，会将该任务的执行结果，作为入参，传递到回调方法中，但是回调方法是<strong>没有返回值</strong>的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureThenAcceptTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; orgFuture = CompletableFuture.supplyAsync(</span><br><span class="line">                ()-&gt;&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;原始CompletableFuture方法任务&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;捡田螺的小男孩&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="type">CompletableFuture</span> <span class="variable">thenAcceptFuture</span> <span class="operator">=</span> orgFuture.thenAccept((a) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;捡田螺的小男孩&quot;</span>.equals(a)) &#123;<span class="comment">//这里a就是上一个任务结束返回传过来的入参。</span></span><br><span class="line">                System.out.println(<span class="string">&quot;关注了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;先考虑考虑&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(thenAcceptFuture.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-thenApply-x2F-thenApplyAsync"><a href="#3-thenApply-x2F-thenApplyAsync" class="headerlink" title="3. thenApply&#x2F;thenApplyAsync"></a>3. thenApply&#x2F;thenApplyAsync</h2><p>CompletableFuture的thenApply方法表示，第一个任务执行完成后，执行第二个回调方法任务，会将该任务的执行结果，作为入参，传递到回调方法中，<strong>并且回调方法是有返回值的。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureThenApplyTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; orgFuture = CompletableFuture.supplyAsync(</span><br><span class="line">                ()-&gt;&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;原始CompletableFuture方法任务&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;捡田螺的小男孩&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; thenApplyFuture = orgFuture.thenApply((a) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;捡田螺的小男孩&quot;</span>.equals(a)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;关注了&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;先考虑考虑&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(thenApplyFuture.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">原始CompletableFuture方法任务</span><br><span class="line">关注了</span><br></pre></td></tr></table></figure><h2 id="4-exceptionally"><a href="#4-exceptionally" class="headerlink" title="4. exceptionally"></a>4. exceptionally</h2><p>CompletableFuture的exceptionally方法表示，某个任务执行异常时，执行的回调方法;并且有<strong>抛出异常作为参数</strong>，传递到回调方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureExceptionTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; orgFuture = CompletableFuture.supplyAsync(</span><br><span class="line">                ()-&gt;&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;当前线程名称：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; exceptionFuture = orgFuture.exceptionally((e) -&gt; &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;你的程序异常啦&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(exceptionFuture.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">当前线程名称：ForkJoinPool.commonPool-worker-<span class="number">1</span></span><br><span class="line">java.util.concurrent.CompletionException: java.lang.RuntimeException</span><br><span class="line">at java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:<span class="number">273</span>)</span><br><span class="line">at java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:<span class="number">280</span>)</span><br><span class="line">at java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:<span class="number">1592</span>)</span><br><span class="line">at java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:<span class="number">1582</span>)</span><br><span class="line">at java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:<span class="number">289</span>)</span><br><span class="line">at java.util.concurrent.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:<span class="number">1056</span>)</span><br><span class="line">at java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:<span class="number">1692</span>)</span><br><span class="line">at java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:<span class="number">157</span>)</span><br><span class="line">Caused by: java.lang.RuntimeException</span><br><span class="line">at cn.eovie.future.FutureWhenTest.lambda$main$<span class="number">0</span>(FutureWhenTest.java:<span class="number">13</span>)</span><br><span class="line">at java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:<span class="number">1590</span>)</span><br><span class="line">... <span class="number">5</span> more</span><br><span class="line">你的程序异常啦</span><br></pre></td></tr></table></figure><h2 id="5-whenComplete方法"><a href="#5-whenComplete方法" class="headerlink" title="5. whenComplete方法"></a>5. whenComplete方法</h2><p>CompletableFuture的whenComplete方法表示，某个任务执行完成后，执行的回调方法，<strong>无返回值</strong>；并且whenComplete方法返回的CompletableFuture的<strong>result是上个任务的结果</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureWhenTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; orgFuture = CompletableFuture.supplyAsync(</span><br><span class="line">                ()-&gt;&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;当前线程名称：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">2000L</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;捡田螺的小男孩&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; rstFuture = orgFuture.whenComplete((a, throwable) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前线程名称：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            System.out.println(<span class="string">&quot;上个任务执行完啦，还把&quot;</span> + a + <span class="string">&quot;传过来&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;捡田螺的小男孩&quot;</span>.equals(a)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;233333&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(rstFuture.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">当前线程名称：ForkJoinPool.commonPool-worker-<span class="number">1</span></span><br><span class="line">当前线程名称：ForkJoinPool.commonPool-worker-<span class="number">1</span></span><br><span class="line">上个任务执行完啦，还把捡田螺的小男孩传过来</span><br><span class="line"><span class="number">666</span></span><br><span class="line"><span class="number">233333</span></span><br><span class="line">捡田螺的小男孩</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>CompletableFuture的handle方法表示，<strong>某个任务执行完成后，执行回调方法，并且是有返回值的</strong>;并且handle方法返回的CompletableFuture的result是<strong>回调方法执行的结果</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureHandlerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; orgFuture = CompletableFuture.supplyAsync(</span><br><span class="line">                ()-&gt;&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;当前线程名称：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">2000L</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;捡田螺的小男孩&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; rstFuture = orgFuture.handle((a, throwable) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;上个任务执行完啦，还把&quot;</span> + a + <span class="string">&quot;传过来&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;捡田螺的小男孩&quot;</span>.equals(a)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;关注了&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;233333&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(rstFuture.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">当前线程名称：ForkJoinPool.commonPool-worker-<span class="number">1</span></span><br><span class="line">上个任务执行完啦，还把捡田螺的小男孩传过来</span><br><span class="line"><span class="number">666</span></span><br><span class="line">关注了</span><br></pre></td></tr></table></figure><h1 id="多个任务组合处理"><a href="#多个任务组合处理" class="headerlink" title="多个任务组合处理"></a>多个任务组合处理</h1><h2 id="AND组合关系"><a href="#AND组合关系" class="headerlink" title="AND组合关系"></a>AND组合关系</h2><p>thenCombine &#x2F; thenAcceptBoth &#x2F; runAfterBoth都表示：<strong>将两个CompletableFuture组合起来，只有这两个都正常执行完了，才会执行某个任务</strong>。</p><p>区别在于：</p><ul><li>thenCombine：会将两个任务的执行结果作为方法入参，传递到指定方法中，且<strong>有返回值</strong></li><li>thenAcceptBoth: 会将两个任务的执行结果作为方法入参，传递到指定方法中，且<strong>无返回值</strong></li><li>runAfterBoth 不会把执行结果当做方法入参，且没有返回值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThenCombineTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException &#123;</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; first = CompletableFuture.completedFuture(<span class="string">&quot;第一个异步任务&quot;</span>);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        CompletableFuture&lt;String&gt; future = CompletableFuture</span><br><span class="line">                <span class="comment">//第二个异步任务</span></span><br><span class="line">                .supplyAsync(() -&gt; <span class="string">&quot;第二个异步任务&quot;</span>, executor)</span><br><span class="line">                <span class="comment">// (w, s) -&gt; System.out.println(s) 是第三个任务</span></span><br><span class="line">                .thenCombineAsync(first, (s, w) -&gt; &#123;</span><br><span class="line">                    System.out.println(w);</span><br><span class="line">                    System.out.println(s);</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;两个异步任务的组合&quot;</span>;</span><br><span class="line">                &#125;, executor);</span><br><span class="line">        System.out.println(future.join());</span><br><span class="line">        executor.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">第一个异步任务</span><br><span class="line">第二个异步任务</span><br><span class="line">两个异步任务的组合</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="OR-组合的关系"><a href="#OR-组合的关系" class="headerlink" title="OR 组合的关系"></a>OR 组合的关系</h2><p>applyToEither &#x2F; acceptEither &#x2F; runAfterEither 都表示：将两个CompletableFuture组合起来，只要其中一个执行完了,就会执行某个任务。</p><p>区别在于：</p><ul><li>applyToEither：会将已经执行完成的任务，作为方法入参，传递到指定方法中，且有返回值</li><li>acceptEither: 会将已经执行完成的任务，作为方法入参，传递到指定方法中，且无返回值</li><li>runAfterEither： 不会把执行结果当做方法入参，且没有返回值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AcceptEitherTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//第一个异步任务，休眠2秒，保证它执行晚点</span></span><br><span class="line">        CompletableFuture&lt;String&gt; first = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">                Thread.sleep(<span class="number">2000L</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;执行完第一个异步任务&quot;</span>);&#125;</span><br><span class="line">                <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;第一个任务异常&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;第一个异步任务&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">        CompletableFuture&lt;Void&gt; future = CompletableFuture</span><br><span class="line">                <span class="comment">//第二个异步任务</span></span><br><span class="line">                .supplyAsync(() -&gt; &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;执行完第二个任务&quot;</span>);</span><br><span class="line">                            <span class="keyword">return</span> <span class="string">&quot;第二个任务&quot;</span>;&#125;</span><br><span class="line">                , executor)</span><br><span class="line">                <span class="comment">//第三个任务</span></span><br><span class="line">                .acceptEitherAsync(first, System.out::println, executor);</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">执行完第二个任务</span><br><span class="line">第二个任务</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="AllOf"><a href="#AllOf" class="headerlink" title="AllOf"></a>AllOf</h2><p>​所有任务都执行完成后，才执行 allOf返回的CompletableFuture。如果任意一个任务异常，allOf的CompletableFuture，执行get方法，会抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">allOfFutureTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Void&gt; a = CompletableFuture.runAsync(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我执行完了&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;Void&gt; b = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我也执行完了&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;Void&gt; allOfFuture = CompletableFuture.allOf(a, b).whenComplete((m,k)-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">我执行完了</span><br><span class="line">我也执行完了</span><br><span class="line">finish</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="AnyOf"><a href="#AnyOf" class="headerlink" title="AnyOf"></a>AnyOf</h3><p>任意一个任务执行完，就执行anyOf返回的CompletableFuture。如果执行的任务异常，anyOf的CompletableFuture，执行get方法，会抛出异常</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AnyOfFutureTest</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws ExecutionException, InterruptedException</span> &#123;</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Void&gt; a = CompletableFuture.runAsync(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;我执行完了&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;Void&gt; b = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;我也执行完了&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;Object&gt; anyOfFuture = CompletableFuture.anyOf(a, b).whenComplete((m,k)-&gt;&#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line"><span class="comment">//            return &quot;捡田螺的小男孩&quot;;</span></span><br><span class="line">        &#125;);</span><br><span class="line">        anyOfFuture.<span class="keyword">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">我也执行完了</span><br><span class="line">finish</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="thenCompose"><a href="#thenCompose" class="headerlink" title="thenCompose"></a>thenCompose</h3><p>thenCompose方法会在某个任务执行完成后，将该任务的执行结果,作为方法入参,去执行指定的方法。该方法会返回一个新的CompletableFuture实例</p><ul><li>如果该CompletableFuture实例的result不为null，则返回一个基于该result新的CompletableFuture实例；</li><li>如果该CompletableFuture实例为null，然后就执行这个新任务</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThenComposeTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; f = CompletableFuture.completedFuture(<span class="string">&quot;第一个任务&quot;</span>);</span><br><span class="line">        <span class="comment">//第二个异步任务</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">        CompletableFuture&lt;String&gt; future = CompletableFuture</span><br><span class="line">                .supplyAsync(() -&gt; <span class="string">&quot;第二个任务&quot;</span>, executor)</span><br><span class="line">                .thenComposeAsync(data -&gt; &#123;</span><br><span class="line">                    System.out.println(data); <span class="keyword">return</span> f; <span class="comment">//使用第一个任务作为返回</span></span><br><span class="line">                &#125;, executor);</span><br><span class="line">        System.out.println(future.join());</span><br><span class="line">        executor.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">第二个任务</span><br><span class="line">第一个任务</span><br></pre></td></tr></table></figure><h1 id="CompletableFuture使用注意点"><a href="#CompletableFuture使用注意点" class="headerlink" title="CompletableFuture使用注意点"></a>CompletableFuture使用注意点</h1><h2 id="1-Future需要获取返回值，才能获取异常信息"><a href="#1-Future需要获取返回值，才能获取异常信息" class="headerlink" title="1. Future需要获取返回值，才能获取异常信息"></a>1. Future需要获取返回值，才能获取异常信息</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>, <span class="number">10</span>, <span class="number">5L</span>,</span><br><span class="line">    TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>));</span><br><span class="line">CompletableFuture&lt;Void&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">666</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> b / a;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;,executorService).thenAccept(System.out::println);</span><br><span class="line">   </span><br><span class="line"> <span class="comment">//如果不加 get()方法这一行，看不到异常信息</span></span><br><span class="line"> <span class="comment">//future.get();</span></span><br></pre></td></tr></table></figure><p>Future需要获取返回值，才能获取到异常信息。如果不加 get()&#x2F;join()方法，看不到异常信息。小伙伴们使用的时候，注意一下哈,考虑是否加try…catch…或者使用exceptionally方法。</p><h3 id="2-CompletableFuture的get-方法是阻塞的。"><a href="#2-CompletableFuture的get-方法是阻塞的。" class="headerlink" title="2. CompletableFuture的get()方法是阻塞的。"></a>2. CompletableFuture的get()方法是阻塞的。</h3><p>CompletableFuture的get()方法是阻塞的，如果使用它来获取异步调用的返回值，需要添加超时时间~</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例</span></span><br><span class="line"> CompletableFuture.<span class="keyword">get</span>();</span><br><span class="line"><span class="comment">//正例</span></span><br><span class="line">CompletableFuture.<span class="keyword">get</span>(<span class="number">5</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><h3 id="3-默认线程池的注意点"><a href="#3-默认线程池的注意点" class="headerlink" title="3. 默认线程池的注意点"></a>3. 默认线程池的注意点</h3><p>CompletableFuture代码中又使用了默认的线程池，处理的线程个数是电脑CPU核数-1。在<strong>大量请求过来的时候，处理逻辑复杂的话，响应会很慢</strong>。一般建议使用自定义线程池，优化线程池配置参数。</p><h3 id="4-自定义线程池时，注意饱和策略"><a href="#4-自定义线程池时，注意饱和策略" class="headerlink" title="4. 自定义线程池时，注意饱和策略"></a>4. 自定义线程池时，注意饱和策略</h3><p>CompletableFuture的get()方法是阻塞的，我们一般建议使用<code>future.get(3, TimeUnit.SECONDS)</code>。并且一般建议使用自定义线程池。</p><p>但是如果线程池拒绝策略是<code>DiscardPolicy</code>或者<code>DiscardOldestPolicy</code>，当线程池饱和时，会直接丢弃任务，不会抛弃异常。因此建议，CompletableFuture线程池策略<strong>最好使用AbortPolicy</strong>，然后耗时的异步线程，做好<strong>线程池隔离</strong>。</p><p><strong>为什么要做线程池隔离</strong></p><p>​比如现在有一个系统需要调用三个业务请求，分别是查询订单、查询商品、查询用户，而且这三个业务请求都依赖第三方服务——订单服务、商品服务、用户服务。三个服务均通过RPC调用。当查询订单服务于时，加入响应持续延迟，这时后续有大量的查询订单请求过来，那么容器中的现成数量会持续增加直至CPU资源耗尽，整个服务对外不可用，在集群环境下就会发生雪崩。从一个订单服务不可用最后演变成整个应用不可用。如果我们给调用订单服务的请求分配一个固定的线程池，用一个线程池隔离其他业务，那么就能够防范这样的事故发生，因为线程的使用数不会超过系统负载阈值。</p>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CompletableFuture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发-AQS原理</title>
      <link href="/2022/09/15/%E5%B9%B6%E5%8F%91-AQS%E5%8E%9F%E7%90%86/"/>
      <url>/2022/09/15/%E5%B9%B6%E5%8F%91-AQS%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>AQS 就是一个抽象类，主要用来构建锁和同步器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractQueuedSynchronizer</span> <span class="keyword">extends</span> <span class="title class_">AbstractOwnableSynchronizer</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AQS 为构建锁和同步器提供了一些通用功能的是实现，因此，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 <code>ReentrantLock</code>，<code>Semaphore</code>，其他的诸如 <code>ReentrantReadWriteLock</code>，<code>SynchronousQueue</code>，<code>FutureTask</code>(jdk1.7) 等等皆是基于 AQS 的。</p><h1 id="AQS-原理"><a href="#AQS-原理" class="headerlink" title="AQS 原理"></a>AQS 原理</h1><p>​AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 <strong>CLH 队列锁</strong>实现的，即将暂时获取不到锁的线程加入到队列中。</p><p>​CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。</p><span id="more"></span><p><img src="1.jpg"></p><p>​AQS 使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;<span class="comment">//共享变量，使用volatile修饰保证线程可见性Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure><p>​状态信息通过 <code>protected</code> 类型的<code>getState()</code>，<code>setState()</code>，<code>compareAndSetState()</code> 进行操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 设置同步状态的值</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span> &#123;</span><br><span class="line">        state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AQS-对资源锁的类型"><a href="#AQS-对资源锁的类型" class="headerlink" title="AQS 对资源锁的类型"></a>AQS 对资源锁的类型</h2><h3 id="1-Exclusive（独占）"><a href="#1-Exclusive（独占）" class="headerlink" title="1)Exclusive（独占）"></a>1)Exclusive（独占）</h3><p>详细源码说明：<a href="https://juejin.cn/post/6844903601538596877">深入理解AbstractQueuedSynchronizer(AQS) - 掘金 (juejin.cn)</a></p><p>只有一个线程能执行，如 ReentrantLock。<strong>ReentrantLock 中相关的源代码：</strong></p><p>​ReentrantLock 默认采用非公平锁，因为考虑获得更好的性能，通过 boolean 来决定是否用公平锁（传入 true 用公平锁）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Synchronizer providing all implementation mechanics */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 默认非公平锁</span></span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><code>ReentrantLock</code> 中公平锁的 <code>lock</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// AbstractQueuedSynchronizer.acquire(int arg)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 1. 和非公平锁相比，这里多了一个判断：是否有线程在等待</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>非公平锁的 <code>lock</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 2. 和公平锁相比，这里会直接先进行一次CAS，成功就返回了</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// AbstractQueuedSynchronizer.acquire(int arg)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs non-fair tryLock.  tryAcquire is implemented in</span></span><br><span class="line"><span class="comment"> * subclasses, but both need nonfair try for trylock method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里没有对阻塞队列进行判断</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>总结：公平锁和非公平锁只有两处不同：</p><ol><li>非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。</li><li>非公平锁在 CAS 失败后，和公平锁一样都会进入到 <code>tryAcquire</code> 方法，在 <code>tryAcquire</code> 方法中，如果发现锁这个时候被释放了（state &#x3D;&#x3D; 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。</li></ol><p>​公平锁和非公平锁就这两点区别，如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。</p><p>​相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。</p><h3 id="2-Share（共享）"><a href="#2-Share（共享）" class="headerlink" title="2)Share（共享）"></a>2)Share（共享）</h3><p>​多个线程可同时执行，如 <code>Semaphore</code>、<code>CountDownLatch</code>、 <code>CyclicBarrier</code>、<code>ReadWriteLock</code> 。</p><p>​<code>ReentrantReadWriteLock</code> 可以看成是组合式，因为 <code>ReentrantReadWriteLock</code> 也就是读写锁允许多个线程同时对某一资源进行读。</p><p>​不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等），AQS 已经在上层已经帮我们实现好了。</p><h2 id="AQS中的模板方法模式"><a href="#AQS中的模板方法模式" class="headerlink" title="AQS中的模板方法模式"></a>AQS中的模板方法模式</h2><p>​同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样：</p><ol><li>使用者继承 <code>AbstractQueuedSynchronizer</code> 并重写指定的方法。（这些重写方法很简单，无非是对于共享资源 state 的获取和释放）</li><li>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li></ol><p><strong>AQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的钩子方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span>)</span><span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span>)</span><span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span>)</span><span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span>)</span><span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span><span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure><p>​模板设计模式通过钩子方法控制固定步骤的实现。</p><p>​除了上面提到的钩子方法之外，AQS 类中的其他方法都是 <code>final</code> ，所以无法被其他类重写。</p><p>​以 <code>ReentrantLock</code> 为例，state 初始化为 0，表示未锁定状态。A 线程 <code>lock()</code> 时，会调用 <code>tryAcquire()</code> 独占该锁并将 <code>state+1</code> 。此后，其他线程再 <code>tryAcquire()</code> 时就会失败，直到 A 线程 <code>unlock()</code> 到 <code>state=</code>0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多少次，这样才能保证 state 是能回到零态的。</p><p>​再以 <code>CountDownLatch</code> 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后<code> countDown()</code> 一次，state 会 CAS(Compare and Swap) 减 1。等到所有子线程都执行完后(即 <code>state=0</code> )，会 <code>unpark()</code> 主调用线程，然后主调用线程就会从 <code>await()</code> 函数返回，继续后余动作。</p><p>​一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现<code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code>中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code>。</p><h2 id="AQS总结"><a href="#AQS总结" class="headerlink" title="AQS总结"></a>AQS总结</h2><p>​AQS是JUC中很多同步组件的构建基础，简单来讲，它内部实现主要是状态变量state和一个FIFO队列来完成，同步队列的头结点是当前获取到同步状态的结点，获取同步状态state失败的线程，会被构造成一个结点（或共享式或独占式）加入到同步队列尾部（采用自旋CAS来保证此操作的线程安全），随后线程会阻塞；释放时唤醒头结点的后继结点，使其加入对同步状态的争夺中。</p><p>　　AQS为我们定义好了顶层的处理实现逻辑，我们在使用AQS构建符合我们需求的同步组件时，只需重写tryAcquire，tryAcquireShared，tryRelease，tryReleaseShared几个方法，来决定同步状态的释放和获取即可，至于背后复杂的线程排队，线程阻塞&#x2F;唤醒，如何保证线程安全，都由AQS为我们完成了，这也是非常典型的模板方法的应用。AQS定义好顶级逻辑的骨架，并提取出公用的线程入队列&#x2F;出队列，阻塞&#x2F;唤醒等一系列复杂逻辑的实现，将部分简单的可由使用者决定的操作逻辑延迟到子类中去实现。　</p><h1 id="Semaphore-信号量"><a href="#Semaphore-信号量" class="headerlink" title="Semaphore(信号量)"></a>Semaphore(信号量)</h1><p>​<code>synchronized</code> 和 <code>ReentrantLock</code> 都是一次只允许一个线程访问某个资源，<code>Semaphore</code>(信号量)可以指定多个线程同时访问某个资源。</p><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreExample1</span> &#123;</span><br><span class="line">  <span class="comment">// 请求的数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">550</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢）</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">300</span>);</span><br><span class="line">    <span class="comment">// 一次只能允许执行的线程数量。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadnum</span> <span class="operator">=</span> i;</span><br><span class="line">      threadPool.execute(() -&gt; &#123;<span class="comment">// Lambda 表达式的运用</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          semaphore.acquire();<span class="comment">// 获取一个许可，所以可运行线程数量为20/1=20</span></span><br><span class="line">          test(threadnum);</span><br><span class="line">          semaphore.release();<span class="comment">// 释放一个许可</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">    System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> threadnum)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">    System.out.println(<span class="string">&quot;threadnum:&quot;</span> + threadnum);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>​执行 <code>acquire()</code> 方法阻塞，直到有一个许可证可以获得然后拿走一个许可证；每个 <code>release</code> 方法增加一个许可证，这可能会释放一个阻塞的 <code>acquire()</code> 方法。然而，其实并没有实际的许可证这个对象，<code>Semaphore</code> 只是维持了一个可获得许可证的数量。 <code>Semaphore</code> 经常用于限制获取某种资源的线程数量。</p><p>​当然一次也可以一次拿取和释放多个许可，不过一般没有必要这样做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">semaphore.acquire(<span class="number">5</span>);<span class="comment">// 获取5个许可，所以可运行线程数量为20/5=4</span></span><br><span class="line">test(threadnum);</span><br><span class="line">semaphore.release(<span class="number">5</span>);<span class="comment">// 释放5个许可Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure><p>​除了 <code>acquire()</code> 方法之外，另一个比较常用的与之对应的方法是 <code>tryAcquire()</code> 方法，该方法如果获取不到许可就立即返回 false。</p><p><code>Semaphore</code> 有两种模式，公平模式和非公平模式。</p><ul><li><strong>公平模式：</strong> 调用 <code>acquire()</code> 方法的顺序就是获取许可证的顺序，遵循 FIFO；</li><li><strong>非公平模式：</strong> 抢占式的。</li></ul><p><code>Semaphore</code> 对应的两个构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> permits)</span> &#123;</span><br><span class="line">     sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(permits);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> permits, <span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">     sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>(permits) : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(permits);</span><br><span class="line"> &#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><strong>这两个构造方法，都必须提供许可的数量，第二个构造方法可以指定是公平模式还是非公平模式，默认非公平模式。</strong></p><p>​<code>Semaphore</code> 与 <code>CountDownLatch</code> 一样，也是共享锁的一种实现。它默认构造 AQS 的 state 为 <code>permits</code>。当执行任务的线程数量超出 <code>permits</code>，那么多余的线程将会被放入阻塞队列 Park,并自旋判断 state 是否大于 0。只有当 state 大于 0 的时候，阻塞的线程才能继续执行,此时先前执行任务的线程继续执行 <code>release()</code> 方法，<code>release()</code> 方法使得 state 的变量会加 1，那么自旋的线程便会判断成功。 如此，每次只有最多不超过 <code>permits</code> 数量的线程能自旋成功，便限制了执行任务线程的数量。</p><h1 id="CountDownLatch（倒计时器）"><a href="#CountDownLatch（倒计时器）" class="headerlink" title="CountDownLatch（倒计时器）"></a>CountDownLatch（倒计时器）</h1><p>​<code>CountDownLatch</code> 允许 <code>count</code> 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。</p><p><code>CountDownLatch</code> 是共享锁的一种实现,它默认构造 AQS 的 <code>state</code> 值为 <code>count</code>。当线程使用 <code>countDown()</code> 方法时,其实使用了<code>tryReleaseShared</code>方法以 CAS 的操作来减少 <code>state</code>,直至 <code>state</code> 为 0 。当调用 <code>await()</code> 方法的时候，如果 <code>state</code> 不为 0，那就证明任务还没有执行完毕，<code>await()</code> 方法就会一直阻塞，也就是说 <code>await()</code> 方法之后的语句不会被执行。然后，<code>CountDownLatch</code> 会自旋 CAS 判断 <code>state == 0</code>，如果 <code>state == 0</code> 的话，就会释放所有等待的线程，<code>await()</code> 方法之后的语句得到执行。</p><h2 id="CountDownLatch-的两种典型用法"><a href="#CountDownLatch-的两种典型用法" class="headerlink" title="CountDownLatch 的两种典型用法"></a>CountDownLatch 的两种典型用法</h2><p><strong>1、某一线程在开始运行前等待 n 个线程执行完毕。</strong></p><p>​将 <code>CountDownLatch</code> 的计数器初始化为 n （<code>new CountDownLatch(n)</code>），每当一个任务线程执行完毕，就将计数器减 1 （<code>countdownlatch.countDown()</code>），当计数器的值变为 0 时，在 <code>CountDownLatch 上 await()</code> 的线程就会被唤醒。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。</p><p><strong>2、实现多个线程开始执行任务的最大并行性。</strong></p><p>​注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的 <code>CountDownLatch</code> 对象，将其计数器初始化为 1 （<code>new CountDownLatch(1)</code>），多个线程在开始执行任务前首先 <code>coundownlatch.await()</code>，当主线程调用 <code>countDown()</code> 时，计数器变为 0，多个线程同时被唤醒。</p><h2 id="CountDownLatch-的使用示例"><a href="#CountDownLatch-的使用示例" class="headerlink" title="CountDownLatch 的使用示例"></a>CountDownLatch 的使用示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchExample1</span> &#123;</span><br><span class="line">  <span class="comment">// 请求的数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">550</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢）</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">300</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadnum</span> <span class="operator">=</span> i;</span><br><span class="line">      threadPool.execute(() -&gt; &#123;<span class="comment">// Lambda 表达式的运用</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          test(threadnum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          countDownLatch.countDown();<span class="comment">// 表示一个请求已经被完成</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await(); <span class="comment">//表示已经到了屏障的点。</span></span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">    System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> threadnum)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">    System.out.println(<span class="string">&quot;threadnum:&quot;</span> + threadnum);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>上面的代码中，我们定义了请求的数量为 550，当这 550 个请求被处理完成之后，才会执行<code>System.out.println(&quot;finish&quot;);</code>。</p><p>与 <code>CountDownLatch</code> 的第一次交互是主线程等待其他线程。主线程必须在启动其他线程后立即调用 <code>CountDownLatch.await()</code> 方法。这样主线程的操作就会在这个方法上阻塞，直到其他线程完成各自的任务。</p><p>其他 N 个线程必须引用闭锁对象，因为他们需要通知 <code>CountDownLatch</code> 对象，他们已经完成了各自的任务。这种通知机制是通过 <code>CountDownLatch.countDown()</code>方法来完成的；每调用一次这个方法，在构造函数中初始化的 count 值就减 1。所以当 N 个线程都调 用了这个方法，count 的值等于 0，然后主线程就能通过 <code>await()</code>方法，恢复执行自己的任务。</p><p>再插一嘴：<code>CountDownLatch</code> 的 <code>await()</code> 方法使用不当很容易产生死锁，比如我们上面代码中的 for 循环改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount-<span class="number">1</span>; i++) &#123;</span><br><span class="line">.......</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>这样就导致 <code>count</code> 的值没办法等于 0，然后就会导致一直等待。</p><h2 id="CountDownLatch-的不足"><a href="#CountDownLatch-的不足" class="headerlink" title="CountDownLatch 的不足"></a>CountDownLatch 的不足</h2><p><code>CountDownLatch</code> 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 <code>CountDownLatch</code> 使用完毕后，它不能再次被使用。</p><h1 id="CyclicBarrier-循环栅栏"><a href="#CyclicBarrier-循环栅栏" class="headerlink" title="CyclicBarrier(循环栅栏)"></a>CyclicBarrier(循环栅栏)</h1><p>​<code>CyclicBarrier</code> 和 <code>CountDownLatch</code> 非常类似，它也可以实现线程间的技术等待，但是它的功能比 <code>CountDownLatch</code> 更加复杂和强大。主要应用场景和 <code>CountDownLatch</code> 类似。</p><p>​<code>CountDownLatch</code> 的实现是基于 AQS 的，而 <code>CycliBarrier</code> 是基于 <code>ReentrantLock</code>(<code>ReentrantLock</code> 也属于 AQS 同步器)和 <code>Condition</code> 的。</p><p>​<code>CyclicBarrier</code> 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是：<strong>让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门</strong>，所有被屏障拦截的线程才会继续干活。</p><p>​<code>CyclicBarrier</code> 默认的构造方法是 <code>CyclicBarrier(int parties)</code>，其参数表示屏障拦截的线程数量，每<strong>个线程调用 <code>await()</code> 方法告诉 <code>CyclicBarrier</code> 我已经到达了屏障，然后当前线程被阻塞</strong>。</p><p>​再来看一下它的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(parties, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties, Runnable barrierAction)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.parties = parties;</span><br><span class="line">    <span class="built_in">this</span>.count = parties;</span><br><span class="line">    <span class="built_in">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>​其中，parties 就代表了有拦截的线程的数量，当拦截的线程数量达到这个值的时候就打开栅栏，让所有线程通过。</p><h2 id="CyclicBarrier-的应用场景"><a href="#CyclicBarrier-的应用场景" class="headerlink" title="CyclicBarrier 的应用场景"></a>CyclicBarrier 的应用场景</h2><p>​<code>CyclicBarrier</code> 可以用于多线程计算数据，最后合并计算结果的应用场景。比如我们用一个 Excel 保存了用户所有银行流水，每个 Sheet 保存一个帐户近一年的每笔银行流水，现在需要统计用户的日均银行流水，先用多线程处理每个 sheet 里的银行流水，都执行完之后，得到每个 sheet 的日均银行流水，最后，再用 barrierAction 用这些线程的计算结果，计算出整个 Excel 的日均银行流水。</p><h2 id="CyclicBarrier-的使用示例"><a href="#CyclicBarrier-的使用示例" class="headerlink" title="CyclicBarrier 的使用示例"></a>CyclicBarrier 的使用示例</h2><p>示例 1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierExample2</span> &#123;</span><br><span class="line">  <span class="comment">// 请求的数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">550</span>;</span><br><span class="line">  <span class="comment">// 需要同步的线程数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 创建线程池  线程池的大小为10，超过线程池的大小的需要在队列中等待。</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadNum</span> <span class="operator">=</span> i;</span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">      threadPool.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          test(threadNum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">          <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> threadnum)</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;threadnum:&quot;</span> + threadnum + <span class="string">&quot;is ready&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">/**等待60秒，保证子线程完全执行结束*/</span>  <span class="comment">//表示本线程已经到达了屏障，需要等待初始化时候约定的线程都到达了屏障的时候该方法之后的语句才会在继续执行。</span></span><br><span class="line">      cyclicBarrier.await(<span class="number">60</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;-----CyclicBarrierException------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;threadnum:&quot;</span> + threadnum + <span class="string">&quot;is finish&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>运行结果，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">threadnum:0is ready</span><br><span class="line">threadnum:1is ready</span><br><span class="line">threadnum:2is ready</span><br><span class="line">threadnum:3is ready</span><br><span class="line">threadnum:4is ready</span><br><span class="line">threadnum:4is finish</span><br><span class="line">threadnum:0is finish</span><br><span class="line">threadnum:1is finish</span><br><span class="line">threadnum:2is finish</span><br><span class="line">threadnum:3is finish</span><br><span class="line">threadnum:5is ready</span><br><span class="line">threadnum:6is ready</span><br><span class="line">threadnum:7is ready</span><br><span class="line">threadnum:8is ready</span><br><span class="line">threadnum:9is ready</span><br><span class="line">threadnum:9is finish</span><br><span class="line">threadnum:5is finish</span><br><span class="line">threadnum:8is finish</span><br><span class="line">threadnum:7is finish</span><br><span class="line">threadnum:6is finish</span><br><span class="line">......Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>可以看到当线程数量也就是请求数量达到我们定义的 5 个的时候， <code>await()</code> 方法之后的方法才被执行。</p><p>另外，<code>CyclicBarrier</code> 还提供一个更高级的构造函数 <code>CyclicBarrier(int parties, Runnable barrierAction)</code>，用于在线程到达屏障时，优先执行 <code>barrierAction</code>，方便处理更复杂的业务场景。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierExample3</span> &#123;</span><br><span class="line">  <span class="comment">// 请求的数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">550</span>;</span><br><span class="line">  <span class="comment">// 需要同步的线程数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">5</span>, () -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;------当线程数达到之后，优先执行------&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 创建线程池</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadNum</span> <span class="operator">=</span> i;</span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">      threadPool.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          test(threadNum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">          <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> threadnum)</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;threadnum:&quot;</span> + threadnum + <span class="string">&quot;is ready&quot;</span>);</span><br><span class="line">    cyclicBarrier.await();</span><br><span class="line">    System.out.println(<span class="string">&quot;threadnum:&quot;</span> + threadnum + <span class="string">&quot;is finish&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>运行结果，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">threadnum:0is ready</span><br><span class="line">threadnum:1is ready</span><br><span class="line">threadnum:2is ready</span><br><span class="line">threadnum:3is ready</span><br><span class="line">threadnum:4is ready</span><br><span class="line">------当线程数达到之后，优先执行------</span><br><span class="line">threadnum:4is finish</span><br><span class="line">threadnum:0is finish</span><br><span class="line">threadnum:2is finish</span><br><span class="line">threadnum:1is finish</span><br><span class="line">threadnum:3is finish</span><br><span class="line">threadnum:5is ready</span><br><span class="line">threadnum:6is ready</span><br><span class="line">threadnum:7is ready</span><br><span class="line">threadnum:8is ready</span><br><span class="line">threadnum:9is ready</span><br><span class="line">------当线程数达到之后，优先执行------</span><br><span class="line">threadnum:9is finish</span><br><span class="line">threadnum:5is finish</span><br><span class="line">threadnum:6is finish</span><br><span class="line">threadnum:8is finish</span><br><span class="line">threadnum:7is finish</span><br><span class="line">......Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><h2 id="CyclicBarrier-源码分析"><a href="#CyclicBarrier-源码分析" class="headerlink" title="CyclicBarrier 源码分析"></a>CyclicBarrier 源码分析</h2><p>​当调用 <code>CyclicBarrier</code> 对象调用 <code>await()</code> 方法时，实际上调用的是 <code>dowait(false, 0L)</code>方法。 <code>await()</code> 方法就像树立起一个栅栏的行为一样，将线程挡住了，当拦住的线程数量达到 <code>parties</code> 的值时，栅栏才会打开，线程才得以通过执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(toe); <span class="comment">// cannot happen</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><code>dowait(false, 0L)</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 当线程数量或者请求数量达到 count 时 await 之后的方法才会被执行。上面的示例中 count 的值就为 5。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Main barrier code, covering the various policies.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dowait</span><span class="params">(<span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span><br><span class="line">               TimeoutException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">        <span class="comment">// 锁住</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Generation</span> <span class="variable">g</span> <span class="operator">=</span> generation;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果线程中断了，抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout减1</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> --count;</span><br><span class="line">            <span class="comment">// 当 count 数量减为 0 之后说明最后一个线程已经到达栅栏了，也就是达到了可以执行await 方法之后的条件</span></span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">ranAction</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">command</span> <span class="operator">=</span> barrierCommand;</span><br><span class="line">                    <span class="keyword">if</span> (command != <span class="literal">null</span>)</span><br><span class="line">                        command.run();</span><br><span class="line">                    ranAction = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">// 将 count 重置为 parties 属性的初始化值</span></span><br><span class="line">                    <span class="comment">// 唤醒之前等待的线程</span></span><br><span class="line">                    <span class="comment">// 下一波执行开始</span></span><br><span class="line">                    nextGeneration();</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                        breakBarrier();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!timed)</span><br><span class="line">                        trip.await();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                        nanos = trip.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                        breakBarrier();</span><br><span class="line">                        <span class="keyword">throw</span> ie;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// We&#x27;re about to finish waiting even if we had not</span></span><br><span class="line">                        <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                        <span class="comment">// &quot;belong&quot; to subsequent execution.</span></span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (g.broken)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (g != generation)</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TimeoutException</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>总结：<code>CyclicBarrier</code> 内部通过一个 count 变量作为计数器，count 的初始值为 parties 属性的初始化值，每当一个线程到了栅栏这里了，那么就将计数器减一。如果 count 值为 0 了，表示这是这一代最后一个线程到达栅栏，就尝试执行我们构造方法中输入的任务。</p><h2 id="CyclicBarrier-和-CountDownLatch-的区别"><a href="#CyclicBarrier-和-CountDownLatch-的区别" class="headerlink" title="CyclicBarrier 和 CountDownLatch 的区别"></a>CyclicBarrier 和 CountDownLatch 的区别</h2><p>下面这个是国外一个大佬的回答：</p><p><code>CountDownLatch</code> 是计数器，只能使用一次，而 <code>CyclicBarrier</code> 的计数器提供 <code>reset</code> 功能，可以多次使用。但是我不那么认为它们之间的区别仅仅就是这么简单的一点。我们来从 jdk 作者设计的目的来看，javadoc 是这么描述它们的：</p><blockquote><p>CountDownLatch: A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.(CountDownLatch: 一个或者多个线程，等待其他多个线程完成某件事情之后才能执行；) CyclicBarrier : A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point.(CyclicBarrier : 多个线程互相等待，直到到达同一个同步点，再继续一起执行。)</p></blockquote><p>对于 <code>CountDownLatch</code> 来说，重点是“一个线程（多个线程）等待”，而其他的 N 个线程在完成“某件事情”之后，可以终止，也可以等待。而对于 <code>CyclicBarrier</code>，重点是多个线程，在任意一个线程没有完成，所有的线程都必须等待。</p><p><code>CountDownLatch</code> 是计数器，线程完成一个记录一个，只不过计数不是递增而是递减，而 <code>CyclicBarrier</code> 更像是一个阀门，需要所有线程都到达，阀门才能打开，然后继续执行。</p><h2 id="ReentrantLock-和-ReentrantReadWriteLock"><a href="#ReentrantLock-和-ReentrantReadWriteLock" class="headerlink" title="ReentrantLock 和 ReentrantReadWriteLock"></a>ReentrantLock 和 ReentrantReadWriteLock</h2><p>​<code>ReentrantLock</code> 和 <code>synchronized</code> 的区别在上面已经讲过了这里就不多做讲解。另外，需要注意的是：读写锁 <code>ReentrantReadWriteLock</code> 可以保证多个线程可以同时读，所以在读操作远大于写操作的时候，读写锁就非常有用了。</p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AQS原理 </tag>
            
            <tag> Semaphore(信号量) </tag>
            
            <tag> CountDownLatch </tag>
            
            <tag> CyclicBarrier </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发-Atomic原子类</title>
      <link href="/2022/09/15/%E5%B9%B6%E5%8F%91-Atomic%E5%8E%9F%E5%AD%90%E7%B1%BB/"/>
      <url>/2022/09/15/%E5%B9%B6%E5%8F%91-Atomic%E5%8E%9F%E5%AD%90%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="Atomic-原子类"><a href="#Atomic-原子类" class="headerlink" title="Atomic 原子类"></a>Atomic 原子类</h1><h2 id="简介与分类"><a href="#简介与分类" class="headerlink" title="简介与分类"></a>简介与分类</h2><p>Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。</p><p>根据操作的数据类型，可以将 JUC 包中的原子类分为 4 类</p><p><strong>基本类型</strong></p><p>使用原子的方式更新基本类型</p><ul><li>AtomicInteger：整型原子类</li><li>AtomicLong：长整型原子类</li><li>AtomicBoolean ：布尔型原子类</li></ul><span id="more"></span><p><strong>数组类型</strong></p><p>使用原子的方式更新数组里的某个元素</p><ul><li>AtomicIntegerArray：整型数组原子类</li><li>AtomicLongArray：长整型数组原子类</li><li>AtomicReferenceArray ：引用类型数组原子类</li></ul><p><strong>引用类型</strong></p><ul><li>AtomicReference：引用类型原子类</li><li>AtomicMarkableReference：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来。</li><li>AtomicStampedReference ：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li></ul><p><strong>对象的属性修改类型</strong></p><ul><li>AtomicIntegerFieldUpdater:原子更新整型字段的更新器</li><li>AtomicLongFieldUpdater：原子更新长整型字段的更新器</li><li>AtomicReferenceFieldUpdater：原子更新引用类型里的字段</li></ul><h2 id="AtomicInteger-类常用方法"><a href="#AtomicInteger-类常用方法" class="headerlink" title="AtomicInteger 类常用方法"></a>AtomicInteger 类常用方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> <span class="comment">//获取当前的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> newValue)</span><span class="comment">//获取当前的值，并设置新的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span><span class="comment">//获取当前的值，并自增</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">()</span> <span class="comment">//获取当前的值，并自减</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> delta)</span> <span class="comment">//获取当前的值，并加上预期的值</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> <span class="comment">//如果当前内存的数值等于预期值，则以原子方式将该值设置为输入值（update）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lazySet</span><span class="params">(<span class="type">int</span> newValue)</span><span class="comment">//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的</span></span><br></pre></td></tr></table></figure><h2 id="AtomicInteger-线程安全原理"><a href="#AtomicInteger-线程安全原理" class="headerlink" title="AtomicInteger 线程安全原理"></a>AtomicInteger 线程安全原理</h2><p>AtomicInteger 类的部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p><p>CAS 的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址。另外 value 是一个 volatile 变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</p><h2 id="AtomicIntegerArray-类常用方法"><a href="#AtomicIntegerArray-类常用方法" class="headerlink" title="AtomicIntegerArray 类常用方法"></a><strong>AtomicIntegerArray 类常用方法</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span> <span class="comment">//获取 index=i 位置元素的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> newValue)</span><span class="comment">//返回 index=i 位置的当前的值，并将其设置为新值：newValue</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">(<span class="type">int</span> i)</span><span class="comment">//获取 index=i 位置元素的值，并让该位置的元素自增</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">(<span class="type">int</span> i)</span> <span class="comment">//获取 index=i 位置元素的值，并让该位置的元素自减</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> delta)</span> <span class="comment">//获取 index=i 位置元素的值，并加上预期的值</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> expect, <span class="type">int</span> update)</span> <span class="comment">//如果内存的数值等于预期值，则以原子方式将 index=i 位置的元素值设置为输入值（update）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lazySet</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> newValue)</span><span class="comment">//最终 将index=i 位置的元素设置为newValue,使用 lazySet 设置之后可能导致其他线程在之</span></span><br></pre></td></tr></table></figure><h2 id="AtomicReference-类使用示例"><a href="#AtomicReference-类使用示例" class="headerlink" title="AtomicReference 类使用示例"></a>AtomicReference 类使用示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicReferenceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        AtomicReference&lt;Person&gt; ar = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;Person&gt;();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;SnailClimb&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        ar.set(person);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">updatePerson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Daisy&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        ar.compareAndSet(person, updatePerson);</span><br><span class="line"></span><br><span class="line">        System.out.println(ar.get().getName());</span><br><span class="line">        System.out.println(ar.get().getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>上述代码首先创建了一个 Person 对象，然后把 Person 对象设置进 AtomicReference 对象中，然后调用 compareAndSet 方法，该方法就是通过 CAS 操作设置 ar。如果 ar 的值为 person 的话，则将其设置为 updatePerson。实现原理与 AtomicInteger 类中的 compareAndSet 方法相同。运行上面的代码后的输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Daisy</span><br><span class="line">20Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><h2 id="AtomicStampedReference-类使用示例"><a href="#AtomicStampedReference-类使用示例" class="headerlink" title="AtomicStampedReference 类使用示例"></a>AtomicStampedReference 类使用示例</h2><p>基本类型原子类只能更新一个变量，如果需要原子更新多个变量，需要使用 引用类型原子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicStampedReferenceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 实例化、取当前值和 stamp 值</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">initialRef</span> <span class="operator">=</span> <span class="number">0</span>, initialStamp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> AtomicStampedReference&lt;Integer&gt; asr = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(initialRef, initialStamp);</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + asr.getReference() + <span class="string">&quot;, currentStamp=&quot;</span> + asr.getStamp());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// compare and set</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">newReference</span> <span class="operator">=</span> <span class="number">666</span>, newStamp = <span class="number">999</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">casResult</span> <span class="operator">=</span> asr.compareAndSet(initialRef, newReference, initialStamp, newStamp);</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + asr.getReference()</span><br><span class="line">                + <span class="string">&quot;, currentStamp=&quot;</span> + asr.getStamp()</span><br><span class="line">                + <span class="string">&quot;, casResult=&quot;</span> + casResult);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前的值和当前的 stamp 值</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">currentValue</span> <span class="operator">=</span> asr.get(arr);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">currentStamp</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + currentValue + <span class="string">&quot;, currentStamp=&quot;</span> + currentStamp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单独设置 stamp 值</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">attemptStampResult</span> <span class="operator">=</span> asr.attemptStamp(newReference, <span class="number">88</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + asr.getReference()</span><br><span class="line">                + <span class="string">&quot;, currentStamp=&quot;</span> + asr.getStamp()</span><br><span class="line">                + <span class="string">&quot;, attemptStampResult=&quot;</span> + attemptStampResult);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新设置当前值和 stamp 值</span></span><br><span class="line">        asr.set(initialRef, initialStamp);</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + asr.getReference() + <span class="string">&quot;, currentStamp=&quot;</span> + asr.getStamp());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">wCasResult</span> <span class="operator">=</span> asr.weakCompareAndSet(initialRef, newReference, initialStamp, newStamp);</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + asr.getReference()</span><br><span class="line">                + <span class="string">&quot;, currentStamp=&quot;</span> + asr.getStamp()</span><br><span class="line">                + <span class="string">&quot;, wCasResult=&quot;</span> + wCasResult);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">currentValue=0, currentStamp=0</span><br><span class="line">currentValue=666, currentStamp=999, casResult=true</span><br><span class="line">currentValue=666, currentStamp=999</span><br><span class="line">currentValue=666, currentStamp=88, attemptStampResult=true</span><br><span class="line">currentValue=0, currentStamp=0</span><br><span class="line">currentValue=666, currentStamp=999, wCasResult=trueCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><h2 id="AtomicMarkableReference-类使用示例"><a href="#AtomicMarkableReference-类使用示例" class="headerlink" title="AtomicMarkableReference 类使用示例"></a>AtomicMarkableReference 类使用示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicMarkableReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicMarkableReferenceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 实例化、取当前值和 mark 值</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Boolean</span> <span class="variable">initialRef</span> <span class="operator">=</span> <span class="literal">null</span>, initialMark = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">final</span> AtomicMarkableReference&lt;Boolean&gt; amr = <span class="keyword">new</span> <span class="title class_">AtomicMarkableReference</span>&lt;&gt;(initialRef, initialMark);</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + amr.getReference() + <span class="string">&quot;, currentMark=&quot;</span> + amr.isMarked());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// compare and set</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Boolean</span> <span class="variable">newReference1</span> <span class="operator">=</span> <span class="literal">true</span>, newMark1 = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">casResult</span> <span class="operator">=</span> amr.compareAndSet(initialRef, newReference1, initialMark, newMark1);</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + amr.getReference()</span><br><span class="line">                + <span class="string">&quot;, currentMark=&quot;</span> + amr.isMarked()</span><br><span class="line">                + <span class="string">&quot;, casResult=&quot;</span> + casResult);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前的值和当前的 mark 值</span></span><br><span class="line">        <span class="type">boolean</span>[] arr = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Boolean</span> <span class="variable">currentValue</span> <span class="operator">=</span> amr.get(arr);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">currentMark</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + currentValue + <span class="string">&quot;, currentMark=&quot;</span> + currentMark);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单独设置 mark 值</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">attemptMarkResult</span> <span class="operator">=</span> amr.attemptMark(newReference1, <span class="literal">false</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + amr.getReference()</span><br><span class="line">                + <span class="string">&quot;, currentMark=&quot;</span> + amr.isMarked()</span><br><span class="line">                + <span class="string">&quot;, attemptMarkResult=&quot;</span> + attemptMarkResult);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新设置当前值和 mark 值</span></span><br><span class="line">        amr.set(initialRef, initialMark);</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + amr.getReference() + <span class="string">&quot;, currentMark=&quot;</span> + amr.isMarked());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// [不推荐使用，除非搞清楚注释的意思了] weak compare and set</span></span><br><span class="line">        <span class="comment">// 困惑！weakCompareAndSet 这个方法最终还是调用 compareAndSet 方法。[版本: jdk-8u191]</span></span><br><span class="line">        <span class="comment">// 但是注释上写着 &quot;May fail spuriously and does not provide ordering guarantees,</span></span><br><span class="line">        <span class="comment">// so is only rarely an appropriate alternative to compareAndSet.&quot;</span></span><br><span class="line">        <span class="comment">//  感觉有可能是 jvm 通过方法名在 native 方法里面做了转发</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">wCasResult</span> <span class="operator">=</span> amr.weakCompareAndSet(initialRef, newReference1, initialMark, newMark1);</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + amr.getReference()</span><br><span class="line">                + <span class="string">&quot;, currentMark=&quot;</span> + amr.isMarked()</span><br><span class="line">                + <span class="string">&quot;, wCasResult=&quot;</span> + wCasResult);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">currentValue=null, currentMark=false</span><br><span class="line">currentValue=true, currentMark=true, casResult=true</span><br><span class="line">currentValue=true, currentMark=true</span><br><span class="line">currentValue=true, currentMark=false, attemptMarkResult=true</span><br><span class="line">currentValue=null, currentMark=false</span><br><span class="line">currentValue=true, currentMark=true, wCasResult=trueCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><h2 id="对象的属性修改类型原子类"><a href="#对象的属性修改类型原子类" class="headerlink" title="对象的属性修改类型原子类"></a>对象的属性修改类型原子类</h2><h3 id="对象的属性修改类型原子类介绍"><a href="#对象的属性修改类型原子类介绍" class="headerlink" title="对象的属性修改类型原子类介绍"></a>对象的属性修改类型原子类介绍</h3><p>如果需要原子更新某个类里的某个字段时，需要用到对象的属性修改类型原子类。</p><ul><li>AtomicIntegerFieldUpdater:原子更新整形字段的更新器</li><li>AtomicLongFieldUpdater：原子更新长整形字段的更新器</li><li>AtomicReferenceFieldUpdater ：原子更新引用类型里的字段的更新器</li></ul><p>要想原子地更新对象的属性需要两步。第一步，因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法 newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。第二步，更新的对象属性必须使用 public volatile 修饰符。</p><p>上面三个类提供的方法几乎相同，所以我们这里以 <code>AtomicIntegerFieldUpdater</code>为例子来介绍。</p><h3 id="AtomicIntegerFieldUpdater-类使用示例"><a href="#AtomicIntegerFieldUpdater-类使用示例" class="headerlink" title="AtomicIntegerFieldUpdater 类使用示例"></a>AtomicIntegerFieldUpdater 类使用示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicIntegerFieldUpdater;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerFieldUpdaterTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        AtomicIntegerFieldUpdater&lt;User&gt; a = AtomicIntegerFieldUpdater.newUpdater(User.class, <span class="string">&quot;age&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Java&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        System.out.println(a.getAndIncrement(user));<span class="comment">// 22</span></span><br><span class="line">        System.out.println(a.get(user));<span class="comment">// 23</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">22</span><br><span class="line">23</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Atomic原子类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发-常见并发容器</title>
      <link href="/2022/09/13/%E5%B9%B6%E5%8F%91-%E5%B8%B8%E8%A7%81%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"/>
      <url>/2022/09/13/%E5%B9%B6%E5%8F%91-%E5%B8%B8%E8%A7%81%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>JDK 提供的这些容器大部分在 <code>java.util.concurrent</code> 包中。如下具体容器：</p><ul><li><strong><code>ConcurrentHashMap</code></strong> : 线程安全的 <code>HashMap</code></li><li><strong><code>CopyOnWriteArrayList</code></strong> : 线程安全的 <code>List</code>，在读多写少的场合性能非常好。</li><li><strong><code>ConcurrentLinkedQueue</code></strong> : 高效的并发队列，使用链表实现。可以看做一个线程安全的 <code>LinkedList</code>，这是一个非阻塞队列。</li><li><strong><code>BlockingQueue</code></strong> : 这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。</li><li><strong><code>ConcurrentSkipListMap</code></strong> : 跳表的实现。这是一个 Map，使用跳表的数据结构进行快速查找。</li></ul><span id="more"></span><h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><p>​在 <code>ConcurrentHashMap</code> 中，无论是读操作还是写操作都能保证很高的性能：在进行读操作时(几乎)不需要加锁，而在写操作时通过<strong>锁分段</strong>技术只对所操作的段加锁而不影响客户端对其它段的访问。</p><h2 id="ConcurrentHashMap和HashMap以及Hashtable的区别"><a href="#ConcurrentHashMap和HashMap以及Hashtable的区别" class="headerlink" title="ConcurrentHashMap和HashMap以及Hashtable的区别"></a>ConcurrentHashMap和HashMap以及Hashtable的区别</h2><p><strong>HashMap</strong></p><p><code>HashMap</code>是线程不安全的，因为<code>HashMap</code>中操作都没有加锁，因此在多线程环境下会导致数据覆盖之类的问题，所以，在多线程中使用<code>HashMap</code>是会抛出异常的。</p><p><strong>HashTable</strong></p><p><code>HashTable</code>是线程安全的,但是<code>HashTable</code>只是单纯的在<code>put()</code>方法上加上<code>synchronized</code>。保证插入时阻塞其他线程的插入操作。虽然安全，但因为设计简单，所以性能低下。</p><p><strong>ConcurrentHashMap</strong></p><p><code>ConcurrentHashMap</code>是线程安全的，<code>ConcurrentHashMap</code>并非锁住整个方法，而是通过原子操作和局部加锁的方法保证了多线程的线程安全，且尽可能减少了性能损耗。</p><h2 id="ConcurrentHashMap线程安全原理"><a href="#ConcurrentHashMap线程安全原理" class="headerlink" title="ConcurrentHashMap线程安全原理"></a>ConcurrentHashMap线程安全原理</h2><h2 id="1-7版本"><a href="#1-7版本" class="headerlink" title="1.7版本"></a>1.7版本</h2><p>​ConcurrentHashMap 采用分段锁（Segment 数组，一个 Segment 就是一个锁）技术，每当一个线程访问 HashEntry 中存储的数据从而占用一个 Segment 锁时，并不会影响到其他的 Segment</p><p><img src="1.jpg"></p><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p>首先，既然 ConcurrentHashMap 使用分段锁 Segment 来保护不同段的数据，那么在插入和获取元素的时候，必须先通过 Hash 算法定位到 Segment：然后在对应的 Segment 中进行真正的 put：</p><p>1）尝试获取锁，如果获取失败则利用 scanAndLockForPut() 进行自旋</p><p>2）遍历该 HashEntry 数组：</p><p>如果当前遍历到的 HashEntry 不为空则判断传入的 key 和当前遍历到的 key 是否相等，相等则覆盖旧的 value<br>为空则新建一个 HashEntry 并加入到 Segment 中（先判断是否需要对 Segment 数组进行扩容）</p><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>1）将 Key 通过 Hash 定位到具体的 Segment</p><p>2）再通过一次 Hash 定位到具体的元素上</p><h2 id="JDK-1-8"><a href="#JDK-1-8" class="headerlink" title="JDK 1.8"></a>JDK 1.8</h2><p>​不同于 JDK 1.7 版本的 Segment 数组 + HashEntry 链表，JDK 1.8 版本中的 ConcurrentHashMap 直接抛弃了 Segment 锁，一个 ConcurrentHashMap 包含一个 Node 数组（和 HashEntry 实现差不多），每个 Node 是一个链表结构，并且在链表长度大于一定值时会转换为红黑树结构（TreeBin）。</p><p><img src="2.jpg"></p><p>​1.8版本中是使用synchronized + CAS来保证插入元素的线程安全性，简单来说，Node 数组其实就是一个哈希桶数组，每个 Node 头节点及其所有的 next 节点组成的链表就是一个桶，<strong>只要锁住这个桶的头结点，就不会影响其他哈希桶数组元素的读写</strong>。桶级别的粒度显然比 1.7 版本的 Segment 段要细。<br>ConcurrentHashMap底层初始化的时候是懒加载，并没有初始化，是在插入数据的时候才进行初始化操作。Node数组初始化的时候采用了CAS+自旋，让抢到资格的线程给Node数组初始化。</p><h3 id="initTable"><a href="#initTable" class="headerlink" title="initTable()"></a>initTable()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="comment">//可能同时有多个线程同时初始化，自旋CAS来初始化，判断依据是sc</span></span><br><span class="line">    <span class="comment">//如果sc = -1，说明有其他线程在初始化</span></span><br><span class="line">    <span class="comment">//如果sc &gt; 0 说明初始化完成了</span></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield(); <span class="comment">//有其他线程在初始化了，当前线程可以停止了</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;<span class="comment">//如果CAS成功将sizeCtl更新成了-1</span></span><br><span class="line">            <span class="keyword">try</span> &#123;<span class="comment">//如果table为空</span></span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果初始化容量了，则设置为sc，否则设置为默认容量16</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    <span class="comment">//初始化table</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">//将sc设置为0.75*n，下一次扩容的阈值</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//扩容的阈值</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="put-方法："><a href="#put-方法：" class="headerlink" title="put 方法："></a>put 方法：</h3><p>1）根据要 put 数据的 key 计算出 hashcode</p><p>2）遍历 table 数组，根据 hashcode 定位 Node：</p><p>如果 Node 为空表示当前位置可以写入数据，利用 CAS 尝试写入(失败则自旋)<br>如果当前位置的 hashcode &#x3D;&#x3D; MOVED &#x3D;&#x3D; -1，则需要对 Node 数组进行扩容<br>如果 Node 不为空并且也不需要进行扩容，则利用 synchronized 锁写入数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line"> </span><br><span class="line">       <span class="comment">// 这里跟HashMap不一样，这里不运行key和value存在null值。</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line"> </span><br><span class="line">       <span class="comment">// hash算法，这里算出来的值为正整数，因为需要来判断正负来决定干不同的事。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line"> </span><br><span class="line">       <span class="comment">// 这个是个计数器，来记录插入的次数，因为扩容需要他</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">       <span class="comment">// 插入的死循环，为什么需要死循环后面代码会出答案</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line"> </span><br><span class="line">           <span class="comment">// 创建一些临时变量</span></span><br><span class="line">            Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">    </span><br><span class="line">           <span class="comment">// 判断是否是null或者长度为0，也就是是否需要初始化</span></span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line">               <span class="comment">// 初始化的方法，默认长度是16，负载因子的阈值是16*0.75=12，负载因子决定扩容时机</span></span><br><span class="line">               <span class="comment">// 这里初始化的时候，因为会存在并发初始化的情况，所以内部使用unsafe的cas操作保证</span></span><br><span class="line">               <span class="comment">// 初始化的原子性</span></span><br><span class="line">                tab = initTable();</span><br><span class="line"> </span><br><span class="line">           <span class="comment">// 这里使用hash值在通过算法获取到插入位置，再获取到插入位置是否有值。没值就直接添加。</span></span><br><span class="line">           <span class="comment">// 因为要保证线程安全，所以ConcurrentHashMap内部维护了一个Unsafe使用cas操作保证</span></span><br><span class="line">           <span class="comment">// 原子性，所以多线程的情况下是安全的</span></span><br><span class="line">           <span class="comment">// tabAt()方法取值也是通过unsafe的取值。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,</span><br><span class="line">                             <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">                    <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">           <span class="comment">// ForwardingNode节点MOVED为-1，达标已经有线程在移动扩容了，此时我们帮助移动</span></span><br><span class="line">           <span class="comment">// 帮助移动完毕就产生新的Node数组，这里就再进入For循环找位置插入</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                tab = helpTransfer(tab, f);</span><br><span class="line"> </span><br><span class="line">           <span class="comment">// 能进到else中，就代表当前进来的值已经是hash冲撞了</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 临时变量</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">               <span class="comment">// 同步锁，但是这个同步锁锁的对象是冲撞的head节点，所以他的锁的力度不大</span></span><br><span class="line">               <span class="comment">// 对于其他数组节点、数组链表、数组红黑树的添加操作不影响。</span></span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line"> </span><br><span class="line">                   <span class="comment">// double check操作，因为之前获取的可能数组扩容变换位置了。</span></span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                </span><br><span class="line">                       <span class="comment">// fh是啥？  没错他就是hash值，从上一个else if判断中获取到的</span></span><br><span class="line">                       <span class="comment">// hash值为正数就代表是非红黑树的添加</span></span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    </span><br><span class="line">                           <span class="comment">// 计数器+1，计数器为了后面的扩容做计数</span></span><br><span class="line">                            binCount = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">                           <span class="comment">// 因为进到这里肯定是hash冲撞了，所以需要判断是否是同一个key</span></span><br><span class="line">                           <span class="comment">// 因为map集合是无序不重复，所以相同的key就是替换value值。</span></span><br><span class="line">                           <span class="comment">// 但是也有可能只是hash值冲撞了，但是key值并不相同</span></span><br><span class="line">                           <span class="comment">// 所以就产生了单Node链表,所以这里循环也是在遍历链表</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                                </span><br><span class="line">                               <span class="comment">// 存储已经存在链表的的key值，并非本次添加的key值。</span></span><br><span class="line">                                K ek;</span><br><span class="line"> </span><br><span class="line">                               <span class="comment">// 判断是否相等，相等就替换</span></span><br><span class="line">                               <span class="comment">// 其实从这里就可以得出hashcode相等，equals不相等</span></span><br><span class="line">                               <span class="comment">// 但是equals相等他的hashcode必然相等</span></span><br><span class="line">                                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                    ((ek = e.key) == key ||</span><br><span class="line">                                     (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                </span><br><span class="line">                                   <span class="comment">// 如果是相等了就把旧值赋值给临时变量，并且作为返回值返回</span></span><br><span class="line">                                    oldVal = e.val;</span><br><span class="line"> </span><br><span class="line">                                   <span class="comment">// 对于concurrentHashMap来说默认是不重复，</span></span><br><span class="line">                                   <span class="comment">// 但是可以通过onlyIfAbsent变量来控制新来的值是否替换</span></span><br><span class="line">                                   <span class="comment">// 是使用之前的还是新的</span></span><br><span class="line">                                    <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line"> </span><br><span class="line">                               <span class="comment">// 走到这里就达标hashcode冲撞了，但是key值并不相等</span></span><br><span class="line">                               <span class="comment">// 所以这里就判断链表的next节点是否为null，为null就添加</span></span><br><span class="line">                               <span class="comment">// 不为null就进入到下一次循环，下一次循环就继续走上面的代码</span></span><br><span class="line">                               <span class="comment">// 继续判断是否key值相等，不相等又来到这里，直到next节点为null</span></span><br><span class="line">                               <span class="comment">// 大家都知道链表长度为8转红黑树，所以这里又可以得出是大于等于8</span></span><br><span class="line">                                Node&lt;K,V&gt; pred = e;</span><br><span class="line">                                <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                    pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                              value, <span class="literal">null</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"> </span><br><span class="line">                       <span class="comment">// 红黑树的添加node节点</span></span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            binCount = <span class="number">2</span>;</span><br><span class="line">                            <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                           value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                                oldVal = p.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">               <span class="comment">// 判断是否从链表转成红黑树结构</span></span><br><span class="line">               <span class="comment">// 条件是单链表大于等于8切数组长度为64，如果数组长度不满足64就扩容</span></span><br><span class="line">                <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                        treeifyBin(tab, i);</span><br><span class="line"> </span><br><span class="line">                   <span class="comment">// 判断是否key值重复，重复了就返回旧的value值</span></span><br><span class="line">                    <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                        <span class="keyword">return</span> oldVal;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">       <span class="comment">// 这里是添加一次计数器的值，并且达到负载因子的阈值就会进行扩容</span></span><br><span class="line">        addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">         </span><br><span class="line">       <span class="comment">// 如果是没有key值重复的情况就是返回null，如果key值重复就是返回旧的value值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="casTabAt-写入方法"><a href="#casTabAt-写入方法" class="headerlink" title="casTabAt()写入方法"></a>casTabAt()写入方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="type">boolean</span> <span class="title function_">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i,</span></span><br><span class="line"><span class="params">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="type">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​多个线程来同时竞争到Node数组的同一插槽时通过cas来竞争，没抢到的就返回false，就进入到下次循环，下次进来通过hash算法还是同一个插槽所以就进入到else中的循环来看是否是key值重复或者是hash冲撞添加到链表尾部。</p><h3 id="get方法："><a href="#get方法：" class="headerlink" title="get方法："></a>get方法：</h3><p>1）根据 key 对应 hashcode 找到对应的桶，如果正好是桶的头节点，则直接返回值</p><p>2）如果不是桶的头节点，并且是红黑树结构，那就按照树的方式去查找值</p><p>3）如果既不是桶的头节点，也不是红黑树结构，那就按照链表的方式去查找值（也就是遍历）</p><h2 id="计算-ConcurrentHashMap-Size"><a href="#计算-ConcurrentHashMap-Size" class="headerlink" title="计算 ConcurrentHashMap Size"></a>计算 ConcurrentHashMap Size</h2><p>在并发环境中计算容器size的时候还有线程在并发地插入数据，这个就可能会导致我们计算出来的size和实际的有差距。那么ConcurrentHashMap在1.7和1.8中是如何解决这个问题的呢：</p><p><strong>在 JDK1.7 中</strong>，第一种方案他会使用不加锁的模式去尝试多次计算 ConcurrentHashMap 的 size，最多三次，比较前后两次计算的结果，结果一致就认为当前没有元素加入，计算的结果是准确的。 第二种方案是如果第一种方案不符合，他就会给每个 Segment 加上锁，然后计算 ConcurrentHashMap 的 size 返回。</p><p><strong>在JDK1.8</strong>中简化了这个操作：size（）源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">n</span> <span class="operator">=</span> sumCount();</span><br><span class="line">    <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">           (n &gt; (<span class="type">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE : (<span class="type">int</span>)n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最大值是 Integer 类型的最大值，但是 Map 的 size 可能超过 MAX_VALUE， 所以还有一个方法 **mappingCount()**，JDK 的建议使用 <code>mappingCount()</code> 而不是<code>size()</code>。<code>mappingCount()</code> 的代码如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public long mappingCount() &#123;</span><br><span class="line">    long n = sumCount();</span><br><span class="line">    return (n &lt; 0L) ? 0L : n; // ignore transient negative values</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上可以看出，无论是 <code>size()</code> 还是 <code>mappingCount()</code>, 计算大小的核心方法都是 <code>sumCount()</code>。<code>sumCount()</code> 的代码如下:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">final long sumCount() &#123;</span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">    long sum = baseCount;</span><br><span class="line">    if (as != null) &#123;</span><br><span class="line">       for (int i = 0; i &lt; as.length; ++i) &#123;</span><br><span class="line">           if ((a = as[i]) != null)</span><br><span class="line">               sum += a.value;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcurrentHashMap 提供了 baseCount、counterCells <strong>两个辅助变量</strong>和一个 CounterCell <strong>辅助内部类</strong>。<code>sumCount()</code> 就是迭代 counterCells 来统计 sum 的过程，</p><ol><li><strong>在没有并发的情况下，使用一个<code>volatile修饰</code>的 <code>baseCount</code> 变量即可；</strong></li><li>当有并发时，<strong>CAS 修改 baseCount 失败后</strong>，会使用 CounterCell 类，即 创建一个CounterCell对象，设置其volatile修饰的 value 属性为 1，并将其放在ConterCells数组的随机位置；最终在sumCount()方法中通过<strong>累加 baseCount和CounterCells数组里每个CounterCell的值 得出Map的总大小Size</strong>。然而 返回的值是一个估计值；如果有并发插入或者删除操作，和实际的数量可能有所不同。</li></ol><h2 id="addCount-方法："><a href="#addCount-方法：" class="headerlink" title="addCount()方法："></a>addCount()方法：</h2><p>影响size的操作最终都会调用addCount()方法来维护size：addCount()方法分为两个阶段，分别为：**</p><ol><li>计算当前存入的KV键值对总数size；</li><li>存储的总kv数量达到了阈值，执行扩容</li></ol><p>首先我们关注size的第一阶段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数 x 表示键值对个数的变化值，如果为正，表示新增了元素，如果为负，表示删除了元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">addCount</span><span class="params">(<span class="type">long</span> x, <span class="type">int</span> check)</span> &#123;</span><br><span class="line">    CounterCell[] as; <span class="type">long</span> b, s;</span><br><span class="line">    <span class="comment">// 如果 counterCells 为空，则直接尝试通过 CAS 将 x 累加到 baseCount 中</span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="literal">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="built_in">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        <span class="comment">// counterCells 非空</span></span><br><span class="line">        <span class="comment">// 或 counterCells 为空，但 CAS baseCount 失败都会来到这里</span></span><br><span class="line">        CounterCell a; <span class="type">long</span> v; <span class="type">int</span> m;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">uncontended</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">// CAS 数组元素时，有没有发生线程争用的标志</span></span><br><span class="line">        <span class="comment">// 如果当前线程探针哈希到的数组元素非空，则尝试将 x 累加到对应数组元素</span></span><br><span class="line">        <span class="keyword">if</span> (as == <span class="literal">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="literal">null</span> ||</span><br><span class="line">            !(uncontended =</span><br><span class="line">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">            <span class="comment">// counterCells 为空，或其长度小于1</span></span><br><span class="line">            <span class="comment">// 或当前线程探针哈希到的数组元素为空</span></span><br><span class="line">            <span class="comment">// 或当前线程探针哈希到的数组元素非空，但 CAS 数组元素失败</span></span><br><span class="line">            <span class="comment">// 都会调用 fullAddCount 方法来完成 x 的写入</span></span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 如果调用过 fullAddCount，则当前线程一定不会协助扩容</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 走到这说明，CAS 数组元素成功</span></span><br><span class="line">        <span class="comment">// 此时如果 check &lt;= 1，也不协助可能会发生的扩容</span></span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 如果 check 大于 1，则计算当前 map 的 size，为判断是否需要扩容做准备</span></span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// size 的变化已经写入完成</span></span><br><span class="line">    <span class="comment">// 后面如果 check &gt;= 0，则判断当前的 size 是否会触发扩容</span></span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 扩容相关的逻辑</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="type">int</span> n, sc;</span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="type">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(n);</span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="literal">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="literal">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上可以看出在修改影响size大小的baseCount，CounterCell 值时有以下几种情况：</p><ol><li>（没有并发）第一次执行addCount()方法时，counterCells数组为null，则<code>(as = counterCells) != null</code>为false，所以线程直接使用CAS将<code>baseCount</code>执行 +V（删改元素数量）操作；</li><li>（有并发）CAS失败 或 第N次执行<code>addCount()</code>方法时发现counterCells不为空，会做进一步判断：<ol><li>（才开始并发）counterCells等于null（第一次CAS修改baseCount值失败时）</li><li>（并发一会了，找到一个闲置的counterCell）counterCells初始化了但是其中没有数据 或 counterCells中随机一个下标位置a处没有存储数据</li><li>（疯狂并发中）找到了要+V的counterCells下标位置a处的counterCell执行CAS做 + v操作都失败了，说明这个时候并发很严重；</li></ol></li></ol><p>​第2种情况都会进入到<code>fullAddCount()</code>方法中进一步处理多线程竞争下的键值对size维护操作，但是使用一个boolean类型的变量uncontended标记是否为对counterCells下标位置a处执行CAS失败才进入的<code>fullAddCount()</code>方法表示这个时候是疯狂并发中。</p><h2 id="fullAddCount-方法："><a href="#fullAddCount-方法：" class="headerlink" title="fullAddCount()方法："></a>fullAddCount()方法：</h2><p><strong>fullAddCount()又可以分为两个阶段：</strong></p><ul><li>第一阶段，计算当前线程的探针哈希值（找到可以添加size变化值V的counterCell元素）；</li><li>第二阶段，找到了counterCell，就在无限循环中，利用CounterCell进行计数。</li></ul><p>这里解释一下<strong>探针哈希值</strong>：探针哈希值的作用是哈希线程，将线程和数组中的不同元素对应起来，尽量避免线程争用同一数组元素，这里也就是要个当前线程找到可以插入size变化的counterCell。</p><p><strong>探针哈希值与map里使用的哈希值区别是</strong>：当线程发生数组元素争用后，可以改变线程的探针哈希值，让线程去使用另一个数组元素，而map中key对象的哈希值，由于有定位value的需求，所以它是一定不能变的。</p><p><strong>第二阶段包含三种情况：</strong></p><ol><li>counterCells不为空且其中有元素；<ol><li>随机数h待插入的counterCells数组下标位置没有数据；并且没有线程正在操作counterCells数组，则通过CAS将cellsBusy设置为1，然后新建一个CounterCell插入到 随机数h &amp; counterCells.length下标位置，在将cellsBusy设置为0；</li><li>随机数h待插入的counterCells数组下标位置有数据，则通过CAS将原数据值 + v；CAS成功退出循环；</li><li>如果多线程CAScounterCells 指定下标位置的value值时发生碰撞，CAS的失败的线程会对counterCells数组进行两倍扩容，以减少碰撞次数。</li></ol></li><li>counterCells为空，且没有其他线程正在操作counterCells；<ol><li>直接创建一个长度为2的CounterCell数组counterCells，并将V赋值进数组的 <code>h &amp; 1</code>下标位置，跳出循环。</li></ol></li><li>尝试直接通过CAS修改baseCount的值；<ul><li>如果CAS修改baseCount成功，则跳出循环，否则继续下一轮循环。</li></ul></li></ol><p><strong>需要注意的是CounterCell对象定义的前面加上了@sun.misc.Contended注解：</strong></p><p>@sun.misc.Contended是Java8新增的一个注解，对某个字段加上该注解 则表示该字段会单独占用一个缓存行（Cache Line）；</p><p>​缓存行是指CPU缓存（L1、L2、L3）的存储单元，常见的缓存行大小为64字节；<br>​JVM添加-XX:-RestrictContended参数后@sun.misc.Contended注解才有效。</p><p>添加这个注解是为了避免伪共享：</p><p>​为了提高读取速度，每个CPU都有自己的缓存，CPU读取数据后会存到自己的缓存里；并且为了节省空间，一个缓存行可能存储着多个变量，即<strong>伪共享</strong>。</p><p>但是伪共享对于共享变量，会造成性能问题，比如：</p><p>​当一个CPU要修改共享变量A时会先锁定自己缓存里 A所在的缓存行，并且把其他CPU缓存上相关的缓存行设置为无效。<br>​但如果被锁定或失效的缓存行里，还存储了其他不相干的变量B，其他线程此时就访问不了B。<br>​或者由于缓存行失效需要重新从内存中读取加载到缓存里，也就造成了开销。<br>​所以让共享变量A单独使用一个缓存行就不会影响到其他线程对其他共享变量的访问。</p><p>在<strong>Java8之前</strong>，是通过代码里手动添加属性的方式避免伪共享，比如类A中有一个long类型的value；因为一个long占8个字节，所以再添加7个long属性就会变成64个字节，刚好是一个缓存行大小。</p><p><strong>应用场景：</strong>主要适用于会被频繁写的共享数据上。如果不是被频繁写的数据，那么CPU缓存行被锁的几率就不大，所以没必要使用；否则不仅占空间还会浪费CPU访问&#x2F;操作数据的时间。</p><h3 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a><strong>我的理解</strong></h3><p>​这里的设计确实很巧妙：我理解的是：当没有冲突的时候增删元素的时候只用将size的变化表示在baseCount上就行，但是有冲突的时候就不能只在baseCount上改变了，为了尽可能降低并发，就去一个数组（counterCells）来存储后续所有 size 的变化，只要一个要改变size的线程成功在数组上任意一个counterCell上+1了，就算完成。反正最后统计size的时候都会加上所有counterCell中的值。</p><p>​但是这个 CounterCell的数量是在哪里维护的呢，肯定是在增删的过程中会有影响到CounterCell数量的地方： put 操作时，肯定会影响 <code>size()</code>，<strong>在 <code>put()</code> 方法最后会调用 <code>addCount()</code> 方法修改Map的size</strong>。</p><p>​如果 CAS 数组元素连续失败两次，就会进行 counterCells 数组的扩容，直到达到机器的处理器数为止。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​通过源码可以看出，ConcurrentHashMap和HashMap的区别就是<br>1、引入了sizeCtl，sizeCtl有三种状态<br>​1.1、0：还未初始化<br>​1.2、-1：正在初始化<br>​1.3、&lt;0但是不等于-1，此时表示正在扩容。第一个扩容的线程会将sizeCtl设置为sizeStamp(n)&lt;&lt;16+2<br>​1.4、大于0.这时为扩容的阈值，为n*0.75<br>2、通过Synchronized将对应的槽位的第一个节点锁住，只会锁住一个槽，而不是一整个table</p><p>3、扩容：<br>        是将n个槽分为若干个连续的组，一个组的长度为固定的stride，stride&#x3D;n&#x2F;8&#x2F;cpu个数，如果小于16会将其赋值为16。</p><p>​并允许多个线程同时扩容，每个线程都有其搬运的上下界区间。上界由一个transferIndex变量控制，transferIndex初始值为n，每个线程再申请搬运区间的时候，会将transfer -&#x3D; stride，其对应的区间为[transferIndex -stride,transferIndex],然后开始搬运区间中对应的槽位。搬运完这stride个槽位后，如果发现transferIndex&gt;0,还会继续搬运，直到transderIndex &lt; 0 说明搬运区间已经被申请完了，但是这时未必全部都搬运完成了，申请搬运区间到搬运完成是需要一个过程的。</p><p>​sizeCtl与扩容状态也有关,sizeCtl的高16位代表着扩容的时间戳，后16位对应着搬运的线程数。第一个扩容的线程会将sizeCtl设置为sizeStamp(n)&lt;&lt;16+2，当线程插入或者删除的时候，发现正在扩容，首先会帮助扩容，当扩容完毕后才会执行插入或者删除操作。具体做法是将sizeCtl+1，然后申请搬运区间并搬运，当线程申请不到搬运区间的时候，将sizeCtl-1,当sizeCtl &#x3D;&#x3D; sizeStamp(n)&lt;&lt;16+2的时候，说明搬运完成。</p><p>参考：<a href="https://blog.csdn.net/qq_43799161/article/details/122814374">https://blog.csdn.net/qq_43799161/article/details/122814374</a></p><h1 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h1><p>​<code>CopyOnWriteArrayList</code> 读取是完全不用加锁的，并且在写入的时候也不会阻塞读取操作，只有写入和写入之间需要进行同步等待。</p><p><img src="3.jpg"></p><p>可以看到CopyOnWriteArrayList的继承体系·：</p><ul><li>实现了List, RandomAccess, Cloneable, java.io.Serializable等接口。</li><li>实现了List，提供了基础的添加、删除、遍历等操作。</li><li>实现了RandomAccess，提供了随机访问的能力。</li><li>实现了Cloneable，可以被克隆。</li><li>实现了Serializable，可以被序列化。</li></ul><p>CopyOnWriteArrayList 类的所有可变操作（add，set 等等）都是通过创建底层数组的<strong>新副本</strong>来实现的。当 List 需要被修改的时候，我并不修改原有内容，而是对原有数据进行一次复制，将修改的内容写入副本。写完之后，再将修改完的副本<strong>替换原来的数据</strong>，这样就可以保证写操作不会影响读操作了。</p><p><img src="2.png"></p><p><strong>这两个属性是 CopyOnWriteArrayList 的核心 。</strong></p><p><strong>lock：ReentrantLock，独占锁，多线程运行的情况下，只有一个线程会获得这个锁，只有释放锁后其他线程才能获得。</strong></p><p><strong>array：存放数据的数组，关键是被volatile修饰了，被volatile修饰，就保证了可见性，也就是一个线程修改后，其他线程立即可见。</strong></p><h2 id="CopyOnWriteArrayList-读取和写入源码"><a href="#CopyOnWriteArrayList-读取和写入源码" class="headerlink" title="CopyOnWriteArrayList 读取和写入源码"></a>CopyOnWriteArrayList 读取和写入源码</h2><h3 id="CopyOnWriteArrayList-读取操作的实现"><a href="#CopyOnWriteArrayList-读取操作的实现" class="headerlink" title="CopyOnWriteArrayList 读取操作的实现"></a>CopyOnWriteArrayList 读取操作的实现</h3><p>​读取操作没有任何同步控制和锁操作，理由就是内部数组 <code>array</code> 不会发生修改，只会被另外一个 <code>array</code> 替换，因此可以保证数据安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The array, accessed only via getArray/setArray. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">private</span> E <span class="title function_">get</span><span class="params">(Object[] a, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="CopyOnWriteArrayList-写入操作的实现"><a href="#CopyOnWriteArrayList-写入操作的实现" class="headerlink" title="CopyOnWriteArrayList 写入操作的实现"></a>CopyOnWriteArrayList 写入操作的实现</h3><p>​<code>CopyOnWriteArrayList</code> 写入操作 <code>add()</code>方法在添加集合的时候加了锁，保证了同步，避免了多线程写的时候会 copy 出多个副本出来。这个过程是线程安全的，COW的核心思想就是每次修改的时候拷贝一个新的资源去修改，add()方法再拷贝新资源的时候将数组容量+1，这样虽然每次添加元素都会浪费一定的空间，但是数组的长度正好是元素的长度，也在一定程度上节省了扩容的开销。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();<span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);<span class="comment">//拷贝新数组</span></span><br><span class="line">        newElements[len] = e;<span class="comment">//将元素添加到新数组的末尾</span></span><br><span class="line">        setArray(newElements);<span class="comment">//将新数组替换了array数组</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();<span class="comment">//释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="与Vector的区别："><a href="#与Vector的区别：" class="headerlink" title="与Vector的区别："></a>与Vector的区别：</h2><p>Vector集合的所有操作元素的方法都加了synchronized关键字，这就导致了操作Vector的效率会非常低，在开发中，往往读操作的使用频率会远高于其他操作，而CopyOnWriteArrayList 就是这样一种读操作效率远高于写操作效率的List</p><h1 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h1><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>Java 提供的线程安全的 <code>Queue</code> 可以分为<strong>阻塞队列</strong>和<strong>非阻塞队列</strong>，阻塞队列与普通队列的区别在于，当队列是空的时，从队列中获取元素的操作将会被阻塞，或者当队列是满时，往队列里添加元素的操作会被阻塞。其中阻塞队列的典型例子是 <code>BlockingQueue</code>，非阻塞队列的典型例子是 <code>ConcurrentLinkedQueue</code><strong>，阻塞队列可以通过加锁来实现，非阻塞队列可以通过 CAS 操作实现。</strong></p><h2 id="非阻塞算法："><a href="#非阻塞算法：" class="headerlink" title="非阻塞算法："></a>非阻塞算法：</h2><p><strong>基于锁的算法会带来一些活跃度失败的风险。如果线程在持有锁的时候因为阻塞I&#x2F;O、页面错误、或其他原因发生延迟，很可能所有的线程都不能工作了。一个线程的失败或挂起不应该影响其他线程的失败或挂起，这样的算法称为非阻塞算法</strong>；如果算法的每一个步骤中都有一些线程能够继续执行，那么这样的算法称为锁自由（lock-free）算法。在线程间使用CAS进行协调，这样的算法如果能构建正确的话，它既是非阻塞的，又是锁自由的。java中提供了基于CAS非阻塞算法实现的队列，比较有代表性的有ConcurrentLinkedQueue和LinkedTransferQueue（下方介绍），它们采用CAS的性能一般比阻塞队列的好。</p><p>​ConcurrentLinkedQueue这个队列使用<strong>链表</strong>作为其数据结构，并使用无锁方案： <strong>CAS 非阻塞算法</strong>来实现线程安全，适合在对性能要求相对较高，同时对队列的<strong>读写存在多个线程同时进行</strong>的场景。</p><h2 id="ConcurrentLinkedQueue源码分析"><a href="#ConcurrentLinkedQueue源码分析" class="headerlink" title="ConcurrentLinkedQueue源码分析"></a>ConcurrentLinkedQueue源码分析</h2><p>​CoucurrentLinkedQueue的结构由head节点和tail节点组成，每个节点由<strong>节点元素item</strong>和<strong>指向下一个节点的next引用</strong>组成，而节点与节点之间的关系就是通过该next关联起来的，从而组成一张链表的队列。节点Node为ConcurrentLinkedQueue的内部类，定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">      <span class="comment">/** 节点元素域 */</span></span><br><span class="line">      <span class="keyword">volatile</span> E item;</span><br><span class="line">      <span class="keyword">volatile</span> Node&lt;E&gt; next;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">//初始化,获得item 和 next 的偏移量,为后期的CAS做准备</span></span><br><span class="line">    </span><br><span class="line">      Node(E item) &#123;</span><br><span class="line">          UNSAFE.putObject(<span class="built_in">this</span>, itemOffset, item);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">boolean</span> <span class="title function_">casItem</span><span class="params">(E cmp, E val)</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, itemOffset, cmp, val);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">void</span> <span class="title function_">lazySetNext</span><span class="params">(Node&lt;E&gt; val)</span> &#123;</span><br><span class="line">          UNSAFE.putOrderedObject(<span class="built_in">this</span>, nextOffset, val);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">boolean</span> <span class="title function_">casNext</span><span class="params">(Node&lt;E&gt; cmp, Node&lt;E&gt; val)</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, nextOffset, cmp, val);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Unsafe mechanics</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">      <span class="comment">/** 偏移量 */</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> itemOffset;</span><br><span class="line">      <span class="comment">/** 下一个元素的偏移量 */</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> nextOffset;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">static</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">              Class&lt;?&gt; k = Node.class;</span><br><span class="line">              itemOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                      (k.getDeclaredField(<span class="string">&quot;item&quot;</span>));</span><br><span class="line">              nextOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                      (k.getDeclaredField(<span class="string">&quot;next&quot;</span>));</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(e);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="offer"><a href="#offer" class="headerlink" title="offer"></a>offer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="comment">//检查节点是否为null</span></span><br><span class="line">        checkNotNull(e);</span><br><span class="line">        <span class="comment">// 创建新节点</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//死循环 直到成功为止</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class="line">            Node&lt;E&gt; q = p.next;</span><br><span class="line">            <span class="comment">// q == null 表示 p已经是最后一个节点了，尝试加入到队列尾</span></span><br><span class="line">            <span class="comment">// 如果插入失败，则表示其他线程已经修改了p的指向</span></span><br><span class="line">            <span class="keyword">if</span> (q == <span class="literal">null</span>) &#123;                                <span class="comment">// --- 1</span></span><br><span class="line">                <span class="comment">// casNext：t节点的next指向当前节点</span></span><br><span class="line">                <span class="comment">// casTail：设置tail 尾节点</span></span><br><span class="line">                <span class="keyword">if</span> (p.casNext(<span class="literal">null</span>, newNode)) &#123;             <span class="comment">// --- 2</span></span><br><span class="line">                    <span class="comment">// node 加入节点后会导致tail距离最后一个节点相差大于一个，需要更新tail</span></span><br><span class="line">                    <span class="keyword">if</span> (p != t)                             <span class="comment">// --- 3</span></span><br><span class="line">                        casTail(t, newNode);                    <span class="comment">// --- 4</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// p == q 等于自身</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == q)                                <span class="comment">// --- 5</span></span><br><span class="line">                <span class="comment">// p == q 代表着该节点已经被删除了</span></span><br><span class="line">                <span class="comment">// 由于多线程的原因，我们offer()的时候也会poll()，如果offer()的时候正好该节点已经poll()了</span></span><br><span class="line">                <span class="comment">// 那么在poll()方法中的updateHead()方法会将head指向当前的q，而把p.next指向自己，即：p.next == p</span></span><br><span class="line">                <span class="comment">// 这样就会导致tail节点滞后head（tail位于head的前面），则需要重新设置p</span></span><br><span class="line">                p = (t != (t = tail)) ? t : head;           <span class="comment">// --- 6</span></span><br><span class="line">            <span class="comment">// tail并没有指向尾节点</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// tail已经不是最后一个节点，将p指向最后一个节点</span></span><br><span class="line">                p = (p != t &amp;&amp; t != (t = tail)) ? t : q;    <span class="comment">// --- 7</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>​ConcurrentLinkedQueue提供了poll()方法进行出列操作。入列主要是涉及到tail，出列则涉及到head。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 如果出现p被删除的情况需要从head重新开始</span></span><br><span class="line">        restartFromHead: </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 节点 item</span></span><br><span class="line">                <span class="type">E</span> <span class="variable">item</span> <span class="operator">=</span> p.item;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// item 不为null，则将item 设置为null</span></span><br><span class="line">                <span class="keyword">if</span> (item != <span class="literal">null</span> &amp;&amp; p.casItem(item, <span class="literal">null</span>)) &#123;                    <span class="comment">// --- 1</span></span><br><span class="line">                    <span class="comment">// p != head 则更新head</span></span><br><span class="line">                    <span class="keyword">if</span> (p != h)                                                 <span class="comment">// --- 2</span></span><br><span class="line">                        <span class="comment">// p.next != null，则将head更新为p.next ,否则更新为p</span></span><br><span class="line">                        updateHead(h, ((q = p.next) != <span class="literal">null</span>) ? q : p);          <span class="comment">// --- 3</span></span><br><span class="line">                    <span class="keyword">return</span> item;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// p.next == null 队列为空</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((q = p.next) == <span class="literal">null</span>) &#123;                                <span class="comment">// --- 4</span></span><br><span class="line">                    updateHead(h, p);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当一个线程在poll的时候，另一个线程已经把当前的p从队列中删除——将p.next = p，p已经被移除不能继续，需要重新开始</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p == q)                                                <span class="comment">// --- 5</span></span><br><span class="line">                    <span class="keyword">continue</span> restartFromHead;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p = q;                                                      <span class="comment">// --- 6</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上诉有一个很重要的方法：updateHead()，该方法用于CAS更新head节点，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">updateHead</span><span class="params">(Node&lt;E&gt; h, Node&lt;E&gt; p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (h != p &amp;&amp; casHead(h, p))</span><br><span class="line">        h.lazySetNext(h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ConcurrentLinkedQueue中规定，p &#x3D;&#x3D;  q表明，该节点已经被删除了，也就说tail滞后于head，head无法通过succ()方法遍历到tail，怎么做？ (t !&#x3D; (t &#x3D;  tail))? t : head;这段代码主要是来判读tail节点是否已经发生了改变，如果发生了改变，则说明tail已经重新定位了，只需要重新找到tail即可，否则就只能指向head了。</p><h1 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h1><p>​阻塞队列（<code>BlockingQueue</code>）被广泛使用在“生产者-消费者”问题中，其原因是 <code>BlockingQueue</code> 提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。</p><p>​<code>BlockingQueue</code> 是一个接口，继承自 <code>Queue</code>，所以其实现类也可以作为 <code>Queue</code> 的实现来使用，而 <code>Queue</code> 又继承自 <code>Collection</code> 接口。下面是 <code>BlockingQueue</code> 的相关实现类：</p><p><img src="1.png"></p><p>BlockingQueue 对插入操作、移除操作、获取元素操作提供了四种不同的方法用于不同的场景中使用：1、抛出异常；2、返回特殊值（null 或 true&#x2F;false，取决于具体的操作）；3、阻塞等待此操作，直到这个操作成功；4、阻塞等待此操作，直到成功或者超时指定时间。总结如下：</p><p><img src="4.jpg"></p><h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><p><code>ArrayBlockingQueue</code> 是 <code>BlockingQueue</code> 接口的有界队列实现类，底层采用数组来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayBlockingQueue</span>&lt;E&gt;</span><br><span class="line"><span class="keyword">extends</span> <span class="title class_">AbstractQueue</span>&lt;E&gt;</span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">BlockingQueue</span>&lt;E&gt;, Serializable&#123;&#125;</span><br></pre></td></tr></table></figure><p>​<code>ArrayBlockingQueue</code> <strong>一旦创建，容量不能改变</strong>。其并发控制采用<strong>可重入锁 ReentrantLock</strong> ，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。当队列容量满时，尝试将元素放入队列将导致操作阻塞;尝试从一个空队列中取一个元素也会同样阻塞。</p><p>​<code>ArrayBlockingQueue</code> 默认情况下不能保证线程访问队列的公平性，所谓公平性是指严格按照线程等待的绝对时间顺序，即最先等待的线程能够最先访问到 <code>ArrayBlockingQueue</code>。而非公平性则是指访问 <code>ArrayBlockingQueue</code> 的顺序不是遵守严格的时间顺序，有可能存在，当 <code>ArrayBlockingQueue</code> 可以被访问时，长时间阻塞的线程依然无法访问到 <code>ArrayBlockingQueue</code>。如果保证公平性，通常会降低吞吐量。如果需要获得公平性的 <code>ArrayBlockingQueue</code>，可采用如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ArrayBlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;Integer&gt;(<span class="number">10</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><p><code>LinkedBlockingQueue</code> 底层基于<strong>单向链表</strong>实现的阻塞队列，可以当做无界队列也可以当做有界队列来使用，同样满足 FIFO 的特性，与 <code>ArrayBlockingQueue</code> 相比起来具有更高的吞吐量，为了防止 <code>LinkedBlockingQueue</code> 容量迅速增，损耗大量内存。通常在创建 <code>LinkedBlockingQueue</code> 对象时，会指定其大小，如果未指定，容量等于 <code>Integer.MAX_VALUE</code> 。</p><h2 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h2><p>​<code>PriorityBlockingQueue</code> 是一个支持优先级的无界阻塞队列。默认情况下元素采用自然顺序进行排序，也可以通过自定义类实现 <code>compareTo()</code> 方法来指定元素排序规则，或者初始化时通过构造器参数 <code>Comparator</code> 来指定排序规则。</p><p><code>PriorityBlockingQueue</code> 并发控制采用的是可重入锁 <code>ReentrantLock</code>，队列为无界队列（<code>ArrayBlockingQueue</code> 是有界队列，<code>LinkedBlockingQueue</code> 也可以通过在构造函数中传入 <code>capacity</code> 指定队列最大的容量，但是 <code>PriorityBlockingQueue</code> 只能指定初始的队列大小，后面插入元素的时候，<strong>如果空间不够的话会自动扩容</strong>）。</p><p>简单地说，<strong>它就是 <code>PriorityQueue</code> 的线程安全版本</strong>。不可以插入 null 值，同时，插入队列的对象必须是可比较大小的（comparable），否则报 <code>ClassCastException</code> 异常。它的插入操作 put 方法不会 block，因为它是无界队列（take 方法在队列为空的时候会阻塞）。</p><h2 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h2><p>​跳表是一种可以用来快速查找的数据结构，有点类似于平衡树。它们都可以对元素进行快速的查找。但一个重要的区别是：对平衡树的插入和删除往往很可能导致平衡树进行一次全局的调整。而对跳表的插入和删除只需要对整个数据结构的局部进行操作即可。这样带来的好处是：在高并发的情况下，你会需要一个全局锁来保证整个平衡树的线程安全。而对于跳表，你只需要部分锁即可。这样，在高并发环境下，你就可以拥有更好的性能。</p><p><img src="5.jpg"></p><p>​最低层的链表维护了跳表内所有的元素，每上面一层链表都是下面一层的子集。</p><p>​跳表内的所有链表的元素都是排序的。查找时，可以从顶级链表开始找。一旦发现被查找的元素大于当前链表中的取值，就会转入下一层链表继续找。这也就是说在查找过程中，搜索是跳跃式的。</p>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发容器 </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发-ThreadLocal</title>
      <link href="/2022/09/13/%E5%B9%B6%E5%8F%91-ThreadLocal/"/>
      <url>/2022/09/13/%E5%B9%B6%E5%8F%91-ThreadLocal/</url>
      
        <content type="html"><![CDATA[<h1 id="ThreadLocal的使用"><a href="#ThreadLocal的使用" class="headerlink" title="ThreadLocal的使用"></a>ThreadLocal的使用</h1><h2 id="ThreadLocal概念"><a href="#ThreadLocal概念" class="headerlink" title="ThreadLocal概念"></a>ThreadLocal概念</h2><p>​假如想实现每一个线程都有自己的专属本地变量该如何解决呢？ JDK中提供的<code>ThreadLocal</code>类正是为了解决这样的问题。 <strong><code>ThreadLocal</code>类主要解决的就是让每个线程绑定自己的值，可以将<code>ThreadLocal</code>类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</strong>如果你创建了一个<code>ThreadLocal</code>变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是<code>ThreadLocal</code>变量名的由来。他们可以使用 <code>get（）</code> 和 <code>set（）</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; messages = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//存入当前类的实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;ThreadLocalTest&gt; holder = ThreadLocal.withInitial(ThreadLocalTest::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        holder.get().messages.add(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;String&gt; messages = holder.get().messages;</span><br><span class="line">        holder.remove();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;size: &quot;</span> + holder.get().messages.size());</span><br><span class="line">        <span class="keyword">return</span> messages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//往ThreadLocal中放东西</span></span><br><span class="line">        ThreadLocalTest.add(<span class="string">&quot;一枝花算不算浪漫&quot;</span>);</span><br><span class="line">        System.out.println(holder.get().messages);</span><br><span class="line">        ThreadLocalTest.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ThreadLocal</code>对象可以提供线程局部变量，每个线程<code>Thread</code>拥有一份自己的<strong>副本变量</strong>，多个线程互不干扰。</p><h2 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h2><ul><li>set(T value)：设置线程本地变量的内容。</li><li>get()：获取线程本地变量的内容。</li><li>remove()：移除线程本地变量。注意在线程池的线程复用场景中在线程执行完毕时一定要调用remove，避免在线程被重新放入线程池中时被本地变量的旧状态仍然被保存。</li></ul><h1 id="ThreadLocal的数据结构"><a href="#ThreadLocal的数据结构" class="headerlink" title="ThreadLocal的数据结构"></a>ThreadLocal的数据结构</h1><p><img src="1.jpg"></p><p><code>Thread</code>类有一个类型为<code>ThreadLocal.ThreadLocalMap</code>的实例变量<code>threadLocals</code>，也就是说<strong>每个线程有一个自己的<code>ThreadLocalMap</code>。</strong></p><p><code>ThreadLocalMap</code>有自己的独立实现，可以简单地将它的<code>key</code>视作<code>ThreadLocal</code>，<code>value</code>为代码中放入的值（实际上<code>key</code>并不是<code>ThreadLocal</code>本身，而是它的一个<strong>弱引用</strong>）。</p><p>每个线程在往<code>ThreadLocal</code>里放值的时候，<strong>都会往自己的<code>ThreadLocalMap</code>里存，读也是以<code>ThreadLocal</code>作为引用，在自己的<code>map</code>里找对应的<code>key</code><strong>，当需要存多个值时，可以直接存一个复杂对象或者是新建多个ThreadLocal作为当前线程ThreadLocalMap的key来存储值。从而实现了</strong>线程隔离</strong>。</p><p><code>ThreadLocalMap</code>有点类似<code>HashMap</code>的结构，只是<code>HashMap</code>是由<strong>数组+链表</strong>实现的，而<code>ThreadLocalMap</code>中并没有<strong>链表</strong>结构，在插入数据出现散列冲突时会不断向后遍历找到空的位置，将值插入进去。</p><p>我们还要注意<code>Entry</code>， 它的<code>key</code>是<code>ThreadLocal&lt;?&gt; k</code> ，继承自<code>WeakReference</code>， 也就是我们常说的弱引用类型。</p><h1 id="ThreadLocal-set-方法源码"><a href="#ThreadLocal-set-方法源码" class="headerlink" title="ThreadLocal.set()方法源码"></a>ThreadLocal.set()方法源码</h1><p><img src="2.jpg"></p><p><code>ThreadLocal</code>中的<code>set</code>方法原理如上图所示，很简单，主要是判断<code>ThreadLocalMap</code>是否存在，然后使用<code>ThreadLocal</code>中的<code>set</code>方法进行数据处理。</p><p>set方法的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前线程的threadLocals字段</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="comment">// 判断线程的threadLocals是否初始化了</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没有则创建一个ThreadLocalMap对象进行初始化</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="map-set源码："><a href="#map-set源码：" class="headerlink" title="map.set源码："></a>map.set源码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 往map中设置ThreadLocal的关联关系</span></span><br><span class="line"><span class="comment">* set中没有使用像get方法中的快速选择的方法，因为在set中创建新条目和替换旧条目的内容一样常见，</span></span><br><span class="line"><span class="comment">* 在替换的情况下快速路径通常会失败（对官方注释的翻译）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line">    <span class="comment">// map中就是使用Entry[]数据保留所有的entry实例</span></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="comment">// 返回下一个哈希码，哈希码的产生过程与神奇的0x61c88647的数字有关</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i]; e != <span class="literal">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            <span class="comment">// 已经存在则替换旧值</span></span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在设置期间清理哈希表为空的内容，保持哈希表的性质</span></span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tab[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">    <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> ++size;</span><br><span class="line">    <span class="comment">// 扩容逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ThreadLocalMap中的Entry的定义"><a href="#ThreadLocalMap中的Entry的定义" class="headerlink" title="ThreadLocalMap中的Entry的定义"></a>ThreadLocalMap中的Entry的定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">createMap方法：</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line">    <span class="comment">// key为一个ThreadLocal对象，v就是我们要在线程之间隔离的对象</span></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="built_in">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Thread-get方法源码"><a href="#Thread-get方法源码" class="headerlink" title="Thread.get方法源码"></a>Thread.get方法源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取ThreadLocal对应保留在Map中的Entry对象</span></span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="comment">// 获取ThreadLocal对象对应的值</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// map还没有初始化时创建map对象，并设置null，同时返回null</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="ThreadLocal内存泄露问题"><a href="#ThreadLocal内存泄露问题" class="headerlink" title="ThreadLocal内存泄露问题"></a>ThreadLocal内存泄露问题</h1><p>​内存泄露问题：指程序中动态分配的堆内存由于某种原因没有被释放或者无法释放，造成系统内存的浪费，导致程序运行速度减慢或者系统奔溃等严重后果。内存泄露堆积将会导致内存溢出。</p><p>​ThreadLocal的内存泄露问题一般考虑和Entry对象有关，在上面的Entry定义可以看出ThreadLocal::Entry被弱引用所修饰。</p><p><img src="3.jpg"></p><p>当ThreadLocal Ref被回收了，由于在Entry使用的是弱引用，因此在下次垃圾回收的时候就会将ThreadLocal对象清除，这个时候Entry中的KEY&#x3D;null。但是由于ThreadLocalMap中任然存在Current Thread Ref这个强引用，因此Entry中value的值任然无法清除。还是存在内存泄露的问题。</p><p>由此可以发现，使用ThreadLocal造成内存泄露的问题是因为：<strong>ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用,而 value 是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候会 key 会被清理掉，而 value 不会被清理掉。这样一来，ThreadLocalMap 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。使用完 ThreadLocal方法后 最好手动调用remove()方法。</strong>ThreadLocalMap的生命周期与Thread一致，如果不手动清除掉Entry对象的话就可能会造成内存泄露问题。因此，需要我们在每次在使用完之后需要手动的remove掉Entry对象。</p><p><strong>这里使用软引用的原因是：</strong>在ThreadLocalMap的set&#x2F;getEntry中，会对key进行判断，<strong>如果key为null，那么value也会被设置为null</strong>，这样即使在忘记调用了remove方法，当ThreadLocal被销毁时，对应value的内容也会被清空。<strong>多一层保障！</strong></p><h2 id="ThreadLocal的应用场景"><a href="#ThreadLocal的应用场景" class="headerlink" title="ThreadLocal的应用场景"></a>ThreadLocal的应用场景</h2><h3 id="解决Spring线程安全问题"><a href="#解决Spring线程安全问题" class="headerlink" title="解决Spring线程安全问题"></a>解决Spring线程安全问题</h3><p>​在Spring的Web项目中，我们通常会将业务分为Controller层，Service层，Dao层， 我们都知道**@Autowired注解默认使用单例模式**，那么不同请求线程进来之后，由于Dao层使用单例，那么负责数据库连接的Connection也只有一个， 如果每个请求线程都去连接数据库，那么就会造成线程不安全的问题，Spring是如何解决这个问题的呢？</p><p>​在Spring项目中Dao层中装配的Connection肯定是线程安全的，其解决方案就是采用ThreadLocal方法，当每个请求线程使用Connection的时候， 都会从ThreadLocal获取一次，如果为null，说明没有进行过数据库连接，连接后存入ThreadLocal中，如此一来，每一个请求线程都保存有一份自己的Connection。于是便解决了线程安全问题？</p>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThreadLocal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2022/09/12/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/09/12/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="单例模式的线程安全问题"><a href="#单例模式的线程安全问题" class="headerlink" title="单例模式的线程安全问题"></a>单例模式的线程安全问题</h1><p>单例模式有很多实现方法，饿汉、懒汉、DCL、静态内部类、枚举类。前面我们已经讲了 DCL的单例模式(见Java内存模型(JMM)与原子性、可见性、有序性） 和 静态内部类的单例模式（类加载阶段），此处做一个总结。试分析每种实现下获取单例对象（即调用 getInstance）时的线程安全，并思考注释中的问题</p><ul><li>饿汉式：类加载就会导致该单实例对象被创建</li><li>枚举饿汉式</li><li>懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</li><li>DCL 懒汉式</li><li>静态内部类懒汉式</li></ul><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 问题1：为什么加 final  -- 防止被子类继承，破坏单例</span><br><span class="line">// 问题2：如果实现了序列化接口, 还要做什么来防止反序列化破坏单例 -- 因为反序列化也会创建新的对象，需要实现 readResolve 方法，返回 INSTANCE 对象作为反序列化的结果</span><br><span class="line">public final class Singleton implements Serializable &#123; </span><br><span class="line">    // 问题3：为什么设置为私有? 是否能防止反射创建新的实例? -- 防止外部创建新的实例；不能防止反射</span><br><span class="line">    private Singleton() &#123;&#125; </span><br><span class="line">    </span><br><span class="line">    // 问题4：这样初始化是否能保证单例对象创建时的线程安全?  -- 可以，类加载阶段静态成员变量初始化由 JVM 保证线程安全</span><br><span class="line">    private static final Singleton INSTANCE = new Singleton(); </span><br><span class="line">    </span><br><span class="line">    // 问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public, 说出你知道的理由 -- 提供更好的封装性，可以更好的控制，还可以支持泛型 </span><br><span class="line">    public static Singleton getInstance() &#123; </span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 问题2 解决</span><br><span class="line">    public Object readResolve() &#123; </span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举饿汉式"><a href="#枚举饿汉式" class="headerlink" title="枚举饿汉式"></a>枚举饿汉式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 问题1：枚举单例是如何限制实例个数的   -- 定义几个就有几个，就是枚举类的静态成员变量</span><br><span class="line">// 问题2：枚举单例在创建时是否有并发问题 -- 没有，跟饿汉式相同，也是在类加载阶段初始化，由 JVM 保证线程安全</span><br><span class="line">// 问题3：枚举单例能否被反射破坏单例     -- 不能，反射在通过newInstance创建对象时，会检查该类是否ENUM修饰，如果是则抛出异常，反射失败</span><br><span class="line">// 问题4：枚举单例能否被反序列化破坏单例 -- 不能，虽然枚举类默认实现序列化接口，但枚举类已经考虑到了这点</span><br><span class="line">// 问题5：枚举单例属于懒汉式还是饿汉式   -- 饿汉式</span><br><span class="line">// 问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做 -- 写个构造方法就行了</span><br><span class="line"></span><br><span class="line">enum Singleton &#123; </span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public final class Singleton &#123; </span><br><span class="line">    private Singleton() &#123;&#125; </span><br><span class="line">    private static Singleton INSTANCE = null; </span><br><span class="line">    // 分析这里的线程安全, 并说明有什么缺点 -- 是安全的，但是每次都要加锁，并且锁的范围有点大，比较耗时</span><br><span class="line">    public static synchronized Singleton getInstance() &#123; </span><br><span class="line">        if( INSTANCE != null )&#123; </span><br><span class="line">            return INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">        INSTANCE = new Singleton(); </span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DCL-懒汉式（对懒汉式的改进）"><a href="#DCL-懒汉式（对懒汉式的改进）" class="headerlink" title="DCL 懒汉式（对懒汉式的改进）"></a>DCL 懒汉式（对懒汉式的改进）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">final class Singleton &#123;</span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // 问题1：解释为什么要加 volatile ? -- 保证新建对象时的有序性（避免先赋值，再构造的情况）</span><br><span class="line">    private static volatile Singleton INSTANCE = null;</span><br><span class="line"></span><br><span class="line">    // 问题2：对比实现3, 说出这样做的意义 -- 避免重复加锁</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (INSTANCE == null ) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                // 问题3：为什么还要在这里加为空判断, 之前不是判断过了吗 --  里层判断是为了防止第一次同时有多个线程尝试加锁，已经通过了第一个判断，目前在阻塞状态</span><br><span class="line">                if (INSTANCE == null) &#123;</span><br><span class="line">                    INSTANCE = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反射破坏单例性"><a href="#反射破坏单例性" class="headerlink" title="反射破坏单例性"></a>反射破坏单例性</h2><p>反射可以破坏除了静态内部类、枚举的单例模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 使用反射破坏单例</span></span><br><span class="line">        <span class="comment">// 获取空参构造方法 </span></span><br><span class="line">        Constructor&lt;Singleton&gt; declaredConstructor =Singleton.class.getDeclaredConstructor(<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 设置强制访问</span></span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 创建实例</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> declaredConstructor.newInstance();</span><br><span class="line">        System.out.println(<span class="string">&quot;反射创建的实例&quot;</span> + singleton);</span><br><span class="line">        System.out.println(<span class="string">&quot;正常创建的实例&quot;</span> +</span><br><span class="line">        Singleton.getInstance());</span><br><span class="line">        System.out.println(<span class="string">&quot;正常创建的实例&quot;</span> +</span><br><span class="line">        Singleton.getInstance());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h2><p>反射主要是通过获取到单例类的构造器，然后设置构造器为外部可访问的形式，来破坏单例。也就是说，外部方法依然是通过单例类的构造方法来创建一个新的单例的，那么我们想要阻止就很简单了，我们只需要保证构造方法只被执行一次即可。<br>我们在单例类中设置一个boolean变量，当构造方法被执行后，该变量就为true。当通过反射再次调用该构造方法时直接抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;不能创建多个对象...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类懒汉式"><a href="#静态内部类懒汉式" class="headerlink" title="静态内部类懒汉式"></a>静态内部类懒汉式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public final class Singleton &#123; </span><br><span class="line">    private Singleton() &#123; &#125; </span><br><span class="line">    // 问题1：属于懒汉式还是饿汉式 -- 懒汉式，因为类加载就是懒惰的，只有用到时才加载并初始化</span><br><span class="line">    private static class InnerClass &#123; </span><br><span class="line">        static final Singleton INSTANCE = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 问题2：在创建时是否有并发问题 -- 没有，同样也是在类加载阶段初始化，由 JVM 保证线程安全</span><br><span class="line">    public static Singleton getInstance() &#123; </span><br><span class="line">        return InnerClass.INSTANCE;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类的单例由内部类创建，由于JVM加载外部类时不会加载内部类，只有当调用静态内部类的方法&#x2F;属性时，才会加载，并初始化属性。静态属性由于被static修饰，保证只被实例化一次（类加载的最后一步是执行clinit方法，当有多个线程执行初始化方法时，JVM保证只有一个线程可以进入该方法，其他线程进入阻塞，从而保证类的初始化只被执行一次，从而保证只被实例化一次，并且严格保证实例化顺序。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发-ReentrantLock的原理</title>
      <link href="/2022/09/11/%E5%B9%B6%E5%8F%91-ReentrantLock%E7%9A%84%E5%8E%9F%E7%90%86/"/>
      <url>/2022/09/11/%E5%B9%B6%E5%8F%91-ReentrantLock%E7%9A%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="ReentrantLock-简介"><a href="#ReentrantLock-简介" class="headerlink" title="ReentrantLock 简介"></a>ReentrantLock 简介</h1><p>​ReentrantLock 又被称为显式锁，它是基于 AQS 原理继承 Lock 接口实现的，简而言之，就是用 Java 实现的锁，而 synchronized 是用 c++ 实现的，所以被称为隐式锁。它们都支持可重入，相对于 synchronized 它还具备如下特点</p><ul><li>可中断（指的是当线程竞争锁失败时，被动避免死等）</li><li>可以设置超时时间（主动避免死等，可以避免死锁）</li><li>可以设置为公平锁</li><li>支持多个条件变量（可理解成多个条件多个WaitSet，可以提高唤醒的准确性）</li></ul><span id="more"></span><p>基本语法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建一个 Reentrantlock 对象，就是锁对象</span></span><br><span class="line"><span class="type">ReentrantLock</span> <span class="variable">reentrantLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">// 获取（加）锁，也可以放在 try 里面</span></span><br><span class="line">reentrantLock.lock(); <span class="comment">// lock 和 unlock 之间代码的都可以看作临界区</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    reentrantLock.unlock();  <span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h2><p>​可重入原理是基于 AQS 框架的 state 状态计数，1 和 0 代表是否加锁，每次重入时 state 加1，是通过 cas 操作实现的，所以 AQS 内部的原理也大量使用了 cas。</p><h3 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h3><p>可打断指的是当<strong>线程竞争锁失败</strong>时，线程会进入阻塞状态（<code>BLOCKED</code>）等待锁释放</p><ul><li>此时如果是<code>synchronized</code>则不能被打断，会一直阻塞；</li><li>而如果使用<code>.lockInterruptibly()</code>方法加锁，则可以打断处于阻塞状态的线程，打断后会抛出异常<code>InterruptedException</code>。</li></ul><p>注意，获得锁之后都可以被打断。</p><p>​ReentrantLock 阻塞的实现是调用 LockSupport.park 实现的，park 可以被打断，这是 ReentrantLock 可以被打断的原理。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test22_2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test22_2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果没有竞争 --&gt; 获取 lock 对象锁</span></span><br><span class="line">                <span class="comment">// 如果有竞争  --&gt; 进入阻塞队列，但是可以被其他线程打断，不用继续等</span></span><br><span class="line">                <span class="comment">// 注意是在阻塞的时候被打断，即还没获得锁，不是在获得锁之后被打断</span></span><br><span class="line">                log.debug(<span class="string">&quot;尝试获得锁&quot;</span>);</span><br><span class="line">                lock.lockInterruptibly(); <span class="comment">// 可被打断锁</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;<span class="comment">//进入异常表示已经被打断了。</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                log.debug(<span class="string">&quot;等锁的过程中被打断，没有获得到锁，返回&quot;</span>);</span><br><span class="line">                <span class="comment">// 如果不返回会继续执行完本线程，这违背了锁的初衷</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;获取到锁&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程先加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;打断t1&quot;</span>);</span><br><span class="line">        t1.interrupt();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Output:</span></span><br><span class="line"><span class="comment">18:46:44.618 c.Test22_2 [t1] - 尝试获得锁</span></span><br><span class="line"><span class="comment">18:46:45.618 c.Test22_2 [main] - 打断t1</span></span><br><span class="line"><span class="comment">18:46:45.621 c.Test22_2 [t1] - 等锁的过程中被打断，没有获得到锁，返回</span></span><br><span class="line"><span class="comment">java.lang.InterruptedException</span></span><br><span class="line"><span class="comment">at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchronizer.java:898)</span></span><br><span class="line"><span class="comment">at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchronizer.java:1222)</span></span><br><span class="line"><span class="comment">at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:335)</span></span><br><span class="line"><span class="comment">at cn.itcast.test.Test22_2.lambda$main$0(Test22_2.java:21)</span></span><br><span class="line"><span class="comment">at java.lang.Thread.run(Thread.java:748)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>如果用<code>.lock</code>的话打断后没有任何反应，还会一直阻塞。</p><h3 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h3><p>​在获取锁的过程中，如果其他线程持有着锁一直没有释放，尝试获取锁的线程不会一直阻塞，会立即（<code>tryLock()</code>）或者等待一段时间（<code>tryLock(long timeout, TimeUnit unit)</code>）放弃，如果在这段时间后仍然没有获得锁，会取消阻塞。tryLock 在阻塞的过程中也可以被打断。</p><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个 Boolean 值，获取到锁则返回 true</span></span><br><span class="line"><span class="comment">// 可以看出这个方法也可以打断</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test22&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test22</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;t1尝试获得锁&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 等待2s</span></span><br><span class="line">                <span class="keyword">if</span> (!lock.tryLock(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;t1获取不到锁&quot;</span>);</span><br><span class="line">                    <span class="comment">// 获取不到锁，应该返回</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                log.debug(<span class="string">&quot;被打断，t1获取不到锁&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;t1获得到锁&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        log.debug(<span class="string">&quot;主线程获得到锁&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">// 睡眠2s</span></span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;主线程释放了锁&quot;</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Output:</span></span><br><span class="line"><span class="comment">20:26:44.061 c.Test22 [main] - 主线程获得到锁</span></span><br><span class="line"><span class="comment">20:26:44.067 c.Test22 [t1]   - t1尝试获得锁</span></span><br><span class="line"><span class="comment">20:26:45.069 c.Test22 [t1]   - t1获取不到锁</span></span><br><span class="line"><span class="comment">20:26:46.068 c.Test22 [main] - 主线程释放了锁</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><ul><li>公平锁（Fair）：阻塞的线程在阻塞队列中争抢锁时，按照进入阻塞队列的先后顺序，先进入的先获得到锁</li><li>非公平锁（Nonfair）：阻塞的线程在阻塞队列中争抢锁时，一起竞争，不考虑进入阻塞队列的先后顺序</li></ul><p>公平锁的意思就是先到先执行，本义是为了解决<code>饥饿问题</code>，但是用的不多，因为<code>tryLock</code>就可以解决<code>饥饿问题</code>，而且设置为公平锁会降低并发度。</p><p><code>synchronized</code>是不公平的，<code>ReentrantLock</code> 默认也是不公平（false）的，但可以设置成公平锁（true）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 默认不开启公平锁</span><br><span class="line">public ReentrantLock() &#123;</span><br><span class="line">    sync = new NonfairSync(); </span><br><span class="line">&#125;</span><br><span class="line">// 可以自行设置开启公平锁</span><br><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">    sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>原理基于 AQS 框架，定义了阻塞队列，当阻塞队列中的线程被唤醒时恰好也有其他线程来竞争锁的话，公平锁会先判断阻塞队列是否为空，为空才去竞争锁，否则就进入阻塞队列等待；而非公平锁没有判断，直接去竞争，谁能抢到谁执行。</p></blockquote><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p><code>synchronized</code> 中也有条件变量，就是我们讲原理时那个 <code>WaitSet</code> 休息室，当条件不满足时进入 <code>WaitSet</code> 等待；<code>ReentrantLock</code> 的条件变量比 <code>synchronized</code> 强大之处在于，它是支持多个条件变量的，这就好比</p><ul><li><code>synchronized</code> 是那些不满足条件的线程都在一间休息室等消息</li><li>而 <code>ReentrantLock</code> 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤醒</li></ul><blockquote><p>原理基于 AQS 框架，定义了多个阻塞队列，互不影响，而 Monitor 只有一个 WaitSet。</p></blockquote><p>使用要点：</p><ul><li>跟 wait 类似，await 前也需要获得锁</li><li>await 执行后，会释放锁，进入 <code>conditionObject</code> 等待</li><li>await 的线程被唤醒（或打断、或超时）需重新竞争 lock 锁</li><li>竞争 lock 锁成功后，从 await 后继续执行</li></ul><p>使用方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的条件变量(休息室)</span></span><br><span class="line">    <span class="type">Condition</span> <span class="variable">condition1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">condition2</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入休息室1等待</span></span><br><span class="line">    condition1.await();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒休息室1里的一个线程</span></span><br><span class="line">    condition1.signal();</span><br><span class="line">    <span class="comment">// 唤醒休息室1里的所有线程</span></span><br><span class="line">    condition1.signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ReentrantLock的原理"><a href="#ReentrantLock的原理" class="headerlink" title="ReentrantLock的原理"></a>ReentrantLock的原理</h1><p><img src="1.jpg"></p><ul><li>ReentrantLock实现了Lock接口，并使用内部类Sync(Sync继承AbstractQueuedSynchronizer(AQS))来实现同步操作</li><li>ReentrantLock内部类Sync</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span>&#123;</span><br><span class="line">    .... </span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//直接CAS状态加锁，非公平操作</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123; </span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//重写了tryRelease</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">        c = state - releases; <span class="comment">//改变同步状态</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//修改volatile 修饰的状态变量</span></span><br><span class="line">        setState(c); </span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Sync的子类NonfairSync和FairSync都重写了tryAcquire方法</li><li>其中NonfairSync的tryAcquire调用父类的nonfairTryAcquire方法, FairSync则自己重写tryAcquire的逻辑。其中调用hasQueuedPredecessors()判断是否有排队Node，存在则返回false（false会导致当前线程排队等待锁）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;   </span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">....    </span><br></pre></td></tr></table></figure><h1 id="synchronized-和-ReentrantLock-的区别"><a href="#synchronized-和-ReentrantLock-的区别" class="headerlink" title="synchronized 和 ReentrantLock 的区别"></a>synchronized 和 ReentrantLock 的区别</h1><h2 id="两者都是可重入锁"><a href="#两者都是可重入锁" class="headerlink" title="两者都是可重入锁"></a>两者都是可重入锁</h2><p><strong>“可重入锁”</strong> 指的是自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。</p><h2 id="synchronized-依赖于-JVM-而-ReentrantLock-依赖于-API"><a href="#synchronized-依赖于-JVM-而-ReentrantLock-依赖于-API" class="headerlink" title="synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API"></a>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</h2><p><code>synchronized</code> 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 <code>synchronized</code> 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。<code>ReentrantLock</code> 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try&#x2F;finally 语句块来完成）。</p><h2 id="ReentrantLock-比-synchronized-增加了一些高级功能"><a href="#ReentrantLock-比-synchronized-增加了一些高级功能" class="headerlink" title="ReentrantLock 比 synchronized 增加了一些高级功能"></a>ReentrantLock 比 synchronized 增加了一些高级功能</h2><p>相比<code>synchronized</code>，<code>ReentrantLock</code>增加了一些高级功能。主要来说主要有三点：</p><ul><li><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li><li><strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li><li><strong>可实现选择性通知（锁可以绑定多个条件）</strong>: <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>&#x2F;<code>notifyAll()</code>方法相结合可以实现等待&#x2F;通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</li></ul><h2 id="加锁对象的不同："><a href="#加锁对象的不同：" class="headerlink" title="加锁对象的不同："></a><strong>加锁对象的不同</strong>：</h2><p>​<code>synchronized</code>是对某一个对象加锁，释放锁只能等临界区代码执行完或进入<code>WaitSet</code>，而且不能被打断；<code>Reentrantlock</code>是对<code>Reentrantlock</code>对象加锁，所以<code>Reentrantlock</code>释放锁比较方便，可以在任意线程里调用同一 Reentrantlock 对象的<code>unlock</code>方法，而且提供了可被打断的锁实现方法<code>.lockInterruptibly()</code>，可打断这种机制也能解决死锁问题，但这是一种<strong>被动</strong>的解决死锁的方案。</p>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ReentrantLock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发-JMM-Java内存模型与happenBefore</title>
      <link href="/2022/09/11/%E5%B9%B6%E5%8F%91-JMM-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8EhappenBefore/"/>
      <url>/2022/09/11/%E5%B9%B6%E5%8F%91-JMM-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8EhappenBefore/</url>
      
        <content type="html"><![CDATA[<h1 id="CPU-缓存模型"><a href="#CPU-缓存模型" class="headerlink" title="CPU 缓存模型"></a>CPU 缓存模型</h1><p>​CPU Cache 缓存的是内存数据用于解决 CPU 处理速度和内存不匹配的问题，内存缓存的是硬盘数据用于解决硬盘访问速度过慢的问题。现代的 CPU Cache 通常分为三层，分别叫 L1,L2,L3 Cache。</p><p>​<strong>CPU Cache 的工作方式：</strong> 先复制一份数据到 CPU Cache 中，当 CPU 需要用到的时候就可以直接从 CPU Cache 中读取数据，当运算完成后，再将运算得到的数据写回 Main Memory 中。</p><span id="more"></span><h1 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h1><p>​为了提升执行速度&#x2F;性能，计算机在执行程序代码的时候，会对指令进行重排序。</p><p>​常见的指令重排序有下面 2 种情况：</p><ul><li><strong>编译器优化重排</strong> ：编译器（包括 JVM、JIT 编译器等）在不改变单线程程序语义的前提下，重新安排语句的执行顺序。</li><li><strong>指令并行重排</strong> ：现代处理器采用了指令级并行技术(Instruction-Level Parallelism，ILP)来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li></ul><p>​Java 源代码会经历 <strong>编译器优化重排 —&gt; 指令并行重排 —&gt; 内存系统重排</strong> 的过程，最终才变成操作系统可执行的指令序列。</p><p>​<strong>指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong> ，所以在多线程下，指令重排序可能会导致一些问题。</p><p>​内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种 CPU 指令，用来禁止处理器指令发生重排序（像屏障一样），从而保障指令执行的有序性。另外，为了达到屏障的效果，它也会使处理器写入、读取值之前，将主内存的值写入高速缓存，清空无效队列，从而保障变量的可见性。</p><h2 id="JMM-Java内存模型"><a href="#JMM-Java内存模型" class="headerlink" title="JMM(Java内存模型)"></a>JMM(Java内存模型)</h2><p>​<strong>Java 内存模型（JMM）</strong> 抽象了线程和主内存之间的关系，就比如说线程之间的共享变量必须存储在主内存中。线程对于变量的读、写都必须在工作内存中进行，而不能直接读、写主内存中的变量。同时，本线程的工作内存的变量也无法被其他线程直接访问，必须通过主内存完成。</p><ul><li><strong>主内存</strong> ：所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)</li><li><strong>本地内存</strong> ：每个线程都有一个私有的本地内存来存储共享变量的副本，并且，每个线程只能访问自己的本地内存，无法访问其他线程的本地内存。本地内存是 JMM 抽象出来的一个概念，存储了主内存中的共享变量副本。</li></ul><p>从上图来看，线程 1 与线程 2 之间如果要进行通信的话，必须要经历下面 2 个步骤：</p><ol><li>线程 1 把本地内存中修改过的共享变量副本的值同步到主内存中去。</li><li>线程 2 到主存中读取对应的共享变量的值。</li></ol><p><img src="1.png"></p><h1 id="Java内存区域（JVM）与Java内存模型-JMM-的区别"><a href="#Java内存区域（JVM）与Java内存模型-JMM-的区别" class="headerlink" title="Java内存区域（JVM）与Java内存模型(JMM)的区别"></a>Java内存区域（JVM）与Java内存模型(JMM)的区别</h1><ul><li>JVM 内存结构和 Java 虚拟机的运行时区域相关，定义了 JVM 在运行时如何分区存储程序数据，就比如说堆主要用于存放对象实例。</li><li>Java 内存模型和 Java 的并发编程相关，抽象了线程和主内存之间的关系就比如说线程之间的共享变量必须存储在主内存中，规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。</li></ul><p>​happens-before 规定了对共享变量的写操作对其它线程的读操作可见，它是可见性与有序性的一套规则总结，抛开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见。</p><h4 id="线程解锁-m-之前对变量的写，对于接下来对-m-加锁的其它线程对该变量的读可见"><a href="#线程解锁-m-之前对变量的写，对于接下来对-m-加锁的其它线程对该变量的读可见" class="headerlink" title="线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见"></a>线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见</h4><p>synchronized 实现可见性的原理</p><ul><li>线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值</li><li>线程解锁前，必须把共享变量的最新值刷新到主内存中</li></ul><h4 id="线程对-volatile-变量的写，对接下来其它线程对该变量的读可见"><a href="#线程对-volatile-变量的写，对接下来其它线程对该变量的读可见" class="headerlink" title="线程对 volatile 变量的写，对接下来其它线程对该变量的读可见"></a>线程对 volatile 变量的写，对接下来其它线程对该变量的读可见</h4><p>volatile 实现可见性的原理是内存屏障，Memory Barrier（Memory Fence）</p><ul><li>对 volatile 变量执行写指令后会加入写屏障，写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</li><li>对 volatile 变量执行读指令前会加入读屏障，而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据</li></ul><h4 id="线程-start-前对变量的写，对该线程开始后对该变量的读可见"><a href="#线程-start-前对变量的写，对该线程开始后对该变量的读可见" class="headerlink" title="线程 start 前对变量的写，对该线程开始后对该变量的读可见"></a>线程 start 前对变量的写，对该线程开始后对该变量的读可见</h4><p>新建线程刚开始会从主存中读取数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> x; </span><br><span class="line">x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; </span><br><span class="line">    System.out.println(x);  <span class="comment">// 输出 10</span></span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure><h4 id="线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用-t1-isAlive-或-t1-join-等待它结束）"><a href="#线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用-t1-isAlive-或-t1-join-等待它结束）" class="headerlink" title="线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待它结束）"></a>线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待它结束）</h4><p>得知 t1 结束会主动从主存读取数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; </span><br><span class="line">    x = <span class="number">10</span>;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>); </span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line">t1.join();  <span class="comment">//等待t1执行完成</span></span><br><span class="line">System.out.println(x); <span class="comment">// 输出 10</span></span><br></pre></td></tr></table></figure><h4 id="线程-t1-打断-t2（interrupt）前对变量的写，对于其他线程得知-t2-被打断后对变量的读可见（通过-t2-interrupted-或-t2-isInterrupted）"><a href="#线程-t1-打断-t2（interrupt）前对变量的写，对于其他线程得知-t2-被打断后对变量的读可见（通过-t2-interrupted-或-t2-isInterrupted）" class="headerlink" title="线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过 t2.interrupted 或 t2.isInterrupted）"></a>线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过 t2.interrupted 或 t2.isInterrupted）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; </span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span>(Thread.currentThread().isInterrupted()) &#123; </span><br><span class="line">                System.out.println(x); <span class="comment">// 输出 10</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>); </span><br><span class="line">    t2.start();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; </span><br><span class="line">        sleep(<span class="number">1</span>); </span><br><span class="line">        x = <span class="number">10</span>; </span><br><span class="line">        t2.interrupt();</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!t2.isInterrupted()) &#123;</span><br><span class="line">        Thread.yield();</span><br><span class="line">    &#125; </span><br><span class="line">    System.out.println(x); <span class="comment">// 输出 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对变量默认值（0，false，null）的写，对其它线程对该变量的读可见"><a href="#对变量默认值（0，false，null）的写，对其它线程对该变量的读可见" class="headerlink" title="对变量默认值（0，false，null）的写，对其它线程对该变量的读可见"></a>对变量默认值（0，false，null）的写，对其它线程对该变量的读可见</h4><h4 id="具有传递性，如果-x-hb-gt-y-并且-y-hb-gt-z-那么有-x-hb-gt-z-，配合-volatile-的防指令重排，有下面的例子"><a href="#具有传递性，如果-x-hb-gt-y-并且-y-hb-gt-z-那么有-x-hb-gt-z-，配合-volatile-的防指令重排，有下面的例子" class="headerlink" title="具有传递性，如果 x hb-&gt; y 并且 y hb-&gt; z 那么有 x hb-&gt; z ，配合 volatile 的防指令重排，有下面的例子"></a>具有传递性，如果 x hb-&gt; y 并且 y hb-&gt; z 那么有 x hb-&gt; z ，配合 volatile 的防指令重排，有下面的例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> x; </span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; </span><br><span class="line">    y = <span class="number">10</span>; </span><br><span class="line">    x = <span class="number">20</span>; <span class="comment">// 因为这里加了写屏障</span></span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; </span><br><span class="line">    <span class="comment">// x=20 对 t2 可见, 同时 y=10 也对 t2 可见 </span></span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JMM-Java内存模型 </tag>
            
            <tag> happen-before </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发-CAS与volatile原理</title>
      <link href="/2022/09/08/%E5%B9%B6%E5%8F%91-CAS%E4%B8%8Evolatile%E5%8E%9F%E7%90%86/"/>
      <url>/2022/09/08/%E5%B9%B6%E5%8F%91-CAS%E4%B8%8Evolatile%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><h2 id="并发编程中的三个特性"><a href="#并发编程中的三个特性" class="headerlink" title="并发编程中的三个特性"></a>并发编程中的三个特性</h2><ul><li>原子性： 一个或多个操作为一个整体，要么全部执行要么都不执行，synchronized 可以保证代码块的原子性和共享变量的可见性</li><li>可见性： 当多个线程共享同一变量时，若其中一个线程对该共享变量进行了修改，那么该修改对其他线程是立即可见的</li><li>有序性： 程序执行的顺序与代码的先后顺序相同</li></ul><span id="more"></span><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>​可见性是指当一个线程修改了共享变量后，其他线程能够立即得知这个修改。通过之前对synchronzed内存语义进行了分析，当线程获取锁时会从主内存中获取共享变量的最新值，释放锁的时候会将共享变量同步到主内存中。从而，<strong>synchronized具有可见性</strong>，volatile会通过在指令中添加<strong>lock指令</strong>，以实现内存可见性。因此, <strong>volatile具有可见性</strong></p><h2 id="volatile保证数据的可见性"><a href="#volatile保证数据的可见性" class="headerlink" title="volatile保证数据的可见性"></a>volatile保证数据的可见性</h2><p>​当一个共享变量被volatile修饰之后，这个变量就具备了两层语义：</p><ol><li><p><strong>保证共享变量的可见性：保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</strong></p></li><li><p><strong>防止局部指令重排序：happens-before规则中的volatile变量规则规定了一个线程先去写一个volatile变量，然后一个线程去读这个变量，那么这个写操作的结果一定对读的这个线程可见。</strong></p></li></ol><p></p><p>​在 Java 中，<code>volatile</code> 关键字可以保证变量的可见性，如果我们将变量声明为 <strong><code>volatile</code></strong> ，这就指示 JVM这个变量是共享且不稳定的，每次使用它都到主存中进行读取。但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</p><p>​<strong>在 Java 中，<code>volatile</code> 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。</strong> 如果我们将变量声明为 <strong><code>volatile</code></strong> ，在对这个变量进行读写操作的时候，会通过插入特定的 <strong>内存屏障</strong> 的方式来禁止指令重排序。</p><p>​volatile放置指令重排序的经典应用：<strong>双重校验锁实现对象单例（线程安全）</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123; <span class="comment">//这里会因为指令重排序导致没初始化之前就分配了内存导致这里不为空。</span></span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<code>uniqueInstance</code> 采用 <code>volatile</code> 关键字修饰也是很有必要的， <code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p><ol><li>为 <code>uniqueInstance</code> 分配内存空间</li><li>初始化 <code>uniqueInstance</code></li><li>将 <code>uniqueInstance</code> 指向分配的内存地址</li></ol><p>​但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致<strong>一个线程获得还没有初始化的实例</strong>。例如，线程 T1 执行了 1 和 3，此时 T2 调用 <code>getUniqueInstance</code>() 后发现 <code>uniqueInstance</code> 不为空，因此返回 <code>uniqueInstance</code>，但此时 <code>uniqueInstance</code> 还未被初始化。  </p><h2 id="volatile不能保证数据的原子性"><a href="#volatile不能保证数据的原子性" class="headerlink" title="volatile不能保证数据的原子性"></a>volatile不能保证数据的原子性</h2><p><strong><code>volatile</code> 关键字能保证变量的可见性，但不能保证对变量的操作是原子性的。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatoleAtomicityDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">inc</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="type">VolatoleAtomicityDemo</span> <span class="variable">volatoleAtomicityDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VolatoleAtomicityDemo</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">500</span>; j++) &#123;</span><br><span class="line">                    volatoleAtomicityDemo.increase();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 等待1.5秒，保证上面程序执行完成</span></span><br><span class="line">        Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">        System.out.println(inc); <span class="comment">//这里输出结果会出现问题：运行结果小于2500</span></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<code>inc++</code> 其实是一个复合操作，包括三步：</p><ol><li>读取 inc 的值。</li><li>对 inc 加 1。</li><li>将 inc 的值写回内存。</li></ol><p><code>volatile</code> 是无法保证这三个操作是具有原子性的，有可能导致下面这种情况出现：</p><ol><li>线程 1 对 <code>inc</code> 进行读取操作之后，还未对其进行修改。线程 2 又读取了 <code>inc</code>的值并对其进行修改（+1），再将<code>inc</code> 的值写回内存。</li><li>线程 2 操作完毕后，线程 1 对 <code>inc</code>的值进行修改（+1），再将<code>inc</code> 的值写回内存。</li></ol><p>​这也就导致两个线程分别对 <code>inc</code> 进行了一次自增操作后，<code>inc</code> 实际上只增加了 1。</p><p>​利用 <code>synchronized</code> 、<code>Lock</code>或者<code>AtomicInteger</code>可以保证操作执行的原子性。</p><p>使用 <code>synchronized</code> 改进：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">    inc++;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>使用 <code>AtomicInteger</code> 改进：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">AtomicInteger</span> <span class="variable">inc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">    inc.getAndIncrement();</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>使用 <code>ReentrantLock</code> 改进：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="volatile底层原理"><a href="#volatile底层原理" class="headerlink" title="volatile底层原理"></a>volatile底层原理</h2><h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><p>​CAS 的含义就是 比较并交换（<code>Compare-and-Swap</code>）CAS指令需要有三个操作数，分别是内存位置（在Java中可以简单地理解为变量的<strong>内存地址</strong>，用 V 表示）、旧的预期值（用 A 表示）和准备设置的<strong>新值</strong>（用 B 表示）。CAS 指令执行时，<strong>当且仅当 V 符合 A 时，处理器才会用 B 更新 V 的值</strong>，否则它就不执行更新。但是，不管是否更新了 V 的值，都会返回 V 的旧值，上述的处理过程是一个原子操作，执行期间不会被其他线程中断。</p><p>Unsafe 类中 cas 方法的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 四个参数，分别为：操作的变量所属的对象引用，内存偏移量（通过这个变量地址获取 V），旧的预期值 A， 新值 B</span><br><span class="line">public final native boolean compareAndSwapObject(Object var1, long var2, Object var4, Object var5);</span><br><span class="line"></span><br><span class="line">public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);</span><br><span class="line"></span><br><span class="line">public final native boolean compareAndSwapLong(Object var1, long var2, long var4, long var6);</span><br></pre></td></tr></table></figure><h2 id="CAS-的特点"><a href="#CAS-的特点" class="headerlink" title="CAS 的特点"></a>CAS 的特点</h2><p>因为 CAS 往往都是搭配 while循环使用，会一直占用CPU，所以适用于线程数少、多核 CPU 的场景下。</p><ul><li>CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。</li><li>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</li><li>CAS 体现的是无锁并发、无阻塞并发，因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一， 但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响。</li></ul><h2 id="为什么无锁效率高"><a href="#为什么无锁效率高" class="headerlink" title="为什么无锁效率高"></a>为什么无锁效率高</h2><ul><li>无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，而 synchronized 会让线程在没有获得锁的时候，发生上下文切换，进入阻塞。虽然无锁不会进入阻塞，但由于没有分到时间片，仍然会进入到可运行状态，还是会导致上下文切换。</li></ul><h2 id="CAS-搭配-volatile的实现"><a href="#CAS-搭配-volatile的实现" class="headerlink" title="CAS 搭配 volatile的实现"></a>CAS 搭配 volatile的实现</h2><p>​CAS 必须借助 volatile 才能读取到共享变量的最新值来实现比较并交换的效果。</p><h2 id="CAS-的问题（ABA）"><a href="#CAS-的问题（ABA）" class="headerlink" title="CAS 的问题（ABA）"></a>CAS 的问题（ABA）</h2><p>​且CAS从语义上来说并不是真正完美的，它存在一个逻辑漏洞：如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然为 A 值，那就能说明它的值没有被其他线程改变过了吗？这是不能的，因为如果在这段期间它的值曾经被改成 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。这个漏洞称为 CAS 操作的“ABA问题”。</p><h2 id="如何解决ABA问题"><a href="#如何解决ABA问题" class="headerlink" title="如何解决ABA问题"></a>如何解决ABA问题</h2><p>AtomicMarkableReference 和 AtomicStampedReference 可以同来解决 ABA 问题。</p><ul><li><code>AtomicMarkableReference</code> 可以通过控制版本是否更改标记（<strong>boolean 值</strong>）来保证 CAS 的正确性；</li><li><code>AtomicStampedReference</code> 可以通过控制变量值的版本号（<strong>int 值</strong>）来保证 CAS 的正确性。</li></ul><p>不过目前来说这两个类处于相当鸡肋的位置，大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更为高效。</p>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CAS </tag>
            
            <tag> volatile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程安全问题</title>
      <link href="/2022/09/07/%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
      <url>/2022/09/07/%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h1><h2 id="临界区（Critical-Section）"><a href="#临界区（Critical-Section）" class="headerlink" title="临界区（Critical Section）"></a>临界区（Critical Section）</h2><ul><li>一个程序运行多个线程本身是没有问题，问题出在多个线程访问共享资源。</li><li>多个线程读共享资源其实也没有问题，在多个线程对共享资源读写操作时发生<strong>指令交错</strong>，就会出现问题。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> </span><br><span class="line"><span class="comment">// 临界区 </span></span><br><span class="line">&#123;</span><br><span class="line">    counter++; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> </span><br><span class="line"><span class="comment">// 临界区 </span></span><br><span class="line">&#123;</span><br><span class="line">    counter--; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="竞态条件（Race-Condition）"><a href="#竞态条件（Race-Condition）" class="headerlink" title="竞态条件（Race Condition）"></a>竞态条件（Race Condition）</h2><p>多个线程在临界区内执行，由于代码的<strong>执行序列不同</strong>而导致结果无法预测，称之为发生了<strong>竞态条件</strong>。最常见的竞态条件类型是“先检查后执行（Check-Then-Act）”操作，即通过一个可能失效的观测结果来决定下一步的动作。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>为了避免临界区的竞态条件发生，有多种手段可以达到目的。</p><ol><li>互斥（阻塞）同步：synchronized，Lock – 悲观锁</li><li>非阻塞同步：基于 CAS 配合 volatile 操作（原子变量） – 乐观锁</li></ol><p>接下来先介绍阻塞式的解决方案：synchronized，来解决上述问题，即俗称的<strong>对象锁</strong>，它采用互斥的方式让同一时刻至多只有一个线程能持有<strong>对象锁</strong>，其它线程再想获取这个<strong>对象锁</strong>时就会阻塞住。synchronized 实际是用<strong>对象锁</strong>保证了<strong>临界区内代码的原子性</strong>，临界区内的代码对外是不可分割的，不会被线程切换所打断，这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronized(对象) // 线程1， 线程2(blocked) </span><br><span class="line">&#123;</span><br><span class="line">    临界区 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>synchronized 关键字经过 Javac 编译之后，会在同步块的前后分别形成 monitorenter 和 monitorexit 这两个字节码指令。这两个字节码指令都需要一个 reference 类型的参数来指明要锁定和解锁的对象。<strong>方法上的 synchronized 相当于对 this 加锁，静态方法上的相当于对当前类对象 .class 加锁。</strong></p><h2 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h2><ul><li>其实 synchronized 是基于<strong>悲观锁</strong>的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会；</li><li>而基于 CAS 的操作都是基于<strong>乐观锁</strong>的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系， 我吃亏点再重试呗。</li></ul><h1 id="变量的线程安全分析"><a href="#变量的线程安全分析" class="headerlink" title="变量的线程安全分析"></a>变量的线程安全分析</h1><h2 id="成员变量和静态变量是否线程安全"><a href="#成员变量和静态变量是否线程安全" class="headerlink" title="成员变量和静态变量是否线程安全"></a>成员变量和静态变量是否线程安全</h2><ul><li>如果它们没有共享，则线程安全</li><li>如果它们被共享了，根据它们的状态是否能够改变，又分两种情况<ul><li>如果只有读操作，则线程安全</li><li>如果有读写操作，则这段代码是临界区，需要考虑线程安全</li></ul></li></ul><h2 id="局部变量是否线程安全"><a href="#局部变量是否线程安全" class="headerlink" title="局部变量是否线程安全"></a>局部变量是否线程安全</h2><ul><li>局部变量是线程安全的</li><li>但局部变量引用的对象则未必<ul><li>如果该对象没有逃离方法的作用访问，它是线程安全的</li><li>如果该对象逃离方法的作用范围，需要考虑线程安全</li></ul></li></ul><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoStackLocalVariable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(<span class="number">4</span>);</span><br><span class="line">        sb.append(<span class="number">5</span>);</span><br><span class="line">        sb.append(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt; m2(sb)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 局部变量 sb 是线程安全的，因为是线程私有的，没有逃离方法的作用范围</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(<span class="number">1</span>);</span><br><span class="line">        sb.append(<span class="number">2</span>);</span><br><span class="line">        sb.append(<span class="number">3</span>);</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 局部变量 sb 不是线程安全的，因为是作为参数引用传递进来的，所以其他线程可能访问并同时修改它，例如主程序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">(StringBuilder sb)</span> &#123;</span><br><span class="line">        sb.append(<span class="number">1</span>);</span><br><span class="line">        sb.append(<span class="number">2</span>);</span><br><span class="line">        sb.append(<span class="number">3</span>);</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 局部变量 sb 不是线程安全的，因为是作为引用返回出去了（逃离了方法的作用范围），所以其他线程可能访问并同时修改它</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title function_">m3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(<span class="number">1</span>);</span><br><span class="line">        sb.append(<span class="number">2</span>);</span><br><span class="line">        sb.append(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThreadSafe</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadUnsafe</span> <span class="variable">testUnsafe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadUnsafe</span>();</span><br><span class="line">        <span class="type">ThreadSafe</span> <span class="variable">testSafe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadSafe</span>();</span><br><span class="line">        <span class="type">ThreadSafeSubClass</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadSafeSubClass</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="comment">// 1. 存在多线程问题，因为多个线程访问的是堆中的同一个 list 对象</span></span><br><span class="line"><span class="comment">//                testUnsafe.method1(200); </span></span><br><span class="line">                <span class="comment">// 2. 将成员变量修改成局部变量，线程安全，因为每个线程都会在堆中新建一个 list 对象，互不干扰</span></span><br><span class="line"><span class="comment">//                testSafe.method1(200); </span></span><br><span class="line">                <span class="comment">// 3. 测试子类，子类中又新开了一个线程对同一局部变量进行读写，存在线程安全问题</span></span><br><span class="line">                test.method1(<span class="number">200</span>);       </span><br><span class="line">            &#125;, <span class="string">&quot;Thread&quot;</span> + (i+<span class="number">1</span>)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadUnsafe</span> &#123;</span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(<span class="type">int</span> loopNumber)</span> &#123;       <span class="comment">// 循环调用 method 2、3，访问共享对象 list</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            method2();</span><br><span class="line">            method3();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span> &#123;</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 list 修改成局部变量，并且局部变量不可能暴露给外部，因为 method 2，3都是私有的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafe</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(<span class="type">int</span> loopNumber)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            method2(list);</span><br><span class="line">            method3(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要作为参数传入</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(ArrayList&lt;String&gt; list)</span> &#123;</span><br><span class="line">        list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">(ArrayList&lt;String&gt; list)</span> &#123;</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 method3 是 public 的，会不会有线程安全问题？就看局部变量 method1 中的 list 是否能暴露给外部。假如有个子类继承了 ThreadSafe，并重写了 method3，并且在 method3 里又开启了一个线程，在子类重写的方法中对局部变量进行了读写操作，这个就存在问题了，因为我们无法控制子类的行为，将局部变量暴露给子类后，子类可能又暴露给其他线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子类继承了 ThreadSafe，并重写了 method3，在 method3 里又开启了一个线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafeSubClass</span> <span class="keyword">extends</span> <span class="title class_">ThreadSafe</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">(ArrayList&lt;String&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            list.remove(<span class="number">0</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以将method2、3 修改成private，将method1 修改成final 的(<strong>父类中的private方法不能被重写)，只有public和protected方法才能被重写</strong>，从这个例子可以看出 private 或 final 提供<strong>安全</strong>的意义所在，请体会开闭原则中的<strong>闭</strong>。</p><h2 id="常见线程安全类"><a href="#常见线程安全类" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h2><ul><li>String</li><li>Integer</li><li>StringBuffer</li><li>Random</li><li>Vector</li><li>Hashtable</li><li>java.util.concurrent 包下的类</li></ul><p>这里说它们是线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的。它们的每个方法是原子的，但注意它们<strong>多个方法的组合不是原子的</strong>。</p><p>String、Integer 等都是不可变类，因为其内部的状态不可以改变，因此它们的方法都是线程安全的。</p>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程安全问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>synchronized原理</title>
      <link href="/2022/09/07/%E5%B9%B6%E5%8F%91-synchronized%E5%8E%9F%E7%90%86/"/>
      <url>/2022/09/07/%E5%B9%B6%E5%8F%91-synchronized%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>在 Java 早期版本中，<code>synchronized</code> 属于 <strong>重量级锁</strong>，效率低下。 因为监视器锁（monitor）是依赖于底层的操作系统的 <code>Mutex Lock</code> 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。</p><p>在 Java 6 之后进行了优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p><span id="more"></span><h1 id="synchronized的使用"><a href="#synchronized的使用" class="headerlink" title="synchronized的使用"></a>synchronized的使用</h1><p>synchronized 关键字最主要的三种使用方式：</p><ol><li>修饰实例方法</li><li>修饰静态方法</li><li>修饰代码块</li></ol><h3 id="1、修饰实例方法-（锁当前对象实例）"><a href="#1、修饰实例方法-（锁当前对象实例）" class="headerlink" title="1、修饰实例方法 （锁当前对象实例）"></a><strong>1、修饰实例方法</strong> （锁当前对象实例）</h3><p>给当前对象实例加锁，进入同步代码前要获得 <strong>当前对象实例的锁</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、修饰静态方法-（锁当前类）"><a href="#2、修饰静态方法-（锁当前类）" class="headerlink" title="2、修饰静态方法 （锁当前类）"></a><strong>2、修饰静态方法</strong> （锁当前类）</h3><p>给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 <strong>当前 class 的锁</strong>。</p><p>这是因为静态成员不属于任何一个实例对象，归整个类所有，不依赖于类的特定实例，被类的所有实例共享。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态 <code>synchronized</code> 方法和非静态 <code>synchronized</code> 方法之间的调用互斥么？不互斥！如果一个线程 A 调用一个实例对象的非静态 <code>synchronized</code> 方法，而线程 B 需要调用这个实例对象所属类的静态 <code>synchronized</code> 方法，是允许的，不会发生互斥现象，因为访问静态 <code>synchronized</code> 方法占用的锁是当前类的锁，而访问非静态 <code>synchronized</code> 方法占用的锁是当前实例对象锁。</p><h3 id="3、修饰代码块-（锁指定对象-x2F-类）"><a href="#3、修饰代码块-（锁指定对象-x2F-类）" class="headerlink" title="3、修饰代码块 （锁指定对象&#x2F;类）"></a><strong>3、修饰代码块</strong> （锁指定对象&#x2F;类）</h3><p>对括号里指定的对象&#x2F;类加锁：</p><ul><li><code>synchronized(object)</code> 表示进入同步代码库前要获得 <strong>给定对象的锁</strong>。</li><li><code>synchronized(类.class)</code> 表示进入同步代码前要获得 <strong>给定 Class 的锁</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结：</strong></h3><ul><li><code>synchronized</code> 关键字加到 <code>static</code> 静态方法和 <code>synchronized(class)</code> 代码块上都是是给 Class 类上锁；</li><li><code>synchronized</code> 关键字加到实例方法上是给对象实例上锁；</li><li>尽量不要使用 <code>synchronized(String a)</code> 因为 JVM 中，字符串常量池具有缓存功能。</li></ul><h1 id="synchronized-原理"><a href="#synchronized-原理" class="headerlink" title="synchronized 原理"></a>synchronized 原理</h1><h2 id="synchronized同步语句块原理"><a href="#synchronized同步语句块原理" class="headerlink" title="synchronized同步语句块原理"></a>synchronized同步语句块原理</h2><p>​synchronized<code>同步语句块的实现使用的是</code>monitorenter<code>和</code>monitorexit<code>指令，其中</code>monitorenter<code> 指令指向同步代码块的开始位置，</code>monitorexit<code>指令则指明同步代码块的结束位置。 当执行</code>monitorenter<code>指令时，线程试图获取锁也就是获取 **对象监视器</code>monitor&#96;** 的持有权。</p><p>​在执行<code>monitorenter</code>时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。</p><p>​对象锁的的拥有者线程才可以执行 <code>monitorexit</code> 指令来释放锁。在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。</p><p>如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p><h2 id="Monitor-原理"><a href="#Monitor-原理" class="headerlink" title="Monitor 原理"></a>Monitor 原理</h2><p><strong>32位虚拟机对象头Mark Word：</strong></p><p><img src="1.jpg"></p><p>​Monitor 被翻译为监视器或<strong>管程</strong>，每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（注意，必须是重量级）之后，该对象头的 Mark Word 就被设置为指向 Monitor 对象的指针 + “10” 重量级锁标志。</p><p>Monitor 结构如下：</p><p><img src="2.png"></p><ul><li>刚开始的时候 Monitor 中 Owner 为 null；</li><li>当 Thread-2 执行 synchronized(obj) 就会将obj 关联的 Monitor 的所有者 Owner 置为 Thread-2，Monitor 中只能有一个 Owner ；</li><li>在 Thread-2 持有锁的过程中，如果 Thread-3，Thread-4，Thread-5 也来执行 synchronized(obj)，就会进入 EntryList 陷入 BLOCKED 状态；</li><li>Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁（notifyAll），竞争时是非公平的；</li><li>图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程，后面讲 wait-notify 时会分析。</li></ul><p><strong><code>wait/notify</code>等方法也依赖于<code>monitor</code>对象，这就是为什么只有在同步的块或者方法中才能调用<code>wait/notify</code>等方法</strong>，否则会抛出<code>java.lang.IllegalMonitorStateException</code>的异常的原因。</p><h2 id="synchronized-同步方法原理"><a href="#synchronized-同步方法原理" class="headerlink" title="synchronized 同步方法原理"></a>synchronized 同步方法原理</h2><p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。<br>如果是实例方法，JVM 会尝试获取实例对象的锁。如果是静态方法，JVM 会尝试获取当前 class 的锁。</p><h1 id="synchronized-和-volatile-的区别"><a href="#synchronized-和-volatile-的区别" class="headerlink" title="synchronized 和 volatile 的区别"></a>synchronized 和 volatile 的区别</h1><p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在！</p><ul><li><code>volatile</code> 关键字是线程同步的轻量级实现，所以 <code>volatile</code>性能肯定比<code>synchronized</code>关键字要好 。但是 <code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块 。</li><li><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</li><li><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</li></ul><h1 id="synchronized-和-ReentrantLock-的区别"><a href="#synchronized-和-ReentrantLock-的区别" class="headerlink" title="synchronized 和 ReentrantLock 的区别"></a>synchronized 和 ReentrantLock 的区别</h1><h2 id="两者都是可重入锁"><a href="#两者都是可重入锁" class="headerlink" title="两者都是可重入锁"></a>两者都是可重入锁</h2><p><strong>“可重入锁”</strong> 指的是自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。</p><h2 id="synchronized-依赖于-JVM-而-ReentrantLock-依赖于-API"><a href="#synchronized-依赖于-JVM-而-ReentrantLock-依赖于-API" class="headerlink" title="synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API"></a>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</h2><p><code>synchronized</code> 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 <code>synchronized</code> 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。<code>ReentrantLock</code> 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try&#x2F;finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p><h2 id="ReentrantLock-比-synchronized-增加了一些高级功能"><a href="#ReentrantLock-比-synchronized-增加了一些高级功能" class="headerlink" title="ReentrantLock 比 synchronized 增加了一些高级功能"></a>ReentrantLock 比 synchronized 增加了一些高级功能</h2><p>相比<code>synchronized</code>，<code>ReentrantLock</code>增加了一些高级功能。主要来说主要有三点：</p><ul><li><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li><li><strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li><li><strong>可实现选择性通知（锁可以绑定多个条件）</strong>: <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>&#x2F;<code>notifyAll()</code>方法相结合可以实现等待&#x2F;通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>lock.newCondition()</code>方法。</li></ul><blockquote><p><code>Condition</code>是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个<code>Lock</code>对象中可以创建多个<code>Condition</code>实例（即对象监视器），<strong>线程对象可以注册在指定的<code>Condition</code>中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用<code>notify()/notifyAll()</code>方法进行通知时，被通知的线程是由 JVM 选择的，用<code>ReentrantLock</code>类结合<code>Condition</code>实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是 Condition 接口默认提供的。而<code>synchronized</code>关键字就相当于整个 Lock 对象中只有一个<code>Condition</code>实例，所有的线程都注册在它一个身上。如果执行<code>notifyAll()</code>方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而<code>Condition</code>实例的<code>signalAll()</code>方法 只会唤醒注册在该<code>Condition</code>实例中的所有等待线程。</p></blockquote><h2 id="轻量级锁与锁重入"><a href="#轻量级锁与锁重入" class="headerlink" title="轻量级锁与锁重入"></a>轻量级锁与锁重入</h2><h3 id="轻量级锁加锁流程"><a href="#轻量级锁加锁流程" class="headerlink" title="轻量级锁加锁流程"></a>轻量级锁加锁流程</h3><p>一旦对象被 synchronized 锁住后，假如后续多个线程执行到 synchronized 处，<strong>当还没有线程对对象加锁时，此时第一个尝试加锁的线程会优先使用轻量级锁</strong>，第一个线程会先在栈中新建一个锁记录对象（Lock Record），包含：<strong>锁记录的地址和指向锁对象的引用</strong>。此时会进行 <strong>cas 操作</strong>，将锁记录对象地址与被锁住的对象的 markword 互换，第一次肯定会 cas 成功，所以对象头中的 markword 有了指向锁记录的地址和状态 00，表示由该线程给对象加锁，并且是轻量级锁，注意此时并没有关联 Monitor。当然如果这时同一线程中再次对该对象进行加锁（同一线程中有多个针对同一对象的 synchronized 方法或代码块），会 cas 失败（因为此时对象头的 Mark Word 存的是锁记录的地址，并且标志位为 00），这是因为是同一线程，进入<strong>锁重入机制</strong>，即再添加一条锁记录作为重入的计数，并且这个锁记录的地址为 null。</p><pre><code>    但如果是其他的线程在此时对该对象尝试进行加锁，也会 cas 失败，并进入**锁膨胀**阶段，**膨胀成重量级锁**，此时 Monitor 就登场了，下面介绍。</code></pre><ul><li>所以cas 失败，有两种情况<ul><li>如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数；</li><li>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程。</li></ul></li></ul><h3 id="轻量级锁解锁流程"><a href="#轻量级锁解锁流程" class="headerlink" title="轻量级锁解锁流程"></a>轻量级锁解锁流程</h3><ul><li>当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一</li><li>当退出 synchronized代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象头<ul><li>成功，则解锁成功</li><li>失败，说明轻量级锁进行了锁膨胀已经升级为重量级锁，进入重量级锁解锁流程。</li></ul></li></ul><h2 id="轻量级锁到重量级锁（锁膨胀）"><a href="#轻量级锁到重量级锁（锁膨胀）" class="headerlink" title="轻量级锁到重量级锁（锁膨胀）"></a>轻量级锁到重量级锁（锁膨胀）</h2><h4 id="重量级锁加锁流程"><a href="#重量级锁加锁流程" class="headerlink" title="重量级锁加锁流程"></a>重量级锁加锁流程</h4><p>如果在尝试加轻量级锁的过程中，cas操作无法成功，这时是第二种情况即有其它线程已经为此对象加上了轻量级锁（有竞争），这时会<strong>先进行自旋</strong>，即竞争的线程先进行自旋，<strong>等自旋多次之后仍然无法cas成功时才会进行锁膨胀，将轻量级锁变为重量级锁。</strong></p><p>具体流程是：尝试在 jvm 里找到一个 Monitor 对象与 obj 关联，并将 obj 对象头 MarkWord 的前 30 位<strong>指向 Monitor 对象</strong>，让 Monitor 的 owner 指向当前持有锁的线程，然后 markword 状态标志位也会改变成相应的值（10），现在这个加入的线程以及后来的线程执行到 synchronized(obj) 时先检查锁住的对象关联的 Monitor 有没有主人（Owner），如果有则只能进入 Moniter 对象的 Entrylist 列表等待（等待线程为 BLOCKED 状态），等待持锁线程释放锁。</p><h4 id="重量级锁解锁流程"><a href="#重量级锁解锁流程" class="headerlink" title="重量级锁解锁流程"></a>重量级锁解锁流程</h4><p>当前锁住对象的线程退出同步块解锁时，首先使用 cas 将 Mark Word 的值恢复给对象头，这时会失败（轻量级解锁流程），进入重量级解锁流程。即按照被锁对象中存储的 Monitor 地址找到 Monitor 对象，将当前锁记录中存储的 MarkWord 交给 Monitor，设置 owner 为 null，唤醒 EntryList 中 BLOCKED 的线程。</p><h2 id="重量锁的自旋优化"><a href="#重量锁的自旋优化" class="headerlink" title="重量锁的自旋优化"></a>重量锁的自旋优化</h2><p>重量级锁竞争的时候，也可以使用自旋来进行优化（所有自旋优化会出现在轻量级锁升级成重量级锁的过程中，也会出现在重量级锁的竞争过程中），如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞，因为挂起线程和恢复线程的操作都需要转入内核态完成，会比较费时。</p><p>但要注意：</p><ul><li>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。</li><li>在 Java 6 之后自旋锁是自适应的并且强制开启，比如线程刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之就少自旋甚至不自旋，总之比较智能。</li></ul><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 markword 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有。</p><blockquote><p>如果说轻量级锁是在无竞争的情况下使用 CAS 操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连 CAS 操作都不去做了。注意它们两个的前提都是无竞争。</p></blockquote><h3 id="偏向状态"><a href="#偏向状态" class="headerlink" title="偏向状态"></a>偏向状态</h3><p>一个对象创建时：</p><ul><li>如果开启了偏向锁（默认开启），那么对象创建后，markword 值为 0x05 即最后 3 位为 101，这时它的 thread ID、epoch、age 都为 0</li><li>偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 <code>X:BiasedLockingStartupDelay=0</code> 来禁用延迟</li><li>如果没有开启偏向锁，那么对象创建后，markword 值为 0x01 即最后 3 位为 001，这时它的 hashcode、 age 都为 0，第一次用到 hashcode 时才会赋值</li></ul><p>测试:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">// 1. 测试偏向锁的延时</span><br><span class="line">    private static void test1() &#123;</span><br><span class="line">        Dog d = new Dog();</span><br><span class="line">        log.debug(ClassLayout.parseInstance(d).toPrintable());</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(4000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(ClassLayout.parseInstance(new Dog()).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">    /*小端格式：低字节在低地址</span><br><span class="line">    // 刚开始它的 thread、epoch、age 都为 0</span><br><span class="line">     OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">          0     4        (object header)                           01 00 00 00 (00000001【001】 00000000 00000000 00000000) (1)</span><br><span class="line">          4     4        (object header)                           00 00 00 00 (00000000       00000000 00000000 00000000) (0)</span><br><span class="line"></span><br><span class="line">    // 存在延迟</span><br><span class="line"></span><br><span class="line">     OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">          0     4        (object header)                           05 00 00 00 (00000101【101】 00000000 00000000 00000000) (5)</span><br><span class="line">          4     4        (object header)                           00 00 00 00 (00000000       00000000 00000000 00000000) (0)</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    // 2. 测试偏向锁</span><br><span class="line">    // 2.1 -XX:BiasedLockingStartupDelay=0 // 关闭延时</span><br><span class="line">    // 2.2 -XX:-UseBiasedLocking           // 禁用偏向锁</span><br><span class="line">    private static void test2() &#123;</span><br><span class="line">        Dog d = new Dog();</span><br><span class="line">        ClassLayout classLayout = ClassLayout.parseInstance(d);</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">                log.debug(&quot;synchronized 前&quot;);</span><br><span class="line">                System.out.println(classLayout.toPrintable());</span><br><span class="line"></span><br><span class="line">                synchronized (d) &#123;</span><br><span class="line">                    log.debug(&quot;synchronized 中&quot;);</span><br><span class="line">                    System.out.println(classLayout.toPrintable());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                log.debug(&quot;synchronized 后&quot;);</span><br><span class="line">                System.out.println(classLayout.toPrintable());</span><br><span class="line">            &#125;, &quot;t1&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    /*</span><br><span class="line">    2.1 输出：</span><br><span class="line">    21:01:54.538 c.TestBiased [t1] - synchronized 前</span><br><span class="line">     OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">          0     4        (object header)                           05 00 00 00 (00000101 00000000 00000000 00000000) (5)</span><br><span class="line">          4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line"></span><br><span class="line">    21:01:54.546 c.TestBiased [t1] - synchronized 中</span><br><span class="line">     OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">          0     4        (object header)                           05 b0 90 b8 (00000101 10110000 10010000 10111000) (-1198477307)</span><br><span class="line">          4     4        (object header)                           03 02 00 00 (00000011 00000010 00000000 00000000) (515)</span><br><span class="line"></span><br><span class="line">    21:01:54.548 c.TestBiased [t1] - synchronized 后</span><br><span class="line">     OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">          0     4        (object header)                           05 b0 90 b8 (00000101 10110000 10010000 10111000) (-1198477307)</span><br><span class="line">          4     4        (object header)                           03 02 00 00 (00000011 00000010 00000000 00000000) (515)</span><br><span class="line"></span><br><span class="line">    注意: 处于偏向锁的对象解锁后，线程 id 仍存储于对象头中</span><br><span class="line"></span><br><span class="line">    2.2 输出：</span><br><span class="line">    21:13:00.584 c.TestBiased [t1] - synchronized 前</span><br><span class="line">     OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">          0     4        (object header)                           01 00 00 00 (00000001【无锁状态】 00000000 00000000 00000000) (1)</span><br><span class="line">          4     4        (object header)                           00 00 00 00 (00000000           00000000 00000000 00000000) (0)</span><br><span class="line"></span><br><span class="line">    21:13:00.589 c.TestBiased [t1] - synchronized 中</span><br><span class="line">     OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">          0     4        (object header)                           d8 f1 9f cc (11011000【轻量级锁】 11110001 10011111 11001100) (-861933096)</span><br><span class="line">          4     4        (object header)                           6b 00 00 00 (01101011           00000000 00000000 00000000) (107)</span><br><span class="line"></span><br><span class="line">    21:13:00.591 c.TestBiased [t1] - synchronized 后</span><br><span class="line">     OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">          0     4        (object header)                           01 00 00 00 (00000001【无锁状态】 00000000 00000000 00000000) (1)</span><br><span class="line">          4     4        (object header)                           00 00 00 00 (00000000           00000000 00000000 00000000) (0)</span><br><span class="line"></span><br><span class="line">     */</span><br></pre></td></tr></table></figure><h3 id="偏向锁撤销"><a href="#偏向锁撤销" class="headerlink" title="偏向锁撤销"></a>偏向锁撤销</h3><h4 id="调用对象-hashCode"><a href="#调用对象-hashCode" class="headerlink" title="调用对象 hashCode"></a>调用对象 hashCode</h4><p>调用了对象的 hashCode，但偏向锁的对象 MarkWord 中存储的是线程 id，如果调用 hashCode 会导致偏向锁被撤销</p><ul><li>轻量级锁会在锁记录中记录 hashCode</li><li>重量级锁会在 Monitor 中记录 hashCode</li></ul><h4 id="其它线程使用对象"><a href="#其它线程使用对象" class="headerlink" title="其它线程使用对象"></a>其它线程使用对象</h4><p>当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁，注意这里的情况具体是对象已经先偏向了线程 t1 并且现在<strong>不存在竞争，</strong>即偏向的线程 t1 已经执行结束<strong>，这个时候其他线程 t2 再来对偏向锁对象加锁会升级为轻量级锁。</strong></p><h4 id="调用-wait-x2F-notify"><a href="#调用-wait-x2F-notify" class="headerlink" title="调用 wait&#x2F;notify"></a>调用 wait&#x2F;notify</h4><p><strong>因为 wait&#x2F;notify 是只有重量级锁才有的操作，所以调用加锁对象的 wait&#x2F;notify 会升级为重量级锁。</strong></p><h3 id="批量重偏向"><a href="#批量重偏向" class="headerlink" title="批量重偏向"></a>批量重偏向</h3><p>如果对象被多个线程访问，但并没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象的 Thread ID。</p><p>当撤销偏向锁阈值超过 20 次后，jvm 会这样觉得，我是不是偏向错了呢，于是会在给这些后续对象加锁时重新偏向至加锁线程。</p><h3 id="批量撤销"><a href="#批量撤销" class="headerlink" title="批量撤销"></a>批量撤销</h3><p>当撤销偏向锁阈值超过 40 次后，jvm 会这样觉得，自己确实偏向错了，根本就不该偏向。于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的。</p><h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><p>在JVM-运行期（晚期）优化中如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须再进行。</p><h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><p>我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小——只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变少。多数情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体之中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗，所以可以进行锁粗化，<strong>将会把加锁同步的范围扩展（粗化）到整个操作序列的外部</strong>，这样就减少了加锁的次数。</p><h1 id="偏向锁-gt-轻量级锁-gt-重量级锁的升级过程"><a href="#偏向锁-gt-轻量级锁-gt-重量级锁的升级过程" class="headerlink" title="偏向锁-&gt;轻量级锁-&gt;重量级锁的升级过程"></a>偏向锁-&gt;轻量级锁-&gt;重量级锁的升级过程</h1><ul><li>检测Mark Word里面是不是当前线程的ID，如果是，表示当前线程处于偏向锁</li><li>如果不是，则使用CAS将当前线程的ID替换Mard Word，如果成功则表示当前线程获得偏向锁，置偏向标志位1</li><li>如果失败，则说明发生竞争，撤销偏向锁，进而升级为轻量级锁。</li><li>当前线程使用CAS将对象头的Mark Word替换为锁记录指针，如果成功，当前线程获得锁</li><li>如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</li><li>如果自旋成功则依然处于轻量级状态。</li><li>如果自旋失败，则升级为重量级锁。</li></ul><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>​线程死锁描述的是：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//资源 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//资源 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123; <span class="comment">//获得资源1</span></span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>); <span class="comment">//等第二个线程获取资源2</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;<span class="comment">//这里被线程二获取了这里就获取不到。</span></span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) &#123;<span class="comment">//获取资源二</span></span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread[线程 <span class="number">1</span>,<span class="number">5</span>,main]get resource1</span><br><span class="line">Thread[线程 <span class="number">2</span>,<span class="number">5</span>,main]get resource2</span><br><span class="line">Thread[线程 <span class="number">1</span>,<span class="number">5</span>,main]waiting get resource2</span><br><span class="line">Thread[线程 <span class="number">2</span>,<span class="number">5</span>,main]waiting get resource1</span><br></pre></td></tr></table></figure><h2 id="如何预防和避免线程死锁"><a href="#如何预防和避免线程死锁" class="headerlink" title="如何预防和避免线程死锁"></a>如何预防和避免线程死锁</h2><ol><li><strong>破坏请求与保持条件</strong> ：一次性申请所有的资源。</li><li><strong>破坏不剥夺条件</strong> ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li><li><strong>破坏循环等待条件</strong> ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Monitor </tag>
            
            <tag> 轻量级锁 </tag>
            
            <tag> 锁重入 </tag>
            
            <tag> 锁膨胀 </tag>
            
            <tag> 重量级锁 </tag>
            
            <tag> 自旋优化 </tag>
            
            <tag> 偏向锁 </tag>
            
            <tag> 锁消除 </tag>
            
            <tag> 锁粗化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thread类方法</title>
      <link href="/2022/09/06/%E5%B9%B6%E5%8F%91-Thread%E7%B1%BB%E6%96%B9%E6%B3%95/"/>
      <url>/2022/09/06/%E5%B9%B6%E5%8F%91-Thread%E7%B1%BB%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>​Thread中方法有些是静态方法，有些是对象方法。对于类方法不难理解，例如 sleep 和 yield，是在哪个线程执行体中调用就对哪个线程起作用。而 join 和 wait 这种是由线程对象调用的就得注意下，其实他们都是调用了wait方法，wait方法必须在 synchronized 块里使用，sychronized 块一定锁住了一个对象（一般是当前对象），那么调用 wait 方法的就是当前对象（被锁住的对象，join 里是线程对象），这个时候不要犯糊涂，始终记住无论是哪个对象调用的，只要这个方法在某个线程执行体里被调用，那么它就是这个线程执行体里的一个普通成员变量调用的某个普通方法（被锁住的对象调用 wait 方法），那么 wait 所在的线程就会被阻塞。</p><span id="more"></span><h1 id="1-start-和-run"><a href="#1-start-和-run" class="headerlink" title="1. start 和 run"></a>1. start 和 run</h1><ul><li>直接调用 run 是在主线程中执行了 run，没有启动新的线程</li><li>使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码，注意调用start方法只是让线程进入Runnable(就绪)状态，等待调度器调度（CPU分配时间片），并不意味着马上执行，只有得到CPU时间片线程才会进入Running(运行)状态。注意<code>start</code>方法只能调用一次</li></ul><h1 id="2-sleep"><a href="#2-sleep" class="headerlink" title="2. sleep"></a>2. sleep</h1><p>​让当前正在执行的线程（写在哪个线程里哪个线程暂停）暂停一段时间，调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞）。</p><p>​sleep()方法是一个类方法，有两种重载形式。</p><ul><li><code>static void sleep(long millis)</code>：让当前正在执行的线程暂停millis毫秒，并进入阻塞状态，该方法受到系统计时器和线程调度器的精度与准确度的影响。</li><li><code>static void sleep(long millis, int nanos)</code>：让当前正在执行的线程暂停millis毫秒加nanos毫微秒，并进入阻塞状态，该方法受到系统计时器和线程调度器的精度与准确度的影响。</li></ul><p>​当前线程调用sleep()方法进入阻塞状态后，在其睡眠时间段内，该线程不会获得执行的机会，即使系统中没有其他可执行的线程，处于sleep()中的线程也不会执行，注意睡眠结束后的线程未必会立刻得到执行，还需要等待调度器的调度。因此sleep()方法常用来暂停程序的执行以及限制cpu的使用。在使用 sleep 方法时要注意，这个方法会抛出异常，要写在 try-catch 块里。</p><ul><li>应用sleep限制cpu的使用</li></ul><p>​<strong>在没有利用 cpu 来计算时，不要让<code> while(true)</code> 空转浪费 cpu，这时可以使用 <code>yield</code> 或 <code>sleep</code> 来让出 cpu 的使用权给其他程序。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while(true) &#123; </span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(50);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123; </span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​有一个问题是sleep方法的可读性不太强，其实Java1.5后提供了<code>TimeUnit.时间单位.sleep</code>方法，这个方法可读性比较强，效果跟sleep完全相同（因为底层也是调用了sleep方法）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TimeUnit.SECONDS.sleep(1);  // sleep一秒钟</span><br><span class="line">Thread.sleep(1000)          // 等价</span><br></pre></td></tr></table></figure><h1 id="3-yield"><a href="#3-yield" class="headerlink" title="3. yield"></a>3. yield</h1><p>​与sleep相同，这也是一个类方法，它也可以让当前<strong>正在执行的线程暂停，但它不会阻塞该线程</strong>，它只是让该线程从<strong>Running（运行）进入 Runnable（就绪）状态</strong>，然后让出处理器资源去调度执行其它线程。yield()只是让当前线程“暂停”一下，让系统的线程调度器重新调度一次，<code>具体的实现依赖于操作系统的任务调度器</code>，完全可能的情况是：当某个线程调用了yield()方法暂停之后，线程调度器又将其调度出来重新执行。</p><ul><li>在这里介绍一下线程优先级</li></ul><p>​每个线程执行时都具有一定的优先级，优先级高的线程获得较多的执行机会，而优先级低的线程则获得较少的执行机会。每个线程默认的优先级都与创建它的父线程的优先级相同，在默认情况下，main线程具有普通优先级，由main线程创建的子线程也具有普通优先级。Thread类提供了<code>setPriority（int newPriority）</code>、<code>getPriority()</code>方法来设置和返回指定线程的优先级，其中<code>setPriority()</code>方法的参数可以是一个整数，范围是1～10之间，也可以使用Thread类的如下三个静态常量。</p><ul><li>MAX_PRIORITY ：其值是10。</li><li>MIN_PRIORITY ：其值是1。</li><li>NORM_PRIORITY：其值是5。</li></ul><p><strong>其实调度器并不是严格按照优先级调度</strong>，只是说优先级高的被调度的几率大一下，如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用。例如：</p><ol><li><p>加 yield</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Runnable task1 = () -&gt; &#123;</span><br><span class="line">            int count = 0;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                System.out.println(&quot;----&gt;1 &quot; + count++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Runnable task2 = () -&gt; &#123;</span><br><span class="line">            int count = 0;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                Thread.yield();         // 1</span><br><span class="line">                System.out.println(&quot;              ----&gt;2 &quot; + count++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t1 = new Thread(task1, &quot;t1&quot;);</span><br><span class="line">        Thread t2 = new Thread(task2, &quot;t2&quot;);</span><br><span class="line">//        t1.setPriority(Thread.MIN_PRIORITY); // 2</span><br><span class="line">//        t2.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// yield让出后得到的机会少</span><br><span class="line">/*</span><br><span class="line">----&gt;1 158521</span><br><span class="line">----&gt;1 158522</span><br><span class="line">----&gt;1 158523</span><br><span class="line">----&gt;1 158524</span><br><span class="line">              ----&gt;2 1043</span><br><span class="line">----&gt;1 158525</span><br><span class="line">----&gt;1 158526</span><br><span class="line">----&gt;1 158527</span><br><span class="line">----&gt;1 158528</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li><li><p>设置优先级</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Runnable task1 = () -&gt; &#123;</span><br><span class="line">            int count = 0;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">//                Thread.yield();         // 1</span><br><span class="line">                System.out.println(&quot;----&gt;1 &quot; + count++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Runnable task2 = () -&gt; &#123;</span><br><span class="line">            int count = 0;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                System.out.println(&quot;              ----&gt;2 &quot; + count++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t1 = new Thread(task1, &quot;t1&quot;);</span><br><span class="line">        Thread t2 = new Thread(task2, &quot;t2&quot;);</span><br><span class="line">        t1.setPriority(Thread.MIN_PRIORITY);  // 2</span><br><span class="line">        t2.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 优先级低的得到的机会少，但他们两个之间具体什么关系依赖于调度器</span><br><span class="line">/*</span><br><span class="line">----&gt;1 3</span><br><span class="line">----&gt;1 4</span><br><span class="line">----&gt;1 5</span><br><span class="line">              ----&gt;2 49</span><br><span class="line">              ----&gt;2 50</span><br><span class="line">              ----&gt;2 51</span><br><span class="line">              ----&gt;2 52</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p><strong>sleep()方法和yield()方法的区别：</strong></p></li><li><p>sleep()方法暂停当前线程后，会给其他线程执行机会，不会理会其他线程的优先级；但yield()方法<code>通常（取决于调度器）</code>给优先级相同或优先级io更高的线程执行机会的概率要大一些。</p></li><li><p>sleep()方法会将线程转入阻塞状态，直到经过阻塞时间才会转入就绪状态；而yield()不会将线程转入阻塞状态，它只是强制当前线程进入就绪状态。因此完全有可能<strong>某个线程调用yield()方法暂停之后，立即再次获得处理器资源被执行。</strong></p></li><li><p>sleep()方法声明抛出了InterruptedException异常，所以调用sleep()方法时要么捕捉该异常，要么显式声明抛出该异常；而yield()方法则没有声明抛出任何异常。</p></li><li><p>sleep()方法比yield()方法有更好的可移植性，<strong>通常不建议使用yield()方法来控制并发线程的执行。</strong></p></li></ol><h1 id="4-join"><a href="#4-join" class="headerlink" title="4. join"></a>4. join</h1><p>​join方法是一个对象方法，当在某个程序执行体中（<strong>在哪个线程的执行体里调用，则哪个线程被阻塞</strong>）调用join()方法时，此线程将被阻塞（相当于调用了wait），Java中是由<code>Runnable</code>转到<code>Waiting</code>状态，<strong>直到被join()方法加入的线程执行完为止</strong>。join()方法内部调用了wait()方法，可以把join()理解成特殊的<code>wait(long millis)</code>方法，这个方法的millis恰好等于join的线程的执行时间。</p><ul><li><code>join()</code>：等待被join的线程执行完成。</li><li><code>join(long millis)</code>：等待被join的线程的时间最长为millis毫秒。如果在millis毫秒内被join的线程还没有执行结束，则不再等待。</li><li><code>join(long millis, int nanos)</code>：等待被join的线程的时间最长为millis毫秒加nanos毫微秒。</li></ul><p>通过下面这个例子能更加深入的理解join的作用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    static int r = 0;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        test1();</span><br><span class="line">    &#125;</span><br><span class="line">    private static void test1() throws InterruptedException &#123;</span><br><span class="line">        log.debug(&quot;开始&quot;);</span><br><span class="line">        Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">            log.debug(&quot;开始&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(1);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(&quot;结束&quot;);</span><br><span class="line">            r = 10;</span><br><span class="line">        &#125;,&quot;t1&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t1.join();   // 1. 不使用join  2. 使用join</span><br><span class="line">        log.debug(&quot;结果为:&#123;&#125;&quot;, r);</span><br><span class="line">        log.debug(&quot;结束&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 不使用join，main线程先于t1线程执行，r打印为0</span><br><span class="line">/*Output1</span><br><span class="line">00:47:15.208 c.Test10 [main] - 开始</span><br><span class="line">00:47:15.309 c.Test10 [t1] - 开始</span><br><span class="line">00:47:15.309 c.Test10 [main] - 结果为:0</span><br><span class="line">00:47:15.311 c.Test10 [main] - 结束</span><br><span class="line">00:47:16.315 c.Test10 [t1] - 结束</span><br><span class="line">*/</span><br><span class="line">// 使用join，main线程阻塞等t1线程执行结束再打印r为10，此处如果用sleep也可以但不好，因为无法预测准确的时间。</span><br><span class="line">/*Output2</span><br><span class="line">00:43:15.128 c.Test10 [main] - 开始</span><br><span class="line">00:43:15.216 c.Test10 [t1] - 开始</span><br><span class="line">00:43:16.218 c.Test10 [t1] - 结束</span><br><span class="line">00:43:16.218 c.Test10 [main] - 结果为:10</span><br><span class="line">00:43:16.221 c.Test10 [main] - 结束</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h2 id="Join的用处"><a href="#Join的用处" class="headerlink" title="Join的用处"></a>Join的用处</h2><p>可以借助join实现多线程的同步，同步和异步的概念以调用方角度来讲如下：</p><ul><li>需要等待结果返回，才能继续运行就是同步；</li><li>不需要等待结果返回，就能继续运行就是异步。</li></ul><p>例如我们要等待多个线程的执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJoin</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">r2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            r1 = <span class="number">10</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            r2 = <span class="number">20</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        log.debug(<span class="string">&quot;join begin&quot;</span>);</span><br><span class="line">        t1.join();</span><br><span class="line">        log.debug(<span class="string">&quot;t2 join end&quot;</span>);</span><br><span class="line">        t2.join();</span><br><span class="line">        log.debug(<span class="string">&quot;t1 join end&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        log.debug(<span class="string">&quot;r1: &#123;&#125; r2: &#123;&#125; cost: &#123;&#125;&quot;</span>, r1, r2, end - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Output:</span></span><br><span class="line"><span class="comment">21:33:39.856 c.TestJoin [main] - join begin</span></span><br><span class="line"><span class="comment">21:33:41.864 c.TestJoin [main] - t2 join end</span></span><br><span class="line"><span class="comment">21:33:41.867 c.TestJoin [main] - t1 join end</span></span><br><span class="line"><span class="comment">21:33:41.868 c.TestJoin [main] - r1: 10 r2: 20 cost: 2014</span></span><br></pre></td></tr></table></figure><p>​上例我们发现，如果join多个线程，<strong>join的多个线程并行执行</strong>，则被join的线程等待的时间应该为<strong>最长线程的执行时间</strong>。如果颠倒两个 join 呢？最终都是输出相同的结果，因为如果先join t2，则t2执行结束后，t1.join就无需等待了，此时t1已经执行结束了。</p><h1 id="5-interrupt"><a href="#5-interrupt" class="headerlink" title="5. interrupt"></a>5. interrupt</h1><h2 id="interrupt-方法打断线程"><a href="#interrupt-方法打断线程" class="headerlink" title="interrupt 方法打断线程"></a>interrupt 方法打断线程</h2><ul><li>case1：打断 sleep, wait, join （阻塞）的线程 – 抛出<code>InterruptedException</code>异常并重置打断标记为false</li><li>case2：打断运行中的线程 – 打断标记变为 true</li></ul><p>​打断阻塞状态（在Java中是<code>WAITING</code>or<code>TIMED_WAITING</code>状态）中的线程，会抛出一个<code>InterruptedException</code>异常，并且会重置<code>打断标记</code>为false。</p><ul><li>介绍一下打断标记</li></ul><p>​Thread类里有一个<code>isInterrupted</code>方法可以返回当前线程是否被打断，被打断返回<code>true</code>，否则<code>false</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean isInterrupted() &#123;</span><br><span class="line">        return isInterrupted(false); // 这里的false指不会重置打断标记</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​还有一个类似的静态方法<code>interrupted</code>也可以返回当前线程是否被打断，被打断返回<code>true</code>，否则<code>false</code>，但是<strong>会重置打断标记为false</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static boolean interrupted() &#123;</span><br><span class="line">    return currentThread().isInterrupted(true);  // 这里的true指会重置打断标记</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="打断阻塞状态的线程"><a href="#打断阻塞状态的线程" class="headerlink" title="打断阻塞状态的线程"></a>打断阻塞状态的线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;sleep...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>); <span class="comment">// wait, join</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;interrupt&quot;</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;打断标记:&#123;&#125;&quot;</span>, t1.isInterrupted()); <span class="comment">// 1</span></span><br><span class="line">        t1.interrupt();</span><br><span class="line">        log.debug(<span class="string">&quot;打断标记:&#123;&#125;&quot;</span>, t1.isInterrupted()); <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Output:</span></span><br><span class="line"><span class="comment">22:29:08.624 c.Test11 [t1] - sleep...</span></span><br><span class="line"><span class="comment">22:29:09.621 c.Test11 [main] - interrupt</span></span><br><span class="line"><span class="comment">22:29:09.621 c.Test11 [main] - 打断标记:false   </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">22:29:09.624 c.Test11 [main] - 打断标记:false</span></span><br><span class="line"><span class="comment">java.lang.InterruptedException: sleep interrupted</span></span><br><span class="line"><span class="comment">at java.lang.Thread.sleep(Native Method)</span></span><br><span class="line"><span class="comment">at cn.itcast.test.Test11.lambda$main$0(Test11.java:12)</span></span><br><span class="line"><span class="comment">at java.lang.Thread.run(Thread.java:748)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>​上面两个false是意义不同的，第一个代表当前线程正常运行，没有被打断；而第二个false代表线程在sleep, wait, join 中（阻塞状态）被打断，会抛出异常并将打断标记重置为false。</p><h3 id="打断正常运行的线程"><a href="#打断正常运行的线程" class="headerlink" title="打断正常运行的线程"></a>打断正常运行的线程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">            while(true) &#123;</span><br><span class="line">                System.out.println(&quot;isInterrupted状态： &quot; + (Thread.currentThread().isInterrupted()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;t1&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        log.debug(&quot;interrupt&quot;);</span><br><span class="line">        t1.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*Output:</span><br><span class="line">...</span><br><span class="line">isInterrupted状态： false</span><br><span class="line">isInterrupted状态： false</span><br><span class="line">isInterrupted状态： false</span><br><span class="line">22:43:30.383 c.Test12 [main] - interrupt</span><br><span class="line">isInterrupted状态： true</span><br><span class="line">isInterrupted状态： true</span><br><span class="line">isInterrupted状态： true</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>​打断后标记变为true， 但是进程并没有停止，那么这个打断到底有啥用啊？我们怎么让被打断后的进程停下来哪？我们可以借助打断标记，如果打断标记为真，就手动退出进程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">            while(true) &#123;</span><br><span class="line">                boolean interrupted = Thread.currentThread().isInterrupted();</span><br><span class="line">                if(interrupted) &#123;</span><br><span class="line">                    log.debug(&quot;被打断了, 退出循环&quot;);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;t1&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        log.debug(&quot;interrupt&quot;);</span><br><span class="line">        t1.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*Output:</span><br><span class="line">22:52:17.742 c.Test12 [main] - interrupt</span><br><span class="line">22:52:17.747 c.Test12 [t1] - 被打断了, 退出循环</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h2 id="interrupt应用：多线程设计模式之两阶段终止"><a href="#interrupt应用：多线程设计模式之两阶段终止" class="headerlink" title="interrupt应用：多线程设计模式之两阶段终止"></a>interrupt应用：多线程设计模式之两阶段终止</h2><p><code>Two Phase Termination</code> :在一个线程 T1 中如何“优雅”终止线程 T2？这里的【优雅】指的是给 T2 一个料理后事的机会。</p><h3 id="错误思路"><a href="#错误思路" class="headerlink" title="错误思路"></a>错误思路</h3><ul><li>使用线程对象的 stop() 方法停止线程<ul><li>stop 方法会真正杀死线程，如果这时线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁， 其它线程将永远无法获取锁</li></ul></li><li>使用 System.exit(int) 方法停止线程<ul><li>目的仅是停止一个线程，但这种做法会让整个程序都停止</li></ul></li></ul><h3 id="两阶段终止模式"><a href="#两阶段终止模式" class="headerlink" title="两阶段终止模式"></a>两阶段终止模式</h3><ul><li>应用场景：后台监控线程（需要设置停止选项）</li><li>思路<br><img src="1.png"></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j(topic = &quot;c.TwoPhaseTermination&quot;)</span><br><span class="line">public class Test_1 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        TwoPhaseTermination_1 tpt = new TwoPhaseTermination_1();</span><br><span class="line">        tpt.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(3500);</span><br><span class="line">        log.debug(&quot;停止监控&quot;);</span><br><span class="line">        tpt.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Slf4j(topic = &quot;c.TwoPhaseTermination&quot;)</span><br><span class="line">class TwoPhaseTermination_1 &#123;</span><br><span class="line">    // 监控线程</span><br><span class="line">    private Thread monitorThread;</span><br><span class="line"></span><br><span class="line">    // 启动监控线程</span><br><span class="line">    public void start() &#123;</span><br><span class="line">        monitorThread = new Thread(() -&gt; &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                Thread current = Thread.currentThread();</span><br><span class="line">                // 是否被打断</span><br><span class="line">                if (current.isInterrupted()) &#123;</span><br><span class="line">                    log.debug(&quot;料理后事&quot;);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);          // 睡眠时被打断  就会抛出异常并且会将标志重新置位false需要在catch中再打断一次将标志置位为true，</span><br><span class="line">                    log.debug(&quot;执行监控记录&quot;);   // 正常打断</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    // 当抛出异常时，因为打断标记已经重置为 false，这里要再打断一次设置为 true</span><br><span class="line">                    current.interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;monitor&quot;);</span><br><span class="line">        monitorThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 停止监控线程</span><br><span class="line">    public void stop() &#123;</span><br><span class="line">        monitorThread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*Output:</span><br><span class="line">00:30:54.263 c.TwoPhaseTermination [monitor] - 执行监控记录</span><br><span class="line">00:30:55.263 c.TwoPhaseTermination [monitor] - 执行监控记录</span><br><span class="line">00:30:56.265 c.TwoPhaseTermination [monitor] - 执行监控记录</span><br><span class="line">00:30:56.765 c.TwoPhaseTermination [main] - 停止监控</span><br><span class="line">00:30:56.765 c.TwoPhaseTermination [monitor] - 料理后事</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">at java.lang.Thread.sleep(Native Method)</span><br><span class="line">at cn.itcast.test.TwoPhaseTermination_1.lambda$start$0(Test_1.java:33)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>​在睡眠时被打断，抛出异常并在捕获异常后，也就是 catch 块中重新设置打断标记为 true（即再来一次interrupted打断），下次循环会优雅的退出线程。正常运行时被打断，也可以优雅的退出线程。</p><h1 id="6-setDaemon"><a href="#6-setDaemon" class="headerlink" title="6. setDaemon"></a>6. setDaemon</h1><h2 id="主线程与守护线程"><a href="#主线程与守护线程" class="headerlink" title="主线程与守护线程"></a>主线程与守护线程</h2><ul><li>默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。</li><li>有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。</li></ul><p>Thread有一个<code>setDeamon</code>方法，将当前线程设置为守护线程，其中<code>daemon</code>是一个boolean值，通过源码我们发现，它会先通过<code>isAlive</code>方法判断线程的状态，如果线程已经运行起来再调用 setDeamon 方法，会抛出异常，还有一点需要注意，这里抛出异常是在<code>t1.setDeamon</code>所在的线程里，不影响 t1 线程，所以<code>setDeamon</code>一定要写在<code>start</code>方法前。</p><ul><li>简单介绍一下<code>isAlive</code>方法：判断当前的线程是否处于活动状态。活动状态是指线程已经启动且尚未终止，线程处于正在运行（Running）或就绪（Runnable）的状态，就认为线程是存活的。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final void setDaemon(boolean on) &#123;</span><br><span class="line">       checkAccess();</span><br><span class="line">       if (isAlive()) &#123;</span><br><span class="line">           throw new IllegalThreadStateException();</span><br><span class="line">       &#125;</span><br><span class="line">       daemon = on;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>我们可以通过java进程是否结束判断线程是否全部结束。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                if (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(&quot;结束&quot;);</span><br><span class="line">        &#125;, &quot;t1&quot;);</span><br><span class="line">//        t1.setDaemon(true);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        log.debug(&quot;结束&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*Output:</span><br><span class="line">16:55:07.072 c.Test15 [main] - 结束</span><br><span class="line"></span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>运行上例会发现当主线程结束后，t1 线程仍然继续运行，此时 java 进程也继续运行。</p><p>如果此时把 t1 设置成守护进程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                if (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(&quot;结束&quot;);</span><br><span class="line">        &#125;, &quot;t1&quot;);</span><br><span class="line">        t1.setDaemon(true);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        log.debug(&quot;结束&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*Output:</span><br><span class="line">17:01:46.975 c.Test15 [main] - 结束</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>t1线程在mian线程结束后也自动结束，此时java进程也会结束。</p><h2 id="守护线程应用"><a href="#守护线程应用" class="headerlink" title="守护线程应用"></a>守护线程应用</h2><ul><li>垃圾回收器线程就是一种守护线程；</li><li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thread类方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发-线程阻塞与唤醒原理</title>
      <link href="/2022/09/05/%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E%E4%B8%8E%E5%94%A4%E9%86%92%E5%8E%9F%E7%90%86/"/>
      <url>/2022/09/05/%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E%E4%B8%8E%E5%94%A4%E9%86%92%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="java-locksupport"><a href="#java-locksupport" class="headerlink" title="java locksupport"></a>java locksupport</h1><p>​LockSupport是一个线程阻塞工具类，所有的方法都是静态方法，可以让线程在任意位置阻塞。各种并发框架如CountDownLatch、CyclicBarrier和Semaphore是基于AQS (AbstractQueuedSynchronizer)框架实现的，AQS框架借助于两个类：</p><ul><li>Unsafe（提供CAS操作） &#x2F;&#x2F;JDK9以后引入了VarHandle变量句柄，代替了Unsafe</li><li>LockSupport（提供park&#x2F;unpark操作）</li></ul><p>​而LockSupport的park和unpark的实现是依赖于Unsafe类的prak和unpark的。重载方法中可以传入一个blocker对象，在dump线程时能获得更多的信息，用于问题排查或系统监控。</p><span id="more"></span><p><strong>其中常用方法如下：</strong></p><p>park(Object blocker); &#x2F;&#x2F; 暂停当前线程<br>parkNanos(Object blocker, long nanos); &#x2F;&#x2F; 暂停当前线程，不过有超时时间的限制<br>parkUntil(Object blocker, long deadline); &#x2F;&#x2F; 暂停当前线程，直到某个时间</p><p>其中这几个语句的blocker是用来记录线程被阻塞时被谁阻塞的。用于线程监控和分析工具来定位原因的<br>unpark(Thread thread); &#x2F;&#x2F; 恢复某个线程</p><p><strong>这里的<code>park</code>和<code>unpark</code>其实实现了<code>wait</code>和<code>notify</code>的功能，不过还是有一些差别的</strong></p><h2 id="park-unpark-与-wait-notify-异同"><a href="#park-unpark-与-wait-notify-异同" class="headerlink" title="park ,unpark 与 wait ,notify 异同"></a>park ,unpark 与 wait ,notify 异同</h2><ol><li>park 和 wait 都会让线程进入<code>WAITING</code>或<code>TIMED_WAITING</code>状态，都可以被 interrupt 方法打断（<strong>ReentrateLock 可打断基于 park</strong> ）；</li><li>wait、notify 和 notifyAll都是Object中的方法,在调用这两个方法前必须先获得锁对象,及其关联的 Monitor 一起使用；而 park、unpark 不必，park没有锁的概念。<ul><li><strong>wait 必须写在 synchronized 里，这是因为 wait 必须是由加锁的对象调用的，其原理是通过加锁的对象关联的同步监视器（Monitor）来管理线程，当调用 wait 方法时，把当前持锁线程放入 Monitor 的 WaitSet，所以无论是 wait 还是 notify 都必须由被锁对象调用。</strong></li><li>而 park 则不同，park 是类方法，调用方式类似于 sleep，而 unpark 必须指定线程对象，所以它是“精确唤醒”。</li></ul></li><li>park &amp; unpark 是以线程为单位来【阻塞】和【唤醒】线程，wait 和 notify 都是以被锁对象（准确讲是其关联的 Monitor）为单位的，所以 notify 只能随机唤醒一个关联的 Monitor 里 WaitSet 等待的线程，notifyAll 是唤醒关联的 Monitor 里 WaitSet 所有的等待的线程，就不那么【精确】</li><li><strong>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify</strong>。</li></ol><h2 id="park-amp-unpark-底层原理"><a href="#park-amp-unpark-底层原理" class="headerlink" title="park &amp; unpark 底层原理"></a>park &amp; unpark 底层原理</h2><h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><p>​park是在怎么实现精准唤醒的哪，其实并不难理解，我们知道wait是基于锁的，所以它有竞争，所以搞了个Monitor管理被锁对象的这些个线程，但park并没有锁的概念，一个线程就关联一个<code>Parker</code>对象，你把我park了（类似于sleep）我就暂停呗，想把我唤醒就必须精确到我现在这一个线程对象。</p><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p>​在具体底层的原理上，每个线程都有自己的一个 <code>Parker</code> 对象，由三部分组成 <code>_counter</code> （计数变量）， <code>_cond</code>（条件变量） 和 <code>_mutex</code>（互斥量）。mutex和condition保护了一个_counter的变量，简单点说：当park时，这个变量被设置为0，当unpark时，这个变量被设置为1。改变变量是基于Unsafe（提供CAS操作）</p><p>​park方法本质是消费许可，先尝试直接能否直接拿到“许可”，即_counter&gt;0时，如果成功，则把_counter设置为0,并返回（）<strong>这时候线程不用阻塞等待许可</strong>：如果没有可消费的许可（<strong>初始时许可是不可用的，所以在调用 park 后 thread 被挂起</strong>），那么就阻塞当前线程，一直等待，直到阻塞线程的unpark方法被其他线程调用，然后消费许可，当前线程被唤醒，继续执行。</p><p>​unpark方法本质是生产许可，直接设置_counter为1，再unlock mutext返回。如果_counter之前的值是0，则还要调用pthread_cond_signal唤醒在park中等待的线程 ，一个线程刚创建出来，然后运行，此时是没有许可的，所以unpark方法可以在park方法前调用。下次park方法调用时，直接消费许可，线程不用阻塞等待许可。许可最多只有一个，连续多次调用unpark只能生产一个许可。</p><h1 id="wait和notify原理"><a href="#wait和notify原理" class="headerlink" title="wait和notify原理"></a>wait和notify原理</h1><p>​我们在 synchronized 原理部分已经介绍过 Monitor: 每个被加上重量级锁的对象或实例都会关联一个moniter。</p><p>​Monitor 结构如下：</p><p><img src="1.jpg"></p><ul><li>Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态；</li><li>BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片；</li><li>BLOCKED 线程会在 Owner 线程释放锁时唤醒；</li><li>WAITING 线程会在 Owner 线程调用 notify 或 notifyAll； 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入 EntryList 重新竞争。</li></ul><h2 id="wait-amp-notify"><a href="#wait-amp-notify" class="headerlink" title="wait &amp; notify"></a>wait &amp; notify</h2><p>wait、notify 方法是 Object 类里的方法。</p><ul><li><p>wait()：导致当前线程等待，直到其他线程调用被加锁对象的 notify() 方法或 notifyAll() 方法来唤醒该线程。wait()方法有3种形式：</p><ul><li>无时间参数的 wait（一直等待，直到其他线程通知）；</li><li>带毫秒参数的 wait（等待指定时间后自动苏醒）；</li><li>带毫秒、毫微秒参数的 wait（等待指定时间后自动苏醒）；</li></ul></li><li><p>notify()：唤醒在此同步监视器上等待的单个线程。如果所有线程都在此同步监视器上等待，则会随机唤醒其中一个线程。只有当前线程放弃对该同步监视器的锁定后（可使用 wait() 方法或线程结束），才可以执行被唤醒的线程。</p></li><li><p>notifyAll()：唤醒在此同步监视器上等待的所有线程，所有线程进行公平竞争锁资源。只有当前线程放弃对该同步监视器的锁定后，才可以执行被唤醒的线程。</p></li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;1. 先获得锁，对 lock 对象加锁成功&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;2. wait，让出 Owner&quot;</span>);</span><br><span class="line">                lock.wait(); <span class="comment">//也就是当前线程让出了时间片</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;6. 被 notify 唤醒了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;3. 先获得锁，对 lock 对象加锁成功&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;4. notify，随机唤醒 lock 对象关联的 Monitor 上的 WaitSet 里的一个线程&quot;</span>);</span><br><span class="line">        lock.notify();</span><br><span class="line">        System.out.println(<span class="string">&quot;5. 别急，必须等我执行结束释放了锁 notify 才发挥作用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*Output:</span></span><br><span class="line"><span class="comment">1. 先获得锁，对 lock 对象加锁成功</span></span><br><span class="line"><span class="comment">2. wait，让出 Owner</span></span><br><span class="line"><span class="comment">3. 先获得锁，对 lock 对象加锁成功</span></span><br><span class="line"><span class="comment">4. notify，随机唤醒 lock 对象关联的 Monitor 上的 WaitSet 里的一个线程</span></span><br><span class="line"><span class="comment">5. 别急，必须等我执行结束释放了锁 notify 才发挥作用</span></span><br><span class="line"><span class="comment">6. 被 notify 唤醒了</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="与-sleep-的区别"><a href="#与-sleep-的区别" class="headerlink" title="与 sleep 的区别"></a>与 sleep 的区别</h2><ul><li>sleep 是 Thread 方法，而 wait 是 Object 的方法</li><li>sleep 不需要强制和 synchronized 配合使用，但 wait 需要 和 synchronized 一起用</li><li>sleep 在睡眠的同时，不会释放对象锁的，但 wait 在等待的时候会释放对象锁</li><li>它们的状态都 TIMED_WAITING</li></ul><p>​调用 wait() 方法的当前线程会释放对该同步监视器的锁定，即进入 WaitSet 并且让出 Owner【这是与 sleep() 最大的区别】，<strong>而 sleep 时线程状态虽然变成 TIMED_WAITING，但 Owner 仍然为自己，仍然占有锁。</strong></p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoWaitAndSleep</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">locker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 被锁的对象，它关联一个 monitor</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>); <span class="comment">// 这里放前面是为了让线程 t1 有机会执行，暂停一会为了让主线程先获取同步监视器的锁</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (locker) &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>().toString());</span><br><span class="line">                System.out.println(<span class="string">&quot;Locked in t1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (locker) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>().toString());</span><br><span class="line">            System.out.println(<span class="string">&quot;Locked in main&quot;</span>);</span><br><span class="line"><span class="comment">//            Thread.sleep(10000);  // 1. 睡眠 10s</span></span><br><span class="line">            locker.wait(<span class="number">10000</span>); <span class="comment">// 2. 等待 10s</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. sleep 输出，t1 晚了 10 秒</span></span><br><span class="line"><span class="comment">    Mon Dec 14 22:10:35 CST 2020</span></span><br><span class="line"><span class="comment">    Locked in main</span></span><br><span class="line"><span class="comment">    Mon Dec 14 22:10:45 CST 2020</span></span><br><span class="line"><span class="comment">    Locked in t1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. wait 输出，几乎同步</span></span><br><span class="line"><span class="comment">    Mon Dec 14 22:11:08 CST 2020</span></span><br><span class="line"><span class="comment">    Locked in main</span></span><br><span class="line"><span class="comment">    Mon Dec 14 22:11:09 CST 2020</span></span><br><span class="line"><span class="comment">    Locked in t1</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发-线程阻塞与唤醒原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发-线程的生命周期和状态</title>
      <link href="/2022/09/05/%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%8A%B6%E6%80%81/"/>
      <url>/2022/09/05/%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%8A%B6%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h1 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态"></a>线程的生命周期和状态</h1><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态</p><ul><li>NEW: 初始状态，线程被创建出来但没有被调用 <code>start()</code> 。</li><li>可运行状态（就绪状态）：指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行，这时还没有获取CPU时间片,这里这是指出来，在实际情况中，时间片的切换时间很短，区分就绪状态和运行状态并没有太大的意义。</li><li>RUNNABLE: 运行状态，线程被调用了 <code>start()</code>等待运行的状态。Java API 层面的 RUNNABLE 状态涵盖了 操作系统层面的 【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为是可运行）</li><li>BLOCKED ：阻塞状态，需要等待锁释放。如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入阻塞状态等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至可运行状态。与可运行状态的区别是，对阻塞状态的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们</li><li>WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。</li><li>TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</li><li>TERMINATED：终止状态，表示该线程已经运行完毕。</li></ul><span id="more"></span><p>其中<code>BLOCKED</code> ， <code>WAITING</code> ， <code>TIMED_WAITING</code> 都是 Java API 层面对【阻塞状态】的细分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestState&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestState</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// New</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Runnable</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t2&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t2.start(); <span class="comment">//当调用 t.start() 方法时，由 NEW --&gt; RUNNABLE</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Terminated</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t3&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Timed_waiting</span></span><br><span class="line"><span class="comment">//                RUNNABLE &lt;--&gt; TIMED_WAITING</span></span><br><span class="line"><span class="comment">//                t 线程用 synchronized(obj) 获取了对象锁后调用 obj.wait(long n) 方法时，t 线程从 RUNNABLE --&gt; TIMED_WAITING</span></span><br><span class="line"><span class="comment">//                t 线程等待时间超过了 n 毫秒，或调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时</span></span><br><span class="line"><span class="comment">//                竞争锁成功，t 线程从 TIMED_WAITING --&gt; RUNNABLE</span></span><br><span class="line"><span class="comment">//                竞争锁失败，t 线程从 TIMED_WAITING --&gt; BLOCKED</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t4&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// 这里t4先对对象上锁，t6线程就没办法加锁了，会陷入 blocked 状态</span></span><br><span class="line">                <span class="keyword">synchronized</span> (TestState.class) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000000</span>); <span class="comment">// timed_waiting</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t4.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Waiting</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t5&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t2.join(); <span class="comment">// waiting</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t5.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Blocked</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t6&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (TestState.class) &#123; <span class="comment">// blocked</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t6.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;t1 state &#123;&#125;&quot;</span>, t1.getState());</span><br><span class="line">        log.debug(<span class="string">&quot;t2 state &#123;&#125;&quot;</span>, t2.getState());</span><br><span class="line">        log.debug(<span class="string">&quot;t3 state &#123;&#125;&quot;</span>, t3.getState());</span><br><span class="line">        log.debug(<span class="string">&quot;t4 state &#123;&#125;&quot;</span>, t4.getState());</span><br><span class="line">        log.debug(<span class="string">&quot;t5 state &#123;&#125;&quot;</span>, t5.getState());</span><br><span class="line">        log.debug(<span class="string">&quot;t6 state &#123;&#125;&quot;</span>, t6.getState());</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Output:</span></span><br><span class="line"><span class="comment">18:02:11.284 c.TestState [t3] - running...</span></span><br><span class="line"><span class="comment">18:02:11.784 c.TestState [main] - t1 state NEW</span></span><br><span class="line"><span class="comment">18:02:11.784 c.TestState [main] - t2 state RUNNABLE</span></span><br><span class="line"><span class="comment">18:02:11.784 c.TestState [main] - t3 state TERMINATED</span></span><br><span class="line"><span class="comment">18:02:11.784 c.TestState [main] - t4 state TIMED_WAITING</span></span><br><span class="line"><span class="comment">18:02:11.784 c.TestState [main] - t5 state WAITING</span></span><br><span class="line"><span class="comment">18:02:11.784 c.TestState [main] - t6 state BLOCKED</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="六种线程之间的状态转换"><a href="#六种线程之间的状态转换" class="headerlink" title="六种线程之间的状态转换"></a>六种线程之间的状态转换</h1><p><img src="1.jpg"></p><ol><li><p>线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，</p></li><li><p>调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p></li><li><p>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态。</p></li><li><p><strong>TIMED_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将线程置于 TIMED_WAITING 状态。当超时时间结束后，线程将会返回到 RUNNABLE 状态。</p></li><li><p>当线程进入 <code>synchronized</code> 方法&#x2F;块或者调用 <code>wait</code> 后（被 <code>notify</code>）重新进入 <code>synchronized</code> 方法&#x2F;块，但是锁被其它线程占有，这个时候线程就会进入 <strong>BLOCKED（阻塞）</strong> 状态。</p></li><li><p>线程在执行完了 <code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p></li></ol><h1 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h1><p>线程在执行过程中会有自己的运行条件和状态（也称上下文），比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p><ul><li>主动让出 CPU，比如调用了 <code>sleep()</code>, <code>wait()</code> 等。</li><li>时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。</li><li>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li><li>被终止或结束运行</li></ul><p>这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 <strong>上下文切换</strong>。</p><p>上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。</p>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发-线程的生命周期和状态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发-进程与线程</title>
      <link href="/2022/09/05/%E5%B9%B6%E5%8F%91-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
      <url>/2022/09/05/%E5%B9%B6%E5%8F%91-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><ul><li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的。</li><li>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</li><li>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</li><li>32位虚拟机的最大寻址地址为 232 也就是 4G，也就是说给进程分配的最大内存为4G。</li></ul><span id="more"></span><h2 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h2><ul><li>管道：简单方便，但是半双工的单向通信，效率低下，不适合频繁通信的场景。</li><li>消息队列：类似于缓存，生产者和消费者模式，队列充当中间商，优点是高效，缺点是消耗的内存比较大。</li><li>共享内存：将分配给多个进程的虚拟内存各取一部分映射到同一块物理内存，多个进程就完成了内存共享，优点是节约了内存，缺点是进程较多时，频繁发生进程竞争内存影响效率。</li><li>信号量：为了解决共享内存的问题，可以引入信号量，其本质就是一个计数器，实现进程之间的互斥和同步。</li><li>套接字（Socket）：用于远程进程间的通信。</li></ul><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p><h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><ul><li>共享内存：volatile共享内存</li><li>消息传递：wait &#x2F; notify &#x2F; join &#x2F; lock(park) &#x2F; unlock(unpark)</li><li>管道流：使用较少</li></ul><h2 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h2><ul><li>进程基本上相互独立的，而线程存在于进程内，一个进程可包含多个线程，进程拥有共享的资源，如内存空间等，供其内部的线程共享</li><li>Java 中，进程作为资源分配的最小单位，线程作为最小调度单位</li><li>进程间通信较为复杂<ul><li>同一台计算机的进程通信称为 IPC（Inter-process communication）</li><li>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP</li></ul></li><li>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量</li><li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</li></ul><h2 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h2><ul><li><strong>并发</strong>：两个及两个以上的作业在同一 <strong>时间段</strong> 内执行。</li><li><strong>并行</strong>：两个及两个以上的作业在同一 <strong>时刻</strong> 执行。</li></ul><h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><ul><li><strong>同步</strong> ： 发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。</li><li><strong>异步</strong> ：调用在发出之后，不用等待返回结果，该调用直接返回。</li></ul><h1 id="线程的创建与运行"><a href="#线程的创建与运行" class="headerlink" title="线程的创建与运行"></a>线程的创建与运行</h1><h2 id="直接new或者继承Thread类"><a href="#直接new或者继承Thread类" class="headerlink" title="直接new或者继承Thread类"></a>直接new或者继承Thread类</h2><p>​重写run()方法，调用start开启线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线程对象 </span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="comment">// 要执行的任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动线程 </span></span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure><p>或者：继承方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;新建的线程-&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startThread1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//创建一个线程对象，调用start方法，开启多线程</span></span><br><span class="line">    <span class="comment">//注：线程开启不一定立即执行，由CPU调度安排</span></span><br><span class="line">    <span class="type">Thread1</span> <span class="variable">testThread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread1</span>();</span><br><span class="line">    testThread1.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现Runnable接口，调用将Runable作为参数的构造函数"><a href="#实现Runnable接口，调用将Runable作为参数的构造函数" class="headerlink" title="实现Runnable接口，调用将Runable作为参数的构造函数"></a>实现Runnable接口，调用将Runable作为参数的构造函数</h2><ul><li>Thread 代表线程</li><li>Runnable 可运行的任务（线程要执行的代码）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123; </span><br><span class="line">    <span class="comment">// 要执行的任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// 创建线程对象 </span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>( runnable ); </span><br><span class="line"><span class="comment">// 启动线程 </span></span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure><p><strong>或者直接使用lambda表达式来创建Runnable</strong>（推荐）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startThread3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="comment">//具体的业务</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(t.getName()+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//启动线程</span></span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FutureTask传入Callable类型的参数"><a href="#FutureTask传入Callable类型的参数" class="headerlink" title="FutureTask传入Callable类型的参数"></a>FutureTask传入Callable类型的参数</h2><p>​Callable用来处理有返回结果的情况，Callable接口可看成是Runnable接口的增强版，Callable 接口中的 call 方法比 run 方法功能更强大。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 创建任务对象，传入一个 Callable 对象</span><br><span class="line">FutureTask&lt;Integer&gt; task3 = new FutureTask&lt;&gt;(() -&gt; &#123; </span><br><span class="line">    log.debug(&quot;hello&quot;); </span><br><span class="line">    return 100;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 参数1 是任务对象; 参数2 是线程名字，推荐 </span><br><span class="line">new Thread(task3, &quot;t3&quot;).start();</span><br><span class="line"></span><br><span class="line">// 主线程阻塞，同步等待 task 执行完毕的结果 </span><br><span class="line">Integer result = task3.get(); </span><br><span class="line">log.debug(&quot;结果是:&#123;&#125;&quot;, result);</span><br></pre></td></tr></table></figure><p>​在 Executors 框架体系中，<strong>FutureTask</strong> 用来表示可获取结果的异步任务。FutureTask 实现了 Future 接口，FutureTask 提供了启动和取消异步任务，查询异步任务是否计算结束以及获取最终的异步任务的结果的一些常用的方法。通过<code>get()</code>方法来获取异步任务的结果，但是会阻塞当前线程直至异步任务执行结束。一旦任务执行结束，任务不能重新启动或取消，除非调用<code>runAndReset()</code>方法。</p><p><code>get()</code>方法用户返回计算结果，如果计算还没有完成，则在get的时候会进行阻塞，直到获取到结果为止。</p><p><code>get(long timeout, TimeUnit unit)</code>方法的耐心是有限的，如果在指定时间内没有完成计算，则会抛出<code>TimeoutException</code>.</p><p><code>isDone()</code>方法用于判断当前Future是否执行完成。</p><p><code>cancel(boolean mayInterruptIfRunning)</code>取消当前线程的执行。参数表示是否在线程执行的过程中阻断。</p><p><code>isCancelled()</code>判断当前task是否被取消。</p><h2 id="Future线程池提交"><a href="#Future线程池提交" class="headerlink" title="Future线程池提交"></a>Future线程池提交</h2><p><img src="1.jpg"></p><p>通过线程池来异步获取执行结果并汇总的代码示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Callable&lt;Long&gt; callable = <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Long&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">seed</span> <span class="operator">=</span> end - start;</span><br><span class="line">        System.out.println(<span class="string">&quot;seed=&quot;</span> + seed);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> seed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">List&lt;Callable&lt;Long&gt;&gt; tasks = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">tasks.add(callable);</span><br><span class="line">tasks.add(callable);</span><br><span class="line">tasks.add(callable);</span><br><span class="line">tasks.add(callable);</span><br><span class="line">tasks.add(callable);</span><br><span class="line">tasks.add(callable);</span><br><span class="line">tasks.add(callable);</span><br><span class="line">tasks.add(callable);</span><br><span class="line">tasks.add(callable);</span><br><span class="line">tasks.add(callable);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">poolSize</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors(); <span class="comment">//判断运行主机的核数</span></span><br><span class="line">System.out.println(<span class="string">&quot;poolSize=&quot;</span> + poolSize);</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(poolSize);</span><br><span class="line">List&lt;Future&lt;Long&gt;&gt; futures = executorService.invokeAll(tasks);</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Future&lt;Long&gt; future : futures) &#123;</span><br><span class="line">    result += future.get();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;result=&quot;</span> + result);</span><br><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure><h2 id="三种方法对比"><a href="#三种方法对比" class="headerlink" title="三种方法对比"></a>三种方法对比</h2><p>采用实现 Runnable、Callable 接口的方式创建多线程的优缺点：</p><ul><li>线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。</li><li>在这种方式下，多个线程可以共享同一个 target 对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。</li><li>劣势是，编程稍稍复杂，如果需要访问当前线程，则必须使用 Thread.currentThread()方法。。</li></ul><p>采用继承Thread类的方式创建多线程的优缺点：</p><ul><li>劣势是，因为线程类已经继承了 Thread 类，所以不能再继承其他父类。</li><li>优势是，编写简单，如果需要访问当前线程，则无须使用 Thread.currentThread()方法，直接使用 this 即可获得当前线程。</li></ul><p>鉴于上面分析，因此一般推荐采用实现 Runnable接口、Callable接口的方式来创建多线程。</p><h1 id="查看进程线程的方法"><a href="#查看进程线程的方法" class="headerlink" title="查看进程线程的方法"></a>查看进程线程的方法</h1><h4 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h4><p>任务管理器可以查看进程和线程数，也可以用来杀死进程</p><ul><li><code>tasklist</code> 查看进程</li><li><code>taskkill</code> 杀死进程</li></ul><h4 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h4><ul><li><code>ps -fe</code> 查看所有进程</li><li><code>ps -fT -p &lt;PID&gt;</code> 查看某个进程（PID）的所有线程</li><li><code>kill</code> 杀死进程</li><li><code>top</code> 按大写 H 切换是否显示线程</li><li><code>top -H -p &lt;PID&gt;</code> 查看某个进程（PID）的所有线程</li></ul><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><ul><li><code>jps</code> 命令查看所有 Java 进程</li><li><code>jstack &lt;PID&gt;</code> 查看某个 Java 进程（PID）的所有线程状态</li><li><code>jconsole</code> 来查看某个 Java 进程中线程的运行情况（图形界面）</li></ul><h4 id="案例1：CPU占用过高"><a href="#案例1：CPU占用过高" class="headerlink" title="案例1：CPU占用过高"></a>案例1：CPU占用过高</h4><ol><li>用<code>top</code>定位哪个进程对cpu的占用过高；</li><li>用<code>ps</code>命令进一步定位是哪个线程引起的cpu占用过高: <code>ps H -eo pid,tid,%cpu | grep 进程id</code>，ps是显示瞬间进程的状态，其中H是打印进程树（显示树状结构，表示程序间的相互关系），-eo代表筛选感兴趣的内容，pid–进程id、tid–线程id、%cpu–对cpu的占用，| grep – 管道运算符，筛选感兴趣的进程；</li><li><code>jstack 进程id</code> 可以根据进程id 找到有问题的线程，进一步定位到问题代码的源码行号。</li></ol><h4 id="案例2：程序运行很长时间没有结果（死锁）"><a href="#案例2：程序运行很长时间没有结果（死锁）" class="headerlink" title="案例2：程序运行很长时间没有结果（死锁）"></a>案例2：程序运行很长时间没有结果（死锁）</h4><ol><li><code>jps</code> 命令查看所有 Java 进程；</li><li><code>jstack &lt;PID&gt;</code> 查看某个 Java 进程（PID）的所有线程状态（如下），或者用<code> jconsole</code> 来查看某个 Java 进程中线程的运行情况（图形界面）。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line">&quot;Thread-1&quot;:</span><br><span class="line">  waiting to lock monitor 0x0000021e94958578 (object 0x00000000d6fb0ca0, a cn.itcast.jvm.t1.stack.A),</span><br><span class="line">  which is held by &quot;Thread-0&quot;</span><br><span class="line">&quot;Thread-0&quot;:</span><br><span class="line">  waiting to lock monitor 0x0000021e9495c618 (object 0x00000000d6fb2dd8, a cn.itcast.jvm.t1.stack.B),</span><br><span class="line">  which is held by &quot;Thread-1&quot;</span><br></pre></td></tr></table></figure><h4 id="案例3：堆内存诊断（垃圾回收后，内存占用仍然很高）"><a href="#案例3：堆内存诊断（垃圾回收后，内存占用仍然很高）" class="headerlink" title="案例3：堆内存诊断（垃圾回收后，内存占用仍然很高）"></a>案例3：堆内存诊断（垃圾回收后，内存占用仍然很高）</h4><ol><li>jps 工具：查看当前系统中有哪些 java 进程；</li><li>jmap 工具： 查看堆内存占用情况<code> jmap - heap 进程id</code>；</li><li>jconsole 工具： 图形界面的，多功能的监测工具，可以连续监测；</li><li>jvisualvm 工具：图像界面的，可以检测内存占用，相比jconsole，它可以方便的抓取内存快照即堆转储（<code>堆 dump</code>）。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发-进程与线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker常用命令</title>
      <link href="/2022/09/03/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/09/03/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h1><p><strong>列出本地主机上的镜像</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p><strong>搜索镜像</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search 某个XXX镜像名字</span><br></pre></td></tr></table></figure><p>网址中包含所有的镜像 <a href="https://hub.docker.com/">https://hub.docker.com</a></p><span id="more"></span><p><strong>拉取安装镜像</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 某个XXX镜像名字:版本</span><br></pre></td></tr></table></figure><p><strong>删除镜像</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f 镜像ID</span><br></pre></td></tr></table></figure><h1 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h1><p><strong>启动容器</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -p 8080:8080 tomcat</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">docker run [可选参数] image</span><br><span class="line"></span><br><span class="line">#参数说明</span><br><span class="line">--name=&quot;名字&quot;           指定容器名字</span><br><span class="line">-d                     后台方式运行</span><br><span class="line">-it                    使用交互方式运行,进入容器查看内容</span><br><span class="line">-p                     指定容器的端口</span><br><span class="line">(</span><br><span class="line">-p ip:主机端口:容器端口  配置主机端口映射到容器端口</span><br><span class="line">-p 主机端口:容器端口</span><br><span class="line">-p 容器端口</span><br><span class="line">)</span><br><span class="line">-P                     随机指定端口(大写的P)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>列出正在运行的容器</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p><strong>启动和停止容器命令</strong></p><!--more--><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器id          #启动容器</span><br><span class="line">docke restart  容器id        #重启容器</span><br><span class="line">docker stop 容器id           #停止当前运行的容器</span><br><span class="line">docker kill 容器id           #强制停止当前容器</span><br></pre></td></tr></table></figure><p><strong>退出容器命令</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#exit 停止并退出容器（后台方式运行则仅退出）</span><br><span class="line">ctrl+p+q run进去容器,ctr1+p+q退出，容器不停止·</span><br></pre></td></tr></table></figure><p><strong>运行并进入容器</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it centos /bin/bash</span><br></pre></td></tr></table></figure><p><strong>进入容器</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mysql /bin/bash</span><br></pre></td></tr></table></figure><p><strong>删除容器</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器id                 #删除指定的容器,不能删除正在运行的容器,强制删除使用 rm -f</span><br></pre></td></tr></table></figure><p><strong>查看容器日志</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker log 容器ID</span><br></pre></td></tr></table></figure><p><strong>查看容器内运行的线程</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top 容器ID</span><br></pre></td></tr></table></figure><p><strong>从容器内拷贝文件到主机上</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp  容器ID:容器内路径 目的主机路径</span><br></pre></td></tr></table></figure><p>导入和导出容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export 导出容器的内容留作为一个tar归档文件[对应import命令]</span><br><span class="line">import 从tar包中的内容创建一个新的文件系统再导入为镜像[对应export]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker常用命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker相关使用</title>
      <link href="/2022/09/03/Docker%E7%9B%B8%E5%85%B3%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/09/03/Docker%E7%9B%B8%E5%85%B3%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker概述"><a href="#Docker概述" class="headerlink" title="Docker概述"></a>Docker概述</h1><h2 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h2><p>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。</p><p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p><p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p><span id="more"></span><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol><li>Web 应用的自动化打包和发布。</li><li>自动化测试和持续集成、发布。</li><li>在服务型环境中部署和调整数据库或其他的后台应用。</li><li>从头编译或者扩展现有的 Openshellift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。</li></ol><h2 id="Docker的基本组成"><a href="#Docker的基本组成" class="headerlink" title="Docker的基本组成"></a>Docker的基本组成</h2><p><strong>镜像（image)</strong></p><p>​docker镜像就好比是一个<strong>只读</strong>的模板，可以通过这个模板来创建容器服务，tomcat镜像&#x3D;&gt;run &#x3D;&gt;tomcat01容器(提供服务器)，通过这个镜像可以创建多个容器（最终服务运行或者项目运行就是在容器中的)。</p><p><strong>容器（Container）</strong></p><p>Docker 利用容器（Container）独立运行的一个或一组应用，应用程序或服务运行在容器里面，容器就类似于一个虚拟化的运行环境，容器为镜像提供了一个标准的和隔离的运行环境，它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台.</p><p><strong>仓库（Repository）</strong></p><p>仓库（Repository）是集中存放镜像文件的场所。仓库分为公开仓库（Public）和私有仓库（Private）两种形式。Docker公司提供的官方registry被称为Docker Hub，存放各种镜像模板的地方。</p><h1 id="Docker镜像的结构"><a href="#Docker镜像的结构" class="headerlink" title="Docker镜像的结构"></a>Docker镜像的结构</h1><p>​镜像是采用分层的结构，镜像分层最大的一个好处就是共享资源，方便复制迁移，就是为了复用。比如说有多个镜像都从相同的 base 镜像构建而来，那么 Docker Host 只需在磁盘上保存一份 base 镜像；同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</p><h2 id="UnionFS（联合文件系统）"><a href="#UnionFS（联合文件系统）" class="headerlink" title="UnionFS（联合文件系统）"></a>UnionFS（联合文件系统）</h2><p>​Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p><h2 id="Docker镜像加载原理"><a href="#Docker镜像加载原理" class="headerlink" title="Docker镜像加载原理"></a>Docker镜像加载原理</h2><p>​docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。</p><p>​bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是引导文件系统bootfs。</p><p>​rootfs (root file system) ，在bootfs之上。包含的就是典型 Linux 系统中的 &#x2F;dev, &#x2F;proc, &#x2F;bin, &#x2F;etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版</p><p><img src="Docker%E7%9B%B8%E5%85%B3%E4%BD%BF%E7%94%A8%5C1.png"></p><h2 id="镜像与容器的关系"><a href="#镜像与容器的关系" class="headerlink" title="镜像与容器的关系"></a>镜像与容器的关系</h2><p>​Docker镜像层都是只读的，容器层是可写的，当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。所有对容器的改动 - 无论添加、删除、还是修改文件都只会发生在容器层中。只有容器层是可写的，容器层下面的所有镜像层都是只读的。</p><p><strong>容器提交为镜像：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker commit 提交容器副本使之成为一个新的镜像</span><br><span class="line"></span><br><span class="line">docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot;容器ID要创建的目标镜像名:[标签名]</span><br></pre></td></tr></table></figure><h1 id="Docker容器数据卷"><a href="#Docker容器数据卷" class="headerlink" title="Docker容器数据卷"></a>Docker容器数据卷</h1><p>​卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性：</p><p>​卷的设计目的就是数据的持久化，完全独立于容器的生存周期，<strong>因此Docker不会在容器删除时删除其挂载的数据卷</strong></p><p>​使用数据卷的优点：</p><ol><li>数据卷可在容器之间共享或重用数据</li><li>卷中的更改可以直接实时生效。</li><li>数据卷中的更改不会包含在镜像的更新中</li><li>数据卷的生命周期一直持续到没有容器使用它为止</li></ol><p>​如在启动redis容器时指定数据卷，那么生成的redis容器的配置就是安装映射的数据卷的配置来的，并且数据是保存在，宿主机定义的数据卷地址上。这样即使删掉这个容器，数据仍然存在。</p><p><strong>运行一个带有容器卷存储功能的容器实例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录﹐镜像名</span><br></pre></td></tr></table></figure><h1 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol><li><p>Dockerfile，需要定义一个Dockerfile，Dockerfile定义了进程需要的一切东西。Dockerfile涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程(当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计namespace的权限控制)等等;</p></li><li><p>Docker镜像，在用Dockerfile定义一个文件之后，docker build时会产生一个Docker镜像，当运行 Docker镜像时会真正开始提供服务;</p></li><li><p>Docker容器，容器是直接提供服务的。</p></li></ol><p></p><p>Dockerfile是用来构建Docker镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。</p><p>​我的理解就是，上面讲过镜像是一层一层构成的，在启动容器之前，根据需求定制镜像，这个DockerFile就是需求描述，使用docker build命令来构建镜像，之后在run的容器就是我们定制后需要的容器。</p><h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a><strong>常用指令</strong></h2><p><img src="Docker%E7%9B%B8%E5%85%B3%E4%BD%BF%E7%94%A8%5C2.png"></p><h2 id="项目发布到Docker步骤"><a href="#项目发布到Docker步骤" class="headerlink" title="项目发布到Docker步骤"></a>项目发布到<strong>Docker</strong>步骤</h2><ol><li>使用Maven中Clean  Complie  Package将项目打包成jar包</li><li>将编写的DockerFile和jar包上川岛宿主机的同一个目录下</li><li>构建镜像 docker build -t 名字:版本</li><li>启动镜像docker run -d -p 8080:8080 镜像名字：版本</li></ol><h2 id="Docker执行Dockerfile的大致流程"><a href="#Docker执行Dockerfile的大致流程" class="headerlink" title="Docker执行Dockerfile的大致流程"></a>Docker执行Dockerfile的大致流程</h2><p>DockerFile中每条指令都会创建—个新的镜像层并对镜像进行提交，</p><ol><li>docker从基础镜像运行一个容器</li><li>执行一条指令并对容器作出修改</li><li>执行类似docker commit的操作提交一个新的镜像层</li><li>docker再基于刚提交的镜像运行一个新容器</li><li>执行dockerfile中的下—条指令直到所有指令都执行完成</li></ol><h1 id="Mysql安装"><a href="#Mysql安装" class="headerlink" title="Mysql安装"></a>Mysql安装</h1><ol><li><strong>新建mysql容器实例</strong>:</li></ol><p>​这里制指定了具体的数据卷，指定了数据持久化的地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3306:3306 --privileged=true -v /wanghao/mysql/log:/var/log/mysql -v /wanghao/mysql/data:/var/lib/mysql -v /wanghao/mysql/conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456 --name mysql mysql:5.7</span><br></pre></td></tr></table></figure><p>​mysq相关文件放置在&#x2F;wanghao下</p><!--more--><ol start="2"><li><strong>新建my.cnf</strong></li></ol><p>​通过容器卷同步给mysql容器实例，设置字符格式，中文不报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /wanghao/mysql/conf/</span><br><span class="line"></span><br><span class="line">vim my.cnf</span><br><span class="line"></span><br><span class="line">cat my.cnf</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">default_character_set=utf8</span><br><span class="line">[mysqld]</span><br><span class="line">collation_server = utf8_general_ci</span><br><span class="line">character_set_server = utf8</span><br></pre></td></tr></table></figure><ol start="3"><li>进入当前执行的容器</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mysql /bin/bash</span><br></pre></td></tr></table></figure><h1 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h1><ol><li><p><strong>拉取Redis镜像到本地</strong></p></li><li><p>在宿主机上新建文件夹存放持久化数据和配置文件</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /app/redis</span><br></pre></td></tr></table></figure><p>​&#x2F;app&#x2F;redis目录下添加redis.conf文件和data文件，在启动docker容器的时候指定配置文件，并且修改配置文件之后重新启动docker容器，配置文件是生效的</p><ol start="3"><li>运行镜像生成容器</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run  -p 6379:6379 --name redis --privileged=true -v /app/redis/redis.conf:/etc/redis/redis.conf -v /app/redis/data:/data -d redis:6.0.8 redis-server /etc/redis/redis.conf</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述就是容器卷的挂载应用。</p><ol start="4"><li>进入redis容器：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 运行着Rediis服务的容器ID redis-cli</span><br></pre></td></tr></table></figure><ol start="5"><li>运行客户端</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br></pre></td></tr></table></figure><h1 id="ElasticSearch安装"><a href="#ElasticSearch安装" class="headerlink" title="ElasticSearch安装"></a>ElasticSearch安装</h1><ol><li>拉取Elasticsearch镜像</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull elasticsearch:7.7.0</span><br></pre></td></tr></table></figure><ol start="2"><li>创建存放数据及配置文件的文件夹，启动时挂载数据卷。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p  /home/elasticsearch/data/      -p： 参数来创建多级文件夹</span><br><span class="line">mkdir -p  /home/elasticsearch/config/</span><br></pre></td></tr></table></figure><ol start="3"><li>编写配置文件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;http.host: 0.0.0.0</span><br><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot; &#x27;&gt;&gt;/home/elasticsearch/config/elasticsearch.yml</span><br></pre></td></tr></table></figure><ol start="4"><li>修改文件夹权限</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod -R 777 /home/elasticsearch/</span><br><span class="line">ls -l # 查看文件权限</span><br></pre></td></tr></table></figure><ol start="5"><li>启动elasticseach镜像</li></ol>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker相关使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL中的分区表</title>
      <link href="/2022/09/01/MySQL%E4%B8%AD%E7%9A%84%E5%88%86%E5%8C%BA%E8%A1%A8/"/>
      <url>/2022/09/01/MySQL%E4%B8%AD%E7%9A%84%E5%88%86%E5%8C%BA%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="分区概述"><a href="#分区概述" class="headerlink" title="分区概述"></a>分区概述</h2><ul><li>分区是一种表的设计模式。分区功能并不是在存储引擎层完成的，因此不只有InnoDB存储引擎支持分区。</li><li>分区的过程是将一个表或索引分解为多个更小、更可管理的部分。就访问数据库的应用而言，从逻辑上讲，只有一个表或一个索引，但是在物理上这个表或索引可能由数十个物理分区组成。每个分区都是独立的对象，可以独自处理，也可以作为一个更大对象的一部分进行处理。</li><li>MySQL数据库支持的分区类型为水平分区（分行），并不支持垂直分区（分列）。此外，MySQL数据库的分区是局部分区索引，一个分区中既存放数据又存放索引。全局分区是指，数据存放各个分区中，但是所有数据的索引放在一个对象中。目前，MySQL数据库暂时不支持全局分区。</li></ul><span id="more"></span><h2 id="分区类型"><a href="#分区类型" class="headerlink" title="分区类型"></a>分区类型</h2><p>当前MySQL数据库支持以下几种类型的分区：</p><ul><li>RANGE分区：行数据基于属于一个给定<strong>连续</strong>区间的列值放入分区。</li><li>LIST分区：和RANGE分区类型一样，只是LIST分区面向的是<strong>离散</strong>的值。</li><li>HASH分区：根据<strong>用户自定义的表达式</strong>来进行分区，返回值不能为负数。</li><li>KEY分区：根据<strong>MySQL数据库提供的散列函数</strong>来进行分区。</li><li>COLUMNS分区：前面四种分区的条件必须是整型（integer），如果不是整型，那么需要通过函数将其转化为整型。MySQL 5.5版本开始支持COLUMNS分区，可视为对RANGE分区和LIST分区的一种进化。COLUMNS分区<strong>可以直接使用非整型的数据进行分区，分区根据类型直接比较而得到，不需要转化为整型</strong>。此外，RANGE COLUMNS分区可以对多个列的值进行分区。</li></ul><p>不论创建何种类型的分区，如果表中存在主键或唯一索引时，分区列必须是唯一索引的一个组成部分。也就是说如果唯一索引为 <code>UNIQUE KEY (col1, col2)</code>，那么分区列必须为col1 或者 col2。接下来详细介绍这四种分区。</p><h3 id="RANGE-分区"><a href="#RANGE-分区" class="headerlink" title="RANGE 分区"></a>RANGE 分区</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+------------+----------------------------------------------------------------+</span><br><span class="line">| Table      | Create Table                                                   |</span><br><span class="line">+------------+----------------------------------------------------------------+</span><br><span class="line">| parti_test | CREATE TABLE `parti_test` (</span><br><span class="line">  `id` int DEFAULT NULL</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=gbk</span><br><span class="line">/*!50100 PARTITION BY RANGE (`id`)</span><br><span class="line">(PARTITION p0 VALUES LESS THAN (10) ENGINE = InnoDB,</span><br><span class="line"> PARTITION p1 VALUES LESS THAN (20) ENGINE = InnoDB,</span><br><span class="line"> PARTITION p2 VALUES LESS THAN MAXVALUE ENGINE = InnoDB) */ |</span><br><span class="line">+------------+----------------------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>例如上面这个表，就是一种RANGE分区，我们按照 id 列分成了p0，p1，p2三个区，在磁盘的物理文件中我们的确发现了三个文件，也就是说这个表在物理层面被拆分成了三个子表，代表三个分区。<br><img src="https://note.youdao.com/yws/api/personal/file/WEB3d44d8cb323f888375f47066d09c2847?method=download&shareKey=09849fae1e53e5fe3e26dfe3bdaad8a3" alt="img"><br>接下来我们插入数据9, 10,15, 21，由于表根据列id进行分区，因此数据根据id列值的范围存放在不同的物理文件中，我们可以通过explain的partitons信息查看所查询的数据位于哪个分区。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from parti_test;</span><br><span class="line">+------+</span><br><span class="line">| id   |</span><br><span class="line">+------+</span><br><span class="line">|    9 |</span><br><span class="line">|   15 |</span><br><span class="line">|   10 |</span><br><span class="line">|   21 |</span><br><span class="line">+------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from parti_test;</span><br><span class="line">+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">| id | select_type | table      | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |</span><br><span class="line">+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | parti_test | p0,p1,p2   | ALL  | NULL          | NULL | NULL    | NULL |    4 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from parti_test where id&lt;10;</span><br><span class="line">+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table      | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | parti_test | p0         | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | Using where |</span><br><span class="line">+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from parti_test where id&gt;=10 and id&lt;20;</span><br><span class="line">+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table      | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | parti_test | p1         | ALL  | NULL          | NULL | NULL    | NULL |    2 |    50.00 | Using where |</span><br><span class="line">+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from parti_test where id&gt;=20;</span><br><span class="line">+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table      | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | parti_test | p2         | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | Using where |</span><br><span class="line">+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>我们还可以通过查询information_schema架构下的PARTITIONS表来查看每个分区的具体信息，执行的语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from information_schema.PARTITIONS WHERE table_schema=database() AND table_name=&#x27;parti_test&#x27;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">                TABLE_CATALOG: def</span><br><span class="line">                 TABLE_SCHEMA: dbtest</span><br><span class="line">                   TABLE_NAME: parti_test</span><br><span class="line">               PARTITION_NAME: p0</span><br><span class="line">            SUBPARTITION_NAME: NULL</span><br><span class="line">   PARTITION_ORDINAL_POSITION: 1</span><br><span class="line">SUBPARTITION_ORDINAL_POSITION: NULL</span><br><span class="line">             PARTITION_METHOD: RANGE</span><br><span class="line">          SUBPARTITION_METHOD: NULL</span><br><span class="line">         PARTITION_EXPRESSION: `id`</span><br><span class="line">      SUBPARTITION_EXPRESSION: NULL</span><br><span class="line">        PARTITION_DESCRIPTION: 10</span><br><span class="line">                   TABLE_ROWS: 1</span><br><span class="line">               AVG_ROW_LENGTH: 16384</span><br><span class="line">                  DATA_LENGTH: 16384</span><br><span class="line">              MAX_DATA_LENGTH: 0</span><br><span class="line">                 INDEX_LENGTH: 0</span><br><span class="line">                    DATA_FREE: 0</span><br><span class="line">                  CREATE_TIME: 2021-04-26 12:45:21</span><br><span class="line">                  UPDATE_TIME: 2021-05-09 10:08:14</span><br><span class="line">                   CHECK_TIME: NULL</span><br><span class="line">                     CHECKSUM: NULL</span><br><span class="line">            PARTITION_COMMENT:</span><br><span class="line">                    NODEGROUP: default</span><br><span class="line">              TABLESPACE_NAME: NULL</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">                TABLE_CATALOG: def</span><br><span class="line">                 TABLE_SCHEMA: dbtest</span><br><span class="line">                   TABLE_NAME: parti_test</span><br><span class="line">               PARTITION_NAME: p1</span><br><span class="line">            SUBPARTITION_NAME: NULL</span><br><span class="line">   PARTITION_ORDINAL_POSITION: 2</span><br><span class="line">SUBPARTITION_ORDINAL_POSITION: NULL</span><br><span class="line">             PARTITION_METHOD: RANGE</span><br><span class="line">          SUBPARTITION_METHOD: NULL</span><br><span class="line">         PARTITION_EXPRESSION: `id`</span><br><span class="line">      SUBPARTITION_EXPRESSION: NULL</span><br><span class="line">        PARTITION_DESCRIPTION: 20</span><br><span class="line">                   TABLE_ROWS: 2</span><br><span class="line">               AVG_ROW_LENGTH: 8192</span><br><span class="line">                  DATA_LENGTH: 16384</span><br><span class="line">              MAX_DATA_LENGTH: 0</span><br><span class="line">                 INDEX_LENGTH: 0</span><br><span class="line">                    DATA_FREE: 0</span><br><span class="line">                  CREATE_TIME: 2021-04-26 12:45:21</span><br><span class="line">                  UPDATE_TIME: 2021-05-09 10:08:20</span><br><span class="line">                   CHECK_TIME: NULL</span><br><span class="line">                     CHECKSUM: NULL</span><br><span class="line">            PARTITION_COMMENT:</span><br><span class="line">                    NODEGROUP: default</span><br><span class="line">              TABLESPACE_NAME: NULL</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">                TABLE_CATALOG: def</span><br><span class="line">                 TABLE_SCHEMA: dbtest</span><br><span class="line">                   TABLE_NAME: parti_test</span><br><span class="line">               PARTITION_NAME: p2</span><br><span class="line">            SUBPARTITION_NAME: NULL</span><br><span class="line">   PARTITION_ORDINAL_POSITION: 3</span><br><span class="line">SUBPARTITION_ORDINAL_POSITION: NULL</span><br><span class="line">             PARTITION_METHOD: RANGE</span><br><span class="line">          SUBPARTITION_METHOD: NULL</span><br><span class="line">         PARTITION_EXPRESSION: `id`</span><br><span class="line">      SUBPARTITION_EXPRESSION: NULL</span><br><span class="line">        PARTITION_DESCRIPTION: MAXVALUE</span><br><span class="line">                   TABLE_ROWS: 1</span><br><span class="line">               AVG_ROW_LENGTH: 16384</span><br><span class="line">                  DATA_LENGTH: 16384</span><br><span class="line">              MAX_DATA_LENGTH: 0</span><br><span class="line">                 INDEX_LENGTH: 0</span><br><span class="line">                    DATA_FREE: 0</span><br><span class="line">                  CREATE_TIME: 2021-04-26 12:45:21</span><br><span class="line">                  UPDATE_TIME: 2021-05-09 10:08:28</span><br><span class="line">                   CHECK_TIME: NULL</span><br><span class="line">                     CHECKSUM: NULL</span><br><span class="line">            PARTITION_COMMENT:</span><br><span class="line">                    NODEGROUP: default</span><br><span class="line">              TABLESPACE_NAME: NULL</span><br><span class="line">3 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><blockquote><p>其实上面 TABLE_ROWS: 1 这里并不总是准确的，我猜想可能也是抽样统计的，并不是实时的数量，因为有时候看就是错的。</p></blockquote><p>那 RANGE 分区的优点是什么哪，我们为什么要进行分区哪？</p><ul><li>RANGE分区非常适用于对日期列的分区，例如，对于销售类的表，可以根据年份来分区存放销售记录，这样创建的好处是便于对表的管理，如果要删除2008年的数据，我们不需要执行DELETE FROM sales WHERE date&gt;&#x3D;’2008-01-01’ and date &lt;’2009-01-01’，只需删除2008年数据所在的分区即可。</li><li>这样创建的另一个好处是可以加快某些查询操作，例如上面我们explain查询语句发现，对于范围查询，如果落在分区范围内，只会搜索这个分区，而不会搜索整个分区——称为Partition Pruning（分区修剪）。</li></ul><h3 id="LIST-分区"><a href="#LIST-分区" class="headerlink" title="LIST 分区"></a>LIST 分区</h3><p>LIST分区和RANGE分区非常相似，只是分区列的值是离散的，而非连续的，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show create table parti_list;</span><br><span class="line">+------------+---------------------------------------------------------------------------------------------+</span><br><span class="line">| Table      | Create Table                                                                                |</span><br><span class="line">+------------+---------------------------------------------------------------------------------------------+</span><br><span class="line">| parti_list | CREATE TABLE `parti_list` (</span><br><span class="line">  `a` int DEFAULT NULL,</span><br><span class="line">  `b` int DEFAULT NULL</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci</span><br><span class="line">/*!50100 PARTITION BY LIST (`b`)</span><br><span class="line">(PARTITION p0 VALUES IN (1,3,5,7,9) ENGINE = InnoDB,</span><br><span class="line"> PARTITION p1 VALUES IN (0,2,4,6,8) ENGINE = InnoDB) */ |</span><br><span class="line">+------------+---------------------------------------------------------------------------------------------+</span><br><span class="line">1 row in set (0.03 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from parti_list;</span><br><span class="line">+------+------+</span><br><span class="line">| a    | b    |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 |    1 |</span><br><span class="line">|    1 |    3 |</span><br><span class="line">|    1 |    2 |</span><br><span class="line">|    1 |    4 |</span><br><span class="line">+------+------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from parti_list;</span><br><span class="line">+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">| id | select_type | table      | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |</span><br><span class="line">+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | parti_list | p0,p1      | ALL  | NULL          | NULL | NULL    | NULL |    4 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select table_name, partition_name, table_rows from information_schema.partitions where table_name=&#x27;parti_list&#x27; and table_schema=database() \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">    TABLE_NAME: parti_list</span><br><span class="line">PARTITION_NAME: p0</span><br><span class="line">    TABLE_ROWS: 2</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">    TABLE_NAME: parti_list</span><br><span class="line">PARTITION_NAME: p1</span><br><span class="line">    TABLE_ROWS: 2</span><br><span class="line">2 rows in set (0.03 sec)</span><br></pre></td></tr></table></figure><p>如果插入的值不在分区的定义中，那么MySQL数据库同样会抛出异常。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into parti_list select 1,11;</span><br><span class="line">ERROR 1526 (HY000): Table has no partition for value 11</span><br></pre></td></tr></table></figure><p>另外，在执行INSERT操作插入多个行数据的过程中如果遇到分区未定义的值，MyISAM和InnoDB存储引擎的处理会完全不同。MyISAM引擎会将之前的行数据都插入，但之后的数据不会被插入。<strong>而InnoDB存储引擎将其视为一个事务，没有任何数据被插入</strong>。</p><h3 id="HASH分区"><a href="#HASH分区" class="headerlink" title="HASH分区"></a>HASH分区</h3><p>HASH分区的目的是将数据均匀地分布到预先定义的各个分区中，保证各分区的数据数量大致是一样的。在RANGE和LIST分区中，必须明确指定一个给定的列值或列值集合应该保存在哪个分区中；而在HASH分区中，MySQL自动完成这些工作，用户所要做的只是基于将要被散列的列值指定一个表达式（哈希函数），以及指定被分区的表将要被分割成的分区数量。其格式为在create table 后面加上，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PARTITION BY HASH(expr)   -- expr为表达式，也就是哈希函数，即用某列的值作为函数的输入，当然也可以用列值本身</span><br><span class="line">PARTITIONS num;           -- 分区数，不写默认为1，就是不分区</span><br></pre></td></tr></table></figure><p>例如下列取函数 year(b) 即哈希函数为对该列取年份值，然后对哈希值取模计算分区：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show create table parti_hash;</span><br><span class="line">+------------+---------------------------------------------------------------------------------------------+</span><br><span class="line">| Table      | Create Table                                                                                |</span><br><span class="line">+------------+---------------------------------------------------------------------------------------------+</span><br><span class="line">| parti_hash | CREATE TABLE `parti_hash` (</span><br><span class="line">  `a` int DEFAULT NULL,</span><br><span class="line">  `b` datetime DEFAULT NULL</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci</span><br><span class="line">/*!50100 PARTITION BY HASH (year(`b`))</span><br><span class="line">PARTITIONS 4 */ |</span><br><span class="line">+------------+---------------------------------------------------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into parti_hash select 1, &#x27;2021-04-01&#x27;;</span><br><span class="line">Query OK, 1 row affected (0.04 sec)</span><br><span class="line">Records: 1  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from parti_hash;</span><br><span class="line">+------+---------------------+</span><br><span class="line">| a    | b                   |</span><br><span class="line">+------+---------------------+</span><br><span class="line">|    1 | 2021-04-01 00:00:00 |</span><br><span class="line">+------+---------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>因为 <code>2021 MOD 4 = 1</code>， 因此该记录会被放入分区p1中，我们可以按如下方法来验证一下，果然放在了p1中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select table_name, partition_name, table_rows from information_schema.partitions where table_name=&#x27;parti_hash&#x27; and table_schema=database() \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">    TABLE_NAME: parti_hash</span><br><span class="line">PARTITION_NAME: p0</span><br><span class="line">    TABLE_ROWS: 0</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">    TABLE_NAME: parti_hash</span><br><span class="line">PARTITION_NAME: p1</span><br><span class="line">    TABLE_ROWS: 1</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">    TABLE_NAME: parti_hash</span><br><span class="line">PARTITION_NAME: p2</span><br><span class="line">    TABLE_ROWS: 0</span><br><span class="line">*************************** 4. row ***************************</span><br><span class="line">    TABLE_NAME: parti_hash</span><br><span class="line">PARTITION_NAME: p3</span><br><span class="line">    TABLE_ROWS: 0</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>MySQL数据库还支持一种称为LINEAR HASH的分区，它使用一个更加复杂的算法来确定新行插入到已经分区的表中的位置。它的语法和HASH分区的语法相似，只是将关键字HASH改为LINEAR HASH，感兴趣的同学可以了解一下。</p><h3 id="KEY分区"><a href="#KEY分区" class="headerlink" title="KEY分区"></a>KEY分区</h3><p>KEY分区也很简单，使用和HASH分区相似，唯一的不同之处在于HASH分区通过用户定义的函数进行分区，而KEY分区使用MySQL数据库提供的函数进行分区。MySQL数据库使用其内部的散列函数来分区。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE parti_key (</span><br><span class="line">    -&gt; a INT,</span><br><span class="line">    -&gt; b DATETIME)ENGINE=InnoDB</span><br><span class="line">    -&gt; PARTITION BY KEY(b)</span><br><span class="line">    -&gt; PARTITIONS 4;</span><br></pre></td></tr></table></figure><h3 id="COLUMNS分区"><a href="#COLUMNS分区" class="headerlink" title="COLUMNS分区"></a>COLUMNS分区</h3><p>在前面介绍的RANGE、LIST、HASH和KEY这四种分区中，分区的条件必须是整型（integer），如果不是整型，那么需要通过函数将其转化为整型，如YEAR（）、TO_DAYS（）、MONTH（）等函数。MySQL5.5版本开始支持COLUMNS分区，可视为对RANGE分区和LIST分区的一种进化。COLUMNS分区可以直接使用非整型的数据进行分区，分区根据类型直接比较而得到，不需要转化为整型。此外，RANGE COLUMNS分区可以对多个列的值进行分区。</p><p>COLUMNS分区支持以下数据类型：</p><ul><li>所有的整型类型，如INT、SMALLINT、TINYINT和BIGINT。对FLOAT和DECIMAL则不予支持。</li><li>日期类型，如DATE和DATETIME。对其余的日期类型不予支持。</li><li>字符串类型，如CHAR、 VARCHAR、BINARY和VARBINARY。对BLOB和TEXT类型不予支持。</li></ul><p>用法也很简单，对于之前的RANGE和LIST分区，只需要用RANGE COLUMNS和LIST COLUMNS代替即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table parti_cloumns_range (</span><br><span class="line">    a int, b datetime) </span><br><span class="line">    partition by range(b)(</span><br><span class="line">    partition p0 values less than (&#x27;2015-01-01&#x27;), </span><br><span class="line">    partition p1 values less than (&#x27;2020-01-01&#x27;));</span><br><span class="line">ERROR 1697 (HY000): VALUES value for partition &#x27;p0&#x27; must have type INT -- 报错，必须是整形</span><br><span class="line"></span><br><span class="line">mysql&gt; create table parti_cloumns_range (</span><br><span class="line">    a int, b datetime) </span><br><span class="line">    partition by range columns(b)(</span><br><span class="line">    partition p0 values less than (&#x27;2015-01-01&#x27;), </span><br><span class="line">    partition p1 values less than (&#x27;2020-01-01&#x27;));</span><br><span class="line">Query OK, 0 rows affected (0.83 sec)</span><br></pre></td></tr></table></figure><h2 id="子分区"><a href="#子分区" class="headerlink" title="子分区"></a>子分区</h2><p>子分区（subpartitioning）是在分区的基础上再进行分区，有时也称这种分区为复合分区（composite partitioning）。MySQL数据库允许在RANGE和LIST的分区上再进行HASH或KEY的子分区。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table subparti (</span><br><span class="line">    -&gt; a int,</span><br><span class="line">    -&gt; b date)</span><br><span class="line">    -&gt; partition by range(year(b))</span><br><span class="line">    -&gt; subpartition by hash(to_days(b))</span><br><span class="line">    -&gt; subpartitions 2(</span><br><span class="line">    -&gt; partition p0 values less than (2000),</span><br><span class="line">    -&gt; partition p1 values less than (2020),</span><br><span class="line">    -&gt; partition p2 values less than maxvalue);</span><br><span class="line">Query OK, 0 rows affected (1.76 sec)</span><br></pre></td></tr></table></figure><p>表 subparti 先根据b列进行了RANGE分区分成三个，然后对每个分区又进行了一次HASH分区分为两个，所以分区的数量应该为（3*2&#x3D;6）个，这通过查看物理磁盘上的文件也可以得到证实。<br><img src="https://note.youdao.com/yws/api/personal/file/9272F49427F34BFCAF5E40F6ED25B94C?method=download&shareKey=09849fae1e53e5fe3e26dfe3bdaad8a3" alt="img"></p><p>我们也可以通过使用 SUBPARTITION 语法来显式地指出各个子分区的名字，对上述的表同样可以执行以下语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table subparti (</span><br><span class="line">    -&gt; a int,</span><br><span class="line">    -&gt; b date)</span><br><span class="line">    -&gt; partition by range(year(b))</span><br><span class="line">    -&gt; subpartition by hash(to_days(b)) (</span><br><span class="line">    -&gt; partition p0 values less than (2000) (</span><br><span class="line">    -&gt; subpartition s0,</span><br><span class="line">    -&gt; subpartition s1),</span><br><span class="line">    -&gt; partition p1 values less than (2020) (</span><br><span class="line">    -&gt; subpartition s2,</span><br><span class="line">    -&gt; subpartition s3),</span><br><span class="line">    -&gt; partition p2 values less than maxvalue (</span><br><span class="line">    -&gt; subpartition s4,</span><br><span class="line">    -&gt; subpartition s5)</span><br><span class="line">    -&gt; );</span><br><span class="line">Query OK, 0 rows affected (1.76 sec)</span><br></pre></td></tr></table></figure><p>子分区的建立需要注意以下几个问题：</p><ul><li>每个子分区的数量必须相同。</li><li>如果在一个分区表的任何分区上使用SUBPARTITION来明确定义任何子分区，那么就必须定义所有的子分区。</li><li>每个SUBPARTITION子句必须包括子分区的一个名字。</li><li>子分区的名字必须是唯一的。</li></ul><h2 id="分区中的NULL值"><a href="#分区中的NULL值" class="headerlink" title="分区中的NULL值"></a>分区中的NULL值</h2><p>MySQL数据库允许对NULL值进行分区，但是处理方法可能与其他数据库不同。<strong>MySQL数据库的分区总是把NULL值视为小于任何的一个非NULL值，这和MySQL数据库中处理NULL值的ORDER BY操作是一样的</strong>。因此对于不同的分区类型，MySQL数据库对NULL值的处理也各不相同。</p><ul><li>对于RANGE分区，如果向分区列插入了NULL值，那么MySQL数据库会将该值放入最左边的分区。</li><li>要在LIST分区下使用NULL值，必须显式地指出向哪个分区中可以放入NULL值，否则会报错。</li><li>HASH和KEY分区对NULL的处理方式与RANGE和LIST分区不一样，任何分区函数（哈希函数）都会将含有NULL值的记录返回为0，所以NULL值一定会放在p0分区。</li></ul><h2 id="分区的性能"><a href="#分区的性能" class="headerlink" title="分区的性能"></a>分区的性能</h2><p>数据库的应用分为两类：一类是<strong>OLTP（联机事务处理）</strong>，如Blog、电子商务、网络游戏等；另一类是<strong>OLAP（联机分析处理）</strong>，如数据仓库、数据集市等。在一个实际的应用环境中，可能既有OLTP的应用，也有OLAP的应用。</p><p>对于OLAP的应用，分区的确可以很好地提高查询的性能，因为OLAP应用的大多数查询需要频繁地扫描一张很大的表。假设有一张1亿行的表，其中有一个时间戳属性列，需要从这张表中获取一年的数据。如果按时间戳进行分区，则只需要扫描相应的分区即可。这就是前面介绍的Partition Pruning技术。</p><p>然而对于OLTP的应用，在分区时应该非常小心。在这种应用下，通常不可能会获取一张大表中10%的数据，大部分都是通过索引返回几条记录即可。而根据B+树索引的原理可知，对于一张大表，一般的B+树需要2～3次的磁盘IO操作，因此B+树可以很好地完成对大表的查询操作，不需要分区的帮助，更何况设计不好的分区会带来严重的性能问题。</p><p>一千万行的表是一张非常大的表吗？需要分区吗？例如对主键做10个HASH分区，这样每个分区就只有一百万的数据了，我们可能会认为这时查询应该变得更快了，但是考虑这样一个问题：一百万行和一千万行的数据本身构成的B+树的层次是其实都很小，可能都是两层，那么上述主键分区的索引可能并不会带来性能的提高。假设一千万行数据的B+树的高度是3，一百万行数据的B+树的高度是2，这样上述主键分区的索引可以避免一次IO，从而提高查询的效率，这没问题，但是这张表只有主键索引，没有任何其他列需要查询吗？如果我们查询其他列（非分区列），这时就需要扫描所有的10个分区，即使每个分区的查询开销为2次IO操作，那么一共需要20次IO。而对于原来单表的设计，此次查询原本只需要2～3次IO操作，所以要综合考虑，分区并不一定能带来性能提升。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL中的分区表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的联结（Join）算法</title>
      <link href="/2022/09/01/MySQL%E7%9A%84%E8%81%94%E7%BB%93%EF%BC%88Join%EF%BC%89%E7%AE%97%E6%B3%95/"/>
      <url>/2022/09/01/MySQL%E7%9A%84%E8%81%94%E7%BB%93%EF%BC%88Join%EF%BC%89%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h3><p>​所有的广义内连接的核心和共同点是完全基于<strong>笛卡尔积</strong>原理的，两个表进行笛卡尔积运算得到的结果表是由第一个表的每一行与第二个表的每一行拼接后形成的表，称为‘笛卡尔积表’，结果表的行数等于两个表的行数之积。如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * from 表1 [CROSS] JOIN 表2；</span><br></pre></td></tr></table></figure><p>这里没有任何限制和条件，这种联结称为<strong>交叉连接</strong>，得到的结果就是两个表的笛卡尔积，所有广义内连接在原理上都是通过在笛卡尔积的基础上进行过滤得到的。</p><span id="more"></span><h3 id="内连接（等值连接）"><a href="#内连接（等值连接）" class="headerlink" title="内连接（等值连接）"></a>内连接（等值连接）</h3><p>​我们要在笛卡尔积的基础上进行过滤了，以选择我们需要的记录（行）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 写法1：显式内连接，通过ON进行过滤</span><br><span class="line">SELECT * from 表1 [INNER] JOIN 表2 ON 等值条件；</span><br><span class="line">-- 写法2：隐式内连接，通过WHERE进行过滤</span><br><span class="line">SELECT * from 表1，表2 WHERE 等值条件；</span><br></pre></td></tr></table></figure><p>​注意这里的条件是等值条件，一般类似 <strong>表1.字段1&#x3D;表2.字段2</strong> 这种（字段就是列），所以内连接又称为等值连接。内连接允许条件不是等值的，那就不是等值连接就是一般的内连接了。不过我们一般都用等值连接。内连接也允许没有等值条件，如果没有 ON 的话此时就等同于交叉联结CROSS JOIN。</p><h3 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h3><p>​上述内连接是对行进行过滤，对列进行过滤的话就是自然连接，自然连接要求你只能选择那些唯一的列，一般通过对一个表使用通配符（SELECT *），而对其他表的列使用明确的子集来完成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 写法1</span><br><span class="line">SELECT 表1.*, 表2.不包含重复列的其他列 from 表1 [INNER] JOIN 表2；</span><br><span class="line">-- 写法2</span><br><span class="line">SELECT 表1.*, 表2.不包含重复列的其他列 from 表1，表2；</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​但一般我们是既对行进行过滤也对列进行过滤，事实上，我们几乎使用的每个内连接都是自然连接，很可能永远都不会用到不是自然连接的内连接，即它们两个是搭配使用的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 写法1</span><br><span class="line">SELECT 表1.*, 表2.不包含重复列的其他列 from 表1 [INNER] JOIN 表2 ON 等值条件；</span><br><span class="line">-- 写法2</span><br><span class="line">SELECT 表1.*, 表2.不包含重复列的其他列 from 表1，表2 WHERE 等值条件；</span><br></pre></td></tr></table></figure><p>​在MySQL中有提供实现的自然连接（NATURAL JOIN），注意这里的自然连接跟我们上面说的有那么一点点不同，NATURAL JOIN等同于INNTER JOIN与USING的组合，它隐含的作用是将两个表中具有相同名称的列进行匹配，前提是两个表必须含有相同名字的列，然后我们可以省略ON条件，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT * from 表1 NATURAL JOIN 表2;</span><br><span class="line"></span><br><span class="line">等同于</span><br><span class="line"></span><br><span class="line">SELECT * from 表1 [INNER] JOIN 表2 ON t1.same_column = t2.same_column;</span><br></pre></td></tr></table></figure><h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><p>​自连接顾名思义就是自己跟自己连接，说白了他本质上还是一种特殊的自己跟自己的交叉连接，自连接的实现必须借助给表起别名，如果不用别名就会报错，因为要多次调用同一个表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 写法1，AS t1为起别名操作，注意也可以省略AS，直接t1即可</span><br><span class="line">SELECT * from 表1 [AS] t1 [INNER] JOIN 表2 [AS] t2；</span><br><span class="line">-- 写法2</span><br><span class="line">SELECT * from 表1 [AS] t1，表2 [AS] t2；</span><br></pre></td></tr></table></figure><p>​但一般我们不这么用，与前面类似，自连接的使用一般搭配内连接和自然连接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 写法1</span><br><span class="line">SELECT 表1.*, 表2.不包含重复列的其他列 from 表1 AS t1 [INNER] JOIN 表2 AS t2 ON 等值条件；</span><br><span class="line">-- 写法2</span><br><span class="line">SELECT 表1.*, 表2.不包含重复列的其他列 from 表1 AS t1，表2 AS t2 WHERE 等值条件；</span><br></pre></td></tr></table></figure><h2 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h2><p>​之前我们提到所有的广义内连接是完全基于笛卡尔积的，即所有广义内连接的结果都能在笛卡尔积表里找到，内连接将一个表中的行与另一个表中的行相关联，但有时候需要包含没有关联行的那些行，这些行在是笛卡尔积中是不存在的，这时就要用到外连接了，即<strong>外连接不是完全基于笛卡尔积的</strong>。</p><p>​左外连接</p><p><strong>返回包括左表中的所有记录和右表中连接字段相等的记录</strong>。这个要求笛卡尔积表并不能满足。例如有两个表如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">员工表：</span><br><span class="line">    +----------+--------------+----------+</span><br><span class="line">    | 员工ID   | 员工名字     | 部门ID   |</span><br><span class="line">    +----------+--------------+----------+</span><br><span class="line">    | 1        | 张三         | 1        |</span><br><span class="line">    | 2        | 李四         | 2        |</span><br><span class="line">    | 3        | 王五         | NULL     |</span><br><span class="line">    +----------+--------------+----------+</span><br><span class="line">部门表：</span><br><span class="line">    +----------+--------------+</span><br><span class="line">    | 部门ID   | 部门名字     |</span><br><span class="line">    +----------+--------------+</span><br><span class="line">    | 1        | 销售部       |</span><br><span class="line">    | 2        | 财务部       |</span><br><span class="line">    +----------+--------------+</span><br></pre></td></tr></table></figure><p>假设这么一种情况，王五刚入职，还没有分配部门，这时领导要求查询所有员工的信息及所在的部门信息，包括未分配部门的员工。那这个要求在笛卡尔积表里能找到吗？<br>我们试一下内连接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM emp [INNER] JOIN dep ON emp.`员工ID` = dep.`部门ID`;</span><br><span class="line"></span><br><span class="line">+----------+--------------+----------+----------+--------------+</span><br><span class="line">| 员工ID   | 员工名字     | 部门ID   | 部门ID   | 部门名字     |</span><br><span class="line">+----------+--------------+----------+----------+--------------+</span><br><span class="line">| 1        | 张三         | 1        | 1        | 销售部       |</span><br><span class="line">| 2        | 李四         | 2        | 2        | 财务部       |</span><br><span class="line">+----------+--------------+----------+----------+--------------+</span><br></pre></td></tr></table></figure><p>好像不行，并不包括王五的记录啊，那我们看一下笛卡尔表里都有什么：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM emp [INNER] JOIN dep;</span><br><span class="line">+----------+--------------+----------+----------+--------------+</span><br><span class="line">| 员工ID   | 员工名字     | 部门ID   | 部门ID   | 部门名字     |</span><br><span class="line">+----------+--------------+----------+----------+--------------+</span><br><span class="line">| 1        | 张三         | 1        | 1        | 销售部       |</span><br><span class="line">| 1        | 张三         | 1        | 2        | 财务部       |</span><br><span class="line">| 2        | 李四         | 2        | 1        | 销售部       |</span><br><span class="line">| 2        | 李四         | 2        | 2        | 财务部       |</span><br><span class="line">| 3        | 王五         | NULL     | 1        | 销售部       |</span><br><span class="line">| 3        | 王五         | NULL     | 2        | 财务部       |</span><br><span class="line">+----------+--------------+----------+----------+--------------+</span><br></pre></td></tr></table></figure><p>我们发现笛卡尔积表里并没有符合要求的记录，此时就要用到外连接了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM emp LEFT [OUTER] JOIN dep ON emp.`员工ID` = dep.`部门ID`;</span><br><span class="line"></span><br><span class="line">+----------+--------------+----------+----------+--------------+</span><br><span class="line">| 员工ID   | 员工名字     | 部门ID   | 部门ID   | 部门名字     |</span><br><span class="line">+----------+--------------+----------+----------+--------------+</span><br><span class="line">| 1        | 张三         | 1        | 1        | 销售部       |</span><br><span class="line">| 2        | 李四         | 2        | 2        | 财务部       |</span><br><span class="line">| 3        | 王五         | NULL     | NULL     | NULL         |</span><br><span class="line">+----------+--------------+----------+----------+--------------+</span><br></pre></td></tr></table></figure><p>我们可以看到王五那条记录在笛卡尔积表是不存在的，这也是我们所说的<strong>外连接不是完全基于笛卡尔积的，左外连接会返回包括左表中的所有记录和右表中连接字段相等的记录（可以理解成外连接比内连接的记录更多，多了一边为null的记录）</strong>。</p><p>这存在一个隐式的条件，外连接可以没有条件吗？我们知道内连接没有条件会变成交叉连接，答案是外连接必须存在等值条件，不然这种连接就跟外连接的定义相违背，SQL也会报错。但是我们可以给一个恒为true的条件，这时外连接是否会就退化成内连接了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM 表1 LEFT [OUTER] JOIN 表2 ON 1=1;</span><br><span class="line"> </span><br><span class="line">-- 等价于 </span><br><span class="line"></span><br><span class="line">SELECT * FROM 表1, 表2;</span><br></pre></td></tr></table></figure><p>或者我们用逻辑查询处理的思路分析一下上面这种特殊情况，首先从from开始生成两个表的笛卡尔积，然后ON过滤，这里条件始终为true没有执行任何过滤，笛卡尔积中的所有记录都保留下来，然后到join中添加外部行，因为左边的边的记录都在，所以不需要添加外部行，所以这时就是笛卡尔积。</p><h3 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h3><p>跟左外连接原理完全相同，只不过返回包括右表中的所有记录和左表中连接字段相等的记录。其实掌握一个就行，左外连接中两个表互换位置就是右外连接了。语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * from RIGHT [OUTER] JOIN 表2 ON 等值条件；</span><br></pre></td></tr></table></figure><h3 id="全外连接"><a href="#全外连接" class="headerlink" title="全外连接"></a>全外连接</h3><p>返回左右表中所有的记录和左右表中连接字段相等的记录。<br>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * from FULL [OUTER] JOIN 表2 ON 等值条件；</span><br></pre></td></tr></table></figure><blockquote><p>注意：FULL OUTER JOIN的支持： Access、MariaDB、MySQL、Open Office Base和SQLite不支持FULL OUTER JOIN语法</p></blockquote><p><img src="1.png"></p><h2 id="联结算法"><a href="#联结算法" class="headerlink" title="联结算法"></a>联结算法</h2><p>​联接算法是MySQL数据库用于处理联接的物理策略。目前MySQL数据库仅支持Nested-Loops Join算法，这里只简单介绍一下这个联结算法。Nested-Loops Join算法有三种，分别为：</p><ul><li><p>Index Nested-Loop Join</p></li><li><p>Simple Nested-Loops Join算法</p></li><li><p>Block Nested-Loops Join算法</p></li></ul><h3 id="Index-Nested-Loop-Join"><a href="#Index-Nested-Loop-Join" class="headerlink" title="Index Nested-Loop Join"></a>Index Nested-Loop Join</h3><p>​当被驱动表有索引的时候，联结查询的执行过程是：</p><p>​先遍历表t1，然后根据从表t1中取出的每行数据中的a值，去表t2中查找满足条件的记录。在形式上，这个过程就跟我们写程序时的嵌套查询类似，并且可以用上被驱动表的索引，所以我们称之为“Index Nested-Loop Join”，简称NLJ。假设在t2表上有a的索引，那么这里t1<strong>驱动表是走全表扫描，而被驱动表是走树搜索。</strong>从这里的驱动表和被驱动表的查询过程可以看出，可以使用被驱动表的索引的前提下，<strong>使用join时将体量较小的小表作为驱动表</strong></p><h3 id="Simple-Nested-Loop-Join"><a href="#Simple-Nested-Loop-Join" class="headerlink" title="Simple Nested-Loop Join"></a>Simple Nested-Loop Join</h3><p>​当被驱动表用不上索引的时候，那么拿到了表1的行数据之后需要在被驱动表上做一次全表扫描。如果两个表都是使用的全表扫描的话，那么扫描的行数就是两个表行数之积。算法太过于笨重，MySQL也没有使用这个Simple Nested-Loop Join算法。而是使用了另一个叫作“Block Nested-Loop Join”的算法，简称BNL。</p><h3 id="Block-Nested-Loop-Join"><a href="#Block-Nested-Loop-Join" class="headerlink" title="Block Nested-Loop Join"></a>Block Nested-Loop Join</h3><p>​这时候，被驱动表上没有可用的索引，算法的流程是这样的：</p><ol><li>把表t1的数据读入线程内存join_buffer中，由于我们这个语句中写的是select *，因此是把整个表t1放入了内存；</li><li>扫描表t2，把表t2中的每一行取出来，跟join_buffer中的数据做对比，满足join条件的，作为结果集的一部分返回。</li></ol><p>​在这个过程中，对表t1和t2都做了一次全表扫描，由于join_buffer是以无序数组的方式组织的，因此对表t2中的每一行都需要做比对判断。但是，Block Nested-Loop Join算法的判断都是内存操作，速度上会快很多，性能也更好。这个时候任何一个表作为驱动表和被驱动表耗时都是一样的。</p><p>​在实际过程中如果join_buffer放不下一整个表的数据，就分段放满然后使用被驱动表做匹配，匹配完之后就清空join_buffer继续读驱动表的数据。这也是这个算法名字“Block”的由来：表示“分块去join”。但是在join_buffer_size不够大的时候（这种情况更常见），应该选择小表做驱动表。这样尽可能让join_buffer一次性就加载完驱动表这样被驱动表就不用重复去匹配。</p><p>​这里的小表定义规则是：<strong>在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，计算参与join的各个字段的总数据量，数据量小的那个表，就是“小表”，应该作为驱动表。</strong></p><h2 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h2><ul><li>与联接操作一样，集合操作也是对两个输入进行操作，并生成一个虚拟表，有点类似于数学中的合并；</li><li>集合操作的两个输入必须拥有相同的列数，若数据类型不同，MySQL数据库会自动将进行隐式转化，并且结果列的名称由第一个输入决定；</li><li>若SELECT语句中包含LIMIT和ORDER BY子句，要为参与集合操作的各SELECT语句添加括号，否则执行集合查询会产生错误。</li></ul><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from x;</span><br><span class="line">+------+</span><br><span class="line">| a    |</span><br><span class="line">+------+</span><br><span class="line">| a    |</span><br><span class="line">| b    |</span><br><span class="line">| c    |</span><br><span class="line">+------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from y;</span><br><span class="line">+------+</span><br><span class="line">| a    |</span><br><span class="line">+------+</span><br><span class="line">| a    |</span><br><span class="line">| b    |</span><br><span class="line">+------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select a as m from x</span><br><span class="line">    -&gt; union</span><br><span class="line">    -&gt; select 1 as n from dual</span><br><span class="line">    -&gt; union select &#x27;abc&#x27; as o from dual;</span><br><span class="line">+---------------------+</span><br><span class="line">| m                   |</span><br><span class="line">+---------------------+</span><br><span class="line">| a                   |</span><br><span class="line">| b                   |</span><br><span class="line">| c                   |</span><br><span class="line">| 1                   |</span><br><span class="line">| abc                 |</span><br><span class="line">+---------------------+</span><br></pre></td></tr></table></figure><h3 id="UNION-DISTINCT"><a href="#UNION-DISTINCT" class="headerlink" title="UNION [DISTINCT]"></a>UNION [DISTINCT]</h3><p>UNION DISTINCT组合两个输入，并应用DISTINCT过滤重复项。一般省略DISTINCT关键字，直接用UNION，例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from x</span><br><span class="line">    -&gt; union</span><br><span class="line">    -&gt; select * from y;</span><br><span class="line">+------+</span><br><span class="line">| a    |</span><br><span class="line">+------+</span><br><span class="line">| a    |</span><br><span class="line">| b    |</span><br><span class="line">| c    |</span><br><span class="line">+------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>MySQL数据库目前对UNION DISTINCT的实现方式如下：</p><ul><li>创建一张临时表，即虚拟表。</li><li>对这张临时表的列添加唯一索引（Unique Index）。</li><li>将输入的数据插入临时表。</li><li>返回虚拟表。</li></ul><h3 id="UNION-ALL"><a href="#UNION-ALL" class="headerlink" title="UNION ALL"></a>UNION ALL</h3><p>UNION ALL组合两个输入中所有项的结果集，并包含重复的选项，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from x</span><br><span class="line">    -&gt; union all</span><br><span class="line">    -&gt; select * from y;</span><br><span class="line">+------+</span><br><span class="line">| a    |</span><br><span class="line">+------+</span><br><span class="line">| a    |</span><br><span class="line">| b    |</span><br><span class="line">| c    |</span><br><span class="line">| a    |</span><br><span class="line">| b    |</span><br><span class="line">+------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL的联结（Join）算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL主备一致原理</title>
      <link href="/2022/08/31/MySQL%E4%B8%BB%E5%A4%87%E4%B8%80%E8%87%B4%E5%8E%9F%E7%90%86/"/>
      <url>/2022/08/31/MySQL%E4%B8%BB%E5%A4%87%E4%B8%80%E8%87%B4%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>​之前介绍的binlog可以用来归档，也可以用来做主备同步。</p><h1 id="MySQL主备的基本原理"><a href="#MySQL主备的基本原理" class="headerlink" title="MySQL主备的基本原理"></a>MySQL主备的基本原理</h1><h2 id="主备切换流程"><a href="#主备切换流程" class="headerlink" title="主备切换流程"></a>主备切换流程</h2><ol><li>原先的状态时客户端的读写都是直接访问A节点，而节点B是A的备库，B被设置为只读（readonly）模式，只是将A的更新都同步过来，到本地执行。这样可以保持节点B和A的数据是相同的。</li><li>当需要切换的时候，将客户端读写访问的都切换成节点B，而节点A是B的备库。</li></ol><h2 id="主备延迟"><a href="#主备延迟" class="headerlink" title="主备延迟"></a>主备延迟</h2><p>​所谓主备延迟，就是同一个事务，在备库执行完成的时间和主库执行完成的时间之间的差值，可以在备库上执行show slave status命令，它的返回结果里面会显示seconds_behind_master，用于表示当前备库延迟了多少秒。</p><span id="more"></span><p>​seconds_behind_master的计算方法是这样的：</p><ol><li>每个事务的binlog 里面都有一个时间字段，用于记录主库上写入的时间；</li><li>备库取出当前正在执行的事务的时间字段的值，计算它与当前系统时间的差值，得到seconds_behind_master。</li></ol><p>主备延迟最直接的表现是，备库消费中转日志（relay log）的速度，比主库生产binlog的速度要慢。</p><h1 id="update在主备数据库上的执行流程"><a href="#update在主备数据库上的执行流程" class="headerlink" title="update在主备数据库上的执行流程"></a>update在主备数据库上的执行流程</h1><p>​主库接收到客户端的更新请求后，执行内部事务的更新逻辑，同时写binlog。备库B跟主库A之间维持了一个长连接。主库A内部有一个线程，专门用于服务备库B的这个长连接。一个事务日志同步的完整过程是这样的：</p><ol><li>在备库B上通过change master命令，设置主库A的IP、端口、用户名、密码，以及要从哪个位置开始请求binlog，这个位置包含文件名和日志偏移量。</li><li>在备库B上执行start slave命令，这时候备库会启动两个线程：io_thread和sql_thread。其中io_thread负责与主库建立连接。</li><li>主库A校验完用户名、密码后，开始按照备库B传过来的位置，从本地读取binlog，发给B。</li><li>备库B拿到binlog后，写到本地文件，称为<strong>中转日志（relay log）</strong>。</li><li>sql_thread读取中转日志，解析出日志里的命令，并执行。</li></ol><h1 id="binlog的三种格式"><a href="#binlog的三种格式" class="headerlink" title="binlog的三种格式"></a>binlog的三种格式</h1><h2 id="statement格式"><a href="#statement格式" class="headerlink" title="statement格式"></a>statement格式</h2><p>statement记录的就是我们输入的SQL原文，可能会出现：在主库执行这条SQL语句的时候，用的是索引a；而在备库执行这条SQL语句的时候，却使用了索引t_modified。</p><h2 id="row格式"><a href="#row格式" class="headerlink" title="row格式"></a>row格式</h2><p>​row格式的binlog里没有了SQL语句的原文，而是替换成了两个event：Table_map和Delete_rows。</p><ol><li>Table_map event，用于说明接下来要操作的表是test库的表t;</li><li>Delete_rows event，用于定义删除的行为。当我们执行delete语句时，row格式的binlog也会把被删掉的行的整行信息保存起来。</li></ol><p>​当binlog_format使用row格式的时候，binlog里面记录了真实删除行的主键id，这样binlog传到备库去的时候，就肯定会删除id&#x3D;4的行，不会有主备删除不同行的问题。</p><h2 id="mixed格式"><a href="#mixed格式" class="headerlink" title="mixed格式"></a>mixed格式</h2><p>​mixed格式的意思是，MySQL自己会判断这条SQL语句是否可能引起主备不一致，如果有可能，就用row格式，否则就用statement格式。</p><p>​原因是：有些statement格式的binlog可能会导致主备不一致，所以要使用row格式。但是row格式的缺点是，很占空间。比如你用一个delete语句删掉10万行数据，用statement的话就是一个SQL语句被记录到binlog中，占用几十个字节的空间。但如果用row格式的binlog，就要把这10万条记录都写到binlog中。这样做，不仅会占用更大的空间，同时写binlog也要耗费IO资源，影响执行速度。</p><h5 id="MySQL主备，读写分离出现的问题"><a href="#MySQL主备，读写分离出现的问题" class="headerlink" title="MySQL主备，读写分离出现的问题"></a>MySQL主备，读写分离出现的问题</h5><p>​由于主从数据库可能存在延迟，客户端执行完一个更新事务后马上发起查询，如果查询选择的是从库的话，就有可能读到刚刚的事务更新之前的状态。这种情况称为过期读。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL主备一致原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL查询加锁规则</title>
      <link href="/2022/08/30/MySQL%E6%9F%A5%E8%AF%A2%E5%8A%A0%E9%94%81%E8%A7%84%E5%88%99/"/>
      <url>/2022/08/30/MySQL%E6%9F%A5%E8%AF%A2%E5%8A%A0%E9%94%81%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>​间隙锁是一种加在两个索引之间的锁，例如(10, 20)；或者加在第一个索引之前，例如(-∞, 10)；或最后一个索引之后的间隙，例如(20, ∞)。这个间隙可以跨一个索引记录，多个索引记录，甚至是空的。另：间隙锁在可重复读隔离级别下才有效，而在别的隔离级别下只有行锁。<strong>在读提交隔离级别下语句执行过程中加上的行锁，在语句执行完成后，就要把“不满足条件的行”上的行锁直接释放了</strong>，不需要等到事务提交。</p><span id="more"></span><h1 id="加锁规则"><a href="#加锁规则" class="headerlink" title="加锁规则"></a>加锁规则</h1><ol><li>原则1：MySQL查询的加锁单位是前开后闭区间的next-key lock（间隙锁 + 行锁）需要注意的是这个加锁步骤是按照两步来执行的：第一步的间隙锁不是互斥的，也就是别的事务加了这个事务还能加。</li><li>原则2：查找过程中访问到的对象才会加锁。</li><li>优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁。</li><li>优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁。（右闭退化掉，变成左开右开</li></ol><h1 id="等值查询间隙锁"><a href="#等值查询间隙锁" class="headerlink" title="等值查询间隙锁"></a>等值查询间隙锁</h1><p>​<strong>等值查询：通过索引树搜索</strong>，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from t where id&gt;9 and id&lt;12 order by id desc for update;</span><br></pre></td></tr></table></figure><p>​如上查询语句：这个过程是通过索引树的搜索过程得到的，在引擎内部，其实是要找到 id&#x3D;12 的这个值，只是最终没找到，但找到了 (10,15) （开区间是因为上述的优化2）这个间隙。然后向左遍历，在遍历过程中，就不是等值查询了，会扫描到 id&#x3D;5 这一行，所以会加一个 next-key lock (0,5]。</p><h1 id="非唯一索引等值锁"><a href="#非唯一索引等值锁" class="headerlink" title="非唯一索引等值锁"></a>非唯一索引等值锁</h1><p>​建表语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `c` int(11) DEFAULT NULL,</span><br><span class="line">  `d` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `c` (`c`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">insert into t values(0,0,0),(5,5,5),</span><br><span class="line">(10,10,10),(15,15,15),(20,20,20),(25,25,25);</span><br></pre></td></tr></table></figure><p><img src="1.jpg"></p><p>​这里session A要给普通索引c上c&#x3D;5的这一行加上读锁。</p><ol><li>加锁单位是next-key lock，因此会给(0,5]加上next-key lock。</li><li>因为c是普通索引，因此仅访问c&#x3D;5这一条记录是不能马上停下来的，需要向右遍历，查到c&#x3D;10才放弃。根据原则2，访问到的都要加锁，因此要给(5,10]加next-key lock。</li><li>但是同时这个符合优化2：等值判断，向右遍历，最后一个值不满足c&#x3D;5这个等值条件，因此退化成间隙锁(5,10)。</li><li><strong>只有访问到的对象才会加锁</strong>，这个查询使用覆盖索引，并不需要访问主键索引，所以主键索引上没有加任何锁，所以session B的update语句可以执行完成，但session C要插入一个(7,7,7)的记录，就会被session A的间隙锁(5,10)锁住。</li></ol><p>​<strong>这里的关键是lock in share mode只锁覆盖索引，如果是for update会顺便给主键索引上满足条件的行加上行锁。</strong></p><p>​这个例子说明的是，锁是加在索引上的，且只有访问到的索引对象才会加锁。使用覆盖索引就可以返回所有查询的数据的时候，就不会去锁主键索引。</p><h1 id="主键索引范围锁"><a href="#主键索引范围锁" class="headerlink" title="主键索引范围锁"></a>主键索引范围锁</h1><p>​如下语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where id&gt;=10 and id&lt;11 for update;</span><br></pre></td></tr></table></figure><p>​首先使用等值查询找到第一个id&#x3D;10的行，本该是next-key lock(5,10]。 主键id上的等值条件，退化成行锁，只加了id&#x3D;10这一行的行锁。</p><p>​再使用范围查询判断，往后继续找，找到id&#x3D;15这一行停下来，因此需要加next-key lock(10,15]。</p><h1 id="非唯一索引范围锁"><a href="#非唯一索引范围锁" class="headerlink" title="非唯一索引范围锁"></a>非唯一索引范围锁</h1><p>​上面一个例子用到的索引是主键索引，下面这一个语句是普通索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where c&gt;=10 and c&lt;11 for update;</span><br></pre></td></tr></table></figure><p>​加锁规则跟非唯一索引等值锁唯一的不同是：在第一次用c&#x3D;10定位记录的时候，索引c上加了(5,10]这个next-key lock后，由于索引c是非唯一索引，没有优化规则，也就是说不会蜕变为行锁，最终加的锁是，索引c上的(5,10] 和(10,15] 这两个next-key lock。</p><h1 id="limit-语句加锁"><a href="#limit-语句加锁" class="headerlink" title="limit 语句加锁"></a>limit 语句加锁</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line"></span><br><span class="line">delete from t where c=10 limit 2;</span><br></pre></td></tr></table></figure><p>这里在遍历到(c&#x3D;10, id&#x3D;30)这一行之后，满足条件的语句已经有两条，循环就结束了。就不再往后加锁了。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL查询加锁规则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引失效</title>
      <link href="/2022/08/28/MySQL%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/"/>
      <url>/2022/08/28/MySQL%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/</url>
      
        <content type="html"><![CDATA[<h1 id="一：条件字段函数操作"><a href="#一：条件字段函数操作" class="headerlink" title="一：条件字段函数操作"></a>一：条件字段函数操作</h1><p>​看如下语句：t_modified字段上建有索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*) from tradelog where month(t_modified)=7;</span><br></pre></td></tr></table></figure><p>​此时这条语句是不会走t_modified字段索引的，而where t_modified&#x3D;’2018-7-1’的时候可以用上索引。原因如下：</p><span id="more"></span><p><img src="1.jpg"></p><p>​当条件用的是where t_modified&#x3D;’2018-7-1’的话，引擎就会按照上面绿色箭头的路线，快速定位到 t_modified&#x3D;’2018-7-1’需要的结果。但是，如果计算month()函数的话，你会看到传入7的时候，在树的第一层就不知道该怎么办了。</p><p>​<strong>对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。</strong>然后优化器对比索引大小，选择一个索引较小的走全索引扫描。</p><h1 id="二：隐式类型转换"><a href="#二：隐式类型转换" class="headerlink" title="二：隐式类型转换"></a>二：隐式类型转换</h1><p>如下例子：</p><p>​字段交易编号tradeid：varchar(32)上建有索引，执行如下语句发现走的全表扫描：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tradelog where tradeid=110717;</span><br></pre></td></tr></table></figure><p>​原因是tradeid的字段类型是varchar(32)，而输入的参数却是整型，所以需要做类型转换。<strong>在MySQL中，字符串和数字做比较的话，是将字符串转换成数字。</strong></p><h1 id="三：隐式字符编码转换"><a href="#三：隐式字符编码转换" class="headerlink" title="三：隐式字符编码转换"></a>三：隐式字符编码转换</h1><p>​在进行连表查询时，当两个表的字符集不同时，如一个是utf8，一个是utf8mb4，就用不上用不上关联字段的索引。如下例子：</p><p>​交易日志表tradelog（utf8mb4）和交易详情表trade_detail（utf8）（tradeid字段有索引）连表查询，现在要查询id&#x3D;2（tradelog）的交易的所有操作步骤信息（trade_detail）sql语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select d.* from tradelog l, trade_detail d where d.tradeid=l.tradeid and l.id=2; </span><br></pre></td></tr></table></figure><p><img src="2.jpg"></p><p>​</p><ol><li>第一行显示优化器会先在交易记录表tradelog上查到id&#x3D;2的行，这个步骤用上了主键索引，rows&#x3D;1表示只扫描一行；</li><li>第二行key&#x3D;NULL，表示没有用上交易详情表trade_detail上的tradeid索引，进行了全表扫描。</li></ol><p>​在这个执行计划里，是从tradelog表中取tradeid字段，再去trade_detail表里查询匹配字段。因此，我们把<strong>tradelog称为驱动表</strong>，<strong>把trade_detail称为被驱动表</strong>，<strong>把tradeid称为关联字段</strong>。</p><p>执行流程如下：</p><ul><li>第1步，是根据id在tradelog表里找到L2这一行；</li><li>第2步，是从L2中取出tradeid字段的值；</li><li>第3步，是根据tradeid值到trade_detail表中查找条件匹配的行。explain的结果里面第二行的key&#x3D;NULL表示的就是，这个过程是通过遍历主键索引的方式，一个一个地判断tradeid的值是否匹配。</li></ul><p>​表trade_detail里tradeid字段上是有索引的，但是上述步骤3却没有快速定位到结果，而是一个一个地判断tradeid的值是否匹配。</p><p>​字符编码转换规则：字符集utf8mb4是utf8的超集，所以当这两个类型的字符串在做比较的时候，MySQL内部的操作是，<strong>先把utf8字符串转成utf8mb4字符集</strong>，再做比较。</p><p>​隐式字符编码转导致索引失效的根本原因是<strong>连接过程中要求在被驱动表的索引字段上加函数操作</strong>，导致对被驱动表做全表扫描。<strong>如果函数转换发生在驱动表，也就是说函数加载输入参数上，这样是可以用上被驱动表的索引的。</strong></p><p>​<strong>解决方法是：</strong></p><p>​改成相同的字符集</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table trade_detail modify tradeid varchar(32) CHARACTER SET utf8mb4 default null;</span><br></pre></td></tr></table></figure><p>​如果数据量比较大， 或者业务上暂时不能做这个DDL的话，那就只能采用修改SQL语句的方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select d.* from tradelog l , trade_detail d where d.tradeid=CONVERT(l.tradeid USING utf8) and l.id=2; </span><br></pre></td></tr></table></figure><p>​将驱动表上的输入给被驱动表索引的字符类型改为utf8，就避免了被驱动表上的字符编码转换。</p><h1 id="四：Like模糊查询"><a href="#四：Like模糊查询" class="headerlink" title="四：Like模糊查询"></a>四：Like模糊查询</h1><p>尽量避免%XXX%，用不到索引，%在前面不能用到索引，如%ABC不能用索引，而ABC%能用索引</p>]]></content>
      
      
      <categories>
          
          <category> MySQL数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL索引失效 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL优雅地使用count（*）和Order By</title>
      <link href="/2022/08/21/MySQL%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8count%EF%BC%88-%EF%BC%89%E5%92%8COrder%20By/"/>
      <url>/2022/08/21/MySQL%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8count%EF%BC%88-%EF%BC%89%E5%92%8COrder%20By/</url>
      
        <content type="html"><![CDATA[<p>​在实际开发中经常经常需要计算一个表的行数，但是随着系统中记录数越来越多，select count(*) from t 语句执行得也会越来越慢，</p><h1 id="count-的实现方式"><a href="#count-的实现方式" class="headerlink" title="count(*)的实现方式"></a>count(*)的实现方式</h1><ul><li>MyISAM引擎把一个表的总行数存在了磁盘上，因此执行count(*)的时候会直接返回这个数，效率很高；</li><li>而InnoDB引擎就麻烦了，它执行count(*)的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</li></ul><p>​InnoDB的事务设计默认的隔离级别是可重复读，在代码上就是通过多版本并发控制，也就是MVCC来实现的，每一行记录都要判断自己是否对这个会话可见，对于count(*)请求来说，InnoDB会遍历全表把数据一行一行地读出依次判断，因此对于不同事务中的结果可能不一样。</p><span id="more"></span><h1 id="优化方法："><a href="#优化方法：" class="headerlink" title="优化方法："></a>优化方法：</h1><p>​由于MVCC的存在，Inoonodb没办法自己保存一个表中行数的数据，但是我们可以自己计数。具体方法如下：</p><h2 id="用缓存系统保存计数"><a href="#用缓存系统保存计数" class="headerlink" title="用缓存系统保存计数"></a>用缓存系统保存计数</h2><p>​用一个Redis服务来保存这个表的总行数。并定期将redis中的值定期地持久化存储起来，如果redis异常重启了，就到数据库里面单独执行一次count(*)获取真实的行数，再把这个值写回到Redis里。但是仍然会出现并发时的数据不一致问题，比如查到了新增加的记录，但是redis中并没有加一。</p><h2 id="在数据库保存计数"><a href="#在数据库保存计数" class="headerlink" title="在数据库保存计数"></a>在数据库保存计数</h2><p>​把这个计数直接放到数据库里单独的一张计数表中，这时就不会出现上述的数据不一致原因，因为innodb的默认隔离级别是可重复读，也就是说只有当将表中的数据加了一，数据也插入了，这个事务完整地提交了，这两个操作才对其他的事务可见。这就解决了数据不一致问题。</p><h2 id="不同count用法"><a href="#不同count用法" class="headerlink" title="不同count用法"></a>不同count用法</h2><p>count(*)、count(主键id)、count(字段)和count(1)等不同用法的性能，有哪些差别？</p><p>​count()是一个聚合函数，对于返回的结果集，一行行地判断，如果count函数的参数不是NULL，累计值就加1，否则不加。最后返回累计值。</p><p>​count(*)、count(主键id)和count(1) 都表示返回满足条件的结果集的总行数；</p><p>​而count(字段)，则表示返回满足条件的数据行里面，参数“字段”不为NULL的总个数。</p><h3 id="count-主键id"><a href="#count-主键id" class="headerlink" title="count(主键id):"></a>count(主键id):</h3><p>​InnoDB引擎会遍历整张表，把每一行的id值都取出来，返回给server层。server层拿到id后，判断是不可能为空的，就按行累加。</p><h3 id="count-1"><a href="#count-1" class="headerlink" title="count(1):"></a>count(1):</h3><p>​InnoDB引擎遍历整张表，但不取值。server层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。</p><p>​count(1)执行得要比count(主键id)快。因为从引擎返回id会涉及到解析数据行，以及拷贝字段值的操作。</p><h3 id="count-字段"><a href="#count-字段" class="headerlink" title="count(字段):"></a>count(字段):</h3><ol><li><p>如果这个“字段”是定义为not null的话，一行行地从记录里面读出这个字段，判断不能为null，按行累加；</p></li><li><p>如果这个“字段”定义允许为null，那么执行的时候，判断到有可能是null，还要把值取出来再判断一下，不是null才累加。</p></li></ol><h3 id="count-："><a href="#count-：" class="headerlink" title="**count(*)**："></a>**count(*)**：</h3><p>​并不会把全部字段取出来，而是专门做了优化，不取值。count(*)肯定不是null，按行累加。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><strong>按照效率排序的话，count(字段)&lt;count(主键id)&lt;count(1)≈count(*)</strong></p><h1 id="MySQL-orderby工作流程"><a href="#MySQL-orderby工作流程" class="headerlink" title="MySQL orderby工作流程"></a>MySQL orderby工作流程</h1><p>​在使用order时，为了避免全表扫描。需要加索引。在执行时，MySQL会给每个线程分配一块内存用于排序，称为sort_buffer。</p><pre><code>     执行流程分析举例：select city,name,age from t where city=&#39;杭州&#39; order by name limit 1000 ;</code></pre><h2 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h2><p>流程如下：</p><ol><li>初始化sort_buffer，确定放入name、city、age这三个字段；</li><li><strong>从索引city找到第一个满足city&#x3D;’杭州’条件的主键id。</strong></li><li>到主键id索引取出整行，取name、city、age三个字段的值，存入sort_buffer中；</li><li>从索引city取下一个记录的主键id；</li><li>重复步骤3、4直到city的值不满足查询条件为止</li><li>按照排序结果取前1000行返回给客户端。</li></ol><p>​按name排序”这个动作如果要排序的数据量小于sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。外部排序一般使用归并排序算法。<strong>MySQL将需要排序的数据分成n份，每一份单独排序后存在这些临时文件中。然后把这n个有序文件再合并成一个有序的大文件。</strong></p><h2 id="rowid排序"><a href="#rowid排序" class="headerlink" title="rowid排序"></a>rowid排序</h2><p>​在全字段排序中，只对原表的数据读了一遍，剩下的操作都是在sort_buffer和临时文件中执行的。如果查询要返回的字段很多的话，sort_buffer里面要放的字段数太多，并且超过max_length_for_sort_data，就会采用rowid排序算法：<strong>只有要排序的列（即name字段）和主键id放入sort_buffer中</strong>。但是排序的结果就因为少了city和age字段的值，不能直接返回了</p><p>​流程如下：</p><ol><li>初始化sort_buffer，确定放入两个字段，即name和id；</li><li>从索引city找到第一个满足city&#x3D;’杭州’条件的主键id；</li><li>到主键id索引取出整行，取name、id这两个字段，存入sort_buffer中；</li><li>从索引city取下一个记录的主键id；</li><li>重复步骤3、4直到不满足city&#x3D;’杭州’条件为止；</li><li>对sort_buffer中的数据按照字段name进行排序；</li><li>遍历排序结果，取前1000行，并按照id的值回到原表中取出city、name和age三个字段返回给客户端。</li></ol><h2 id="全字段排序-与-rowid排序对比"><a href="#全字段排序-与-rowid排序对比" class="headerlink" title="全字段排序 与 rowid排序对比"></a>全字段排序 与 rowid排序对比</h2><p>​对比全字段排序，<strong>rowid排序多访问了一次表t的主键索引</strong>，就是步骤7。</p><p>​相同的地方就是两者都在一个<strong>临时表sort_buffer</strong>中进行排序</p><p>​如果MySQL实在是担心排序内存太小，会影响排序效率，才会采用rowid排序算法，这样排序过程中一次可以排序更多行，但是需要再回到原表去取数据。</p><p>​如果MySQL认为内存足够大，会优先选择全字段排序，把需要的字段都放到sort_buffer中，这样排序后就会直接从内存里面返回查询结果了，不用再回到原表去取数据。</p><h2 id="不需要排序的特殊情况"><a href="#不需要排序的特殊情况" class="headerlink" title="不需要排序的特殊情况"></a>不需要排序的特殊情况</h2><p>​上面那个例子中创建一个city和name的联合索引，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t add index city_user(city, name);</span><br></pre></td></tr></table></figure><p>​那么就能保证从city这个索引上取出来的行，天然就是按照name递增排序的。</p><p>​这样整个查询过程的流程就变成了：</p><ol><li>从索引(city,name)找到第一个满足city&#x3D;’杭州’条件的主键id；</li><li>到主键id索引取出整行，取name、city、age三个字段的值，作为结果集的一部分直接返回；</li><li>从索引(city,name)取下一个记录主键id；</li><li>重复步骤2、3，直到查到第1000条记录，或者是不满足city&#x3D;’杭州’条件时循环结束。</li></ol><p>​上面流程还可以继续优化为覆盖索引，创建一个city、name和age的联合索引：<strong>该索引上的信息足够满足查询请求，不需要再回到主键索引上去取数据。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t add index city_user_age(city, name, age);</span><br></pre></td></tr></table></figure><p>​这时，对于city字段的值相同的行来说，还是按照name字段的值递增排序的，此时的查询语句也就不再需要排序了。这样整个查询语句的执行流程就变成了：</p><ol><li>从索引(city,name,age)找到第一个满足city&#x3D;’杭州’条件的记录，取出其中的city、name和age这三个字段的值，作为结果集的一部分直接返回；</li><li>从索引(city,name,age)取下一个记录，同样取出这三个字段的值，作为结果集的一部分直接返回；</li><li>重复执行步骤2，直到查到第1000条记录，或者是不满足city&#x3D;’杭州’条件时循环结束。</li></ol>]]></content>
      
      
      <categories>
          
          <category> MySQL数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL优雅地使用count（*)和Order By </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL主键不连续原因</title>
      <link href="/2022/08/21/MySQL%E4%B8%BB%E9%94%AE%E4%B8%8D%E8%BF%9E%E7%BB%AD%E5%8E%9F%E5%9B%A0/"/>
      <url>/2022/08/21/MySQL%E4%B8%BB%E9%94%AE%E4%B8%8D%E8%BF%9E%E7%BB%AD%E5%8E%9F%E5%9B%A0/</url>
      
        <content type="html"><![CDATA[<p>自增主键可以让主键索引尽量地保持递增顺序插入，避免了页分裂，因此索引更紧凑。</p><h3 id="自增值保存策略"><a href="#自增值保存策略" class="headerlink" title="自增值保存策略"></a><strong>自增值保存策略</strong></h3><p>表的结构定义存放在后缀名为.frm的文件中，但是并不会保存自增值。不同的引擎对于自增值的保存策略不同。</p><ul><li><p>MyISAM引擎的自增值保存在数据文件中。</p></li><li><p>在MySQL 5.7及之前的版本，自增值保存在内存里，并没有持久化。每次重启后，第一次打开表的时候，都会去找自增值的最大值max(id)，然后将max(id)+1作为这个表当前的自增值。﻿</p></li><li><p>在MySQL 8.0版本，将自增值的变更记录在了redo log中，重启的时候依靠redo log恢复重启之前的值。</p></li></ul><span id="more"></span><h3 id="自增值修改机制"><a href="#自增值修改机制" class="headerlink" title="自增值修改机制"></a><strong>自增值修改机制</strong></h3><p>在MySQL里面，如果字段id被定义为AUTO_INCREMENT，在插入一行数据的时候，自增值的行为如下：</p><ol><li>如果插入数据时id字段指定为0、null 或未指定值，那么就把这个表当前的 AUTO_INCREMENT值填到自增字段；</li><li>如果插入数据时id字段指定了具体的值，就直接使用语句里指定的值。</li></ol><p>根据要插入的值和当前自增值的大小关系，自增值的变更结果也会有所不同。假设，某次要插入的值是X，当前的自增值是Y。</p><ol><li>如果X&lt;Y，那么这个表的自增值不变；</li><li>如果X≥Y，就需要把当前自增值修改为新的自增值。</li></ol><p><strong>新的自增值生成算法是</strong>：从auto_increment_offset开始，以auto_increment_increment为步长，持续叠加，直到找到第一个大于X的值，作为新的自增值。</p><p>其中，auto_increment_offset 和 auto_increment_increment是两个系统参数，分别用来表示自增的初始值和步长，默认值都是1。</p><h3 id="主键不连续原因："><a href="#主键不连续原因：" class="headerlink" title="主键不连续原因："></a><strong>主键不连续原因：</strong></h3><ol><li><p>不断insert的过程中出现某些字段<strong>唯一键冲突，或者提交失败事务回滚了</strong>没有插入成功，但是自增主键自增了却没有回退，导致下一次成功插入的时候中间就缺了一个。</p></li><li><p>对于批量插入数据的语句，MySQL有一个批量申请自增id的策略：</p><ol><li>语句执行过程中，第一次申请自增id，会分配1个；</li><li>1个用完以后，这个语句第二次申请自增id，会分配2个；</li><li>2个用完以后，还是这个语句，第三次申请自增id，会分配4个；</li><li>依此类推，同一个语句去申请自增id，每次申请到的自增id个数都是上一次的两倍。</li></ol><p>这样当插入的行数据不够时就会出现自增id的浪费，导致自增id不是连续的。</p></li></ol><h3 id="自增值为什么不能回退："><a href="#自增值为什么不能回退：" class="headerlink" title="自增值为什么不能回退："></a><strong>自增值为什么不能回退</strong>：</h3><p>假设有两个并行执行的事务，在申请自增值的时候，为了避免两个事务申请到相同的自增id，肯定要加锁，然后顺序申请。一个获取主键2 一个获取主键3 但是如果一个事务执行失败，另一个执行成功的，自增主键要回退到2，那么下一个事务就会导致主键冲突</p><p>而为了解决这个主键冲突，有两种方法：</p><ol><li>每次申请id之前，先判断表里面是否已经存在这个id。如果存在，就跳过这个id。但是，这个方法的成本很高。因为，本来申请id是一个很快的操作，现在还要再去主键索引树上判断id是否存在。</li><li>把自增id的锁范围扩大，必须等到一个事务执行完成并提交，下一个事务才能再申请自增id。这个方法的问题，就是锁的粒度太大，系统并发能力大大下降。</li></ol><p>可见，这两个方法都会导致性能问题。造成这些麻烦的罪魁祸首，就是我们假设的这个“允许自增id回退”的前提导致的。</p><p>因此，InnoDB放弃了这个设计，语句执行失败也不回退自增id。也正是因为这样，所以才只保证了自增id是递增的，但不保证是连续的。</p><h3 id="特殊情况下的insert语句"><a href="#特殊情况下的insert语句" class="headerlink" title="特殊情况下的insert语句"></a>特殊情况下的insert语句</h3><p>​在上面提到，MySQL对自增主键锁做了优化，尽量在申请到自增id以后，就释放自增锁。这个结论对于普通的insert语句”才有效。</p><p>​还有些insert语句是属于“特殊情况”的，在执行过程中需要给其他资源加锁，或者无法在申请到自增id以后就立马释放自增锁。</p><h4 id="insert-循环写入"><a href="#insert-循环写入" class="headerlink" title="insert 循环写入"></a>insert 循环写入</h4><p>​比如：insert … select 是很常见的在两个表之间拷贝数据的方法。但需要注意的是，在可重复读隔离级别下，这个语句会给select的表里扫描到的记录和间隙加读锁。而如果insert和select的对象是同一个表，则有可能会造成循环写入。这种情况下，我们需要引入用户临时表来做优化，至于为什么需要临时表，原因是这类一边遍历数据，一边更新数据的情况，如果读出来的数据直接写回原表，就可能在遍历过程中，读到刚刚插入的记录，新插入的记录如果参与计算逻辑，就跟语义不符。。</p><h4 id="insert-唯一键冲突"><a href="#insert-唯一键冲突" class="headerlink" title="insert 唯一键冲突"></a>insert 唯一键冲突</h4><p>​在执行insert插入语句时，如果发生主键冲突，并不只是简单地报错返回，还在冲突的索引上加了共享next-key lock（读锁）。但是当两个事务同时插入出现主键冲突的话，两个事务都会加上读锁。就会陷入到相互等待的死锁情况。所以碰到由于唯一键约束导致报错后，要尽快提交或回滚事务，避免加锁时间过长。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL主键不连续原因 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的删除与空间回收</title>
      <link href="/2022/08/21/MySQL%E7%9A%84%E5%88%A0%E9%99%A4%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%9B%9E%E6%94%B6/"/>
      <url>/2022/08/21/MySQL%E7%9A%84%E5%88%A0%E9%99%A4%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%9B%9E%E6%94%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="问题发现"><a href="#问题发现" class="headerlink" title="问题发现"></a>问题发现</h1><p>​在使用MySQL数据库中经常会出现删除了表数据，但是表的大小并没有变小。并且删除了行数据之后，下次再新增数据时，自增主键不连续。</p><h1 id="数据删除流程"><a href="#数据删除流程" class="headerlink" title="数据删除流程"></a>数据删除流程</h1><p>​InnoDB里的数据都是用B+树的结构组织的。如下图所示;</p><span id="more"></span><p><img src="1.jpg" alt="1"></p><p>​1. 删掉单个记录，InnoDB引擎只会把这个记录标记为删除。如果之后要再插入一个ID在300和600之间的记录时，可能会复用这个位置。但是，磁盘文件的大小并不会缩小。</p><p>​2. 如果删掉了一个数据页上的所有记录，整个数据页就可以被复用。但是，<strong>数据页的复用跟记录的复用是不同的。</strong>记录的复用，只限于符合范围条件的数据。而当整个页从B+树里面摘掉以后，可以复用到任何位置。如果相邻的两个数据页利用率都很小，系统就会把这两个页上的数据合到其中一个页上，另外一个数据页就被标记为可复用。</p><p>​3. 如果delete命令把整个表的数据删除，那么所有的数据页都会被标记为可复用。但是磁盘上，文件不会变小。</p><p>​所以：delete命令其实只是把记录的位置，或者数据页标记为了“可复用”，但磁盘文件的大小是不会变的。也就是说，通过delete命令是不能回收表空间的。这些可以复用，而没有被使用的空间，看起来就像是“空洞”。</p><p>​<strong>插入数据也会造成空洞：</strong>如果数据是按照索引递增顺序插入的，那么索引是紧凑的。但如果数据是随机插入的，就可能造成索引的数据页分裂。</p><h1 id="去除数据空洞"><a href="#去除数据空洞" class="headerlink" title="去除数据空洞"></a>去除数据空洞</h1><h2 id="重建表"><a href="#重建表" class="headerlink" title="重建表"></a>重建表</h2><p>​<strong>使用alter table A engine&#x3D;InnoDB命令来重建表</strong>。MySQL会自动完成转存数据、交换表名、删除旧表的操作。显然，花时间最多的步骤是往临时表插入数据的过程，如果在这个过程中，有新的数据要写入到表A的话，就会造成数据丢失。因此，在整个DDL过程中，表A中不能有更新。也就是说，这个DDL不是Online的。<strong>MySQL 5.6版本开始引入的Online DDL，对这个操作流程做了优化。</strong></p><p>​<strong>Online DDL之后，重建表的流程：</strong></p><ol><li>建立一个临时文件，扫描表A主键的所有数据页；</li><li>用数据页中表A的记录生成B+树，存储到临时文件中；</li><li>生成临时文件的过程中，<strong>将所有对A的操作记录在一个日志文件（row log）中</strong>。</li><li>临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表A相同的数据文件。</li><li>用临时文件替换表A的数据文件。</li></ol><p>​<strong>重建表中的锁降级：</strong></p><p>alter语句在启动的时候需要获取MDL写锁，但是这个写锁在真正拷贝数据之前就退化成读锁了。MDL读锁就不会阻塞增删改操作。</p><p>​<strong>三种重建表的的区别</strong>：</p><ul><li>alter table t engine &#x3D; InnoDB（也就是recreate）默认的就是上面图4的流程了；</li><li>analyze table t 其实不是重建表，只是对表的索引信息做重新统计，没有修改数据，这个过程中加了MDL读锁；</li><li>optimize table t 等于recreate+analyze。</li></ul><h2 id="创建索引的Inplace和Online方式"><a href="#创建索引的Inplace和Online方式" class="headerlink" title="创建索引的Inplace和Online方式"></a>创建索引的Inplace和Online方式</h2><p><strong>1.Inplace方式：</strong></p><p>​这是原生MySQL 5.5，以及innodb_plugin中提供的创建索引的方式。所谓Inplace，也就是索引创建在原表上直接进行，不会拷贝临时表。相对于Copy Table方式，这是一个进步。Inplace方式创建索引，创建过程中，<strong>原表同样可读的，但是不可写。</strong></p><p><strong>2.Online方式</strong><br>        这是MySQL 5.6.7中提供的创建索引的方式。无论是Copy Table方式，还是Inplace方式，创建索引的过程中，原表只能允许读取，不可写。对应用有较大的限制，因此MySQL最新版本中，InnoDB支持了所谓的Online方式创建索引。</p><p>​InnoDB的Online Add Index，首先是Inplace方式创建索引，无需使用临时表。在遍历聚簇索引，收集记录并插入到新索引的过程中，原表记录可修改。<strong>而修改的记录保存在Row Log中</strong>。当聚簇索引遍历完毕，并全部插入到新索引之后，重放Row Log中的记录修改，使得新索引与聚簇索引记录达到一致状态。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL的删除与空间回收 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发-锁全解</title>
      <link href="/2022/08/20/%E5%B9%B6%E5%8F%91-%E9%94%81%E5%85%A8%E8%A7%A3/"/>
      <url>/2022/08/20/%E5%B9%B6%E5%8F%91-%E9%94%81%E5%85%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="公平锁-x2F-非公平锁"><a href="#公平锁-x2F-非公平锁" class="headerlink" title="公平锁&#x2F;非公平锁"></a>公平锁&#x2F;非公平锁</h2><p>公平锁指多个线程按照申请锁的顺序来获取锁。非公平锁指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。可能会造成优先级反转或者饥饿现象。</p><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p><strong>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁，典型的synchronized、ReentrantLock</strong></p><h2 id="独享锁-x2F-共享锁"><a href="#独享锁-x2F-共享锁" class="headerlink" title="独享锁&#x2F;共享锁"></a>独享锁&#x2F;共享锁</h2><ul><li>独享锁：是指该锁一次只能被一个线程所持有。</li><li>共享锁：是该锁可被多个线程所持有。</li></ul><h2 id="互斥锁-x2F-读写锁"><a href="#互斥锁-x2F-读写锁" class="headerlink" title="互斥锁&#x2F;读写锁"></a>互斥锁&#x2F;读写锁</h2><p><strong>上面讲的独享锁&#x2F;共享锁就是一种广义的说法，互斥锁&#x2F;读写锁就是其具体的实现</strong></p><h2 id="乐观锁-x2F-悲观锁"><a href="#乐观锁-x2F-悲观锁" class="headerlink" title="乐观锁&#x2F;悲观锁"></a>乐观锁&#x2F;悲观锁</h2><ol><li>乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。</li><li>悲观锁认为对于同一个人数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出现问题。</li><li>乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作时没有事情的。</li><li>悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁带来大量的性能提升。</li><li>悲观锁在Java中的使用，就是利用各种锁。乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子类操作的更新。重量级锁是悲观锁的一种，自旋锁、轻量级锁与偏向锁属于乐观锁</li></ol><h2 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h2><ol><li>分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其1.7并发的实现就是通过分段锁的形式来哦实现高效的并发操作。</li><li>以ConcurrentHashMap来说一下分段锁的含义以及设计思想，ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是ReentrantLock（Segment继承了ReentrantLock）</li><li>当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。</li><li>分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。</li></ol><h2 id="偏向锁-x2F-轻量级锁-x2F-重量级锁"><a href="#偏向锁-x2F-轻量级锁-x2F-重量级锁" class="headerlink" title="偏向锁&#x2F;轻量级锁&#x2F;重量级锁"></a>偏向锁&#x2F;轻量级锁&#x2F;重量级锁</h2><ol><li>这三种锁是锁的状态，并且是针对Synchronized。在Java5通过引入锁升级的机制来实现高效Synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。</li><li>偏向锁的适用场景：始终只有一个线程在执行代码块，在它没有执行完释放锁之前，没有其它线程去执行同步快，在锁无竞争的情况下使用，一旦有了竞争就升级为轻量级锁，升级为轻量级锁的时候需要撤销偏向锁，撤销偏向锁的时候会导致stop the  word操作；在有锁竞争时，偏向锁会多做很多额外操作，尤其是撤销偏向锁的时候会导致进入安全点，安全点会导致stw，导致性能下降，这种情况下应当禁用。</li><li>轻量级锁是指当锁是偏向锁的时候，被另一个线程锁访问，偏向锁就会升级为轻量级锁，其他线程会通过自选的形式尝试获取锁，不会阻塞，提高性能。</li><li>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。</li></ol><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><ol><li>在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。</li><li>自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。</li><li>自旋锁尽可能的减少线程的阻塞，适用于锁的竞争不激烈，且占用锁时间非常短的代码来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗。</li><li>但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适用使用自旋锁了，因为自旋锁在获取锁前一直都是占用cpu做无用功，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要cpu的线程又不能获取到cpu，造成cpu的浪费。</li></ol><h2 id="读写锁（ReentrantReadWriteLock）"><a href="#读写锁（ReentrantReadWriteLock）" class="headerlink" title="读写锁（ReentrantReadWriteLock）"></a>读写锁（ReentrantReadWriteLock）</h2><p>Java中的锁——Lock和synchronized中介绍的ReentrantLock和synchronized基本上都是<strong>排它锁</strong>，意味着这些锁在同一时刻只允许一个线程进行访问，而<strong>读写锁在同一时刻可以允许多个读线程访问</strong>，<strong>在写线程访问的时候其他的读线程和写线程都会被阻塞</strong>。<strong>读写锁维护一对锁(读锁和写锁)，通过锁的分离，使得并发性提高</strong>。</p><p>并发包中对ReadWriteLock接口的实现类是<strong>ReentrantReadWriteLock</strong>，这个实现类具有下面三个特点<br>①具有与ReentrantLock类似的公平锁和非公平锁的实现：默认的支持非公平锁，对于二者而言，非公平锁的吞吐量由于公平锁；<br>②支持重入：读线程获取读锁之后能够再次获取读锁，写线程获取写锁之后能再次获取写锁，<strong>也可以获取读锁。</strong><br>③锁能降级：遵循获取写锁的情况下再获取读锁，释放写锁的顺序，即写锁能够降级为读锁</p><p>ReadWriteLock接口中只有两个方法，分别是readLock和writeLock分别可以获取到读锁和写锁，再分别可以使用readLock.lock和unlock来加锁和释放锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 维护了readlock和writelock</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line"><span class="comment">/** Inner class providing writelock */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line"><span class="comment">/** Performs all synchronization mechanics */</span></span><br><span class="line"><span class="keyword">final</span> Sync sync; <span class="comment">// 同样的是sync 继承aqs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可惜的是state依然是一个， 但是不慌</span></span><br><span class="line"><span class="comment">// 高16位表示读状态，低16位表示获取到写锁的线程的可重入锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHARED_SHIFT</span>   <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 共享锁的读锁的状态单位值65536</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHARED_UNIT</span>    <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line"><span class="comment">// 共享锁线程最大个数65536</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_COUNT</span>      <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 排它锁写锁掩码，二进制 15个1</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EXCLUSIVE_MASK</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 返回读锁线程数</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sharedCount</span><span class="params">(<span class="type">int</span> c)</span>    &#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line"><span class="comment">// 返回写锁可重入个数</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">exclusiveCount</span><span class="params">(<span class="type">int</span> c)</span> &#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br></pre></td></tr></table></figure><p>读写锁同步器的同步状态就是读写锁的读写状态，只是读写锁的同步器需要在同步状态上维护多个读线程和写线程的状态。<strong>使用按位切割的方式将一个整形变量按照高低16位切割成两个部分</strong>。对比下图，<strong>低位值表示当前获取写锁的线程重入两次</strong>，<strong>高位的值表示当前获取读锁的线程重入一次</strong>。读写锁的获取伴随着读写状态值的更新。当低位为0000_0000_0000_0000的时候表示写锁已经释放，当高位为0000_0000_0000_0000的时候表示读锁已经释放。</p><p>从下面的划分得到：当state值不等于0的时候，如果写状态(state &amp; 0x0000FFFF)等于0的话，读状态是大于0的，表示读锁被获取；如果写状态不等于0的话，读锁没有被获取。这个特点也在源码中实现。</p><p><img src="1.png"></p><h3 id="写锁writeLock"><a href="#写锁writeLock" class="headerlink" title="写锁writeLock"></a>写锁writeLock</h3><p>①读写锁是支持重入的锁，而对于<strong>写锁而言还是排他的</strong>，这样避免多个线程同时去修改临界资源导致程序出现错误。如果当前线程已经获取了写锁，则按照上面读写状态的设计增加写锁状态的值；如果当前线程在获取写锁的时候，读锁已经被获取或者该线程之前已经有别的线程获取到写锁，当前线程就会进入等待状态。</p><p>②写锁的释放源码<br>写锁的释放和ReentrantLock的锁释放思路基本相同，每次释放都是减少写状态，直到写状态值为0(exclusiveCount(nextc) &#x3D;&#x3D; 0)的时候释放写锁，后续阻塞等待的读写线程可以继续竞争锁。</p><h3 id="读锁readLock"><a href="#读锁readLock" class="headerlink" title="读锁readLock"></a>读锁readLock</h3><p>①读锁是同样是支持重入的，除此之外也是共享式的，能够被多个线程获取。在同一时刻的竞争队列中，如果没有写线程想要获取读写锁，那么读锁总会被读线程获取到(然后更新读状态的值)。每个读线程都可以重入的获取读锁，而对应的获取次数保存在本地线程中，由线程自身维护该值。</p><p>②获取读锁的条件：其他线程已经获取了写锁，则当前线程获取读锁会失败而进入等待状态；如果<strong>当前线程获取了写锁或者写锁没有被获取，那么就可以获取到读锁</strong>，并更细同步状态(读状态值)。</p><p>③读锁的每次释放都是减少读状态，</p><h2 id="锁的降级"><a href="#锁的降级" class="headerlink" title="锁的降级"></a>锁的降级</h2><p>锁降级的概念：如果当先线程是写锁的持有者，并保持获得写锁的状态，同时又获取到读锁，然后释放写锁的过程。(注意不同于这样的分段过程：当前线程拥有写锁，释放掉写锁之后再获取读锁的过程，这种分段过程不能称为锁降级)。</p><h2 id="Java锁总结"><a href="#Java锁总结" class="headerlink" title="Java锁总结"></a>Java锁总结</h2><p><strong>Java锁机制可归为Sychornized锁和Lock锁两类。Synchronized是基于JVM来保证数据同步的，而Lock则是硬件层面，依赖特殊的CPU指令来实现数据同步的。</strong></p><ul><li>Synchronized是一个非公平、悲观、独享、互斥、可重入的重量级锁。</li><li>ReentrantLock是一个默认非公平但可实现公平的、悲观、独享、互斥、可重入、重量级锁。</li><li>ReentrantReadWriteLock是一个默认非公平但可实现公平的、悲观、写独享、读共享、读写、可重入、重量级锁。</li></ul><p><a href="https://www.cnblogs.com/cscw/p/13769404.html#7-%E5%9F%BA%E4%BA%8Evolatile--cas-%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86">参考</a></p><p><a href="https://cloud.tencent.com/developer/article/2118483">读写锁参考</a></p>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java的锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL中Inoodb的MVCC版本控制原理</title>
      <link href="/2022/08/20/MySQL%E4%B8%ADInoodb%E7%9A%84MVCC%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/"/>
      <url>/2022/08/20/MySQL%E4%B8%ADInoodb%E7%9A%84MVCC%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="MVCC底层原理："><a href="#MVCC底层原理：" class="headerlink" title="MVCC底层原理："></a>MVCC底层原理：</h1><p>​在可重复读隔离级别下，事务在启动的时候就“拍了个基于整库的快照”。</p><p>​InnoDB里面每个事务有一个唯一的事务ID，叫作transaction id。它是在事务开始的时候向InnoDB的事务系统申请的，是按申请顺序严格递增的。</p><p>​而每行数据也都是有多个版本的。<strong>每次事务更新数据的时候，都会生成一个新的数据版本</strong>，并且把transaction id赋值给这个数据版本的事务ID，<strong>记为row trx_id</strong>。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。也就是说，数据表中的一行记录，其实可能有多个版本(row)，每个版本有自己的row trx_id。</p><p>​如下图所示，就是一个记录被多个事务连续更新后的状态。</p><span id="more"></span><p><img src="1.jpg" alt="1"></p><p>​<strong>其中U1,U2,U3为undo log（回滚日志），V1、V2、V3并不是物理上真实存在的，而是每次需要的时候根据当前版本和undo log计算出来的。比如，需要V2的时候，就是通过V4依次执行U3、U2算出来。</strong></p><p>​在实现上， InnoDB为每个事务构造了一个数组，<strong>用来保存这个事务启动瞬间，当前正在“活跃”的所有事务ID</strong>。“活跃”指的就是，启动了但还没提交。数组里面<strong>事务ID的最小值记为低水位</strong>，当前系统里面已经创建过的事务ID的最大值加1记为高水位。</p><p>这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。</p><p>而数据版本的可见性规则，就是基于数据的row trx_id和这个一致性视图的对比结果得到的。</p><p>这个视图数组把所有的row trx_id 分成了几种不同的情况。</p><p><img src="2.jpg" alt="2"></p><p>这样，对于当前事务的启动瞬间来说，一个数据版本的row trx_id，有以下几种可能：</p><ol><li>如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；</li><li>如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；</li><li>如果落在黄色部分，那就包括两种情况<br>a. 若 row trx_id在数组中，表示这个版本是由还没提交的事务生成的，不可见；<br>b. 若 row trx_id不在数组中，表示这个版本是已经提交了的事务生成的，可见。</li></ol><p>一个数据版本，对于一个事务视图来说，<strong>除了自己的更新总是可见以外</strong>，有三种情况：</p><ol><li>版本未提交，不可见；</li><li>版本已提交，但是是在视图创建后提交的，不可见；</li><li>版本已提交，而且是在视图创建前提交的，可见。</li></ol><p>该规则在更新数据的时候就不适用了，<strong>更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。</strong>，除了如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。update语句外，<strong>select语句如果加锁（加上lock in share mode 或 for update），也是当前读。</strong></p><ul><li>在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；</li><li>在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。</li></ul><p><strong>InnoDB利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。</strong></p>]]></content>
      
      
      <categories>
          
          <category> MySQL数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL中Inoodb的MVCC版本控制原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL中的锁</title>
      <link href="/2022/08/20/MySQL%E4%B8%AD%E7%9A%84%E9%94%81/"/>
      <url>/2022/08/20/MySQL%E4%B8%AD%E7%9A%84%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL中锁的分类"><a href="#MySQL中锁的分类" class="headerlink" title="MySQL中锁的分类"></a>MySQL中锁的分类</h1><h2 id="按照设计思想分类"><a href="#按照设计思想分类" class="headerlink" title="按照设计思想分类"></a>按照设计思想分类</h2><p>乐观锁和悲观锁是一种设计思想，这种设计思想广泛存在于所有需要同步加锁的场景中，例如Java中的实现：乐观锁为volatile+cas，悲观锁为synchronized或ReentrantLock这种锁。在mysql中思想是类似的。</p><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>每次读数据的时候都认为其他人不会修改，所以不会上锁，而是在更新的时候去判断在此期间有没有其他人更新了数据，可以<strong>使用版本号机制</strong>。在数据库中可以通过为数据表增加一个版本号字段实现。读取数据时将版本号一同读出，数据每次更新时对版本号加一。当我们更新的时候，判断数据库表对应记录的当前版本号与第一次取出来的版本号值进行比对，如果值相等，则予以更新，否则认为是过期数据，类似于Java中的cas操作。乐观锁适用于多读的应用类型，可以提高吞吐量。</p><span id="more"></span><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>每次读数据的时候都认为别人会修改，所以每次在读数据的时候都会上锁，这样别人想读这个数据时就会被阻塞。MySQL中就用到了很多这种锁机制，比如行锁、表锁、读锁、写锁等，都是在操作之前先上锁。</p><h3 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h3><p>共享锁又叫做<strong>读锁或S锁</strong>，在数据（表或者行，后面会介绍）被加上共享锁后，所有事务都可以并发读取数据，但其他事务如果自己没有获得共享锁，那么在当前共享锁作用期限内不能对数据进行修改（即对数据加排他锁），直到已释放其他所有共享锁。但当前事务可以对数据进行修改，这时候会先释放掉共享锁，然后为数据加上排他锁，这段有点绕，细节有点难以理解，后面会结合死锁的案例详细分析。</p><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><p>在select语句后加上<code>lock in share mode。</code></p><h4 id="作用期限"><a href="#作用期限" class="headerlink" title="作用期限"></a>作用期限</h4><p>要真正理解共享锁，必须搞清楚它的作用期限，即什么时候释放。<strong>一般读取操作一完成，就立即释放资源上的共享锁</strong>，除非将事务隔离级别设置为可重复读或更高级别，<strong>或者在事务持续时间内用锁定提示保留共享锁</strong>。</p><p>例如，用例表格如下，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+-----------+------------------------------------------------------------------+</span><br><span class="line">| Table     | Create Table                                                     |</span><br><span class="line">+-----------+------------------------------------------------------------------+</span><br><span class="line">| lock_test | CREATE TABLE `lock_test` (</span><br><span class="line">  `id` bigint NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(255) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=18 DEFAULT CHARSET=utf8mb3 |</span><br><span class="line">+-----------+------------------------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from lock_test;</span><br><span class="line">+----+--------+</span><br><span class="line">| id | name   |</span><br><span class="line">+----+--------+</span><br><span class="line">|  1 | chengu |</span><br><span class="line">+----+--------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>一般我们在设置自动提交的前提下，一句select语句就是一个事务，执行完后共享锁就释放了</p><h3 id="排它锁"><a href="#排它锁" class="headerlink" title="排它锁"></a>排它锁</h3><p>排他锁又叫<strong>写锁或X锁</strong>，某个事务对数据加上排他锁后，只能这个事务对其进行读写，在此事务结束之前，其他事务不能对其加任何锁，需等待其释放。排他锁（X 锁）可以防止并发事务对资源进行访问。</p><p><img src="1.jpg"></p><h4 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h4><ol><li><strong>数据修改语句通常默认请求共享锁和排他锁</strong>。数据修改语句（如 INSERT、UPDATE 和 DELETE）合并了修改和读取操作。语句在执行所需的修改操作之前首先执行读取操作以获取数据。 例如，UPDATE 语句可能根据与一个表的联接修改另一个表中的行。在此情况下，除了请求更新行上的排他锁之外，UPDATE 语句还将请求在联接表中读取的行上的共享锁。</li><li>显示调用：在sql语句后加<code>for update</code>。</li></ol><h2 id="按照作用区域分类"><a href="#按照作用区域分类" class="headerlink" title="按照作用区域分类"></a>按照作用区域分类</h2><p><strong>根据加锁的范围，MySQL里面的锁大致可以分成全局锁、表级锁和行锁三类</strong></p><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>​顾名思义，全局锁就是对整个数据库实例加锁。MySQL提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。</p><p><strong>全局锁的典型使用场景是，做全库逻辑备份。</strong>也就是把整库每个表都select出来存成文本。</p><ul><li>如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；</li><li>如果你在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟。</li></ul><p>​但是一般的做法是使用官方自带的逻辑备份工具mysqldump。当mysqldump使用参数–single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。</p><h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>​MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。</p><p>​<strong>表锁的语法是 lock tables … read&#x2F;write。</strong>与FTWRL类似，可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</p><p>​<strong>另一类表级的锁是MDL（metadata lock)。</strong>MDL不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是，保证读写的正确性。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。</p><p>​因此，在MySQL 5.5版本中引入了MDL，当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。</p><ul><li>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。</li><li>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</li></ul><p>在实际使用中需要注意：给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据，需要获取到写锁，如果该事务正在等待写锁的话，会阻塞后面的读写操作</p><h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><p>​MySQL的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如<strong>MyISAM引擎就不支持行锁</strong>。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB是支持行锁的</p><p>​顾名思义，行锁就是针对数据表中行记录的锁。这很好理解，比如事务A更新了一行，而这时候事务B也要更新同一行，则必须等事务A的操作完成后才能进行更新。</p><p>​<strong>在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</strong>这也就是说在具体的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。如下业务逻辑：</p><ol><li>记录一条交易日志。</li><li>从顾客A账户余额中扣除电影票价；</li><li>给影院B的账户余额增加这张电影票价；（安排在最后，影响最小）</li></ol><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>由于表锁和行锁虽然锁定范围不同，但是会相互冲突。所以当你要加表锁时，势必要先遍历该表的所有记录，判断是否加有排他锁。这种遍历检查的方式显然是一种低效的方式，<strong>MySQL 引入了意向锁，来快捷检测表锁和行锁的冲突，提高加锁的效率。</strong>举个例子，如果表中记录1亿，事务A把其中有几条记录上了排它锁了，这时事务B需要给这个表加表级锁，如果没有意向锁的话，那就要去表中查找这一亿条记录是否上锁了。如果存在意向锁，事务Ａ在更新一条记录之前，先加意向锁，再加Ｘ锁，事务B先检查该表上是否存在意向锁，存在的意向锁是否与自己准备加的锁冲突，如果有冲突，则等待直到事务Ａ释放，而无须逐条记录去检测。事务Ｂ更新表时，其实无须知道到底哪一行被锁了，它只要知道反正有一行被锁了就行了。</p><h3 id="Record-Lock（记录锁）"><a href="#Record-Lock（记录锁）" class="headerlink" title="Record Lock（记录锁）"></a>Record Lock（记录锁）</h3><p>​记录锁是最简单的行锁。<strong>上边描述 InnoDB 加锁原理中的锁就是记录锁，只锁住 id &#x3D; 19 或者 name &#x3D; ‘Tom’ 这一条记录</strong>。当 SQL 语句无法使用索引时，会进行全表扫描，这个时候 MySQL 会给整张表的所有数据行加记录锁，再由 MySQL Server 层进行过滤。但是，在 MySQL Server 层进行过滤的时候，如果发现不满足 WHERE 条件，会释放对应记录的锁。这样做，保证了最后只会持有满足条件记录上的锁。</p><h3 id="Gap-Lock（间隙锁）"><a href="#Gap-Lock（间隙锁）" class="headerlink" title="Gap Lock（间隙锁）"></a>Gap Lock（间隙锁）</h3><p>​还是最开始更新用户年龄的例子，如果 id &#x3D; 19 这条记录不存在，这个 SQL 语句还会加锁吗？答案是可能有，这取决于数据库的隔离级别。这种情况下，<strong>在 RC 隔离级别不会加任何锁，在 RR 隔离级别会在 id &#x3D; 19 前后两个索引之间加上间隙锁。把隔离级别设置为读提交的话，就没有间隙锁了。但同时，要解决可能出现的数据和日志不一致问题，需要把binlog格式设置为row</strong></p><p>​间隙锁是一种加在两个索引之间的锁，例如(10, 20)；或者加在第一个索引之前，例如(-∞, 10)；或最后一个索引之后的间隙，例如(20, ∞)**。这个间隙可以跨一个索引记录，多个索引记录，甚至是空的。</p><p>​间隙锁之间是不互斥的，<strong>会导致同样的语句锁住更大的范围</strong>，有可能会引发死锁。如下例子：</p><p><img src="2.jpg"></p><p>上述语句执行流程如下：</p><ol><li>session A 执行select … for update语句，由于id&#x3D;9这一行并不存在，因此会加上间隙锁(5,10);</li><li>session B 执行select … for update语句，同样会加上间隙锁(5,10)，间隙锁之间不会冲突，因此这个语句可以执行成功；</li><li>session B 试图插入一行(9,9,9)，被session A的间隙锁挡住了，只好进入等待；</li><li>session A试图插入一行(9,9,9)，被session B的间隙锁挡住了。</li></ol><p>​至此，两个session进入互相等待状态，形成死锁。当然，InnoDB的死锁检测马上就发现了这对死锁关系，让session A的insert语句报错返回了。</p><h4 id="避免幻读的原理"><a href="#避免幻读的原理" class="headerlink" title="避免幻读的原理"></a>避免幻读的原理</h4><p><strong>什么是幻读</strong>：</p><p>​幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，<strong>幻读在“当前读”（加for update）下才会出现。</strong></p><p>​幻读产生原因：产生幻读的原因是，<strong>行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”</strong></p><p>​我们经常在资料上看到，<strong>mysql在RR隔离级别下就可以解决幻读问题，其原理就是通过间隙锁来实现的，</strong>使用间隙锁可以防止其他事务在这个范围内插入或修改记录，保证两次读取这个范围内的记录不会变，从而不会出现幻读现象。先来回顾一下什么是幻读，简而言之就是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的数据行，还是取上面的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update user set age = 10 where id = 19;</span><br></pre></td></tr></table></figure><p>​假设在一个事务的过程中，我们执行上面的sql，首先通过索引没找到id为19的记录。试想一下，假如没有加间隙锁可能出现怎样的后果。假如这时有另外一个事务新增了一条id为19的记录，那么当前事务再次执行上面那条sql（查询）便会奇怪的找到了记录，彷佛出现了幻觉，这就是幻读。那么如果在RR隔离级别下，会在索引(10, 20)之间加间隙锁，也就避免了幻读问题的出现。</p><h4 id="快照读和当前读"><a href="#快照读和当前读" class="headerlink" title="快照读和当前读"></a>快照读和当前读</h4><p>在RR和RC级别下，数据库的读分为快照读和当前读:</p><ul><li>快照读：单纯的select操作。读取的是快照（ReadView）中的数据，可能是历史数据。</li><li>当前读：如下情况会用当前读<code>select ... for update/in share mode、update、insert、delete</code>。读取的总是当前的最新数据，RC 只加记录锁，RR 除了加记录锁，还会加间隙锁，用于解决幻读问题。</li></ul><p>不同的 SQL 语句对应不同的读模式，也会加不同的锁，总结起来主要分为五种情况：</p><ul><li>SELECT … 语句正常情况下为快照读，不加锁；</li><li>SELECT … LOCK IN SHARE MODE 语句为当前读，加 S 锁；</li><li>SELECT … FOR UPDATE 语句为当前读，加 X 锁；</li><li>常见的 DML 语句（如 INSERT、DELETE、UPDATE）为当前读，加 X 锁；</li><li>常见的 DDL 语句（如 ALTER、CREATE 等）加表级锁，且这些语句为隐式提交，不能回滚。</li></ul><p>其中，当前读的 SQL 语句的 where 从句的不同也会影响加锁，包括是否使用索引，索引是否是唯一索引等等。</p><p><strong>RR模式下</strong>幻读的问题我觉得要分快照读和当前读两种情况来讨论：</p><ul><li>对于快照读，RR中一个事务的所有快照读读取的都是同一份快照，所以无论其他的事务怎么修改，无论是更新还是插入删除，都不会影响当前事务的快照读结果，也就不会出现不可重复读、幻读的情形。<strong>快照读解决幻读问题的原理是基于MVCC的</strong>。</li><li>对于当前读，你读取的行，以及行的间隙都会被加锁，直到事务提交时才会释放，其他的事务无法进行修改，所以也不会出现不可重复读、幻读的情形。</li></ul><p><strong>所以如果你总是进行快照读，或者总是进行当前读，是不会出现幻读的情况的。而你的事务之所以会出现“幻读”，是因为你先进行了一次快照读（select），读取了历史数据，再进行了一次当前读读取最新数据，这样就出现幻读了。</strong></p><h3 id="Next-Key-Lock"><a href="#Next-Key-Lock" class="headerlink" title="Next-Key Lock"></a>Next-Key Lock</h3><p><strong>Next-key锁是记录锁和间隙锁的组合</strong>，它指的是加在某条记录以及这条记录前面间隙上的锁。假设一个索引包含 5、8、10、20这几个值，可能的 Next-key 锁如下：<code>(-∞, 5]，(5, 8]，(8, 10]，(10, 20]，(20, +∞)</code>。通常我们都用这种左开右闭区间来表示 Next-key 锁，其中，圆括号表示不包含该记录，方括号表示包含该记录。前面四个都是 Next-key 锁，最后一个为间隙锁。<strong>和间隙锁一样，在 RC 隔离级别下没有 Next-key 锁，只有 RR 隔离级别才有。</strong>还是之前的例子，这次我们换一下设定，假设 id 不是主键，而是二级索引，且不是唯一索引，那么这个 SQL 在 RR 隔离级别下就会加如下的 Next-key 锁 (8, 10]、(10, 20)。此时如果插入一条 id &#x3D; 10 的记录将会阻塞住。之所以要把 id &#x3D; 10 前后的间隙都锁住，仍然是为了解决幻读问题，因为 id 是非唯一索引，所以 id &#x3D; 10 可能会有多条记录，为了防止再插入一条 id &#x3D; 10 的记录。</p><h3 id="插入意向-GAP-锁"><a href="#插入意向-GAP-锁" class="headerlink" title="插入意向 GAP 锁"></a>插入意向 GAP 锁</h3><p>插入意向锁是一种特殊的间隙锁（简写成 II GAP）表示插入的意向，只有在 INSERT 的时候才会有这个锁。注意，这个锁虽然也叫意向锁，但是和上面介绍的表级意向锁是两个完全不同的概念，不要搞混了。多个插入意向锁之间互不冲突，所以可以在同一个间隙中有多个事务同时插入不同索引的记录。譬如在上面的例子中，id &#x3D; 30 和 id &#x3D; 49 之间如果有两个事务要同时分别插入 id &#x3D; 32 和 id &#x3D; 33 是没问题的，虽然两个事务都会在 id &#x3D; 30 和 id &#x3D; 50 之间加上插入意向锁，但是不会冲突。</p><p><strong>插入意向锁只会和间隙锁或 Next-key 锁冲突，正如上面所说，间隙锁唯一的作用就是防止其他事务插入记录造成幻读，正是由于在执行 INSERT 语句时需要加插入意向锁，而插入意向锁和间隙锁冲突，从而阻止了插入操作的执行。</strong></p><h1 id="使用索引时的锁获取"><a href="#使用索引时的锁获取" class="headerlink" title="使用索引时的锁获取"></a>使用索引时的锁获取</h1><p>下面以两条 SQL 的执行为例，讲解一下 InnoDB 对于单行数据的加锁原理，这个表中id为主键（一级索引），我们也为name列建立了索引（二级索引）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update user set age = 10 where id = 19;</span><br><span class="line"></span><br><span class="line">update user set age = 10 where name = &#x27;Tom&#x27;;</span><br></pre></td></tr></table></figure><p>第一条 SQL 使用<strong>主键索引</strong>来查询，则只需要在 id &#x3D; 19 这个主键索引上加上写锁；第二条 SQL 则使用<strong>二级索引</strong>来查询，则首先在 name &#x3D; Tom 这个索引上加写锁，然后由于使用 InnoDB 二级索引还需再次根据主键索引查询，所以还需要在 id &#x3D; 19 这个主键索引上加写锁。也就是说使用主键索引需要加一把锁，使用二级索引需要在二级索引和主键索引上各加一把锁。<strong>所以在使用索引的情况下，是为索引加锁也就是加的是行锁。</strong></p><h1 id="不使用索引时的锁获取"><a href="#不使用索引时的锁获取" class="headerlink" title="不使用索引时的锁获取"></a>不使用索引时的锁获取</h1><p>根据索引对单行数据进行更新的加锁原理了解了，那如果更新操作涉及多个行呢，比如下面 SQL 的执行场景。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update user set age = 10 where id &gt; 19;</span><br></pre></td></tr></table></figure><p>MySQL Server 会根据 WHERE 条件读取第一条满足条件的记录，然后 InnoDB 引擎会将第一条记录返回并加锁，接着 MySQL Server 发起更新改行记录的 UPDATE 请求，更新这条记录。一条记录操作完成，再读取下一条记录，直至没有匹配的记录为止。<strong>所以在不使用索引的情况下会为表中所有记录加锁，也就是加的是表锁</strong>。<strong>所以更新操作必须要根据索引进行操作，没有索引时，不仅会消耗大量的锁资源，增加数据库的开销，还会极大的降低了数据库的并发性能。</strong></p><h1 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h1><p>​当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。</p><p>​当出现死锁以后，有两种策略：</p><ul><li>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数innodb_lock_wait_timeout来设置。</li><li>另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑。</li></ul><p>但是第二种的主动死锁检测也有一定的弊端：每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。当出现大量并发等待锁的时候，虽然最终检测的结果是没有死锁，但是这期间要消耗大量的CPU资源。因此，就会导致CPU利用率很高，但是每秒却执行不了几个事务。</p><h2 id="如何解决热点行更新导致的性能问题？"><a href="#如何解决热点行更新导致的性能问题？" class="headerlink" title="如何解决热点行更新导致的性能问题？"></a>如何解决热点行更新导致的性能问题？</h2><p>1、如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关闭掉。一般不建议采用<br>2、控制并发度，对应相同行的更新，在进入引擎之前排队。这样在InnoDB内部就不会有大量的死锁检测工作了。<br>3、将热更新的行数据拆分成逻辑上的多行来减少锁冲突，但是业务复杂度可能会大大提高。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL中的锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL数据库的索引</title>
      <link href="/2022/08/19/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%B4%A2%E5%BC%95/"/>
      <url>/2022/08/19/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h1 id="索引的定义"><a href="#索引的定义" class="headerlink" title="索引的定义"></a>索引的定义</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>MySQL官方对索引的定义：索引（Index）是帮助MySQL 高效获取数据的数据结构。可以得到索引的本质是数据结构，可以简单理解为<strong>排好序的快速查找数据结构</strong>。这种数据结构往往空间很大，是存在硬盘里的，又称为磁盘级索引。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>优势：</p><ul><li>提高数据检索的效率，降低数据库的IO成本。</li><li>通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗。</li></ul><p>劣势：</p><ul><li>虽然索引提高了查询速度，但同时会降低更新表的速度。在更新表时，MySQL不仅要更新数据，也要维护索引，调整因为更新所带来的键值变化后的索引信息（所以说在频繁更新的列上不建议建索引）。</li><li>实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要占用空间的。</li></ul><span id="more"></span><h1 id="索引常见的实现模型"><a href="#索引常见的实现模型" class="headerlink" title="索引常见的实现模型"></a>索引常见的实现模型</h1><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>​哈希表是一种以键-值（key-value）存储数据的结构，我们只要输入待查找的值即key，就可以找到其对应的值即Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置。不可避免地，多个key值经过哈希函数的换算，会出现同一个值的情况，即哈希冲突。处理这种情况的一种方法是，拉出一个链表。哈希表存储是无序的，这样做的好处是增加新的User时速度会很快，只需要往后追加。但缺点是，因为不是有序的，所以哈希索引做区间查询的速度是很慢的。<strong>哈希表这种结构适用于只有等值查询的场景</strong>，</p><!--more--><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><strong>有序数组在等值查询和范围查询场景中的性能就都非常优秀</strong>。但是，在需要更新数据的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。所以，<strong>有序数组索引只适用于静态存储引擎</strong>，</p><h2 id="搜索树"><a href="#搜索树" class="headerlink" title="搜索树"></a>搜索树</h2><p>​二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。这样在搜索的时候，就可以直接比较大小顺着路径找到目标。当然为了维持O(log(N))的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是O(log(N))，树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。</p><p>​树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。以InnoDB的一个整数字段索引为例，这个N差不多是1200。这棵树高是4的时候，就可以存1200的3次方个值，这已经17亿了。考虑到树根的数据块总是在内存中的，一个10亿行的表上一个整数字段的索引，查找一个值最多只需要访问3次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。</p><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>​B树是<strong>一颗多路平衡查找树</strong>，它类似普通的平衡二叉树，不同的一点是B树允许每个节点有更多的子节点。下图是 B树的简化图.</p><p><img src="4.jpg" alt="4"></p><p>B树有如下特点:</p><ol><li>所有键值分布在整颗树中（索引值和具体data都在每个节点里）；</li><li>任何一个关键字出现且只出现在一个结点中；</li><li>搜索有可能在非叶子结点结束（最好情况O(1)就能找到数据）；</li><li>在关键字全集内做一次查找,性能逼近二分查找；</li></ol><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+ 树"></a>B+ 树</h3><p>B+树是B树的变体，也是一种多路搜索树, 它与 B树的不同之处在于:</p><ol><li>所有关键字存储在叶子节点出现,内部节点(非叶子节点并不存储真正的 data)</li><li>为所有叶子结点增加了一个链指针</li></ol><p><img src="5.jpg" alt="5"></p><h3 id="B树与B-树的对比"><a href="#B树与B-树的对比" class="headerlink" title="B树与B+树的对比"></a>B树与B+树的对比</h3><ul><li>B+树相比B树特点</li><li>B+树非叶子节点不保存数据相关的信息，只保存关键字和子节点的引用，关键字对应的数据保存在叶子节点中，叶子节点是顺序排列的，并且相邻节点具有顺序引用的关系，通过指针进行链接，实际上是一个有序链表。</li><li>B+树的关键字采用闭合区间，这也是它之所以能够实现除了叶子节点都不放数据的结构特性，[1，28)，假如找1，显然我们就一直往下找直到叶子节点，而如果在B树里，如果1是关键字，那在根节点就已经命中了；</li><li>B+树的关键字为什么采用左闭合区间而不是右闭？因为我们的使用中一般主键数据都是是自增的，所以往右边插入比较多，所以设计成左闭合区间；</li><li>B+树作为索引树相比B树优点</li><li>B+树是B树的变种（plus）多路绝对平衡查找树，它拥有B树的优势</li><li>B+树的扫库扫表的能力更强（只需要扫叶子节点，而且叶子节点是有序链表）</li><li>B+树的磁盘读写能力更强——高扇出性（非叶子节点不保存数据区，每个磁盘块可以保存更多的关键字）</li><li>B+树的排序能力更强（B+树天然具备排序功能，B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高）</li><li>B+树的查询效率更加稳定（IO的次数恒定，因为叶子节点的深度相同）</li></ul><h1 id="InnoDB-的索引模型"><a href="#InnoDB-的索引模型" class="headerlink" title="InnoDB 的索引模型"></a>InnoDB 的索引模型</h1><p>​在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。InnoDB使用了B+树索引模型，所以数据都是存储在B+树中的。<strong>每一个索引在InnoDB里面对应一棵B+树。</strong></p><p>​在InnoDB中数据和索引是存储在一起的，在InnoDB中，真正的数据存储在<strong>聚集索引</strong>（默认为主键索引）的叶子节点上，所以说它是也主键为索引来组织数据的存储的，而且除了聚集索引，其他索引（<strong>辅助索引</strong>）的叶子节点上存的是对应数据行主键的值，所以我们如果用辅助索引查找数据时会先从辅助索引找到对应行的主键，然后再用聚集索引去找到真正的数据，这个过程也称为<strong>回表</strong>。因为辅助索引不包含行记录的所有数据，这就意味着每页可以存放更多的键值，因此其高度一般都要小于聚集索引。总结就是：</p><p><strong>主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也被称为聚簇索引（clustered index）。</strong></p><p><strong>非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为二级索引（secondary index）。</strong></p><h2 id="基于主键索引和普通索引的查询有什么区别"><a href="#基于主键索引和普通索引的查询有什么区别" class="headerlink" title="基于主键索引和普通索引的查询有什么区别"></a>基于主键索引和普通索引的查询有什么区别</h2><ul><li>如果语句是select * from T where ID&#x3D;500，即主键查询方式，则只需要搜索ID这棵B+树；</li><li>如果语句是select * from T where k&#x3D;5，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为回表。</li></ul><p>也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。</p><h1 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h1><p>​B+树为了维护索引有序性，在插入新值的时候需要做必要的维护。当需要插入的当前数据页已经满的了话，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。</p><p>​<strong>在建表的时候，建立非业务字段的自增主键来实现递增的追加插入</strong>，不涉及到挪动其他记录，也不会触发叶子节点的分裂。自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。需要注意的是，自增主键需要占用空间小的字段，<strong>主键长度越小，普通索引（叶子节点数据存储主键，回表查询）的叶子节点就越小，普通索引占用的空间也就越小。</strong></p><h1 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h1><h2 id="联合索引概念"><a href="#联合索引概念" class="headerlink" title="联合索引概念"></a>联合索引概念</h2><p>​联合索引：根据创建联合索引的顺序，以最左原则进行where检索，比如（age，name）以age&#x3D;1 或 age&#x3D; 1 and name&#x3D;‘张三’可以使用索引，单以name&#x3D;‘张三’ 不会使用索引，考虑到存储空间的问题，还请根据业务需求，将查找频繁的数据进行靠左创建索引。</p><h2 id="联合索引存储结构"><a href="#联合索引存储结构" class="headerlink" title="联合索引存储结构"></a>联合索引存储结构</h2><p>既然是一个索引，必然是一个B+树，假设联合索引(col1, col2,col3)，其非叶子节点存储的是第一个关键字的索引，而叶节点存储的则是三个关键字col1、col2、col3三个关键字的数据，且按照col1、col2、col3的顺序进行排序。如图所示：</p><p><img src="1.jpg" alt="1"></p><h1 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h1><p>​覆盖索引是select的数据列只用从索引中就能够取得，不必读取数据行，换句话说查询列要被所建的<a href="https://baike.baidu.com/item/%E7%B4%A2%E5%BC%95/5716853">索引</a>覆盖，所要查询的数据在索引数结构中就可以取到，就不用回表去查ID然后再在完整的数据中取想要的数据。</p><p>因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引k已经“覆盖了”我们的查询需求，我们称为覆盖索引。</p><h1 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h1><p>​最左前缀原则是，不需要为每一种查询都设计一个索引，只要满足最左前缀，就可以利用该联合索引来加速检索。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。</p><p>​<strong>在建立联合索引的时候，如何安排索引内的字段顺序？</strong></p><p>这里我们的评估标准是，索引的复用能力。因为可以支持最左前缀，所以当已经有了(a,b)这个联合索引后，一般就不需要单独在a上建立索引了。因此，<strong>第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</strong></p><p>​如果既有联合查询，又有基于a、b各自的查询，查询条件里面只有b的语句，是无法使用(a,b)这个联合索引的，这时候不得不同时维护(a,b)、(b) 这两个索引。</p><h1 id="索引下推Index-Condition-Pushdown-ICP"><a href="#索引下推Index-Condition-Pushdown-ICP" class="headerlink" title="索引下推Index Condition Pushdown(ICP)"></a>索引下推Index Condition Pushdown(ICP)</h1><p>如上所述，满足最左前缀原则的时候，最左前缀可以用于在索引中定位记录，以联合索引（name, age）为例。如果现在有一个需求：检索出表中“名字第一个字是张，而且年龄是10岁的所有男孩”。那么，SQL语句是这么写的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tuser where name like &#x27;张%&#x27; and age=10 and ismale=1;</span><br></pre></td></tr></table></figure><p>​这个语句在搜索索引树的时候，只能用 “张”，找到第一个满足条件的记录ID3，在MySQL 5.6之前，只能从ID3开始一个个回表。到主键索引上找出数据行，再对比字段值。执行流程如下图所示：</p><p>​在(name,age)索引里,这个过程InnoDB并不会去看age的值，只是按顺序把“name第一个字是’张’”的记录一条条取出来回表。因此，需要回表4次。</p><p><img src="2.jpg" alt="2"></p><p>​而MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，让满足检索条件的行去回表找到完整的行数据，减少回表次数。</p><p>​下图显示InnoDB在(name,age)索引内部就判断了age是否等于10，对于不等于10的记录，直接判断并跳过。在我们的这个例子中，只需要对ID4、ID5这两条记录回表取数据判断，就只需要回表2次。</p><p><img src="3.jpg" alt="3"></p><h1 id="索引建立原则"><a href="#索引建立原则" class="headerlink" title="索引建立原则"></a>索引建立原则</h1><p>​给表创建索引时，应该创建哪些索引，每个索引应该包含哪些字段，字段的顺序怎么排列，这个问题没有标准答案，需要根据具体的业务来做权衡。：<br>​既然这是一个权衡问题，没有办法保证所有的查询都高效，那就要优先保证高频的查询高效，较低频次的查询也尽可能的使用到尽可能长的最左前缀索引。可以借助pt-query-digest来采样统计业务查询语句的访问频度，可能需要迭代几次才能确定联合索引的最终字段及其排序。</p><p><strong>注意</strong>， InnoDB 引擎中,虽然删除了表的部分记录数据,但是它的索引数据还在, 并未释放，往往会出现数据空间不大，索引占用的空间却巨大，这是因为索引可能因为删除，或者页分裂等原因，导致数据页有空洞，重建索引的过程会创建一个新的索引，把数据按顺序插入，这样页面的利用率最高，也就是索引更紧凑、更省空间。</p><h1 id="普通索引与唯一索引的区别"><a href="#普通索引与唯一索引的区别" class="headerlink" title="普通索引与唯一索引的区别"></a>普通索引与唯一索引的区别</h1><ul><li>对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到碰到第一个不满足k&#x3D;5条件的记录。</li><li>对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。</li></ul><h1 id="为字符串建立索引"><a href="#为字符串建立索引" class="headerlink" title="为字符串建立索引"></a>为字符串建立索引</h1><p>​当需要为邮箱这种很长的字符串建立索引时，可以使用前缀索引，也就是说，可以定义字符串的一部分作为索引，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter table SUser add index index2(email(6));</span><br></pre></td></tr></table></figure><p>这样的好处是占用的空间会更小但，这同时带来的损失是，可能会增加额外的记录扫描次数。并且，使用前缀索引就用不上覆盖索引对查询性能的优化了。</p><h2 id="其他方式："><a href="#其他方式：" class="headerlink" title="其他方式："></a>其他方式：</h2><p>​<strong>第一种方式是使用倒序存储:<strong>当需要建索引的目标字符串前缀区分度太低，如身份证，可以</strong>使用倒序存储。</strong>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select field_list from t where id_card = reverse(&#x27;input_id_card_string&#x27;);</span><br></pre></td></tr></table></figure><p>​**第二种方式是使用hash字段:**可以在表上再创建一个整数字段，来保存身份证的校验码，同时在这个字段上创建索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter table t add id_card_crc int unsigned, add index(id_card_crc);</span><br></pre></td></tr></table></figure><p>然后每次插入新记录的时候，都同时用crc32()这个函数得到校验码填到这个新字段。由于校验码可能存在冲突，也就是说两个不同的身份证号通过crc32()函数得到的结果可能是相同的，所以你的查询语句where部分要判断id_card的值是否精确相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select field_list from t where id_card_crc=crc32(&#x27;input_id_card_string&#x27;) and id_card=&#x27;input_id_card_string&#x27;</span><br></pre></td></tr></table></figure><p>这样，索引的长度变成了4个字节，比原来小了很多。</p><h2 id="inoodb的change-buffer"><a href="#inoodb的change-buffer" class="headerlink" title="inoodb的change buffer"></a>inoodb的change buffer</h2><p>​当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，<strong>InooDB会将这些更新操作缓存在change buffer中</strong>，这样就不需要从磁盘中读入这个数据页了。在<strong>下次查询</strong>需要访问这个数据页或者后台定期merge的时间到了，或数据库正常关闭的时候，将<strong>数据页读入内存</strong>，然后执行change buffer中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。</p><p>​change buffer用的是buffer pool里的内存，因此不能无限增大。change buffer的大小，可以通过参数innodb_change_buffer_max_size来动态设置。这个参数设置为50的时候，表示change buffer的大小最多只能占用buffer pool的50%。</p><p>​对于<strong>唯一索引</strong>来说，所有的更新操作都要先判断这个操作是否违反唯一性约束，这必须要将数据页读入内存才能判断，<strong>就没必要使用change buffer。</strong></p><h2 id="change-buffer的merge过程："><a href="#change-buffer的merge过程：" class="headerlink" title="change buffer的merge过程："></a>change buffer的merge过程：</h2><p>merge的执行流程是这样的：</p><ol><li>从磁盘读入数据页到内存（老版本的数据页）；</li><li>从change buffer里找出这个数据页的change buffer 记录(可能有多个），依次应用，得到新版数据页；</li><li>写redo log。这个redo log包含了数据的变更和change buffer的变更。</li></ol><p>到这里merge过程就结束了。这时候，数据页和内存中change buffer对应的磁盘位置都还没有修改，属于脏页，之后各自刷回自己的物理数据，</p><h2 id="change-buffer的使用场景"><a href="#change-buffer的使用场景" class="headerlink" title="change buffer的使用场景"></a>change buffer的使用场景</h2><p>​对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时change buffer的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。</p><p>​反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在change buffer，但之后由于马上要访问这个数据页，会立即触发merge过程。这样随机访问IO的次数不会减少，反而增加了change buffer的维护代价。所以，对于这种业务模式来说，change buffer反而起到了副作用。</p><p>​所以，综上尽量选择普通索引。如果所有的更新后面，都马上伴随着对这个记录的查询，那么应该关闭change buffer。而在其他情况下，change buffer都能提升更新性能。</p><h2 id="与redo-log的区别"><a href="#与redo-log的区别" class="headerlink" title="与redo log的区别"></a>与redo log的区别</h2><p>​<strong>redo log 主要节省的是随机写磁盘的IO消耗（转成顺序写），而change buffer主要节省的则是随机读磁盘的IO消耗（需要添加或者更新的数据页没有在内存中，就先不读到内存中，写到change buffer中，等到下次读操作的时候顺带写入内存，再写入磁盘中）。</strong></p><h2 id="小问题："><a href="#小问题：" class="headerlink" title="小问题："></a>小问题：</h2><p>​change buffer一开始是写内存的，那么如果这个时候机器掉电重启，会不会导致change buffer丢失呢？change buffer丢失可不是小事儿，再从磁盘读入数据可就没有了merge过程，就等于是数据丢失了。会不会出现这种情况呢？</p><p>​答案是会导致change buffer丢失，会导致本次未完成的操作数据丢失，但不会导致已完成操作的数据丢失。<br>1.change buffer中分两部分，一部分是本次写入未写完的，一部分是已经写入完成的。<br>2.针对未写完的，此部分操作，还未写入redo log，因此事务还未提交，所以没影响。<br>3.针对，已经写完成的，可以通过redo log来进行恢复。所以，不会对数据库造成影响。</p><p>​在第三条中如果掉电又分为两部分：未写入内存，和已经写入内存。持久化的change buffer数据已经merge,不用恢复。主要分析没有持久化的数据<br>情况又分为以下几种:<br>(1)change buffer写入,redo log虽然做了fsync但未commit,binlog未fsync到磁盘,这部分数据丢失<br>(2)change buffer写入,redo log写入但没有commit,binlog以及fsync到磁盘,先从binlog恢复redo log,再从redo log恢复change buffer<br>(3)change buffer写入,redo log和binlog都已经fsync.那么直接从redo log里恢复。</p><h1 id="优化器选择索引的原则"><a href="#优化器选择索引的原则" class="headerlink" title="优化器选择索引的原则"></a>优化器选择索引的原则</h1><h2 id="索引区分度-基数"><a href="#索引区分度-基数" class="headerlink" title="索引区分度-基数"></a>索引区分度-基数</h2><p>​MySQL在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据统计信息来估算记录数。</p><p>这个统计信息就是索引的“区分度”。显然，一个索引上不同的值越多，这个索引的区分度就越好。而一个索引上不同的值的个数，我们称之为“基数”（cardinality）。也就是说，这个基数越大，索引的区分度越好。</p><p>我们可以使用show index方法，看到一个索引的基数。因为是基于初略统计信息，结果会有出入。</p><h2 id="基数计算方法"><a href="#基数计算方法" class="headerlink" title="基数计算方法"></a>基数计算方法</h2><p>​MySQL采样统计的方法：采样统计的时候，InnoDB默认会在该索引树上选择N个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。</p><p>而数据表是会持续更新的，索引统计信息也不会固定不变。所以，当变更的数据行数超过1&#x2F;M的时候，会自动触发重新做一次索引统计。</p><p>​在MySQL中，有两种存储索引统计的方式，可以通过设置参数innodb_stats_persistent的值来选择：</p><ul><li>设置为on的时候，表示统计信息会持久化存储。这时，默认的N是20，M是10。</li><li>设置为off的时候，表示统计信息只存储在内存中。这时，默认的N是8，M是16。</li></ul><p>​由于是采样统计，所以不管N是20还是8，这个基数都是很容易不准的。</p><h2 id="MySQL有时会选错索引"><a href="#MySQL有时会选错索引" class="headerlink" title="MySQL有时会选错索引"></a>MySQL有时会选错索引</h2><p>原因：</p><p>​1.优化器会根据索引的统计区分度基数获得要用索引的预估扫描行数，预估扫描行数统计错误，会导致选错索引。</p><ol start="2"><li>如果使用了普通索引，优化器还需要考虑回表查询所需要的时间，优化器会估算这两个选择的代价，从结果看来，优化器认为直接扫描主键索引更快。当然，从执行时间看来，这个选择并不是最优的。</li></ol><p>解决办法：</p><ol><li>统计信息不对。<strong>使用analyze table t 命令修正</strong>，来重新统计索引信息。开发的时候通常不会先写上force index。而是等到线上出现问题的时候，你才会再去修改SQL语句、加上force index。但是修改之后还要测试和发布，对于生产系统来说，这个过程不够敏捷。</li><li><strong>修改语句，引导MySQL使用我们期望的索引</strong></li><li><strong>新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引。</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> MySQL数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL数据库的索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL事务隔离级别</title>
      <link href="/2022/08/19/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
      <url>/2022/08/19/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在MySQL中，事务支持是在引擎层实现的。</p><p>ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）</p><span id="more"></span><h1 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h1><p>当数据库上有多个事务同时执行的时候，就可能出现</p><ol><li><p>脏读（dirty read）：脏读指的是读到了其他事务未提交的数据。此情况仅会发生在： 读未提交的的隔离级别</p></li><li><p>不可重复读（non-repeatable read）：不可重复读指的是在一个事务内，最开始读到的数据和事务结束前的任意时刻读到的同一批数据出现不一致的情况。此情况仅会发生在：读未提交、读提交的隔离级别.</p></li><li><p>幻读（phantom read）：事务B前后两次读取同一个范围的数据，在事务B两次读取的过程中事务A新增了数据，导致事务B后一次读取到前一次查询没有看到的行。幻读和不可重复读有些类似，但是幻读强调的是集合的增减，而不是单条数据的更新。幻读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行，就好象发生了幻觉一样.<br>一般解决幻读的方法是增加范围锁RangeS，锁定检索范围为只读，这样就避免了幻读。</p><p>此情况会回发生在：读未提交、读提交、可重复读的隔离级别.</p></li></ol><p>为了解决这些问题，就有了“隔离级别”的概念。</p><p>​SQL标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）</p><ul><li>读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。</li><li>读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。</li><li>可重复读（<strong>MYsql默认隔离级别</strong>）是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li><li>串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li></ul><p>​在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。</p><h1 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h1><p>在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。</p><p>假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录。</p><p><img src="1.jpg" alt="1"></p><p>但是在查询这条记录的时候，不同时刻启动的事务会有不同的read-view。如图中看到的，在视图A、B、C里面，这一个记录的值分别是1、2、4，<strong>同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）</strong></p><p>当系统里没有比这个回滚日志更早的read-view的时候回滚日志才会删除。所以不建议使用长事务的原因是：长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</p><h1 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h1><ol><li>显式启动事务语句， begin 或 start transaction。配套的提交语句是commit，回滚语句是rollback。</li><li>set autocommit&#x3D;0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个select语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行commit 或 rollback 语句，或者断开连接。</li></ol><p>有些客户端连接框架会默认连接成功后先执行一个set autocommit&#x3D;0的命令。这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。</p><p>建议使用set autocommit&#x3D;1, 通过显式语句的方式来启动事务。</p><p>在autocommit为1的情况下，用begin显式启动的事务，如果执行commit则提交事务。如果执行 commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行begin语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL事务隔离级别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的日志</title>
      <link href="/2022/08/18/MySQL%E7%9A%84%E6%97%A5%E5%BF%97/"/>
      <url>/2022/08/18/MySQL%E7%9A%84%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h1 id="redo-log（重做日志）"><a href="#redo-log（重做日志）" class="headerlink" title="redo log（重做日志）"></a>redo log（重做日志）</h1><p>​在MySQL里，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高。为了解决这个问题，MySQL的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。redo log是InnoDB引擎特有的日志。</p><p>​而粉板和账本配合的整个过程，其实就是MySQL里经常说到的WAL技术，WAL的全称是Write-Ahead Logging，它的关键点就是<strong>先写日志，再写磁盘</strong>，也就是先写粉板，等不忙的时候再写账本，这样就可以让<strong>数据库将随机写转换成了顺序写，大大提升了数据库的性能</strong>。</p><span id="more"></span><p>​具体来说，当有一条记录需要更新的时候，InnoDB引擎就会<strong>先把记录写到redo log（粉板）里面，并更新内存</strong>，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。</p><p>​InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，那么这块“粉板”总共就可以记录4GB的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。</p><p><img src="1.jpg" alt="1"></p><p>write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p><p>write pos和checkpoint之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果write pos追上checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把checkpoint推进一下。</p><p>有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为<strong>crash-safe</strong>。</p><p>要理解crash-safe这个概念，可以想想我们前面赊账记录的例子。只要赊账记录记在了粉板上或写在了账本上，之后即使掌柜忘记了，比如突然停业几天，恢复生意后依然可以通过账本和粉板上的数据明确赊账账目。</p><h2 id="redo-log的写入机制"><a href="#redo-log的写入机制" class="headerlink" title="redo log的写入机制"></a>redo log的写入机制</h2><p>​在下方flush过程中，事务在执行过程中，生成的redo log是要先写到redo log buffer的。如果在事务执行过程中，MySQL发生异常重启，没有持久化的redo log buffer中的日志，因为事务没有提交，数据库便会回滚，不会出现数据不一致的情况。</p><p>​redo log持久化具有三种状态：</p><p><img src="3.jpg"></p><p>这三种状态分别是：</p><ol><li>存在redo log buffer(这个与binlog不同这个是全局共用的)中，物理上是在MySQL进程内存中，就是图中的红色部分；</li><li>写到磁盘(write)，但是没有持久化（fsync)，物理上是在文件系统的page cache里面，也就是图中的黄色部分；</li><li>持久化到磁盘，对应的是hard disk，也就是图中的绿色部分。</li></ol><p>跟binlog类似，redo log也有控制数据持久化的参数：innodb_flush_log_at_trx_commit。它有三种可能取值：</p><ol><li>设置为0的时候，表示每次事务提交时都只是把redo log留在redo log buffer中;</li><li>设置为1的时候，表示每次事务提交时都将redo log直接持久化到磁盘；</li><li>设置为2的时候，表示每次事务提交时都只是把redo log写到page cache。</li></ol><p>​InnoDB有一个后台线程，每隔1秒，就会把redo log buffer中的日志，调用write写到文件系统的page cache，然后调用fsync持久化到磁盘。</p><p>​注意，事务执行中间过程的redo log也是直接写在redo log buffer中的，这些redo log也会被后台线程一起持久化到磁盘。也就是说，一个没有提交的事务的redo log，也是可能已经持久化到磁盘的。</p><p>​这里与两阶段提交可以联系上，时序上redo log先prepare， 再写binlog，最后再把redo log commit。把innodb_flush_log_at_trx_commit设置成1，那么redo log在prepare阶段就要持久化一次，因为有一个崩溃恢复逻辑是要依赖于prepare 的redo log，再加上binlog来恢复的。每秒一次后台轮询刷盘，再加上崩溃恢复这个逻辑，InnoDB就认为redo log在commit的时候就不需要fsync了，只会write到文件系统的page cache中就够了。</p><p>​通常是将MySQL配置为“双1”配置，即sync_binlog和innodb_flush_log_at_trx_commit都设置成 1，</p><h2 id="组提交（group-commit）机制"><a href="#组提交（group-commit）机制" class="headerlink" title="组提交（group commit）机制"></a>组提交（group commit）机制</h2><p>​日志逻辑序列号（log sequence number，LSN),LSN是单调递增的，用来对应redo log的一个个写入点。每次写入长度为length的redo log， LSN的值就会加上length。LSN也会写到InnoDB的数据页中，来确保数据页不会被多次执行重复的redo log。</p><h1 id="binlog（归档日志）"><a href="#binlog（归档日志）" class="headerlink" title="binlog（归档日志）"></a>binlog（归档日志）</h1><p>MySQL整体来看，其实就有两块：一块是Server层，它主要做的是MySQL功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。上面我们聊到的粉板redo log是InnoDB引擎特有的日志，而Server层也有自己的日志，称为binlog（归档日志）。</p><h2 id="与redo-log的不同点"><a href="#与redo-log的不同点" class="headerlink" title="与redo log的不同点"></a>与redo log的不同点</h2><p>这两种日志有以下三点不同。</p><ol><li>redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。</li><li>redo log是物理日志，<strong>记录的是“在某个数据页上做了什么修改”</strong>；<strong>binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID&#x3D;2这一行的c字段加1 ”。</strong></li><li>redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li></ol><h2 id="binlog的写入机制"><a href="#binlog的写入机制" class="headerlink" title="binlog的写入机制"></a>binlog的写入机制</h2><p>​事务执行过程中，先把日志写到binlog cache，事务提交的时候，再把binlog cache写到binlog文件中。</p><p>​系统给binlog cache分配了一片内存，每个线程一个，参数 binlog_cache_size用于控制单个线程内binlog cache所占内存的大小。一个事务的binlog必须确保一次性写入binlog cache，然后事务提交的时候，执行器把binlog cache里的完整事务写入到binlog中，并清空binlog cache。</p><p>​持久化过程分为两步：首先是write，指的就是指把日志写入到文件系统的page cache，并没有把数据持久化到磁盘，所以速度比较快。然后是fsync，才是将数据持久化到磁盘的操作。</p><p>write 和fsync的时机，是由参数sync_binlog控制的：</p><ol><li>sync_binlog&#x3D;0的时候，表示每次提交事务都只write，不fsync；</li><li>sync_binlog&#x3D;1的时候，表示每次提交事务都会执行fsync；</li><li>sync_binlog&#x3D;N(N&gt;1)的时候，表示每次提交事务都write，但累积N个事务后才fsync。</li></ol><p>​在出现IO瓶颈的场景里，将sync_binlog设置成一个比较大的值，可以提升性能。在实际的业务场景中，考虑到丢失日志量的可控性，一般不建议将这个参数设成0，比较常见的是将其设置为100~1000中的某个数值。</p><p>但是，将sync_binlog设置为N，对应的风险是：如果主机发生异常重启，会丢失最近N个事务的binlog日志。</p><h1 id="UPDATE语句完整的流程"><a href="#UPDATE语句完整的流程" class="headerlink" title="UPDATE语句完整的流程"></a>UPDATE语句完整的流程</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update T set c=c+1 where ID=2;</span><br></pre></td></tr></table></figure><ol><li>执行器先找引擎取ID&#x3D;2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID&#x3D;2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li><li>执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li><li>引擎将这行新数据更新到内存中，同时将这个更新操作<strong>记录到redo log里面</strong>，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。</li><li>执行器生成这个操作的binlog，并把binlog写入磁盘。</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。</li></ol><p>下图为update语句的执行流程图，图中浅色框表示是在InnoDB内部执行的，深色框表示是在执行器中执行的。</p><p><img src="2.jpg" alt="2"></p><p>图中将redo log的写入拆成了两个步骤：prepare和commit，这就是”两阶段提交”。</p><h1 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h1><p>​为什么日志需要“两阶段提交”？是为了保证redo log 和binlog中这两个状态保持逻辑上的一致。</p><p>​由于redo log和binlog是两个独立的逻辑，如果不用两阶段提交，要么就是先写完redo log再写binlog，或者采用反过来的顺序。假设执行update语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了crash。</p><ol><li><p><strong>先写redo log后写binlog</strong>。假设在redo log写完，binlog还没有写完的时候，MySQL进程异常重启。由于我们前面说过的，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回来，但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句。因此，之后备份日志的时候，存起来的binlog里面就没有这条语句。如果需要用这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这个临时库就会少了这一次更新，恢复出来数据与原库的值不同。</p><p>当使用两阶段提交时：redolog完成了prepare, 而binlog又失败，那么事务本身会回滚，就能保证redo log和binlog的数据一致性。</p></li><li><p><strong>先写binlog后写redo log</strong>。如果在binlog写完之后crash，由于redo log还没写，崩溃恢复以后这个事务无效。但是binlog里面已经记录了“把c从0改成1”这个日志。所以，在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行c的值就是1，与原库的值不同。</p></li></ol><h1 id="MySQL刷脏页flush过程"><a href="#MySQL刷脏页flush过程" class="headerlink" title="MySQL刷脏页flush过程"></a>MySQL刷脏页flush过程</h1><p>​redo log是日志文件；内存是从磁盘中读入的数据页，磁盘是数据的持久化存储仓库。<strong>将内存中的数据写入磁盘的过程（注意内存的数据不用根据redo log 因为数据都在内存中 在写redo log的时候就直接在内存中写了），被称为flush。</strong>  <strong>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”</strong>。</p><p>​Mysql刷脏页的过程会导致平时执行很快的语句突然变慢。</p><h1 id="触发flush的原因："><a href="#触发flush的原因：" class="headerlink" title="触发flush的原因："></a>触发flush的原因：</h1><ol><li>InnoDB的redo log写满了。这时候系统会停止所有更新操作，把checkpoint往前推进，redo log留出空间可以继续写。那么推进的部分就需要将对应的所有脏页都flush到磁盘上。这种情况是InnoDB要尽量避免的。因为出现这种情况的时候，整个<strong>系统就不能再接受更新</strong>了，所有的更新都必须堵住。如果你从监控上看，这时候更新数会跌为0。</li><li>系统内存（将磁盘中的数据读入，加快访问）不足。当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到磁盘。<strong>InnoDB用缓冲池（buffer pool）管理内存</strong>，InnoDB的策略是尽量使用内存，</li><li>MySQL认为系统“空闲”的时候</li><li>MySQL正常关闭的情况。这时候，MySQL会把内存的脏页都flush到磁盘上，这样下次MySQL启动的时候，就可以直接从磁盘上读数据，启动速度会很快。</li></ol><h1 id="InnoDB刷脏页的控制策略"><a href="#InnoDB刷脏页的控制策略" class="headerlink" title="InnoDB刷脏页的控制策略"></a>InnoDB刷脏页的控制策略</h1><p>​InnoDB的刷盘速度就是要参考这两个因素：一个是脏页比例，一个是redo log写盘速度。InnoDB会根据这两个因素先单独算出两个数字。</p><p>​参数innodb_max_dirty_pages_pct是脏页比例上限，默认值是75%。InnoDB会根据当前的<strong>脏页比例</strong>（假设为M），算出一个范围在0到100之间的数字。</p><p>​InnoDB每次写入的日志都有一个序号，当前写入的序号跟checkpoint对应的序号之间的差值（其实就是<strong>脏页的数量</strong>），我们假设为N。InnoDB会根据这个N算出一个范围在0到100之间的数字，这个计算公式可以记为F2(N)。F2(N)算法比较复杂，你只要知道N越大，算出来的值越大就好了。</p><p>然后，<strong>根据上述算得的F1(M)和F2(N)两个值，取其中较大的值记为R，之后引擎就可以按照innodb_io_capacity定义的磁盘读写能力乘以R%来控制刷脏页的速度。</strong></p>]]></content>
      
      
      <categories>
          
          <category> MySQL数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL的日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL架构与存储引擎</title>
      <link href="/2022/08/18/MySQL%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
      <url>/2022/08/18/MySQL%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL数据库架构"><a href="#MySQL数据库架构" class="headerlink" title="MySQL数据库架构"></a>MySQL数据库架构</h1><p>大体来说，MySQL可以分为Server层和存储引擎层两部分。</p><p>Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p><span id="more"></span><p>而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认存储引擎。</p><p>也就是说，你执行create table建表的时候，如果不指定引擎类型，默认使用的就是InnoDB。不过，你也可以通过指定存储引擎的类型来选择别的引擎，比如在create table语句中使用engine&#x3D;memory, 来指定使用内存引擎创建表。</p><p><img src="1.jpg" alt="1"></p><h2 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h2><p>连接器负责跟客户端建立连接、获取权限、维持和管理连接。</p><p>数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p><p>建立连接的过程通常是比较复杂的，在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。</p><p>但是全部使用长连接后，有些时候MySQL占用内存涨得特别快，这是因为MySQL在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是MySQL异常重启了。</p><h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><pre><code>    MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端。如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。    查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</code></pre><p><strong>MySQL 8.0版本直接将查询缓存的整块功能删掉了，</strong></p><h2 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h2><p>MySQL需要知道你要做什么，因此需要对SQL语句做解析。内建解析树，对其语法检查，先from，再on，再join，再where……；检查权限，生成新的解析树，语义检查（没有字段k在这里）等</p><h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p>经过了分析器，MySQL就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。</p><p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的join：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;</span><br></pre></td></tr></table></figure><ul><li>既可以先从表t1里面取出c&#x3D;10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。</li><li>也可以先从表t2里面取出d&#x3D;20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否等于10。</li></ul><p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。</p><p>优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。</p><h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>获取锁，打开表，通过meta数据，获取数据</p><p>加入要查询的字段没有索引，那么执行器的执行流程是这样的：</p><ol><li>调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中；</li><li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li><li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li></ol><p>至此，这个语句就执行完成了。</p><p>对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。</p><p>你会在数据库的慢查询日志中看到一个rows_examined的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。</p><p>在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此<strong>引擎扫描行数跟rows_examined并不是完全相同的。</strong></p><h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><h2 id="InnoDB-和-MyISAM"><a href="#InnoDB-和-MyISAM" class="headerlink" title="InnoDB 和 MyISAM"></a>InnoDB 和 MyISAM</h2><p>存储引擎的好处是，每个存储引擎都有各自的特点，能够根据具体的应用建立不同存储引擎表。目前最常用的两个存储引擎为InnoDB和MyISAM，我们简要介绍一下这两款存储引擎的异同，对于其他的存储引擎，例如NDB Cluster、Memory等，等以后用到了再学习。</p><h2 id="InnoDB（默认）"><a href="#InnoDB（默认）" class="headerlink" title="InnoDB（默认）"></a>InnoDB（默认）</h2><ul><li>InnoDB存储引擎**、支持外键，其设计目标主要面向在线事务处理（OLTP）的应用，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务。</li><li>InnoDB是行锁设计，也就是锁的粒度最小为行，并支持类似于Oracle的非锁定读，即默认读取操作不会产生锁。</li><li>InnoDB通过使用多版本并发控制（MVCC）来获得高并发性，并且实现了SQL标准的4种隔离级别，默认为REPEATABLE READ级别。InnoDB存储引擎在REPEATABLE READ事务隔离级别下，可以使用Next-KeyLock的锁算法避免幻读的产生，也就是说对于InnoDB在RR级别下就完全遵循和满足事务的ACID特性了。</li><li>InnoDB存储引擎的表使用聚集索引和辅助索引的机制（数据存在聚集索引叶子节点上），单独存放到一个独立的ibd文件中。</li><li>除此之外，InnoDB储存引擎还提供了插入缓冲（insert buffer）、二次写（double write）、自适应哈希索引（adaptive hash index）、预读（read ahead）等高性能和高可用的功能。</li></ul><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><ul><li>MyISAM存储引擎不支持事务、支持全文索引，主要面向一些OLAP数据库应用。</li><li>MyISAM是表锁设计，也就是锁的粒度最小为表。</li><li>MyISAM的缓冲池只缓存（cache）索引文件，而不缓冲数据文件，这点和大多数的数据库都非常不同。</li><li>MyISAM存储引擎表是使用普通索引（没有主次之分，都是平级的），由MYD和MYI组成，MYD用来存放数据文件，MYI用来存放索引文件。</li></ul><table><thead><tr><th>存储引擎</th><th>事务</th><th>外键</th><th>锁粒度</th><th>全文索引</th><th>索引类别</th><th>表文件</th><th></th></tr></thead><tbody><tr><td>InnoDB</td><td>支持</td><td>支持</td><td>表锁、行锁（默认）</td><td>5.7之后支持</td><td>聚集索引 + 辅助索引</td><td>.frm + .ibd</td><td></td></tr><tr><td>MyISAM</td><td>不支持</td><td>不支持</td><td>表锁</td><td>支持</td><td>平级索引</td><td>.frm + .MYI + .MYD</td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> MySQL数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL架构与存储引擎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库SELECT执行流程</title>
      <link href="/2022/08/18/%E6%95%B0%E6%8D%AE%E5%BA%93SELECT%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
      <url>/2022/08/18/%E6%95%B0%E6%8D%AE%E5%BA%93SELECT%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL数据库架构"><a href="#MySQL数据库架构" class="headerlink" title="MySQL数据库架构"></a>MySQL数据库架构</h1><p>大体来说，MySQL可以分为Server层和存储引擎层两部分。</p><p>Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p><span id="more"></span><p>而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认存储引擎。</p><p>也就是说，你执行create table建表的时候，如果不指定引擎类型，默认使用的就是InnoDB。不过，你也可以通过指定存储引擎的类型来选择别的引擎，比如在create table语句中使用engine&#x3D;memory, 来指定使用内存引擎创建表。</p><p><img src="blog\source_posts\MySQL架构与存储引擎\1.jpg" alt="1"></p><h2 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h2><p>连接器负责跟客户端建立连接、获取权限、维持和管理连接。</p><p>数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p><p>建立连接的过程通常是比较复杂的，在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。</p><p>但是全部使用长连接后，有些时候MySQL占用内存涨得特别快，这是因为MySQL在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是MySQL异常重启了。</p><h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p>​MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端。如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。</p><p>​查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</p><p><strong>MySQL 8.0版本直接将查询缓存的整块功能删掉了，</strong></p><h2 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h2><p>MySQL需要知道你要做什么，因此需要对SQL语句做解析。内建解析树，对其语法检查，先from，再on，再join，再where……；检查权限，生成新的解析树，语义检查（没有字段k在这里）等</p><h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p>经过了分析器，MySQL就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。</p><p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的join：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;</span><br></pre></td></tr></table></figure><ul><li>既可以先从表t1里面取出c&#x3D;10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。</li><li>也可以先从表t2里面取出d&#x3D;20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否等于10。</li></ul><p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。</p><p>优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。</p><h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>获取锁，打开表，通过meta数据，获取数据</p><p>加入要查询的字段没有索引，那么执行器的执行流程是这样的：</p><ol><li>调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中；</li><li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li><li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li></ol><p>至此，这个语句就执行完成了。</p><p>对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。</p><p>你会在数据库的慢查询日志中看到一个rows_examined的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。</p><p>在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此<strong>引擎扫描行数跟rows_examined并不是完全相同的。</strong></p><p><a href="https://cloud.tencent.com/developer/article/1402181">参考</a></p>]]></content>
      
      
      <categories>
          
          <category> MySQL数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库SELECT执行流程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL语句级SELECT处理流程</title>
      <link href="/2022/08/17/SQL%E8%AF%AD%E5%8F%A5%E7%BA%A7SELECT%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/"/>
      <url>/2022/08/17/SQL%E8%AF%AD%E5%8F%A5%E7%BA%A7SELECT%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>​查询操作是关系数据库中使用最为频繁的操作，也是构成其他SQL语句（如DELETE、UPDATE）的基础，一个简单的 select 语句其背后的执行确实十分复杂的，我们不仅要学会怎么用，而且要知晓其背后的原理。对于查询处理，可将其分为<code>逻辑查询处理</code>及<code>物理查询处理</code>。逻辑查询处理表示执行查询应该产生什么样的结果，而物理查询代表 MySQL 数据库是如何得到该结果的（例如MySQL内部对语句的优化）。两种查询的方法可能完全不同，但是得到的结果必定是相同的。</p><span id="more"></span><h2 id="逻辑查询处理"><a href="#逻辑查询处理" class="headerlink" title="逻辑查询处理"></a>逻辑查询处理</h2><p>我们可能知道SQL语句的执行顺序不是按照编码顺序的，例如我们在select后面对列起的别名为什么在where里不能使用？这种问题的答案其实就是因为SQL语句的执行顺序导致的。先给出结论，接下来我们将具体分析其执行过程。</p><p><img src="https://note.youdao.com/yws/api/personal/file/49DDF5C52FA1430A81BAA76EB00154A1?method=download&shareKey=09849fae1e53e5fe3e26dfe3bdaad8a3" alt="img"></p><p>可以看到一共有11个步骤，最先执行的是FROM操作，最后执行的是LIMIT操作。每个操作都会产生一张虚拟表，该虚拟表作为一个处理的输入。这些虚拟表对用户是隐藏的，只有最后一步生成的虚拟表才会返回给用户。如果没有在查询中指定某一子句，则将跳过相应的步骤。</p><p>接着我们来具体分析查询处理的各个阶段：</p><h3 id="1-FROM（笛卡尔积）"><a href="#1-FROM（笛卡尔积）" class="headerlink" title="1. FROM（笛卡尔积）"></a>1. FROM（笛卡尔积）</h3><p>对FROM子句中的左表 和右表 执行笛卡儿积（Cartesian product），也叫作交叉连结，产生虚拟表VT1。</p><h3 id="2-ON（第一次过滤）"><a href="#2-ON（第一次过滤）" class="headerlink" title="2. ON（第一次过滤）"></a>2. ON（第一次过滤）</h3><p>对虚拟表VT1应用ON筛选，只有那些符合的行才被插入虚拟表VT2中。</p><p><strong>注意</strong>：对于大多数的编程语言而言，逻辑表达式的值只有两种：TRUE和FALSE。但是在关系数据库中起逻辑表达式作用的并非只有两种，还有一种称为三值逻辑的表达式。<br>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select 1 = NULL;</span><br><span class="line">+----------+</span><br><span class="line">| 1 = NULL |</span><br><span class="line">+----------+</span><br><span class="line">|     NULL |</span><br><span class="line">+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select NULL = NULL;</span><br><span class="line">+-------------+</span><br><span class="line">| NULL = NULL |</span><br><span class="line">+-------------+</span><br><span class="line">|        NULL |</span><br><span class="line">+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>第一个NULL值的比较返回的是NULL而不是0，第二个NULL值的比较返回的仍然是NULL，而不是1。对于比较返回值为NULL的情况，用户应该将其视为UNKNOWN，即表示未知的。这时为什么哪？因为在某些情况下，NULL返回值可能代表1，即NULL等于NULL，而有时NULL返回值可能代表0，对于在ON过滤条件下的NULL值比较，此时的比较结果为UNKNOWN，但视为FALSE来进行处理，因为是未知的，即两个NULL并不相同。但是在下面两种情况下认为两个NULL值的比较是相等的：</p><ul><li>GROUP BY子句把所有 NULL 值分到同一组</li><li>ORDER BY子句中把所有 NULL 值排列在一起（NULL值默认最小）</li></ul><h3 id="3-JOIN（有可能添加外部行）"><a href="#3-JOIN（有可能添加外部行）" class="headerlink" title="3. JOIN（有可能添加外部行）"></a>3. JOIN（有可能添加外部行）</h3><p>如果指定了OUTER JOIN（如LEFT OUTER JOIN、RIGHT OUTER JOIN），那么保留表中未匹配的行作为外部行添加到虚拟表VT2中，产生虚拟表VT3。如果FROM子句包含两个以上表，则对上一个连接生成的结果表VT3和下一个表重复执行步骤1）～步骤3），直到处理完所有的表为止。</p><p><strong>注意</strong>：所以这里我们发现上面 ON 的第一次过滤并非永久过滤，在后面的 OUTER JOIN 可能还会将过滤掉的行添加进去，这与下面的 WHERE 是不同的，WHERE 的过滤是永久过滤的，所以有时将过滤条件写在ON 和 WHERE 上会造成不同的结果，但如果是内连接（不添加外部行），过滤条件在ON子句和WHERE子句中是没有任何区别的。</p><h3 id="4-WHERE（第二次过滤）"><a href="#4-WHERE（第二次过滤）" class="headerlink" title="4. WHERE（第二次过滤）"></a>4. WHERE（第二次过滤）</h3><p>对虚拟表VT3应用WHERE过滤条件，只有符合的记录才被插入虚拟表VT4中。</p><p><strong>注意</strong>：由于 WHERE 是在 SELECT 之前调用，所以</p><ul><li>由于数据还没有分组，因此现在还不能在WHERE过滤器中使用 where_condition&#x3D;MIN(col) 这类对统计的过滤。</li><li>由于没有进行列的选取操作，因此在SELECT中使用列的别名也是不被允许的，如SELECT city as c FROM t WHERE c&#x3D;’ShangHai’是不允许出现的。</li></ul><h3 id="5-GROUP-BY"><a href="#5-GROUP-BY" class="headerlink" title="5. GROUP BY"></a>5. GROUP BY</h3><p>根据GROUP BY子句中的列，对VT4中的记录进行分组操作，产生VT5。</p><p><strong>注意</strong>：前面已经介绍了在执行GROUP BY阶段，数据库认为两个NULL值是相等的，因此会将NULL值分到同一个分组中。</p><h3 id="6-CUBE-ROLLUP"><a href="#6-CUBE-ROLLUP" class="headerlink" title="6. CUBE | ROLLUP"></a>6. CUBE | ROLLUP</h3><p>对表VT5进行CUBE或ROLLUP操作，产生表VT6。</p><p>group by 为对列进行分组，只展现分组统计的值，而rollup为分层次展现，cube为展现列中所有层次，用于对多个列进行分组时，简单了解即可。例如 group by a,b,c ;那么</p><ul><li>group by a,b,c with rollup; 就相当于 group by a + group by a,b + group by a,b,c；</li><li>group by a,b,c with cube; 就相当于 group by a + group by b + group by c + group by a,b + group by a,c + group by b,c + group by a,b,c;</li></ul><h3 id="7-HAVING（第三次过滤）"><a href="#7-HAVING（第三次过滤）" class="headerlink" title="7. HAVING（第三次过滤）"></a>7. HAVING（第三次过滤）</h3><p>对虚拟表VT6应用HAVING过滤器，只有符合的记录才被插入虚拟表VT7中。</p><p><strong>注意</strong>：</p><ul><li>HAVING是对分组条件进行过滤的筛选器，即过滤的是分组而不是记录，ON 和 WHERE 过滤的都是行，而 HAVING 必须在 GROUP BY 之后过滤的是整个分组。</li><li>在这个分组中如果使用到 COUNT( ) 时要特别注意能否使用 COUNT(1) 或 COUNT(*)，因为这会把通过OUTER JOIN添加的行（包含NULL值）统计入内，视实际需要而定。</li></ul><p><strong>补充：关于count</strong></p><ol><li><code>count(1)</code>与<code>count(*)</code>得到的结果一致，包含<code>null</code>值。</li><li><code>count(字段)</code>不计算<code>null</code>值</li><li><code>count(null)</code>结果恒为0</li></ol><p><strong>含义：</strong></p><p>1、count(<em>) ：统计所有的行数，包括为null的行（COUNT(</em>)不单会进行全表扫描，也会对表的每个字段进行扫描。而COUNT(‘x’)或者COUNT(COLUMN)或者COUNT(0)等则只进行一个字段的全表扫描）。</p><p>2、count(1)：计算一共有多少符合条件的行，不会忽略null值（其实就可以想成表中有这么一个字段,这个字段就是固定值1,count(1),就是计算一共有多少个1..同理,count(2),也可以,得到的值完全一样,count(‘x’),count(‘y’)都是可以的。count(*),执行时会把星号翻译成字段的具体名字,效果也是一样的,不过多了一个翻译的动作,比固定值的方式效率稍微低一些。）</p><p>3、count(列名)：查询列名那一列的，字段为null不统计（这里的空不是只空字符串或者0，而是表示null）的计数，即某个字段值为NULL时，不统计。<br>执行效果：</p><p>1、count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL。</p><p>2、count(1)包括了忽略所有列，用1代表代码行，在统计结果的时候，不会忽略列值为NULL。</p><p>3、count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空。<br>执行效率：</p><p>列名为主键，count(列名)会比count(1)快  </p><p>列名不为主键，count(1)会比count(列名)快  </p><p>如果表多个列并且没有主键，则 count（1） 的执行效率优于 count（*）  </p><p>如果有主键，则 select count（主键）的执行效率是最优的  </p><p>如果表只有一个字段，则 select count（*）最优</p><h3 id="8-SELECT"><a href="#8-SELECT" class="headerlink" title="8. SELECT"></a>8. SELECT</h3><p>第二次执行SELECT操作，选择指定的列，插入到虚拟表VT8中。</p><p><strong>注意</strong>：列的别名也不能在SELECT中的其他别名表达式中使用，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select order_id as o, o+1 as n from orders; -- ×</span><br></pre></td></tr></table></figure><h3 id="9-DISTINCT"><a href="#9-DISTINCT" class="headerlink" title="9. DISTINCT"></a>9. DISTINCT</h3><p>去除重复数据，产生虚拟表VT9。这张内存临时表的表结构和上一步产生的虚拟表一样，不同的是对进行DISTINCT操作的列增加了一个<strong>唯一索引</strong>，以此来去除重复数据。另外，对于使用了GROUP BY的查询，再使用DISTINCT是多余的，因为已经进行分组，不会移除任何行。</p><h3 id="10-ORDER-BY"><a href="#10-ORDER-BY" class="headerlink" title="10. ORDER BY"></a>10. ORDER BY</h3><p>将虚拟表VT9中的记录按照进行排序操作，产生虚拟表VT10。</p><p><strong>注意</strong>:</p><ul><li>没有 ORDER BY 得到数据并非总是按照主键顺序进行排序的，把数据库想象成集合，SELECT 就是从集合中取元素，所以不要为表中的行假定任何特定的顺序。就是说，在实际使用环境中，如果确实需要有序输出行记录，则必须使用 ORDER BY 子句。</li><li>前面已经提到，在ORDER BY子句中，NULL值被认为是相同 的值，并且是最小的。</li></ul><h3 id="11-LIMIT"><a href="#11-LIMIT" class="headerlink" title="11. LIMIT"></a>11. LIMIT</h3><p>取出指定行的记录，产生虚拟表VT11，并返回给查询用户。对于没有应用ORDER BY的LIMIT子句，结果同样可能是无序的，因此LIMIT子句通常和ORDER BY子句一起使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. limit 是一个MySQL&quot;方言&quot;</span><br><span class="line">2. 语法：limit 每页查询的条数 offset 开始的索引,</span><br><span class="line">   简化版：limit 开始的索引,每页查询的条数;</span><br><span class="line">3. 公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数</span><br><span class="line"></span><br><span class="line">-- 每页显示3条记录 </span><br><span class="line">SELECT * FROM student LIMIT 0,3; -- 第1页</span><br><span class="line">SELECT * FROM student LIMIT 3,3; -- 第2页</span><br><span class="line">SELECT * FROM student LIMIT 6,3; -- 第3页</span><br><span class="line">![img](https://dev.mysql.com/doc/refman/8.0/en/images/mysql-architecture.png)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL语句级SELECT处理流程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL中的变量类型</title>
      <link href="/2022/08/17/MySQL%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/"/>
      <url>/2022/08/17/MySQL%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h2><h3 id="UNSIGNED"><a href="#UNSIGNED" class="headerlink" title="UNSIGNED"></a>UNSIGNED</h3><p>​UNSIGNED 属性就是将数字类型无符号化，与C、C++这些程序语言中的unsigned含义相同。例如，INT的类型范围是-2147483648～2147483647， INTUNSIGNED的范围类型就是0～4294967295。但要注意使用这个属性时可能会出现错误和无法预料的情况，例如： </p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+-------+-------------------------------------------------------------------------------+</span><br><span class="line">| Table | Create Table                                                                                                                                           |</span><br><span class="line">+-------+-------------------------------------------------------------------------------+</span><br><span class="line">| t     | CREATE TABLE `t` (</span><br><span class="line">  `a` int unsigned DEFAULT NULL,</span><br><span class="line">  `b` int unsigned DEFAULT NULL</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci |</span><br><span class="line">+-------+-------------------------------------------------------------------------------+</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t select 1,2; -- 插入数据</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t;</span><br><span class="line">+------+------+</span><br><span class="line">| a    | b    |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 |    2 |</span><br><span class="line">+------+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select a - b from t;</span><br><span class="line">ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in &#x27;(`eesy_mybatis`.`t`.`a` - `eesy_mybatis`.`t`.`b`)&#x27;</span><br></pre></td></tr></table></figure><p>上面 a-b 在windows系统直接报错，不卖关子了，是因为a-b即-1是0xFFFFFFFF，只是0xFFFFFFFF可以代表两种值：对于无符号的整型值，其是整型数的最大值，即4294967295；对于有符号的整型数来说，第一位代表符号位，如果是1，表示是负数，这时应该是取反加1得到负数值，即-1，-1超出了 UNSIGNED 的范围就直接报错了，所以这个谨慎使用。</p><h2 id="基本变量"><a href="#基本变量" class="headerlink" title="基本变量"></a>基本变量</h2><h3 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h3><table><thead><tr><th>类型</th><th>空间</th><th>特点</th></tr></thead><tbody><tr><td>DATETIME</td><td>8 BYTE</td><td>既显示日期，也显示时间，时间范围较大</td></tr><tr><td>DATE</td><td>3 BYTE</td><td>只显示日期，范围同DATETIME</td></tr><tr><td>TIME</td><td>3 BYTE</td><td>只显示时间，范围可正可负，可表示时间间隔</td></tr><tr><td>TIMESTAMP</td><td>4 BYTE</td><td>既显示日期，也显示时间，不过比DATETIME范围小</td></tr><tr><td>YEAR</td><td>1 BYTE</td><td>显示年份，可以指定宽度</td></tr></tbody></table><p>日期函数可能是比较常使用的一种函数。下面介绍一些最为常用的日期函数。</p><ul><li>NOW、CURRENT_TIMESTAMP和SYSDATE<ul><li>CURRENT_TIMESTAMP是NOW的同义词，也就是说两者是相同的。</li><li>SYSDATE函数返回的是执行到当前函数时的时间，而NOW返回的是执行SQL语句时的时间。</li></ul></li></ul><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table t (a int, b timestamp default current_timestamp);</span><br><span class="line">Query OK, 0 rows affected (0.29 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t (a) values (1);</span><br><span class="line">Query OK, 1 row affected (0.05 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t;</span><br><span class="line">+------+---------------------+</span><br><span class="line">| a    | b                   |</span><br><span class="line">+------+---------------------+</span><br><span class="line">|    1 | 2022-08-17 22:06:56 |</span><br><span class="line">+------+---------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h3><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><table><thead><tr><th>类型</th><th>空间</th><th>范围</th></tr></thead><tbody><tr><td>TINYINT</td><td>1 BYTES</td><td>-128 ~ 127</td></tr><tr><td>SMALLINT</td><td>2 BYTES</td><td>…</td></tr><tr><td>MEDIUMINT</td><td>3 BYTES</td><td>…</td></tr><tr><td>INT</td><td>4 BYTES</td><td>-2147483648 ~ 2147483647</td></tr><tr><td>BIGINT</td><td>8 BYTES</td><td>…</td></tr></tbody></table><h4 id="浮点型（非精确类型）"><a href="#浮点型（非精确类型）" class="headerlink" title="浮点型（非精确类型）"></a>浮点型（非精确类型）</h4><table><thead><tr><th>类型</th><th>空间</th><th>范围</th></tr></thead><tbody><tr><td>FLOAT</td><td>4 bytes</td><td>单精度</td></tr><tr><td>DOUBLE</td><td>8 bytes</td><td>双精度</td></tr></tbody></table><h4 id="高精度类型"><a href="#高精度类型" class="headerlink" title="高精度类型"></a>高精度类型</h4><p>DECIMAL 用于保存必须为确切精度的值。</p><blockquote><p>ref: 《阿里巴巴Java开发手册》</p><p>【强制】小数类型为 decimal，禁止使用 float和 double。 说明：float和 double在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不 正确的结果。如果存储的数据范围超过 decimal的范围，建议将数据拆成整数和小数分开存储</p></blockquote><p>使用：decimal(a,b)<br>参数说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- a:指定小数点左边和右边可以存储的十进制数字的最大个数，最大为65。</span><br><span class="line">- b:指定小数点右边可以存储的十进制数字的最大个数。小数位数必须是从0~a之间的值，默认小数位数是0. </span><br><span class="line">举例说明，11615.23653234568</span><br><span class="line">1. decimal：11615，等价于 decimal(5, 0)</span><br><span class="line">2. decimal(3)：999，等价于 deciaml(3, 0)</span><br><span class="line">3. decimal(10,5)：11615.23653</span><br><span class="line">4. decimal(8,3)：11615.237 -- 会四舍五入</span><br><span class="line">超出精度范围的数会被强制进位并只显示数据类型定义的格式</span><br></pre></td></tr></table></figure><h4 id="位类型"><a href="#位类型" class="headerlink" title="位类型"></a>位类型</h4><p>位类型，即BIT数据类型可用来保存位字段的值。BIT(M)类型表示允许存储M位数值，M范围为1到64，占用的空间为 (M+7)&#x2F;8 字节。</p><h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><blockquote><p>拓展：<a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html">关于编码</a></p></blockquote><blockquote><p>ASCII: ASCII 码一共规定了128个字符的编码，比如空格SPACE是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为0。显然 ASCII码 只能满足美国人的需求。</p></blockquote><blockquote><p>UNICODE：万国码。Unicode 当然是一个很大的集合，现在的规模可以容纳100多万个符号。需要注意的是，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储，这里就有两个严重的问题，第一个问题是，如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。</p></blockquote><blockquote><p>UTF-8：这里的关系是，UTF-8 是 Unicode 的实现方式之一。UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</p></blockquote><p>字符串类型指 CHAR 和 VARCHAR、BINARY 和 VARBINARY、BLOB 和 TEXT、ENUM 和 SET。<br>| 类型 | 大小 | 用途 |<br>| ———- | ————————- | ——————————- |<br>| CHAR | 0-255 (2^8) bytes | 定长字符串 |<br>| VARCHAR | 0-65535 (2^16) bytes | 变长字符串 |<br>| TINYBLOB | 0-255 (2^8) bytes | 不超过 255 个字符的二进制字符串 |<br>| BLOB | 0-65535 (2^16) bytes | 二进制形式的长文本数据 |<br>| MEDIUMBLOB | 0-16777215 (2^24) bytes | 二进制形式的中等长度文本数据 |<br>| LONGBLOB | 0-4294967295 (2^32) bytes | 二进制形式的极大文本数据 |<br>| TINYTEXT | 0-255 (2^8) bytes | 短文本字符串 |<br>| TEXT | 0-65535 (2^16) bytes | 长文本数据 |<br>| MEDIUMTEXT | 0-16777215 (2^24) bytes | 中等长度文本数据 |<br>| LONGTEXT | 0-4294967295 (2^32) bytes | 极大文本数据 |</p><h4 id="CHAR-和-VARCHAR"><a href="#CHAR-和-VARCHAR" class="headerlink" title="CHAR 和 VARCHAR"></a>CHAR 和 VARCHAR</h4><ul><li>CHAR(n) 和 VARCHAR(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。</li><li>对于 CHAR 类型的字符串，MySQL 数据库会自动对存储列的右边进行填充（RightPadded）操作，直到字符串达到指定的长度N。而在读取该列时，MySQL 数据库会自动将填充的字符删除。</li><li>VARCHAR 类型存储变长字段的字符类型，与 CHAR 类型不同的是，其存储时需要在前缀长度列表加上实际存储的字符，该字符占用1～2字节的空间。当存储的字符串长度小于255字节时，其需要1字节的空间，当大于255字节时，需要2字节的空间。所以，对于单字节的 latin1 来说，CHAR（10）占用10个字节这是毫无疑问的，而 VARCHAR（10）的最大占用空间数是11字节，因为其需要1字节来存放字符长度。</li><li>CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。</li></ul><blockquote><p>ref: 《阿里巴巴Java开发手册》</p><p><strong>【强制】varchar是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。</strong></p></blockquote><h4 id="BINARY-和-VARBINARY"><a href="#BINARY-和-VARBINARY" class="headerlink" title="BINARY 和 VARBINARY"></a>BINARY 和 VARBINARY</h4><p>BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，对其排序和比较都是按照二进制值进行对比。BINARY（N）和 VARBINARY（N）中的 N 指的是字节长度。</p><h4 id="BLOB-和-TEXT"><a href="#BLOB-和-TEXT" class="headerlink" title="BLOB 和 TEXT"></a>BLOB 和 TEXT</h4><p>在大多数情况下，可以将 BLOB 类型的列视为足够大的 VARBINARY 类型的列。同样，也可以将TEXT类型的列视为足够大的 VARCHAR 类型的列。然而，BLOB 和 TEXT 在以下几个方面又不同于 VARBINARY 和 VARCHAR：</p><ul><li>在BLOB和TEXT类型的列上创建索引时，必须指定索引前缀的长度。而VARCHAR和VARBINARY的前缀长度是可选的。</li><li>BLOB和TEXT类型的列不能有默认值。</li><li>在排序时只使用列的前max_sort_length个字节。</li></ul><p>另外还有一点需要注意，即 BLOB 和 TEXT 的存储也与其他类型不同。在数据库中，最小的存储单元是页（也可以称为块）。为了有效存储列类型为BLOB或TEXT的大数据类型，一般将列的值存放在行溢出页（其他页&#x2F;块），而数据页存储的行数据只包含BLOB或TEXT类型数据列前一部分数据。例如InnoDB存储引擎只存储前20字节，而该列的完整数据则存放在BLOB的行溢出页中。在这种方式下，数据页中能存放大量的行数据，从而提高了数据的查询效率，而且Innodb会将大 VARCHAR 类型字符串（如VARCHAR（65530））自动转化为 TEXT 或 BLOB 类型。</p><p><img src="1.jpg" alt="1"></p><h4 id="ENUM-和-SET"><a href="#ENUM-和-SET" class="headerlink" title="ENUM 和 SET"></a>ENUM 和 SET</h4><p>ENUM和SET类型都是集合类型，不同的是ENUM类型最多可枚举65536个元素，而SET类型最多枚举64个元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table t (user_name varchar(30), sex enum(&#x27;male&#x27;, &#x27;female&#x27;));</span><br><span class="line">Query OK, 0 rows affected (0.33 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t select &#x27;a&#x27;, &#x27;male&#x27;;</span><br><span class="line">Query OK, 1 row affected (0.05 sec)</span><br><span class="line">Records: 1  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t select &#x27;b&#x27;, &#x27;female&#x27;;</span><br><span class="line">Query OK, 1 row affected (0.07 sec)</span><br><span class="line">Records: 1  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t select &#x27;c&#x27;, &#x27;bimale&#x27;;</span><br><span class="line">ERROR 1265 (01000): Data truncated for column &#x27;sex&#x27; at row 1</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t;</span><br><span class="line">+-----------+--------+</span><br><span class="line">| user_name | sex    |</span><br><span class="line">+-----------+--------+</span><br><span class="line">| a         | male   |</span><br><span class="line">| b         | female |</span><br><span class="line">+-----------+--------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL中的变量类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL基础</title>
      <link href="/2022/08/17/SQL%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/08/17/SQL%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL的大小写问题"><a href="#MySQL的大小写问题" class="headerlink" title="MySQL的大小写问题"></a>MySQL的大小写问题</h2><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><p>首先明确一点，无论在哪个关系型数据库管理系统（DBMS）中，SQL语句的关键字是不区分大小写的。</p><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><ol><li>在Windows下，数据库名、表名、字段名不区分大小写。</li><li>在Linux&#x2F;Unix下，数据库名、表名区分大小写，字段名不区分大小写。</li><li>编辑&#x2F;etc&#x2F;my.cnf，设置lower_case_table_names(0区分，1不区分)可以让MySQL是否区分表名的大小写，所以Linux默认为0，Windows默认为1。</li></ol><span id="more"></span><h2 id="SQL-1"><a href="#SQL-1" class="headerlink" title="SQL"></a>SQL</h2><h3 id="SQL定义"><a href="#SQL定义" class="headerlink" title="SQL定义"></a>SQL定义</h3><p>Structured Query Language：结构化查询语言其实就是定义了操作所有关系型数据库的规则。S同常见的编程语言C++、Java、Python一样，是一种<code>编程语言</code>。同时SQL又是一种标准，每个数据库厂商都提供了对标准SQL的支持，此外SQL语言还扩展了每个数据库特有的SQL语法(方言)。</p><h3 id="SQL通用语法"><a href="#SQL通用语法" class="headerlink" title="SQL通用语法"></a>SQL通用语法</h3><ul><li>SQL 语句可以单行或多行书写，以分号结尾。</li><li>可使用空格和缩进来增强语句的可读性。</li><li>MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。</li><li>3 种注释<ul><li>单行注释: – 注释内容 或 # 注释内容(mysql 特有)</li><li>多行注释: &#x2F;* 注释 *&#x2F;</li></ul></li></ul><h3 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a>SQL分类</h3><ol><li><code>DDL(Data Definition Language)</code>数据定义语言: 用来定义数据库对象数据库、表、列等。关键字：create, drop, alter 等</li><li><code>DML(Data Manipulation Language)</code>数据操作语言: 用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等</li><li><code>DQL(Data Query Language)数据查询语言</code>: 用来查询数据库中表的记录(数据)。关键字：select, where 等</li><li><code>DCL(Data Control Language)数据控制语言</code>(了解): 用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT，REVOKE 等</li></ol><h4 id="DDL：操作数据库、表"><a href="#DDL：操作数据库、表" class="headerlink" title="DDL：操作数据库、表"></a>DDL：操作数据库、表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">1. 操作数据库：CRUD</span><br><span class="line">    1. C(Create):创建</span><br><span class="line">        * 创建数据库：</span><br><span class="line">            * create database 数据库名称;</span><br><span class="line">        * 创建数据库，判断不存在，再创建：</span><br><span class="line">            * create database if not exists 数据库名称;</span><br><span class="line">        * 创建数据库，并指定字符集</span><br><span class="line">            * create database 数据库名称 character set 字符集名;</span><br><span class="line"></span><br><span class="line">        * 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk</span><br><span class="line">            * create database if not exists db4 character set gbk;</span><br><span class="line">    2. R(Retrieve)：查询</span><br><span class="line">        * 查询所有数据库的名称:</span><br><span class="line">            * show databases;</span><br><span class="line">        * 查询某个数据库的字符集:查询某个数据库的创建语句</span><br><span class="line">            * show create database 数据库名称;</span><br><span class="line">    3. U(Update):修改</span><br><span class="line">        * 修改数据库的字符集</span><br><span class="line">            * alter database 数据库名称 character set 字符集名称;</span><br><span class="line">    4. D(Delete):删除</span><br><span class="line">        * 删除数据库</span><br><span class="line">            * drop database 数据库名称;</span><br><span class="line">        * 判断数据库存在，存在再删除</span><br><span class="line">            * drop database if exists 数据库名称;</span><br><span class="line">    5. 使用数据库</span><br><span class="line">        * 查询当前正在使用的数据库名称</span><br><span class="line">            * select database();</span><br><span class="line">        * 使用数据库</span><br><span class="line">            * use 数据库名称;</span><br><span class="line"></span><br><span class="line">2. 操作表: CRUD</span><br><span class="line">    1. C(Create):创建</span><br><span class="line">        * 语法：</span><br><span class="line">            create table 表名(</span><br><span class="line">                列名1 数据类型1,</span><br><span class="line">                列名2 数据类型2,</span><br><span class="line">                ....</span><br><span class="line">                列名n 数据类型n</span><br><span class="line">            );</span><br><span class="line">            * 注意：最后一列，不需要加逗号</span><br><span class="line">        * 创建表</span><br><span class="line">            create table student(</span><br><span class="line">                id int,</span><br><span class="line">                name varchar(32),</span><br><span class="line">                age int ,</span><br><span class="line">                score double(4,1),</span><br><span class="line">                birthday date,</span><br><span class="line">                insert_time timestamp</span><br><span class="line">            );</span><br><span class="line">        * 复制表：</span><br><span class="line">            * create table 表名 like 被复制的表名;          </span><br><span class="line">    2. R(Retrieve)：查询</span><br><span class="line">        * 查询某个数据库中所有的表名称</span><br><span class="line">            * show tables;</span><br><span class="line">        * 查询表结构</span><br><span class="line">            * desc 表名;</span><br><span class="line">    3. U(Update):修改</span><br><span class="line">        1. 修改表名</span><br><span class="line">            alter table 表名 rename to 新的表名;</span><br><span class="line">        2. 修改表的字符集</span><br><span class="line">            alter table 表名 character set 字符集名称;</span><br><span class="line">        3. 添加一列</span><br><span class="line">            alter table 表名 add 列名 数据类型;</span><br><span class="line">        4. 修改列名称 类型</span><br><span class="line">            alter table 表名 change 列名 新列别 新数据类型;</span><br><span class="line">            alter table 表名 modify 列名 新数据类型;</span><br><span class="line">        5. 删除列</span><br><span class="line">            alter table 表名 drop 列名;</span><br><span class="line">    4. D(Delete):删除</span><br><span class="line">        * drop table 表名;</span><br><span class="line">        * drop table if exists 表名;</span><br></pre></td></tr></table></figure><h4 id="DML：增删改表中数据"><a href="#DML：增删改表中数据" class="headerlink" title="DML：增删改表中数据"></a>DML：增删改表中数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1. 添加数据：</span><br><span class="line">    * 语法：</span><br><span class="line">        * insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n);</span><br><span class="line">    * 与 select 搭配使用，select * into t_2 from t_1 与 insert into t_2 select * from t_1 这两种写法的区别？</span><br><span class="line">        1. select * into t_2 from t_1--新建t_2，然后查询结果到t_2，t_2不能事先存在</span><br><span class="line">        2. insert into t_2 select * from t_1--插入结果到t_2，即t_2必须事先存在</span><br><span class="line">    * 注意：</span><br><span class="line">        1. 列名和值要一一对应。</span><br><span class="line">        2. 如果表名后，不定义列名，则默认给所有列添加值</span><br><span class="line">            insert into 表名 values(值1,值2,...值n);</span><br><span class="line">        3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来</span><br><span class="line">2. 删除数据：</span><br><span class="line">    * 语法：</span><br><span class="line">        * delete from 表名 [where 条件]</span><br><span class="line">    * 注意：</span><br><span class="line">        1. 如果不加条件，则删除表中所有记录。</span><br><span class="line">        2. 如果要删除所有记录</span><br><span class="line">            1. delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作</span><br><span class="line">            2. TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表（其实它是DDL，在MySQL中隐式自动提交，无法回滚）。</span><br><span class="line">3. 修改数据：</span><br><span class="line">    * 语法：</span><br><span class="line">        * update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件];</span><br><span class="line">    * 注意：</span><br><span class="line">        1. 如果不加任何条件，则会将表中所有记录全部修改</span><br></pre></td></tr></table></figure><h4 id="DQL：查询表中的记录"><a href="#DQL：查询表中的记录" class="headerlink" title="DQL：查询表中的记录"></a>DQL：查询表中的记录</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">* select * from 表名;</span><br><span class="line"></span><br><span class="line">1. 语法：</span><br><span class="line">    select</span><br><span class="line">        字段列表[distinct&lt;select_list&gt;]</span><br><span class="line">    from</span><br><span class="line">        左表</span><br><span class="line">    [join type] join </span><br><span class="line">        右表</span><br><span class="line">    on</span><br><span class="line">        join condition</span><br><span class="line">    where</span><br><span class="line">        条件列表</span><br><span class="line">    group by</span><br><span class="line">        分组字段</span><br><span class="line">    having</span><br><span class="line">        分组之后的条件</span><br><span class="line">    order by</span><br><span class="line">        排序</span><br><span class="line">    limit</span><br><span class="line">        分页限定</span><br><span class="line"></span><br><span class="line">2. 基础查询</span><br><span class="line">    1. 多个字段的查询</span><br><span class="line">        select 字段名1，字段名2... from 表名；</span><br><span class="line">        * 注意：</span><br><span class="line">            * 如果查询所有字段，则可以使用*来替代字段列表。</span><br><span class="line">    2. 去除重复：</span><br><span class="line">        * distinct</span><br><span class="line">    3. 计算列</span><br><span class="line">        * 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）</span><br><span class="line">        * ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null</span><br><span class="line">            * 表达式1：哪个字段需要判断是否为null</span><br><span class="line">            * 如果该字段为null后的替换值。</span><br><span class="line">    4. 起别名：</span><br><span class="line">        * as：as也可以省略</span><br><span class="line"></span><br><span class="line">3. 条件查询</span><br><span class="line">    1. where子句后跟条件</span><br><span class="line">    2. 运算符</span><br><span class="line">        * &gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt;</span><br><span class="line">        * &lt;=&gt; 等于，MySQL中的方言，跟=的区别是对于NULL值的处理，例如1=null在三值判定逻辑中会输出null，代表不确定，但1&lt;=&gt;null会输出0，代表1不等于null。</span><br><span class="line">        * BETWEEN...AND  </span><br><span class="line">        * IN(集合) ：代表集合范围内的任何一个，等同于 “=ANY(集合)” or “=SOME(集合)” 多用于子查询中</span><br><span class="line">        * EXISTS(集合) ：代表是否存在，通常用于子查询中，外部查询高效地检查指定子查询是否产生某些行</span><br><span class="line">        * NOT EXISTS(集合) ：IN or NOT IN 有不确定的状态，而EXIST只有0 -F 1-T，在IN中不确定的状态与0-F状态的处理相同，所以使用IN与使用EXISTS一样，但是输入列表中包含NULL值时，NOT EXISTS和NOT IN就不一样了</span><br><span class="line">        * ALL(集合) ：代表集合范围内的所有，NOT IN 等同于 “&lt;&gt;ALL” </span><br><span class="line">        * LIKE：模糊查询</span><br><span class="line">            * 占位符：</span><br><span class="line">                * _:单个任意字符</span><br><span class="line">                * %：多个任意字符</span><br><span class="line">        * IS NULL -- 为空   or   IS NOT NULL -- 不为空</span><br><span class="line">        * and 或 &amp;&amp;</span><br><span class="line">        * or 或 || </span><br><span class="line">        * not 或 !</span><br><span class="line">        </span><br><span class="line">            -- 查询年龄大于20岁</span><br><span class="line"></span><br><span class="line">            SELECT * FROM student WHERE age &gt; 20;</span><br><span class="line">            </span><br><span class="line">            SELECT * FROM student WHERE age &gt;= 20;</span><br><span class="line">            </span><br><span class="line">            -- 查询年龄等于20岁</span><br><span class="line">            SELECT * FROM student WHERE age = 20;</span><br><span class="line">            </span><br><span class="line">            -- 查询年龄不等于20岁</span><br><span class="line">            SELECT * FROM student WHERE age != 20;</span><br><span class="line">            SELECT * FROM student WHERE age &lt;&gt; 20;</span><br><span class="line">            </span><br><span class="line">            -- 查询年龄大于等于20 小于等于30</span><br><span class="line">            </span><br><span class="line">            SELECT * FROM student WHERE age &gt;= 20 &amp;&amp;  age &lt;=30;</span><br><span class="line">            SELECT * FROM student WHERE age &gt;= 20 AND  age &lt;=30;</span><br><span class="line">            SELECT * FROM student WHERE age BETWEEN 20 AND 30;</span><br><span class="line">            </span><br><span class="line">            -- 查询年龄22岁，18岁，25岁的信息</span><br><span class="line">            SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25</span><br><span class="line">            SELECT * FROM student WHERE age IN (22,18,25);</span><br><span class="line">            </span><br><span class="line">            -- 查询英语成绩为null</span><br><span class="line">            SELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = （!=） 判断</span><br><span class="line">            </span><br><span class="line">            SELECT * FROM student WHERE english IS NULL;</span><br><span class="line">            </span><br><span class="line">            -- 查询英语成绩不为null</span><br><span class="line">            SELECT * FROM student WHERE english  IS NOT NULL;</span><br><span class="line"></span><br><span class="line">            -- 查询姓马的有哪些？ like</span><br><span class="line">            SELECT * FROM student WHERE NAME LIKE &#x27;马%&#x27;;</span><br><span class="line">            -- 查询姓名第二个字是化的人</span><br><span class="line">            </span><br><span class="line">            SELECT * FROM student WHERE NAME LIKE &quot;_化%&quot;;</span><br><span class="line">            </span><br><span class="line">            -- 查询姓名是3个字的人</span><br><span class="line">            SELECT * FROM student WHERE NAME LIKE &#x27;___&#x27;;</span><br><span class="line">            </span><br><span class="line">            -- 查询姓名中包含德的人</span><br><span class="line">            SELECT * FROM student WHERE NAME LIKE &#x27;%德%&#x27;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类的加载与初始化</title>
      <link href="/2022/08/09/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/2022/08/09/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p><strong>如今再看之前写的东西，简直是漏洞百出，之前对Java理解浅薄，现在再看初始化应该叫做实例化，当然这对初学者还是值得一看的，如果想真正理解类的加载和实例化的过程，还需要深入学习JVM。</strong></p><ul><li>类只有在用到时才进行加载，并且只加载一次，首先加载main的入口类，因为它第一个被用到喽，如果入口类有父类，则先加载入口类的父类。第一次加载时会按照定义顺序初始化类中的静态区，即被static修饰的，注意static方法里的局部变量是不会被初始化的，如果有人问如果static方法里面万一有个static变量怎么办？？好问题，不过这种情况是不存在的，因为static不能修饰局部变量。</li></ul><span id="more"></span><ul><li>只有在创建对象时才会对非静态区进行初始化，最后调用构造方法，即在调用构造方法前，所有的初始化都已经完成，换个角度而言，在对象创建之前，非静态区都无法被使用，所以就没必要初始化。</li><li>有一点难以理解的是【欢迎讨论】，导出类的构造方法一定会调用基类的构造方法，尽管调用基类的代码在导出类构造方法中，即看似在导出类非静态对象或变量之后，但初始化顺序仍然为先基类构造方法再导出类非静态对象或变量，再是导出类构造方法。</li></ul><p>所以一般来说初始化及加载的流程为：</p><blockquote><p>加载类&gt;&gt;<strong>基类的</strong>static区（static段、static对象和static变量）&gt;<strong>子类的</strong>static区（static段、static对象和static变量）&gt;&gt;【创建对象】&gt;&gt;<strong>基类的</strong>非静态对象或变量&gt;<strong>基类的</strong>构造方法&gt;&gt;<strong>子类的</strong>非静态对象或变量&gt;<strong>子类的</strong>构造方法。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Base&#123;</span><br><span class="line">    static int i;</span><br><span class="line">    static&#123;</span><br><span class="line">        System.out.println(&quot;Base static&quot;);</span><br><span class="line">        System.out.println(&quot;Static int i = &quot; + i);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;Base notStatic block&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public Base(int i)&#123;</span><br><span class="line">        System.out.println(&quot;Base constructor&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test extends Base&#123;</span><br><span class="line">    static&#123;</span><br><span class="line">        System.out.println(&quot;Test static&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public Test()&#123;</span><br><span class="line">        super(1);</span><br><span class="line">        System.out.println(&quot;Test constructor&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;Test notStatic block&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Test test = new Test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*Output:</span><br><span class="line">    Base static</span><br><span class="line">    Static int i = 0</span><br><span class="line">    Test static</span><br><span class="line">    Base notStatic block</span><br><span class="line">    Base constructor</span><br><span class="line">    Test notStatic block</span><br><span class="line">    Test constructor</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><hr><p>更新：</p><p>有一点需要注意的是，当基类有多个构造方法时，此时并不是每个构造方法都会初始化，<strong>只初始化需要的构造方法</strong>，当然可能还会涉及到更为复杂的<strong>动态绑定</strong>问题。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A(1)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A(2)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B(1)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B(2)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">C</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">1</span>); <span class="comment">//此时调用有参的构造方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;C()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Output:</span></span><br><span class="line"><span class="comment">    B(1)</span></span><br><span class="line"><span class="comment">    A(1)</span></span><br><span class="line"><span class="comment">    B(2)</span></span><br><span class="line"><span class="comment">    C()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类的加载与初始化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初始化与清理</title>
      <link href="/2022/08/09/%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/"/>
      <url>/2022/08/09/%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="用构造器确保初始化"><a href="#用构造器确保初始化" class="headerlink" title="用构造器确保初始化"></a><strong>用构造器确保初始化</strong></h1><p> 在创建对象时，将会为对象分配存储空间，并调用相应的构造器，确保了在调用对象前可以通过构造器进行初始化。</p><h1 id="默认构造器"><a href="#默认构造器" class="headerlink" title="默认构造器"></a><strong>默认构造器</strong></h1><p> 如果你写的类中，没有构造器，那么编译器会自动帮你创建一个默认构造器（无参数），但是如果你已经定义了构造器（无论是否有参数），编译器就不会帮你自动创建默认构造器。</p><span id="more"></span><h1 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a><strong>this关键字</strong></h1><p> this只能在方法内部使用，表示对“调用方法的那个对象”的引用，this的用法和其他对象引用（注意理解对象引用<a href="https://www.cnblogs.com/java-sky/p/7200085.html%EF%BC%89%E5%B9%B6%E6%97%A0%E4%B8%8D%E5%90%8C%E3%80%82">https://www.cnblogs.com/java-sky/p/7200085.html）并无不同。</a></p><p><strong>注意：</strong>如果在方法内部调用同一个类的另一个方法，就不必使用this，直接调用即可。</p><p><strong>this主要作用：</strong></p><p>​this可以调用类的成员变量和成员方法,this还可以调用类中的构造方法.使用这种方式值得注意的是, 只可以在无参构造方法中的第一句使用this关键字调用有参构造方法</p><ul><li>当成员变量与局部变量同名时，用来区分成员变量和局部变量。有时我们为了让变量更具有语义化，经常会出现成员变量和局部变量同名的问题，这时候就要用到this了，比如以下代码：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class World &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Demo d = new Demo(&quot;张三&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Demo &#123;</span><br><span class="line">    String name;</span><br><span class="line">    Demo(String name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在构造函数中调用另一个构造函数。我们知道，构造函数只能在对象创建的时候调用仅调用一次，但是利用this关键字可以在构造函数中调用其他重载的构造函数。<em>注意：用this调用构造函数的语句一定要写在第一行，且不能调用两个；除构造器之外，编译器禁止在其他任何方法中调用构造器。</em></li><li>当需要返回对当前对象的引用时，常常在return里这样写：return this；或者用于将当前对象传递给其他方法，例如将自身传递给外部方法。</li></ul><h1 id="成员初始化"><a href="#成员初始化" class="headerlink" title="成员初始化"></a><strong>成员初始化</strong></h1><p><strong>（1）指定初始化</strong></p><p> 对于方法的局部变量，未初始化会编译错误；类的成员变量不同，未初始化时编译器会给初值，对象引用未初始化时会获得一个特殊值null。</p><p> 还有一种方法是在定义变量时就进行赋值。</p><p><strong>（2）构造器初始化</strong></p><p><strong>初始化顺序：</strong></p><p> 在类的内部，变量定义的先后顺序决定了初始化的顺序。即使变量定义散布于方法定义之间，它们仍旧会在任何方法（包括构造器）被调用之前得到初始化，<em>其中静态对象（static）先初始化，而后是非静态对象。对于静态对象的初始化，静态初始化只有在必要的时候才会进行，并且静态初始化只有在Class对象首次加载的时候进行一次。</em></p><p> static变量也称作静态变量，静态变量和非静态变量的区别是：<strong>静态变量被所有的对象所共享，在内存中只有一个副本</strong>，<em>它当且仅当在类初次加载时会被初始化</em>。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。static成员变量的初始化顺序按照定义的顺序进行初始化。<em>注意static不能修饰局部变量</em>。</p><p><strong>static示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    Person person = new Person(&quot;Test&quot;);</span><br><span class="line">    static&#123;</span><br><span class="line">        System.out.println(&quot;test static&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public Test() &#123;</span><br><span class="line">        System.out.println(&quot;test constructor&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new MyClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Person&#123;</span><br><span class="line">    static&#123;</span><br><span class="line">        System.out.println(&quot;person static&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public Person(String str) &#123;</span><br><span class="line">        System.out.println(&quot;person &quot;+str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class MyClass extends Test &#123;</span><br><span class="line">    Person person = new Person(&quot;MyClass&quot;);</span><br><span class="line">    static&#123;</span><br><span class="line">        System.out.println(&quot;myclass static&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public MyClass() &#123;</span><br><span class="line">        System.out.println(&quot;myclass constructor&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*Output:</span><br><span class="line">    test static</span><br><span class="line">    myclass static</span><br><span class="line">    person static</span><br><span class="line">    person Test</span><br><span class="line">    test constructor</span><br><span class="line">    person MyClass</span><br><span class="line">    myclass constructor</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p> 来看一下这段代码的具体执行过程。首先加载Test类，因此会执行Test类中的static块。接着执行new MyClass()，而MyClass类还没有被加载，因此需要加载MyClass类。在加载MyClass类的时候，发现MyClass类继承自Test类，但是由于Test类已经被加载了，所以只需要加载MyClass类，那么就会执行MyClass类的中的static块。在加载完之后，就通过构造器来生成对象。而在生成对象的时候，必须先初始化父类的成员变量，因此会执行Test中的Person person &#x3D; new Person()，而Person类还没有被加载过，因此会先加载Person类并执行Person类中的static块，接着执行父类的构造器，完成了父类的初始化，然后就来初始化自身了，因此会接着执行MyClass中的Person person &#x3D; new Person()，最后执行MyClass的构造器。(是不是很迷惑，建议看我上一篇初始化及类的加载)</p><p><strong>初始化示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bowl</span> &#123;</span><br><span class="line">    Bowl(<span class="type">int</span> maker) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bowl(&quot;</span> + maker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> maker)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;f1(&quot;</span> + maker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Table</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Bowl</span> <span class="variable">bowl1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bowl</span>(<span class="number">1</span>);</span><br><span class="line">    Table() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Table()&quot;</span>);</span><br><span class="line">        bowl2.f1(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">(<span class="type">int</span> maker)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;f2(&quot;</span> + maker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Bowl</span> <span class="variable">bowl2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bowl</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cupboard</span> &#123;</span><br><span class="line">    <span class="type">Bowl</span> <span class="variable">bowl3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bowl</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Bowl</span> <span class="variable">bowl4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bowl</span>(<span class="number">4</span>);</span><br><span class="line">    Cupboard() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CupBoard()&quot;</span>);</span><br><span class="line">        bowl4.f1(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f3</span><span class="params">(<span class="type">int</span> maker)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;f3(&quot;</span> + maker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Bowl</span> <span class="variable">bowl5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bowl</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticInitialization</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;created new Cupboard() in main&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Cupboard</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;created new Cupboard in main&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Cupboard</span>();</span><br><span class="line">        table.f2(<span class="number">1</span>);</span><br><span class="line">        cupboard.f3(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Table</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Cupboard</span> <span class="variable">cupboard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cupboard</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*Output:</span></span><br><span class="line"><span class="comment">    Bowl(1)</span></span><br><span class="line"><span class="comment">    Bowl(2)</span></span><br><span class="line"><span class="comment">    Table()</span></span><br><span class="line"><span class="comment">    f1(1)</span></span><br><span class="line"><span class="comment">    Bowl(4)</span></span><br><span class="line"><span class="comment">    Bowl(5)</span></span><br><span class="line"><span class="comment">    Bowl(3)</span></span><br><span class="line"><span class="comment">    Cupboard</span></span><br><span class="line"><span class="comment">    f1(2)</span></span><br><span class="line"><span class="comment">    creating new Cupboard()in main</span></span><br><span class="line"><span class="comment">    Bowl(3)</span></span><br><span class="line"><span class="comment">    Cupboard</span></span><br><span class="line"><span class="comment">    f1(2)</span></span><br><span class="line"><span class="comment">    creating new Cupboard()in main</span></span><br><span class="line"><span class="comment">    Bowl(3)</span></span><br><span class="line"><span class="comment">    Cupboard</span></span><br><span class="line"><span class="comment">    f1(2)</span></span><br><span class="line"><span class="comment">    f2(1)</span></span><br><span class="line"><span class="comment">    f3(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>初始化形式：</strong></p><ul><li><strong>显式的静态初始化</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Spoon</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">47</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管上面的代码看起来像个方法，但它实际上只是一段跟在static关键字后面的代码。与其他静态初始化动作一样，这段代码仅执行一次：当首次生成这个类的一个对象时，或者首次访问属于那个类的静态数据成员时（即便从未生成过那个类的对象）。</p><ul><li><strong>非静态实例初始化</strong></li></ul><p>与静态初始化子句一模一样，只不过少了static关键字。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 初始化与清理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>访问权限控制</title>
      <link href="/2022/08/09/%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
      <url>/2022/08/09/%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="关于-java和-class"><a href="#关于-java和-class" class="headerlink" title="关于.java和.class"></a>关于.java和.class</h2><ul><li>.java是Java的源文件后缀，里面存放功能代码。</li><li>.class文件是字节码文件，由.java源文件通过javac命令编译后生成的文件。是可以运行在任何支持Java虚拟机的硬件平台和操作系统上的二进制文件。</li></ul><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>JVM：JVM是一种能够运行java字节码的虚拟机，有自己完善的硬件架构，如处理器、堆栈（Stack）、寄存器等，还具有相应的指令系统（字节码就是一种指令格式）。JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需要生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行，这也是Java与平台无关的基础。</p><span id="more"></span><p><strong>JVM负责运行字节码：JVM把每一条要执行的字节码交给解释器，翻译成对应的机器码，然后由解释器执行</strong>。JVM解释执行字节码文件就是<strong>JVM操作Java解释器进行解释执行字节码文件的过程</strong>。</p><p><strong>Java编译器</strong>：将Java源文件（.java文件）编译成字节码文件（.class文件，是特殊的二进制文件，二进制字节码文件），这种字节码就是JVM的“机器语言”。javac.exe可以简单看成是Java编译器。</p><p><strong>Java解释器</strong>：是JVM的一部分。Java解释器用来解释执行Java编译器编译后的程序。java.exe可以简单看成是Java解释器。</p><p>注意：通常情况下，一个平台上的二进制可执行文件不能在其他平台上工作，因为此可执行文件包含了对目标处理器的机器语言。而Class文件这种特殊的二进制文件，是可以运行在任何支持Java虚拟机的硬件平台和操作系统上的！</p><h2 id="定制工具库"><a href="#定制工具库" class="headerlink" title="定制工具库"></a><strong>定制工具库</strong></h2><p>​用import关键字导入了需要的类库，你可以使用里面的public类，<strong>如果有的类的控制访问符是protected</strong>，其子类也能用，其他的情况是不能用的，这也是包的封装性约束的。</p><p>import static静态导入是JDK1.5中的新特性。一般我们导入一个类都用 import com…..ClassName;而静态导入是这样：import static com…..ClassName.;<strong>这里的多了个static，还有就是类名ClassName后面多了个 .</strong> ，意思是导入这个类里的静态方法。当然，也可以只导入某个静态方法，只要把 .* 换成静态方法名就行了。然后在这个类中，就可以直接用方法名调用静态方法，而不必用ClassName.方法名的方式来调用。</p><p>这种方法的好处就是可以简化一些操作，例如打印操作System.out.println(…);就可以将其写入一个静态方法print(…)，在使用时直接print(…)就可以了。但是这种方法建议在有很多重复调用的时候使用，如果仅有一到两次调用，不如直接写来的方便。</p><p>这个方法比较鸡肋，用得不多，我不认为节省少量的击键次数会让代码更简洁，但许多开发人员要求将它添加到语言中。</p><p>下面是使用静态导入的几条原则：</p><ul><li>必须说import static， 不能说static import。</li><li>提防含糊不清的命名static成员。例如，如果你对Integer类和long类执行了静态导入，引用MAX_VALUE将导致一个编译器错误，因为Integer和Long都有一个MAX_VALUE常量，并且Java不会知道你在引用哪个MAX_VALUE。</li><li>你可以在static对象引用、常量（记住，它们是static 或final）和static方法上进行静态导入。</li></ul><h2 id="System-out-println详解"><a href="#System-out-println详解" class="headerlink" title="System.out.println详解"></a><strong>System.out.println详解</strong></h2><ol><li>System是java.lang里面的一个类。</li><li>out是System里面的一个数据成员(也称为字段)，但这个成员不是基本类，而是java.io.PrintStream类的对象，被关键字static修饰的数据成员或方法可以直接通过“类名.数据成员”或“类名.方法”来引用，而无须先建立对象。所以System.out是应用了out这个静态数据成员。</li><li>而out又是一个java.io.PrintStream类的对象？？，所以out必然可以调用java.io.PrintStream类里面的方法，println()就是java.io.PrintStream类里的一个方法，它的作用就是用来想控制台输出信息的。</li></ol><h2 id="访问权限修饰词"><a href="#访问权限修饰词" class="headerlink" title="访问权限修饰词"></a><strong>访问权限修饰词</strong></h2><ul><li><p>private：你无法访问</p><p>除了包含该成员的类之外，其他任何类都无法访问这个成员。任何可以肯定只是该类的一个“助手”方法的方法，都可以把它指定为private,以确保不会在包内的其他地方误用到它，于是也就防止了你去改变或者去删除这个方法。</p></li><li><p>包访问权限</p><p>默认访问权限，当前包所有的类对那个成员都有访问权限，但对于这个包之外的所有类，这个成员是private的。</p></li><li><p>protected：继承访问权限</p><p>如果创建了一个新包，并自另一个包中继承，那么唯一可以访问的成员就是源包的public成员（除了在同一个包中的继承），要想访问源包其他成员，需在源包成员前加protected。</p></li><li><p>public:接口访问权限</p><p>对每个人都是可用的。</p></li></ul><table><thead><tr><th><strong>修饰词</strong></th><th><strong>本类</strong></th><th><strong>同一个包的类</strong></th><th><strong>继承类</strong></th><th><strong>其他类</strong></th></tr></thead><tbody><tr><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr><tr><td>无（默认）</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><h2 id="类的访问权限"><a href="#类的访问权限" class="headerlink" title="类的访问权限"></a><strong>类的访问权限</strong></h2><blockquote><p> 对于Java中的“类”（不是其内部成员，两者要区分开），其访问权限修饰词仅有public和“无”（即包访问权）两种，而没有private和protected（有一个特例，就是“内部类”，其可以是private或protected的）。所以对于类的访问权限，你仅有两个选择：包访问权或是public。</p></blockquote><p>在创建一个包访问权限的类时，仍旧是在该类的域声明为private时才有意义，应尽可能地总是将域指定为私有的，但是通常来说，将与类（包访问权限）相同的访问权限赋予方法也是很合理的。如果不希望其他任何人对该类拥有访问权限，可以把所有的构造器都指定为private，从而阻止任何人创建该类拥有访问权限，<strong>但有一个例外，就是你在该类的static成员内部可以创建。</strong></p><h2 id="接口与实现"><a href="#接口与实现" class="headerlink" title="接口与实现"></a><strong>接口与实现</strong></h2><p>访问权限的控制常被称为具体实现的隐藏。具体实现的隐藏，以及把数据和方法包装进类中，常共同被称作是<strong>封装</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 访问权限控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复用类</title>
      <link href="/2022/08/09/%E5%A4%8D%E7%94%A8%E7%B1%BB/"/>
      <url>/2022/08/09/%E5%A4%8D%E7%94%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="main方法的理解"><a href="#main方法的理解" class="headerlink" title="main方法的理解"></a>main方法的理解</h1><p>首先，main方法是JVM（java虚拟机）自动调用，JVM调用main方法的位置自然不会在某个类中、或某个包中，因此只有当main方法在公有级别上时，才对JVM可见，所以mian方法需要public修饰，同理，main方法所在的类也需要public修饰符。</p><p>其次，由于main方法是所有程序的入口，<strong>也就是main被调用时没有任何对象创建</strong>，不通过对象调用某一方法，只有将该方法定义为静态方法，所以main方法是一个静态方法，即需要static修饰。</p><p>最后，JVM对于java程序已经是最底层，由它调用的方法的返回值已经没有任何地方可去，因此，main方法返回值为空，即需用void修饰。</p><p>Java程序一定需要main函数，main函数是程序的入口。</p><span id="more"></span><h1 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h1><p><strong>toString( )方法返回反映这个对象的字符串</strong></p><p>因为toString方法是Object里面已经有了的方法，而所有类都是继承Object，所以“<strong>所有对象都有这个方法</strong>”。它通常只是为了方便输出，比如System.out.println(xx)，括号里面的“xx”如果不是String类型的话，就自动调用xx对象的toString( )方法。</p><h1 id="super-super"><a href="#super-super" class="headerlink" title="super.super?"></a>super.super?</h1><ul><li>首先super.super 属于多继承错误。</li><li>对于子类而言，已经继承了父类的所有，那么自然也继承了爷爷类的所有，使用super.super 属于多此一举。</li><li>super是当前类的私有成员（或者说成是“隐含”的私有成员），代表着父类；而super.super的意思是访问父类中的私有成员，所以不可能。或者换种说法，super和this其实都不是类的成员，根本不存在<strong>对象.成员</strong>（即类似于：this.super,super.this）的语句。</li><li>super.super 破坏了Java的封装性，对于子类而言，它只考虑它自己和父类，而不关心父类的父类。</li></ul><h1 id="初始化基类"><a href="#初始化基类" class="headerlink" title="初始化基类"></a>初始化基类</h1><p>对基类子对象的正确初始化，要在构造器中调用基类构造器来执行初始化，即构建过程是从基类“向外”扩散的，所以基类在子类可以访问它之前，就已经完成了初始化。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">C</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;C()&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Output:</span></span><br><span class="line"><span class="comment">    B()</span></span><br><span class="line"><span class="comment">    A()</span></span><br><span class="line"><span class="comment">    B()</span></span><br><span class="line"><span class="comment">    C()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><blockquote><p>初始化过程：[在加载类完成后，执行main方法语句新建一个C类对象]&gt;&gt;首先初始化C的基类A(首先初始化A的成员变量，再调用构造方法)&gt;&gt;初始化C（首先初始化C的成员变量，再调用构造方法）。</p></blockquote><p>但是如果没有默认的基类构造器，或者想要调用一个带参数的基类构造器，就必须用super显式的编写调用基类构造器的语句，否则编译器会报错。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">C</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">1</span>);  <span class="comment">//调用基类的构造方法</span></span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;C()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Output:</span></span><br><span class="line"><span class="comment">    A()</span></span><br><span class="line"><span class="comment">    B()</span></span><br><span class="line"><span class="comment">    C()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="为什么子类重载方法的访问权限不能低于父类中权限？"><a href="#为什么子类重载方法的访问权限不能低于父类中权限？" class="headerlink" title="为什么子类重载方法的访问权限不能低于父类中权限？"></a>为什么子类重载方法的访问权限不能低于父类中权限？</h1><p>​里氏代换原则(Liskov Substitution Principle，LSP)是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p><p>​<strong>把里氏代换原则解释得更完整一些：在一个软件系统中，子类应该可以替换任何基类能够出现的地方，并且经过替换以后，代码还能正常工作。</strong></p><h1 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h1><p>语法规则：&lt;父类型&gt; &lt;引用变量名&gt; &#x3D; new &lt;子类型&gt;( );</p><ul><li>此时通过父类引用变量调用的方法是<strong>子类覆盖或继承父类的方法，不是父类的方法</strong>。</li><li>此时通过父类引用变量无法调用子类特有的方法。</li></ul><p>优点：<strong>使代码简洁</strong>。</p><p>缺点：无法调用子类特有的方法。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Amphibian</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">creep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Amphibian Creep&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">(Amphibian a)</span> &#123;</span><br><span class="line">        a.creep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Frog</span> <span class="keyword">extends</span> <span class="title class_">Amphibian</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">creep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Frog Creep&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jump</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Frog Jump&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Frog</span> <span class="variable">frog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Frog</span>();</span><br><span class="line">        <span class="type">Amphibian</span> <span class="variable">amphibian</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Amphibian</span>();</span><br><span class="line">        <span class="type">Amphibian</span> <span class="variable">frog1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Frog</span>();</span><br><span class="line">        </span><br><span class="line">        Amphibian.move(frog);      <span class="comment">//向上转型，调用子类覆盖的方法</span></span><br><span class="line">        Amphibian.move(amphibian); <span class="comment">//调用对象自己即父类的方法</span></span><br><span class="line">        frog.creep();              <span class="comment">//调用对象自己即子类的方法</span></span><br><span class="line">        amphibian.creep();         <span class="comment">//调用对象自己即父类的方法</span></span><br><span class="line">        frog1.creep();             <span class="comment">//向上转型，调用子类覆盖的方法</span></span><br><span class="line">        <span class="comment">//! frog1.jump();          //报错,不是从父类中继承或覆盖的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Output:</span></span><br><span class="line"><span class="comment">    Frog Creep</span></span><br><span class="line"><span class="comment">    Amphibian Creep</span></span><br><span class="line"><span class="comment">    Frog Creep</span></span><br><span class="line"><span class="comment">    Amphibian Creep</span></span><br><span class="line"><span class="comment">    Frog Creep</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a><strong>向下转型</strong></h1><p>怎么样才能既实现向上转型，又能使子类可以调用其独有的方法呢，这就需要使用向下转型了。<strong>注意：向下转型必须是在向上转型之后才能进行。</strong></p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Amphibian &#123;</span><br><span class="line">    public void creep() &#123;</span><br><span class="line">        System.out.println(&quot;Amphibian Creep&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    static void move(Amphibian a) &#123;</span><br><span class="line">        a.creep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Frog extends Amphibian &#123;</span><br><span class="line">    public void creep() &#123;</span><br><span class="line">        System.out.println(&quot;Frog Creep&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void jump() &#123;</span><br><span class="line">        System.out.println(&quot;Frog Jump&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Amphibian frog1 = new Frog();       //向上转型</span><br><span class="line"></span><br><span class="line">        boolean result = frog1 instanceof Frog;</span><br><span class="line">        System.out.println(result);         //true,frog1 is Frog</span><br><span class="line">        if(result) &#123;</span><br><span class="line">            Frog frog2 = (Frog)frog1;       //向下转型</span><br><span class="line">            frog2.jump();</span><br><span class="line">        &#125;else</span><br><span class="line">            System.out.println(&quot;不能进行向下转型&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*Output：</span><br><span class="line">    true</span><br><span class="line">    Frog Jump</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>向下转型在Java的泛型编程中应用较多，只要记住向下转型之前必须进行向上转型，且可以配合instanceof关键字运用if判断一起使用就可以了。</p><h1 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a><strong>final关键字</strong></h1><p>以下讨论了final的三种情况，数据、方法和类。</p><p><strong>（1）final数据</strong></p><ul><li>一个永不改变的编译时常量</li><li>一个在运行时被初始化的值，而你不希望它被改变</li></ul><p>对于基本数据类型，即编译时不变的常量；对于引用而言，final使引用恒定不变，一旦引用被初始化指向一个对象（数组也是对象）后，就无法再把它改为指向其他的对象，<strong>但对象自身可以被修改</strong>。特殊的是，<strong>一个既是static又是final的域只占据一段不能改变的存储空间</strong>，对于对象而言，他只在装载时进行一次初始化，再次初始化对象不会改变它的值，按照惯例，既是static又是final的域（即编译期常量）将用大写表示，并使用下划线分隔各个单词。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">class Value &#123;</span><br><span class="line">    int i;</span><br><span class="line">    public Value(int i) &#123;</span><br><span class="line">        this.i = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class FinalData &#123;</span><br><span class="line">    private static Random rand = new Random(47);</span><br><span class="line">    private String id;</span><br><span class="line">    public FinalData(String id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    // Can be compile-time constant:</span><br><span class="line">    private final int valueOne = 9;</span><br><span class="line">    private static final int VALUE_TWO = 99;</span><br><span class="line"></span><br><span class="line">    // Typital public constant:</span><br><span class="line">    public static final int VALUE_THREE = 39;</span><br><span class="line"></span><br><span class="line">    //Cannot be compile-time constant:</span><br><span class="line">    private final int i4 = rand.nextInt(20);</span><br><span class="line">    static final int INT_5 = rand.nextInt(20);</span><br><span class="line"></span><br><span class="line">    private Value v1 = new Value(11);</span><br><span class="line">    private final Value v2 = new Value(22);</span><br><span class="line">    private static final Value VAL_3 = new Value(33);</span><br><span class="line"></span><br><span class="line">    //Arrays:</span><br><span class="line">    private final int[] a = &#123;1,2,3,4,5,6&#125;;</span><br><span class="line"></span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return id + &quot;: &quot; + &quot;i4 = &quot; + i4 +&quot;, INT_5 = &quot; + INT_5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        FinalData fd1 = new FinalData(&quot;fd1&quot;);</span><br><span class="line">        //! fd1.valueOne++;           //报错，valueOne是常量</span><br><span class="line"></span><br><span class="line">        fd1.v1 = new Value(111);      //可以，v1不是final对象</span><br><span class="line">        //！ fd1.v2 = new Value(222);</span><br><span class="line">        //! fd1.VAL_3 = new Value(333);</span><br><span class="line">        //! fd1.a = new int [6];      // 报错，v2、VAL_3、a是final对象，无法再指向其他对象</span><br><span class="line"></span><br><span class="line">        fd1.v2.i++;</span><br><span class="line">        fd1.VAL_3.i++;</span><br><span class="line">        for(int i = 0; i &lt; fd1.a.length; i++)</span><br><span class="line">            fd1.a[i]++;              //可以，因为引用初始化指向一个对象后，无法把它改为指向其他的对象，但对象自身可以被修改。</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;Creating new FinalData&quot;);</span><br><span class="line">        FinalData fd2 = new FinalData(&quot;fd2&quot;);</span><br><span class="line">        FinalData fd3 = new FinalData(&quot;fd3&quot;);</span><br><span class="line">        System.out.println(fd1);</span><br><span class="line">        System.out.println(fd2);</span><br><span class="line">        System.out.println(fd3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*Output:</span><br><span class="line">    Creating new FinalData</span><br><span class="line">    fd1: i4 = 15, INT_5 = 18</span><br><span class="line">    fd2: i4 = 13, INT_5 = 18</span><br><span class="line">    fd3: i4 = 1, INT_5 = 18</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>从Output可以看出，分别在fd1、fd2、fd3中，i4的值是唯一的，但INT_5的值是不可以通过创建第二个FinalDate对象而加以改变的，这是因为它是static的，在装载时就已被初始化，而不是每次创建对象时初始化。</p><p><strong>（2）final方法</strong></p><p>使用final方法只有一个原因，<strong>就是把方法锁定以防任何继承类修改它的含义</strong>。这是处于设计的考虑：想要确保在继承中使方法行为保持不变，并且不会被覆盖。</p><p><strong>final和private</strong>关键字都隐式地指定为是final的，可以为private方法添加final修饰词，但没必要，并不会有什么不同，因为无法取用private方法也就无法覆盖它。但有趣的是，似乎可以在子类里“覆盖”private方法，编译器并不会报错，而覆盖final方法则会报错，let us have a try:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">class WithFinals &#123;</span><br><span class="line">    //Identical to &quot;private&quot; alone:</span><br><span class="line">    private final void f() &#123;</span><br><span class="line">        System.out.println(&quot;WithFinals.f()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //Also automatically &quot;final&quot;:</span><br><span class="line">    private void g() &#123;</span><br><span class="line">        System.out.println(&quot;WithFinals.g()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class OverridingPrivate extends WithFinals &#123;</span><br><span class="line">    private final void f() &#123;</span><br><span class="line">        System.out.println(&quot;OverridingPrivate.f()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private void g() &#123;</span><br><span class="line">        System.out.println(&quot;OverridingPrivate.g()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class OverridingPrivate2 extends OverridingPrivate &#123;</span><br><span class="line">    public final void f() &#123;</span><br><span class="line">        System.out.println(&quot;OverridingPrivate2.f()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void g() &#123;</span><br><span class="line">        System.out.println(&quot;OverridingPrivate2.g()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class FinalOverridingIllusion &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        OverridingPrivate2 op2 = new OverridingPrivate2();</span><br><span class="line">        op2.f();</span><br><span class="line">        op2.g();</span><br><span class="line">        //向上造型</span><br><span class="line">        OverridingPrivate op1 = op2;</span><br><span class="line">        //! op1.f();</span><br><span class="line">        //! op1.g();  //不能调用f(),g();说明f()和g()并不是覆盖父类的方法，而是子类新的方法。</span><br><span class="line">        WithFinals wf = op2;</span><br><span class="line">        //! wf.f();</span><br><span class="line">        //! wf.g();  //同理</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*Output:</span><br><span class="line">    OverridingPrivate2.f()</span><br><span class="line">    OverridingPrivate2.g()</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>看来编译器骗了我，<strong>f()和g()并不是真正的覆盖，而是子类的新方法</strong>。如果某方法为 private ，它就不是基类的接口的一部分。它仅是一些隐藏于类中的程序代码，只不过是具有相同的名称而已。辨别办法就是在继承的方法前加上@Override，这些方法是不是真的覆盖就原形毕露了。这也提醒我们，<strong>只有非private的方法才可以被覆盖，在导出类中对于基类中的private方法最好采用不用的名字</strong>。</p><p><strong>（3）final类</strong></p><p>定义为final类，意味着不允许继承该类，对该类的设计永远不需要做任何改动，或者出于安全的考虑，不允许它有子类。<strong>所以final类中的所有的方法都隐式的指定为final的</strong>，也可以给方法添加final修饰词，但没必要。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复用类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组合模式</title>
      <link href="/2022/08/09/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/08/09/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。</p><p>​这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。（可以给自己一个内部属LIst，类型就是本身）</p><span id="more"></span><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>​组合模式使得用户对单个对象和组合对象的访问具有一致性，即：组合能让客户以一致的方式处理个别对象以及组合对象</p><p><strong>组合模式的角色及职责</strong></p><ol><li>Component：这是组合中对象声明接口，在适当情况下，实现所有类共有的接口默认行为，用于访问和管理 Component 子部件，Component 可以是抽象类或者接口</li><li>Leaf：在组合中表示叶子节点，叶子节点没有子节点</li><li>Composite：非叶子节点，用于存储子部件，在 Component 接口中实现子部件的相关操作，比如增加(add)、删除。</li></ol><p><img src="1.png" alt="1"></p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>​展示一个学校院系结构：需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院， 一个学院有多个系<br>把学校、院、系都看做是组织结构，他们之间没有继承的关系，而是一个树形结构，可以更好的实现管理操作。 &#x3D;&gt; 组合模式</p><p><strong>抽象类</strong>（向上转型，可以使用统一的名字）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nemo.composite;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">OrganizationComponent</span> &#123; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 名 字</span></span><br><span class="line">    <span class="keyword">private</span> String des; <span class="comment">// 说 明</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(OrganizationComponent organizationComponent)</span> &#123;</span><br><span class="line">        <span class="comment">//默认实现</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(OrganizationComponent organizationComponent)</span> &#123;</span><br><span class="line">        <span class="comment">//默认实现</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrganizationComponent</span><span class="params">(String name, String des)</span> &#123; </span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.name = name; <span class="built_in">this</span>.des = des;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDes</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> des;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDes</span><span class="params">(String des)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.des = des;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//方法 print,  做成抽象的,  子类都需要实现</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>专业（叶子节点，没有下属）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nemo.composite;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Department</span> <span class="keyword">extends</span> <span class="title class_">OrganizationComponent</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//没有集合</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Department</span><span class="params">(String name, String des)</span> &#123; </span><br><span class="line">        <span class="built_in">super</span>(name, des);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//add , remove 就不用写了，因为他是叶子节点</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getName();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDes</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getDes();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>学院（内部存储专业）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nemo.composite;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList; </span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">College</span> <span class="keyword">extends</span> <span class="title class_">OrganizationComponent</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//List 中 存放的 专业</span></span><br><span class="line">    List&lt;OrganizationComponent&gt; organizationComponents = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;OrganizationComponent&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">College</span><span class="params">(String name, String des)</span> &#123; </span><br><span class="line">        <span class="built_in">super</span>(name, des);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 重 写 add @Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(OrganizationComponent organizationComponent)</span> &#123;</span><br><span class="line">        <span class="comment">//  将来实际业务中，Colleage  的  add  和 University add 不一定完全一样</span></span><br><span class="line">        organizationComponents.add(organizationComponent);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 重 写 remove @Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(OrganizationComponent organizationComponent)</span> &#123;</span><br><span class="line">        organizationComponents.remove(organizationComponent);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getName();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDes</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getDes();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// print 方法，就是输出 University 包含的学院</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------&quot;</span> + getName() + <span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历 organizationComponents</span></span><br><span class="line">        <span class="keyword">for</span> (OrganizationComponent organizationComponent : organizationComponents) &#123; </span><br><span class="line">            organizationComponent.print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>学校</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nemo.composite;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList; </span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//University 就是 Composite ,  可以管理 College</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">University</span> <span class="keyword">extends</span> <span class="title class_">OrganizationComponent</span> &#123;</span><br><span class="line"> </span><br><span class="line">    List&lt;OrganizationComponent&gt; organizationComponents = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;OrganizationComponent&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">University</span><span class="params">(String name, String des)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, des);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 重写 add @Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(OrganizationComponent organizationComponent)</span> &#123;</span><br><span class="line">        organizationComponents.add(organizationComponent);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 重写 remove @Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(OrganizationComponent organizationComponent)</span> &#123;</span><br><span class="line">        organizationComponents.remove(organizationComponent);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getName();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDes</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getDes();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// print 方法，就是输出 University 包含的学院</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------&quot;</span> + getName() + <span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历 organizationComponents</span></span><br><span class="line">        <span class="keyword">for</span> (OrganizationComponent organizationComponent : organizationComponents) &#123; </span><br><span class="line">            organizationComponent.print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nemo.composite;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//从大到小创建对象 学校</span></span><br><span class="line">        <span class="type">OrganizationComponent</span> <span class="variable">university</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">University</span>(<span class="string">&quot;清华大学&quot;</span>, <span class="string">&quot; 中国顶级大学 &quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//创建 学院</span></span><br><span class="line">        <span class="type">OrganizationComponent</span> <span class="variable">computerCollege</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">College</span>(<span class="string">&quot; 计算机学院 &quot;</span>, <span class="string">&quot; 计算机学院 &quot;</span>); </span><br><span class="line">        <span class="type">OrganizationComponent</span> <span class="variable">infoEngineercollege</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">College</span>(<span class="string">&quot;信息工程学院&quot;</span>, <span class="string">&quot; 信息工程学院 &quot;</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment">//创建各个学院下面的系(专业)</span></span><br><span class="line">        computerCollege.add(<span class="keyword">new</span> <span class="title class_">Department</span>(<span class="string">&quot;软件工程&quot;</span>, <span class="string">&quot; 软件工程不错 &quot;</span>)); </span><br><span class="line">        computerCollege.add(<span class="keyword">new</span> <span class="title class_">Department</span>(<span class="string">&quot;网络工程&quot;</span>, <span class="string">&quot; 网络工程不错 &quot;</span>));</span><br><span class="line">        computerCollege.add(<span class="keyword">new</span> <span class="title class_">Department</span>(<span class="string">&quot;计算机科学与技术&quot;</span>, <span class="string">&quot; 计算机科学与技术是老牌的专业 &quot;</span>));</span><br><span class="line"> </span><br><span class="line">        infoEngineercollege.add(<span class="keyword">new</span> <span class="title class_">Department</span>(<span class="string">&quot;通信工程&quot;</span>, <span class="string">&quot; 通信工程不好学 &quot;</span>)); </span><br><span class="line">        infoEngineercollege.add(<span class="keyword">new</span> <span class="title class_">Department</span>(<span class="string">&quot;信息工程&quot;</span>, <span class="string">&quot; 信息工程好学 &quot;</span>));</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment">//将学院加入到学校</span></span><br><span class="line">        university.add(computerCollege);</span><br><span class="line">        university.add(infoEngineercollege);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment">//university.print();</span></span><br><span class="line">        infoEngineercollege.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合模式在JDK源码中的使用"><a href="#组合模式在JDK源码中的使用" class="headerlink" title="组合模式在JDK源码中的使用"></a>组合模式在JDK源码中的使用</h2><pre><code>    Java 的集合类-HashMap 就使用了组合模式</code></pre><ol><li>Map 就是一个抽象的构件，类似于组合模式中的Component；</li><li>HashMap是中间的构件，只不过在HashMap与Component之间多了一层AbstractMap&lt;K,V&gt;，并且重写了Map中put()，putAll()等方法；</li><li>Node是HashMap中的静态内部类,也相当于实现了Map接口，类似于Leaf叶子节点</li></ol><p>Map源码如下</p><p><img src="3.png" alt="1"></p><p>Abstract源码如下</p><p><img src="2.png" alt="1"></p><p>HashMap源码如下</p><p><img src="4.png" alt="1"></p><h2 id="组合模式在Mybatis中的应用"><a href="#组合模式在Mybatis中的应用" class="headerlink" title="组合模式在Mybatis中的应用"></a>组合模式在Mybatis中的应用</h2><p>Mybatis支持动态SQL的强大功能，比如下面的这个SQL：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;update id=<span class="string">&quot;update&quot;</span> parameterType=<span class="string">&quot;org.format.dynamicproxy.mybatis.bean.User&quot;</span>&gt;</span><br><span class="line">    UPDATE users</span><br><span class="line">    &lt;trim prefix=<span class="string">&quot;SET&quot;</span> prefixOverrides=<span class="string">&quot;,&quot;</span>&gt;</span><br><span class="line">        &lt;<span class="keyword">if</span> test=<span class="string">&quot;name != null and name != &#x27;&#x27;&quot;</span>&gt;</span><br><span class="line">            name = #&#123;name&#125;</span><br><span class="line">        &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">        &lt;<span class="keyword">if</span> test=<span class="string">&quot;age != null and age != &#x27;&#x27;&quot;</span>&gt;</span><br><span class="line">            , age = #&#123;age&#125;</span><br><span class="line">        &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">        &lt;<span class="keyword">if</span> test=<span class="string">&quot;birthday != null and birthday != &#x27;&#x27;&quot;</span>&gt;</span><br><span class="line">            , birthday = #&#123;birthday&#125;</span><br><span class="line">        &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">    &lt;/trim&gt;</span><br><span class="line">    <span class="type">where</span> <span class="variable">id</span> <span class="operator">=</span> $&#123;id&#125;</span><br><span class="line">&lt;/update&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这里面使用到了trim、if等动态元素，可以根据条件来生成不同情况下的SQL；</p><p>在DynamicSqlSource.getBoundSql方法里，调用了rootSqlNode.apply(context)方法，apply方法是所有的动态节点都实现的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SqlNode</span> &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">apply</span><span class="params">(DynamicContext context)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于实现该SqlSource接口的所有节点，就是整个组合模式树的各个节点：</p><p>图</p><p>组合模式的简单之处在于，所有的子节点都是同一类节点，可以递归的向下执行，比如对于TextSqlNode，因为它是最底层的叶子节点，所以直接将对应的内容append到SQL语句中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">apply</span><span class="params">(DynamicContext context)</span> &#123;</span><br><span class="line">    <span class="type">GenericTokenParser</span> <span class="variable">parser</span> <span class="operator">=</span> createParser(<span class="keyword">new</span> <span class="title class_">BindingTokenParser</span>(context, injectionFilter));</span><br><span class="line">    context.appendSql(parser.parse(text));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>但是对于IfSqlNode，就需要先做判断，如果判断通过，仍然会调用子元素的SqlNode，即contents.apply方法，实现递归的解析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">apply</span><span class="params">(DynamicContext context)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (evaluator.evaluateBoolean(test, context.getBindings())) &#123;</span><br><span class="line">      contents.apply(context);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组合模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多态</title>
      <link href="/2022/08/08/%E5%A4%9A%E6%80%81/"/>
      <url>/2022/08/08/%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h1 id="Java多态"><a href="#Java多态" class="headerlink" title="Java多态"></a>Java多态</h1><p>简单来说，多态就是同一个接口，使用不同的实例而执行不同操作，</p><h2 id="多态存在的三个必要条件"><a href="#多态存在的三个必要条件" class="headerlink" title="多态存在的三个必要条件"></a>多态存在的三个必要条件</h2><ul><li>继承：必须要有子类继承父类的继承关系。</li><li>重写：子类需要对父类中的一些方法进行重写，然后调用方法时就会调用子类重写的方法而不是原本父类的方法。</li><li>父类引用指向子类对象：Parent p &#x3D; new Child();在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</li></ul><p><strong>向上转型的作用：</strong> 在上面我们说了子类需要对父类中的一些方法进行重写（相同方法名相同参数），然后调用方法时就会调用子类重写的方法而不是原本父类的方法。向上转型后，子类单独定义的方法会丢失（即子类重载（相同方法名不同参数）了父类中的方法），而子类中重写了父类的方法，当我们调用他们时，<strong>会调用子类重写的方法。</strong></p><p><strong>向下转型</strong>（将子类的引用指向父类——&gt;将父类转换为子类）之前必须先向上转型：原因是;</p><p><strong>Animal 引用a 先指向一个Cat 对象，cat引用指向引用a 所指向的堆内存，也就是说引用cat此时和引用a 现在同时指向同一块堆内存。而这块堆内存里面存放的就是一个cat 对象 所以必然可以被引用cat 所指向。可以调用Cat里面所有独特的方法。</strong></p><span id="more"></span><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      show(<span class="keyword">new</span> <span class="title class_">Cat</span>());  <span class="comment">// 以 Cat 对象调用 show 方法</span></span><br><span class="line">      show(<span class="keyword">new</span> <span class="title class_">Dog</span>());  <span class="comment">// 以 Dog 对象调用 show 方法</span></span><br><span class="line">                </span><br><span class="line">      <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();  <span class="comment">// 向上转型  </span></span><br><span class="line">      a.eat();               <span class="comment">// 调用的是 Cat 的 eat (子类重写的方法)</span></span><br><span class="line">      <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> (Cat)a;        <span class="comment">// 向下转型  </span></span><br><span class="line">      c.work();        <span class="comment">// 调用的是 Cat 的 work</span></span><br><span class="line">  &#125;  </span><br><span class="line">            </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(Animal a)</span>  &#123;</span><br><span class="line">      a.eat();  </span><br><span class="line">        <span class="comment">// 类型判断</span></span><br><span class="line">        <span class="keyword">if</span> (a <span class="keyword">instanceof</span> Cat)  &#123;  <span class="comment">// 猫做的事情 </span></span><br><span class="line">            <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> (Cat)a;  </span><br><span class="line">            c.work();  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a <span class="keyword">instanceof</span> Dog) &#123; <span class="comment">// 狗做的事情 </span></span><br><span class="line">            <span class="type">Dog</span> <span class="variable">c</span> <span class="operator">=</span> (Dog)a;  </span><br><span class="line">            c.work();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;  </span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;吃鱼&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;抓老鼠&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;吃骨头&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;看家&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><p>当子类对象调用重写的方法时，调用的是子类的方法，而不是父类中被重写的方法。要想调用父类中被重写的方法，则必须使用关键字 <strong>super</strong>。</p><p>举例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 文件名 : Employee.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String address;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> number;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name, String address, <span class="type">int</span> number)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Employee 构造函数&quot;</span>);</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">      <span class="built_in">this</span>.address = address;</span><br><span class="line">      <span class="built_in">this</span>.number = number;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mailCheck</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;邮寄支票给： &quot;</span> + <span class="built_in">this</span>.name</span><br><span class="line">       + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.address);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> name + <span class="string">&quot; &quot;</span> + address + <span class="string">&quot; &quot;</span> + number;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> address;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddress</span><span class="params">(String newAddress)</span> &#123;</span><br><span class="line">      address = newAddress;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> number;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Salary</span> <span class="keyword">extends</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">double</span> salary; <span class="comment">// 全年工资</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Salary</span><span class="params">(String name, String address, <span class="type">int</span> number, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">       <span class="built_in">super</span>(name, address, number);</span><br><span class="line">       setSalary(salary);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mailCheck</span><span class="params">()</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;Salary 类的 mailCheck 方法 &quot;</span>);</span><br><span class="line">       System.out.println(<span class="string">&quot;邮寄支票给：&quot;</span> + getName()</span><br><span class="line">       + <span class="string">&quot; ，工资为：&quot;</span> + salary);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> salary;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSalary</span><span class="params">(<span class="type">double</span> newSalary)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(newSalary &gt;= <span class="number">0.0</span>) &#123;</span><br><span class="line">          salary = newSalary;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">computePay</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;计算工资，付给：&quot;</span> + getName());</span><br><span class="line">      <span class="keyword">return</span> salary/<span class="number">52</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 文件名 : VirtualDemo.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VirtualDemo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] args)</span> &#123;</span><br><span class="line">      <span class="type">Salary</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Salary</span>(<span class="string">&quot;员工 A&quot;</span>, <span class="string">&quot;北京&quot;</span>, <span class="number">3</span>, <span class="number">3600.00</span>);</span><br><span class="line">      <span class="type">Employee</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Salary</span>(<span class="string">&quot;员工 B&quot;</span>, <span class="string">&quot;上海&quot;</span>, <span class="number">2</span>, <span class="number">2400.00</span>); <span class="comment">//向上转型</span></span><br><span class="line">      System.out.println(<span class="string">&quot;使用 Salary 的引用调用 mailCheck -- &quot;</span>);</span><br><span class="line">      s.mailCheck(); </span><br><span class="line">      System.out.println(<span class="string">&quot;\n使用 Employee 的引用调用 mailCheck--&quot;</span>);</span><br><span class="line">      e.mailCheck();<span class="comment">//调用的是子类重写的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="多态在方法、域、构造器内部的行为"><a href="#多态在方法、域、构造器内部的行为" class="headerlink" title="多态在方法、域、构造器内部的行为"></a>多态在方法、域、构造器内部的行为</h2><p><strong>多态体现：方法绑定</strong></p><p>​将一个方法调用同一个方法主体关联起来被称作绑定，当绑定发生在程序运行之前时（如果有的话，由编译器和连接器负责，C就是一种前期绑定的语言）称为<strong>前期绑定</strong>（early binding）。 在运行时，根据对象的类型来决定运行哪个方法称为<strong>后期绑定</strong>（late binding)，后期绑定也被称为<strong>动态绑定</strong>（dynamic binding）或<strong>运行时绑定</strong>(run-time binding)。</p><p>​<strong>Java 中除了static和final方法之外，其他所有的方法都是属于后期绑定。</strong></p><p>方法中的多态：这是方法绑定中极易混淆的一点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;f1()&quot;</span>);</span><br><span class="line">        f2();</span><br><span class="line">    &#125;</span><br><span class="line">    puqblic <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A : f2()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B : f2()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E10_C</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>(); <span class="comment">//向上转型</span></span><br><span class="line">        a.f1();  <span class="comment">//interesting</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*Output:</span></span><br><span class="line"><span class="comment">    f1()</span></span><br><span class="line"><span class="comment">    B : f2() //**这里调用的是子类中重写的方法**</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>创建一个导出类的对象，并将它向上造型，调用从基类继承的方法f1()，f1()方法内部却调用了导出类的f2()，这是绑定的一个绝佳的示例。</p><p>然而，多态与绑定并非都如上例所示，只有普通的方法调用是多态的，接下来介绍两种特殊的情况。</p><h3 id="多态失效缺陷：直接访问某个域"><a href="#多态失效缺陷：直接访问某个域" class="headerlink" title="多态失效缺陷：直接访问某个域"></a>多态失效缺陷：直接访问某个域</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Super</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">field</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getField</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> field;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Super</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">field</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getField</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> field;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSuperField</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.field;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FieldAccess</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Super</span> <span class="variable">sup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>(); <span class="comment">//向上转型</span></span><br><span class="line">        <span class="comment">//这里得到的还是父类中的域                                   这里是调用子类的方法获取的当然是子类的域</span></span><br><span class="line">        System.out.println(<span class="string">&quot;sup.field = &quot;</span> + sup.field + <span class="string">&quot;, sup.getField = &quot;</span> + sup.getField());</span><br><span class="line">        <span class="type">Sub</span> <span class="variable">sub</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">        <span class="comment">//这里得到的还是父类中的域，</span></span><br><span class="line">        System.out.println(<span class="string">&quot;sub.field = &quot;</span> + sup.field + <span class="string">&quot;, sub.getField = &quot;</span> + sup.getField() + <span class="string">&quot;, sub.getSuperField = &quot;</span> + sub.getSuperField());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Output:</span></span><br><span class="line"><span class="comment">    sup.field = 0, sup.getField = 1               </span></span><br><span class="line"><span class="comment">    sub.field = 0, sub.getField = 1, sub.getSuperField = 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>​在上例中为Super.field和Sub.field分配了不同的存储空间，这样实际上Sub包含两个称为field的域：自己的和从super处得到的。当引用Sub中的field时，是继承自父类的field，在引用Sub中的getField方法时调用的是子类的field，因此为了调用Super.field，必须显式地注明super.field。**在实践中为了避免这样的误解，通常会将所有的域都设置成private，因此不能直接访问它们，其副作用是只能调用方法来访问。另外，不要对基类中的域和导出类中的域赋予同样的名字。</p><h2 id="多态失效缺陷：静态方法的行为不具有多态性"><a href="#多态失效缺陷：静态方法的行为不具有多态性" class="headerlink" title="多态失效缺陷：静态方法的行为不具有多态性"></a>多态失效缺陷：静态方法的行为不具有多态性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StaticSuper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">staticGet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Base staticGet()&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">dynamicGet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Base dynamicGet()&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StaticSub</span> <span class="keyword">extends</span> <span class="title class_">StaticSuper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">staticGet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Derived staticGet()&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">dynamicGet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Derived dynamicGet()&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticPolymorphism</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StaticSuper</span> <span class="variable">sup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticSub</span>();  <span class="comment">//Upcast</span></span><br><span class="line">        System.out.println(sup.staticGet());<span class="comment">//无法调用子类特有的方法，即静态方法的行为不具有多态性</span></span><br><span class="line">        System.out.println(sup.dynamicGet());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Output:</span></span><br><span class="line"><span class="comment">    Base staticGet()</span></span><br><span class="line"><span class="comment">    Derived dynamicGet()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="构造器内部多态方法的行为"><a href="#构造器内部多态方法的行为" class="headerlink" title="构造器内部多态方法的行为"></a>构造器内部多态方法的行为</h2><p>如果在一个构造器的内部调用正在构造的对象的某个动态绑定方法，会发生什么事情？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Glyph</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Glyph.draw()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Glyph() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Glyph() before draw()&quot;</span>);</span><br><span class="line">        draw();</span><br><span class="line">        System.out.println(<span class="string">&quot;Glyph() after draw()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RoundGlyph</span> <span class="keyword">extends</span> <span class="title class_">Glyph</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">radius</span> <span class="operator">=</span> <span class="number">1</span>;  </span><br><span class="line">    RoundGlyph(<span class="type">int</span> r) &#123;</span><br><span class="line">        radius = r;</span><br><span class="line">        System.out.println(<span class="string">&quot;RoundGlyph.RoundGlyph(), radius = &quot;</span> + radius);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;RoundGlyph.draw(), radius = &quot;</span> + radius);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RectangularGlyph</span> <span class="keyword">extends</span> <span class="title class_">Glyph</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    RectangularGlyph(<span class="type">int</span> length,<span class="type">int</span> width) &#123;</span><br><span class="line">        <span class="built_in">this</span>.length = length;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">        System.out.println(<span class="string">&quot;RectangularGlyph.RectangularGlyph(), length = &quot;</span> + length + <span class="string">&quot; width = &quot;</span> + width);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;RectangularGlyph.draw(), length = &quot;</span> + length + <span class="string">&quot; width = &quot;</span> + width);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolyConstructors</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">RoundGlyph</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">RectangularGlyph</span>(<span class="number">4</span>,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*Output:</span></span><br><span class="line"><span class="comment">//父类执行构造方法 此时子类的radius还没有被初始化</span></span><br><span class="line"><span class="comment">    Glyph() before draw()</span></span><br><span class="line"><span class="comment">    RoundGlyph.draw(), radius = 0</span></span><br><span class="line"><span class="comment">    Glyph() after draw()</span></span><br><span class="line"><span class="comment">    //子类构造方法的println打印的是子类变量</span></span><br><span class="line"><span class="comment">    RoundGlyph.RoundGlyph(), radius = 5</span></span><br><span class="line"><span class="comment">    //同样执行父类的构造方法 此时子类的radius还没有被初始化</span></span><br><span class="line"><span class="comment">    Glyph() before draw()</span></span><br><span class="line"><span class="comment">    RectangularGlyph.draw(), length = 0 width = 0</span></span><br><span class="line"><span class="comment">    Glyph() after draw()</span></span><br><span class="line"><span class="comment">    //子类构造方法的println打印的是子类变量</span></span><br><span class="line"><span class="comment">    RectangularGlyph.RectangularGlyph(), length = 4 width = 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>​结果有点令人惊讶，因为在父类构造方法中调用了draw()方法，而此方法在子类中被覆盖，所以在父类的构造方法调用时，会动态绑定到子类的draw()方法，而此时子类的成员变量还未定义。所以编写构造器有一条有效的原则：<strong>“用尽可能简单的方法使对象进入正常的状态；如果可以的话，避免调用其他方法”</strong>。在构造器中，唯一安全能够调用的方法是基类中的final方法（包括private方法)，因为这些方法无法被覆盖。</p><h1 id="用继承进行设计"><a href="#用继承进行设计" class="headerlink" title="用继承进行设计"></a>用继承进行设计</h1><p>用继承表达行为间的差异，并用字段表达状态上的变化。</p><p>例如下例，通过继承得到了三个不同的类，用于表达light()方法的差异；而StartShip通过运用组合使自己的状态发生变化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AlertStatus</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">light</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedAlertStatus</span> <span class="keyword">extends</span> <span class="title class_">AlertStatus</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">light</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;RedAlertStatus&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YellowAlertStatus</span> <span class="keyword">extends</span> <span class="title class_">AlertStatus</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">light</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;YellowAlertStatus&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GreenAlertStatus</span> <span class="keyword">extends</span> <span class="title class_">AlertStatus</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">light</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;GreenAlertStatus&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StartShip</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AlertStatus</span> <span class="variable">alertStatus</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedAlertStatus</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeYellow</span><span class="params">()</span> &#123;</span><br><span class="line">        alertStatus = <span class="keyword">new</span> <span class="title class_">YellowAlertStatus</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeGreen</span><span class="params">()</span> &#123;</span><br><span class="line">        alertStatus = <span class="keyword">new</span> <span class="title class_">GreenAlertStatus</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ligheAlert</span><span class="params">()</span> &#123;</span><br><span class="line">        alertStatus.light();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E16_Startship</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StartShip</span> <span class="variable">startShip</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StartShip</span>();</span><br><span class="line">        startShip.ligheAlert();</span><br><span class="line">        startShip.changeYellow();</span><br><span class="line">        startShip.ligheAlert();</span><br><span class="line">        startShip.changeGreen();</span><br><span class="line">        startShip.ligheAlert();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*Output:</span></span><br><span class="line"><span class="comment">    RedAlertStatus</span></span><br><span class="line"><span class="comment">    YellowAlertStatus</span></span><br><span class="line"><span class="comment">    GreenAlertStatus</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象类与接口</title>
      <link href="/2022/08/08/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/"/>
      <url>/2022/08/08/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="抽象类与抽象方法"><a href="#抽象类与抽象方法" class="headerlink" title="抽象类与抽象方法"></a>抽象类与抽象方法</h1><ul><li>用abstract修饰的类称为抽象类；</li><li>包含抽象方法的类叫做抽象类，但抽象类也可以不包含抽象方法；</li><li>不能为抽象类创建对象；</li><li>abstract修饰的方法为抽象方法，此方法不能有方法体；</li><li>抽象类 天生就是被继承的, and 抽象方法 天生就是被重写的;</li><li>一个继承抽象类的类，必须重写基类中所有的抽象方法，否则就要将自己定义为抽象类。</li><li>抽象类中可以有构造方法，因为抽象类中有属性，抽象类与普通类的区别只是有抽象方法，所以这些属性是要被初始化的，抽象类中的构造方法就是用来初始化的。</li></ul><span id="more"></span><h1 id="抽象类使用原则"><a href="#抽象类使用原则" class="headerlink" title="抽象类使用原则"></a>抽象类使用原则</h1><p>1、抽象方法必须为public或者protected(因为如果是private，那么该类不能被子类继承，其中的抽象方法也就不能被重写)。默认为public。<br>2、抽象类不能被实例话，可以采用向上转型的方法处理。注意：一定要在方法内部实例化<br>3、抽象类必须有子类，用extends继承，一个子类只能继承一个抽象类。<br>4、子类如果不是抽象类的话必须重写抽象类中的全部方法。（如果子类是抽象类重写父类的方法，被重写的父类中的抽象方法在子类中相当于普通方法）<br>Static修饰原则：外部抽象类不允许使用static声明，而内部的抽象类运行使用static声明。使用static声明的内部抽象类相当于一个外部抽象类，继承的时候使用“外部类.内部类”的形式表示类名称。内部类实例话的时候也是 AbstractDemo.inner。</p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><ul><li><p>接口被用来建立类与类之间的协议；</p></li><li><p>可以理解接口为一种特殊的抽象类——完全抽象的类；</p></li><li><p>接口中的方法默认为抽象方法，显然不提供任何实现，即不能含有body，每个方法只是一个声明，并且自动声明为public；</p></li><li><p><strong>但在jdk1.8中，使用default 修饰的方法可以拥有方法体，不需要被子类实现，被称为默认方法，这有点像抽象类了，这样的设计是为了为了以后扩展接口功能而不影响其他子类，JDK8中接口的静态方法只能通过接口名直接去调用，接口中的默认方法因为不是abstract的，所以可重写，也可以不重写。；而且允许接口拥有main方法</strong></p></li><li><p>接口中可以含有域，即定义变量，但变量隐式的是static和final的；</p></li><li><p>实现接口的类要实现接口的所有方法。</p></li><li><p>接口不能创建对象，调用静态方法不需要对象</p></li><li><p>接口支持多继承，即一个接口可以extends多个接口，间接的解决了Java中类的单继承问题；</p></li><li><p>一个类可以实现多个接口；</p></li><li><p>静态方法（static method）：JDK 1.8中允许使用static关键字修饰一个方法，并提供实现，称为接口静态方法。接口静态方法只能通过接口调用（接口名.静态方法名）。</p></li><li><p>(1)如果多个接口定义了同样的静态方法，</p><p>即使存在实现类，同时实现多个接口，仍然是不可使用实现类名调用接口的方法</p></li><li><p>如果多个接口定义了同样的默认方法</p><p>实现类实现多个接口时，必须重写掉默认方法，否则编译失败。</p><p>在接口中可以定义实现的方法体是java8的一大特性，可以定义多个静态或者默认的方法，静态必须加上static，默认方法必须加上default关键字。</p></li></ul><h1 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h1><p>​一个接口能继承另外一个或者多个接口,这和类之间的继承比较相似,接口的继承使用extends关键字,子接口继承父接口的方法.如果父接口中的默认方法有重名的,那么子接口需要重写一次</p><h1 id="抽象类和接口的应用场景"><a href="#抽象类和接口的应用场景" class="headerlink" title="抽象类和接口的应用场景"></a>抽象类和接口的应用场景</h1><p>1、如果你拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类吧。</p><p>2、如果你想实现多重继承，那么你必须使用接口。由于Java不支持多继承，子类不能够继承多个类，但可以实现多个接口。因此你就可以使用接口来解决它。</p><p>3、如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。</p><h1 id="抽象类与接口的相同点"><a href="#抽象类与接口的相同点" class="headerlink" title="抽象类与接口的相同点"></a>抽象类与接口的相同点</h1><p>1、都不能被实例化</p><p>2、接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能实例化。　</p><h1 id="抽象类与接口的不同点"><a href="#抽象类与接口的不同点" class="headerlink" title="抽象类与接口的不同点"></a>抽象类与接口的不同点</h1><p><img src="1.jpg" alt="1"></p><p>a. 抽象类是对一种事务的抽象，是对整个类进行抽象，包括属性，行为（方法）。接口是对行为（行为）的抽象。如果一个类继承或实现了某个抽象类，那么一定是抽象类的种类（拥有同一种属性或行为的类）。<strong>举个简单的例子</strong>，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly(  )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，继承是一个 “是不是”的关系，而 接口 实现则是  “有没有”的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。</p><p>b. 设计层面不同，抽象类作为很多子类的父类，是一种模板设计，而接口是一种规范，它是一种辐射式设计，也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象方法中添加实现，子类可以不用变更，而对于接口不行，如果接口进行了变更，那么实现它的类都需要做变更。<strong>举例说明</strong>什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt  C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt  C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。</p><h1 id="接口中常量的public-static-final"><a href="#接口中常量的public-static-final" class="headerlink" title="接口中常量的public static final"></a>接口中常量的public static final</h1><p>public: 使接口的实现类可以使用该常量；<br>static：接口不涉及和任何具体实例相关的细节，因此接口没有构造方法，不能被实例化，没有实例变量，只有静态变量。（static修饰就表示它属于类的，随的类的加载而存在的，当JVM把字节码加载进JVM的时候，static修饰的成员已经在内存中存在了。如果是非static的话，就表示属于对象的，只有建立对象时才有它，而接口是不能建立对象的，所以接口的常量必须定义为static。）<br>final：接口中不可以定义变量，即定义的变量前都要加上final修饰，使之成为常量，且必须赋初始值！（final修饰就是保证接口定义的常量不能被实现类去修改，如果没有final的话，由子类随意去修改的话，接口建立这个常量就没有意义了。<br>接口中方法的修饰符：public abstract（默认不写）</p><h1 id="接口结合工厂模式"><a href="#接口结合工厂模式" class="headerlink" title="接口结合工厂模式"></a>接口结合工厂模式</h1><p>通过工厂方式，代码将完全与接口的实现分离，这样就可以透明的将某个接口的一个实现替换为另一种实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Tossing</span> &#123; <span class="type">boolean</span> <span class="title function_">event</span><span class="params">()</span>; &#125;</span><br><span class="line"><span class="comment">//工厂接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">TossingFactory</span> &#123; Tossing <span class="title function_">getTossing</span><span class="params">()</span>; &#125;</span><br><span class="line"><span class="comment">//业务接口实现类1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CoinTossing</span> <span class="keyword">implements</span> <span class="title class_">Tossing</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> events;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EVENTS</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">event</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Coin tossing event &quot;</span> + events);</span><br><span class="line">        <span class="keyword">return</span> ++events != EVENTS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//工厂接口实现1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CoinTossingFactory</span> <span class="keyword">implements</span> <span class="title class_">TossingFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> CoinTossing <span class="title function_">getTossing</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CoinTossing</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//业务接口实现类2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DiceTossing</span> <span class="keyword">implements</span> <span class="title class_">Tossing</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> events;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EVENTS</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">event</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dice tossing event &quot;</span> + events);</span><br><span class="line">        <span class="keyword">return</span> ++events != EVENTS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//工厂接口实现类2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DiceTossingFactory</span> <span class="keyword">implements</span> <span class="title class_">TossingFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> DiceTossing <span class="title function_">getTossing</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DiceTossing</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E19_TossingFramework</span> &#123;</span><br><span class="line">    <span class="comment">//传入不同的工厂实现类，得到不同的接口实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">simulate</span><span class="params">(TossingFactory fact)</span> &#123;</span><br><span class="line">        <span class="type">Tossing</span> <span class="variable">t</span> <span class="operator">=</span> fact.getTossing();</span><br><span class="line">        <span class="keyword">while</span>(t.event()) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        simulate(<span class="keyword">new</span> <span class="title class_">CoinTossingFactory</span>());</span><br><span class="line">        simulate(<span class="keyword">new</span> <span class="title class_">DiceTossingFactory</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">    Coin tossing event 0</span></span><br><span class="line"><span class="comment">    Coin tossing event 1</span></span><br><span class="line"><span class="comment">    Dice tossing event 0</span></span><br><span class="line"><span class="comment">    Dice tossing event 1</span></span><br><span class="line"><span class="comment">    Dice tossing event 2</span></span><br><span class="line"><span class="comment">    Dice tossing event 3</span></span><br><span class="line"><span class="comment">    Dice tossing event 4</span></span><br><span class="line"><span class="comment">    Dice tossing event 5</span></span><br><span class="line"><span class="comment"> */</span><span class="comment">//:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 抽象类与接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>策略模式</title>
      <link href="/2022/08/08/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/08/08/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>​在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。<br>​在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。</p><p>​策略模式（Strategy Pattern）中，定义算法族（策略组），分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户<br>这算法体现了几个设计原则，第一、把变化的代码从不变的代码中分离出来；第二、针对接口编程而不是具体类（定义了策略接口）；第三、多用组合&#x2F;聚合，少用继承（客户通过组合方式使用策略）。</p><p><strong>主要就是解决 if…else 所带来的复杂和难以维护问题</strong></p><span id="more"></span><p><strong>优点：</strong></p><p>1、算法可以自由切换。<br>2、避免使用多重条件判断。<br>3、扩展性良好。</p><p><strong>缺点：</strong></p><p>1、策略类会增多。<br>2、所有策略类都需要对外暴露。</p><p><strong>使用场景：</strong></p><p>1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。<br>2、一个系统需要动态地在几种算法中选择一种。<br>3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>实现一个加减法计算器</p><p><strong>策略接口：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">doOperation</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>策略接口实现1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperationAdd</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">doOperation</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> num1 + num2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>策略接口实现2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperationSubtract</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">doOperation</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> num1 - num2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>策略接口实现3</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperationMultiply</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">doOperation</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> num1 * num2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上下文策略选择</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Context</span><span class="params">(Strategy strategy)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">executeStrategy</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> strategy.doOperation(num1, num2);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行时策略选择</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyPatternDemo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">OperationAdd</span>());    </span><br><span class="line">      System.out.println(<span class="string">&quot;10 + 5 = &quot;</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line"> </span><br><span class="line">      context = <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">OperationSubtract</span>());      </span><br><span class="line">      System.out.println(<span class="string">&quot;10 - 5 = &quot;</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line"> </span><br><span class="line">      context = <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">OperationMultiply</span>());    </span><br><span class="line">      System.out.println(<span class="string">&quot;10 * 5 = &quot;</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="策略模式在-JDK-Arrays-应用的源码分析"><a href="#策略模式在-JDK-Arrays-应用的源码分析" class="headerlink" title="策略模式在 JDK-Arrays 应用的源码分析"></a>策略模式在 JDK-Arrays 应用的源码分析</h1><p>​JDK 的 Arrays 的 Comparator 就使用了策略模式</p><p>示例演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nemo.jdk;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.Arrays; <span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//数组</span></span><br><span class="line">        Integer[] data = &#123; <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">3</span> &#125;;</span><br><span class="line">        <span class="comment">// 实现降序排序，返回-1 放左边，1 放右边，0 保持不变</span></span><br><span class="line">        <span class="comment">// 说 明</span></span><br><span class="line">        <span class="comment">// 1.  实现了 Comparator 接口（策略接口） , 匿名类 对象 new Comparator&lt;Integer&gt;()&#123;..&#125;</span></span><br><span class="line">        <span class="comment">// 2.  对象 new Comparator&lt;Integer&gt;()&#123;..&#125;  就是实现了 策略接口 的对象</span></span><br><span class="line">        <span class="comment">// 3. public int compare(Integer o1, Integer o2)&#123;&#125; 指定具体的处理方式</span></span><br><span class="line">        Comparator&lt;Integer&gt; comparator = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123; </span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (o1 &gt; o2) &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 说 明</span></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) &#123; </span></span><br><span class="line"><span class="comment">        *     if (c == null) &#123;</span></span><br><span class="line"><span class="comment">        *         sort(a); //默认方法</span></span><br><span class="line"><span class="comment">        *     &#125; else &#123;</span></span><br><span class="line"><span class="comment">        *         if (LegacyMergeSort.userRequested) </span></span><br><span class="line"><span class="comment">        *             legacyMergeSort(a, c); //使用策略对象 c</span></span><br><span class="line"><span class="comment">        *     else</span></span><br><span class="line"><span class="comment">        *         // 使用策略对象 c</span></span><br><span class="line"><span class="comment">        *         TimSort.sort(a, 0, a.length, c, null, 0, 0);</span></span><br><span class="line"><span class="comment">        *     &#125;</span></span><br><span class="line"><span class="comment">        * &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       </span><br><span class="line">        <span class="comment">//方式 1</span></span><br><span class="line">        Arrays.sort(data, comparator); </span><br><span class="line">        System.out.println(Arrays.toString(data)); <span class="comment">// 降序排序</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//方式 2- 同时 lambda 表达式实现 策略模式</span></span><br><span class="line">        Integer[] data2 = &#123; <span class="number">19</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">18</span>, <span class="number">14</span>, <span class="number">13</span> &#125;;</span><br><span class="line"> </span><br><span class="line">        Arrays.sort(data2, (var1, var2) -&gt; &#123; </span><br><span class="line">            <span class="keyword">if</span>(var1.compareTo(var2) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;data2=&quot;</span> + Arrays.toString(data2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="策略模式使用注意事项"><a href="#策略模式使用注意事项" class="headerlink" title="策略模式使用注意事项"></a>策略模式使用注意事项</h2><ol><li>策略模式的关键是：分析项目中变化部分与不变部分</li><li>策略模式的核心思想是：多用组合&#x2F;聚合 少用继承；用行为类组合，而不是行为的继承。更有弹性</li><li>体现了“对修改关闭，对扩展开放”原则，客户端增加行为不用修改原有代码，只要添加一种策略（或者行为） 即可，避免了使用多重转移语句（if..else if..else）</li><li>提供了可以替换继承关系的办法： 策略模式将算法封装在独立的 Strategy 类中使得你可以独立于其 Context 改变它，使它易于切换、易于理解、易于扩展</li><li>需要注意的是：每添加一个策略就要增加一个类，当策略过多是会导致类数目庞大</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 策略模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息中间件实现延迟消息</title>
      <link href="/2022/07/23/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF/"/>
      <url>/2022/07/23/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="延时任务实现"><a href="#延时任务实现" class="headerlink" title="延时任务实现"></a>延时任务实现</h1><p>​场景：用户下单后放弃支付了，那这笔订单会在指定的时间段后进行关闭操作</p><p>推荐实现的方法：</p><ol><li>使用 rocketmq、rabbitmq、pulsar 等消息队列的延时投递功能</li><li>使用 redisson 提供的 DelayedQueue</li></ol><p>不推荐实现方式：</p><ol><li>使用 redis 的过期监听</li><li>使用 rabbitmq 的死信队列</li><li>使用非持久化的时间轮</li></ol><span id="more"></span><h2 id="redis-过期监听"><a href="#redis-过期监听" class="headerlink" title="redis 过期监听"></a>redis 过期监听</h2><p>​redis 自动过期的实现方式是：定时任务离线扫描并删除部分过期键；在访问键时惰性检查是否过期并删除过期键。redis 从未保证会在设定的过期时间立即删除并发送过期通知。实际上，过期通知晚于设定的过期时间数分钟的情况也比较常见。<br>​此外键空间通知采用的是发送即忘(fire and forget)策略，并不像消息队列一样保证送达。当订阅事件的客户端会丢失所有在断线期间所有分发给它的事件。</p><h2 id="rabbitmq-死信"><a href="#rabbitmq-死信" class="headerlink" title="rabbitmq 死信"></a>rabbitmq 死信</h2><p>​死信(Dead Letter) 是 rabbitmq 提供的一种机制。当一条消息满足下列条件之一那么它会成为死信：</p><ul><li>消息被否定确认（如channel.basicNack) 并且此时requeue 属性被设置为false。</li><li>消息在队列的存活时间超过设置的TTL时间</li><li>消息队列的消息数量已经超过最大队列长度</li></ul><p>若配置了死信队列，死信会被 rabbitmq 投到死信队列中。</p><p>在 rabbitmq 中创建死信队列的操作流程大概是：</p><ul><li>创建一个交换机作为死信交换机</li><li>在业务队列中配置 x-dead-letter-exchange 和 x-dead-letter-routing-key，将第一步的交换机设为业务队列的死信交换机</li><li>在死信交换机上创建队列，并监听此队列</li></ul><p>​死信队列的设计目的是为了存储没有被正常消费的消息，便于排查和重新投递。死信队列同样也没有对投递时间做出保证，在第一条消息成为死信之前，后面的消息即使过期也不会投递为死信。</p><p>为了解决这个问题，rabbit 官方推出了延迟投递插件 rabbitmq-delayed-message-exchange。</p><h2 id="时间轮"><a href="#时间轮" class="headerlink" title="时间轮"></a>时间轮</h2><p>​时间轮是一种很优秀的定时任务的数据结构，然而绝大多数时间轮实现是纯内存没有持久化的。运行时间轮的进程崩溃之后其中所有的任务都会灰飞烟灭。</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 延迟消息实现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java浅克隆与深克隆</title>
      <link href="/2022/07/23/Java%E6%B5%85%E5%85%8B%E9%9A%86%E4%B8%8E%E6%B7%B1%E5%85%8B%E9%9A%86/"/>
      <url>/2022/07/23/Java%E6%B5%85%E5%85%8B%E9%9A%86%E4%B8%8E%E6%B7%B1%E5%85%8B%E9%9A%86/</url>
      
        <content type="html"><![CDATA[<h1 id="浅克隆与深克隆"><a href="#浅克隆与深克隆" class="headerlink" title="浅克隆与深克隆"></a>浅克隆与深克隆</h1><h2 id="浅克隆"><a href="#浅克隆" class="headerlink" title="浅克隆"></a>浅克隆</h2><ol><li>对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。</li><li>对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值</li><li>浅拷贝是使用默认的 clone()方法来实现<br>sheep &#x3D; (Sheep) super.clone();</li></ol><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">clone</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         clone = <span class="built_in">super</span>.clone();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> clone;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="深克隆"><a href="#深克隆" class="headerlink" title="深克隆"></a>深克隆</h2><p>复制对象的所有基本数据类型的成员变量值</p><p>为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象(包括对象的引用类型)进行拷贝<br>**深拷贝实现方式 **</p><ol><li><p>重写 clone 方法来实现深拷贝：多重浅拷贝，就变为了深拷贝。将引用类型全部浅拷贝完，<strong>只剩下基本数据类型或者不可变类型String</strong>即可。</p></li><li><p>通过对象序列化实现深拷贝(推荐)</p><p> 序列化 (Serialization)是将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。可以联想到 xml 序列化，用 xml 来存储或传输对象因为对象是复合引用类型的所以不好持久存储或传输，只能序列化，化为 xml 即可表示对象，继而传输。</p><p> 序列化深拷贝是将对象输出流读入对象，再利用字节数组输出流进行输出，对象输入流又利用字节数组输入流进行读入，封装成一个新的对象。在输出时，序列化会将对象的所有相关信息，包括其拥有的引用类型的对象一起打包输出(而不是只输出引用类型的地址) ，所以接收的时候我们可以得到一个完整的对象。</p><pre><code> 把对象转换为字节序列的过程称为对象的序列化 把字节序列恢复为对象的过程称为对象的反序列化</code></pre></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nemo.prototype.deepclone;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeepCloneableTarget</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>, Cloneable &#123;   <span class="comment">// 这里的Serializable接口是标识接口，并没有实际内容</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String cloneName;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String cloneClass;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DeepCloneableTarget</span><span class="params">(String cloneName, String cloneClass)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.cloneName = cloneName;</span><br><span class="line">        <span class="built_in">this</span>.cloneClass = cloneClass;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//因为该类的属性，都是 String ,  因此我们这里使用默认的 clone 完成即可</span></span><br><span class="line">    <span class="comment">//super.clone() 调用的是父类的克隆方法，默认Object父类，因为Java只能单继承，所以父类super对象唯一。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream; </span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream; </span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream; </span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeepProtoType</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>, Cloneable&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> String name; <span class="comment">//String 属 性</span></span><br><span class="line">    <span class="keyword">public</span> DeepCloneableTarget deepCloneableTarget;<span class="comment">// 引用类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DeepProtoType</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//深拷贝 - 方式 1  使用 clone 方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;        </span><br><span class="line">        <span class="type">Object</span> <span class="variable">deep</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//这里完成对基本数据类型(属性)和 String 的克隆</span></span><br><span class="line">        deep = <span class="built_in">super</span>.clone();</span><br><span class="line">        <span class="comment">//对引用类型的属性，进行单独处理</span></span><br><span class="line">        <span class="type">DeepProtoType</span> <span class="variable">deepProtoType</span> <span class="operator">=</span> (DeepProtoType)deep;</span><br><span class="line">        deepProtoType.deepCloneableTarget = (DeepCloneableTarget)deepCloneableTarget.clone();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//深拷贝 - 方式 2 通过对象的序列化实现 (推荐) </span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">deepClone</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//创建流对象</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//序列化</span></span><br><span class="line">            bos = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>(); <span class="comment">// 字节序列</span></span><br><span class="line">            oos = <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);  <span class="comment">// 对象</span></span><br><span class="line">            oos.writeObject(<span class="built_in">this</span>); <span class="comment">//当前这个对象以对象流的方式输出</span></span><br><span class="line"> </span><br><span class="line">            <span class="comment">//反序列化</span></span><br><span class="line">            bis = <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bos.toByteArray());  <span class="comment">// 从字节序列读取字节</span></span><br><span class="line">            ois = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bis);   <span class="comment">// 对象</span></span><br><span class="line">            <span class="type">DeepProtoType</span> <span class="variable">copyObj</span> <span class="operator">=</span> (DeepProtoType)ois.readObject();    <span class="comment">// 读取</span></span><br><span class="line">            <span class="keyword">return</span> copyObj;</span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception </span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭流 </span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bos.close();</span><br><span class="line">                oos.close();</span><br><span class="line">                bis.close();</span><br><span class="line">                ois.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> handle exception </span></span><br><span class="line">                    System.out.println(e2.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Client.java</span></span><br><span class="line"><span class="keyword">package</span> com.nemo.prototype.deepclone;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub </span></span><br><span class="line">        <span class="type">DeepProtoType</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeepProtoType</span>(); </span><br><span class="line">        p.name = <span class="string">&quot;宋江&quot;</span>;</span><br><span class="line">        p.deepCloneableTarget = <span class="keyword">new</span> <span class="title class_">DeepCloneableTarget</span>(<span class="string">&quot;大牛&quot;</span>, <span class="string">&quot;小牛&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//方式 1  完成深拷贝</span></span><br><span class="line">        <span class="comment">//  DeepProtoType p2 = (DeepProtoType) p.clone();</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//  System.out.println(&quot;p.name=&quot; + p.name + &quot;p.deepCloneableTarget=&quot; + p.deepCloneableTarget.hashCode());</span></span><br><span class="line">        <span class="comment">//  System.out.println(&quot;p2.name=&quot; + p.name + &quot;p2.deepCloneableTarget=&quot; + p2.deepCloneableTarget.hashCode());</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//方式 2  完成深拷贝</span></span><br><span class="line">        <span class="type">DeepProtoType</span> <span class="variable">p2</span> <span class="operator">=</span> (DeepProtoType) p.deepClone();</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;p.name=&quot;</span> + p.name + <span class="string">&quot;p.deepCloneableTarget=&quot;</span> + p.deepCloneableTarget.hashCode()); </span><br><span class="line">        System.out.println(<span class="string">&quot;p2.name=&quot;</span> + p.name + <span class="string">&quot;p2.deepCloneableTarget=&quot;</span> + p2.deepCloneableTarget.hashCode());</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="克隆在JDK源码中的应用"><a href="#克隆在JDK源码中的应用" class="headerlink" title="克隆在JDK源码中的应用"></a>克隆在JDK源码中的应用</h2><h3 id="1-ArrayList（浅克隆）"><a href="#1-ArrayList（浅克隆）" class="headerlink" title="1.ArrayList（浅克隆）"></a>1.ArrayList（浅克隆）</h3><p>java.util.ArrayList实现了Cloneable接口，重写了clone方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="built_in">super</span>.clone();</span><br><span class="line">        v.elementData = Arrays.copyOf(elementData, size);<span class="comment">//这里对基本数据类型或者String来说是深拷贝，对于对象来说是浅拷贝。</span></span><br><span class="line">        v.modCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="comment">// this shouldn&#x27;t happen, since we are Cloneable</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-Date（深克隆）"><a href="#2-Date（深克隆）" class="headerlink" title="2.Date（深克隆）"></a>2.Date（深克隆）</h3><p>java.util.Date实现了Cloneable接口，重写了clone方法，并且调用了属性的clone方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        d = (Date)<span class="built_in">super</span>.clone();</span><br><span class="line">        <span class="keyword">if</span> (cdate != <span class="literal">null</span>) &#123;</span><br><span class="line">            d.cdate = (BaseCalendar.Date) cdate.clone();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;&#125; <span class="comment">// Won&#x27;t happen</span></span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="克隆破坏单例模式"><a href="#克隆破坏单例模式" class="headerlink" title="克隆破坏单例模式"></a>克隆破坏单例模式</h3><pre><code>    如果我们克隆的目标的对象是单例对象，那意味着，深克隆就会破坏单例。实际上防止克隆破坏单例解决思路非常简单，禁止深克隆便可。要么单例类不实现Cloneable 接口；要么重写 clone()方法，在 clone 方法中返回单例对象即可，具体代码如下：</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.deepClone();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java浅克隆与深克隆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建造者模式</title>
      <link href="/2022/07/15/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/07/15/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><p>​建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>​主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。常常使用在一些基本部件不会变，而其组合经常变化的时候。</p><p>​关键组成部分：建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。</p><p>​建造者（Builder）模式的主要角色如下。</p><span id="more"></span><ol><li>产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个零部件。（最终指挥者返回的对象）</li><li>抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。（负责定义该产品由哪些部分组成）</li><li>具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。（这里不同子类就有可以使用不同的材料不同的方式来创建零部件）</li><li>指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。只是规定产品构建的顺序。这里可以传入不同的具体建造者，实现不同产品的构建</li></ol><h2 id="与工厂模式的区别"><a href="#与工厂模式的区别" class="headerlink" title="与工厂模式的区别"></a>与工厂模式的区别</h2><ul><li><p>建造者模式更加注重方法的调用顺序，工厂模式注重创建对象。</p></li><li><p>创建对象的力度不同，建造者模式创建复杂的对象，由各种复杂的部件组成，工厂模式创建出来的对象都一样</p></li><li><p>关注重点不一样，工厂模式只需要把对象创建出来就可以了，而建造者模式不仅要创建出对象，还要知道对象由哪些部件组成。</p></li><li><p>建造者模式根据建造过程中的顺序不一样，最终对象部件组成也不一样。</p><p>控制指的是方法的调用顺序的控制。在Builder 模式中， Director 决定了Builder 角色中方法的</p><p>调用顺序，而在Template Method 模式中，父类决定了子类方法的调用顺序</p></li></ul><h2 id="与抽象工厂模式的区别"><a href="#与抽象工厂模式的区别" class="headerlink" title="与抽象工厂模式的区别"></a>与抽象工厂模式的区别</h2><p>​抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品</p><h2 id="建造者模式的应用场景"><a href="#建造者模式的应用场景" class="headerlink" title="建造者模式的应用场景"></a>建造者模式的应用场景</h2><p>​建造者模式唯一区别于工厂模式的是针对复杂对象的创建。也就是说，如果创建简单对象，通常都是使用工厂模式进行创建，而如果创建复杂对象，就可以考虑使用建造者模式。</p><p>当需要创建的产品具备复杂创建过程时，可以抽取出共性创建过程，然后交由具体实现类自定义创建流程，使得同样的创建行为可以生产出不同的产品，分离了创建与表示，使创建产品的灵活性大大增加。</p><p>建造者模式主要适用于以下应用场景：</p><ul><li>相同的方法，不同的执行顺序，产生不同的结果。</li><li>多个部件或零件，都可以装配到一个对象中，但是产生的结果又不相同。</li><li>产品类非常复杂，或者产品类中不同的调用顺序产生不同的作用。</li><li>初始化一个对象特别复杂，参数多，而且很多参数都具有默认值。</li></ul><h2 id="实例应用"><a href="#实例应用" class="headerlink" title="实例应用"></a>实例应用</h2><pre><code>    使用Builder 模式编写“文档”的程序。文档具有以下结构。含有一个标题，含有几个字符串，含有条目项目    Builder 类中定义了决定文档结构的方法，然后Director 类使用该方法编写一个具体的文档。    Builder 是抽象类，它并没有进行任何实际的处理，仅仅声明了抽象方法。Builder 类的子类决定了用来编写文档的具体处理。    在示例程序中，我们定义了以下Builder 类的子类。    • TextBuilder 类：使用纯文本（普通字符串）编写文档    • HTMLBuilder 类：使用HTML 编写文档    Director 使用TextBuilder 类时可以编写纯文本文档；使用HTMLBuilder 类时可以编写HTML 文档。</code></pre><p>Builder 类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">makeTitle</span><span class="params">(String title)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">makeString</span><span class="params">(String str)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">makeitems</span><span class="params">(String [] items )</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Director 类</p><pre><code>    Director 类的构造函数的参数是Builder 类型的。但是实际上我们并不会将Builder 类的实例作为参数传递给Director 类。这是因为Builder 类是抽象类，是无法生成其实例的。实际上传递给Director 类的是Builder 类的子类（TextBuilder 类和HTMLBuilder 类等）的实例。而正是这些Builder 类的子类决定了编写出的文档的形式。    construct 方法是编写文挡的方法。调用这个方法后就会编写文档。construct 方法中所使用的方法都是在Builder 类中声明的方法</code></pre><p>Director 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Director</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Builder builder;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Director</span><span class="params">(Builder builder)</span> &#123;              <span class="comment">// 因为接收的参数是Builder类的子类</span></span><br><span class="line">        <span class="built_in">this</span>.builder = builder;                     <span class="comment">// 所以可以将其保存在builder字段中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">construct</span><span class="params">()</span> &#123;                       <span class="comment">// 编写文档</span></span><br><span class="line">        builder.makeTitle(<span class="string">&quot;Greeting&quot;</span>);              <span class="comment">// 标题</span></span><br><span class="line">        builder.makeString(<span class="string">&quot;从早上至下午&quot;</span>);         <span class="comment">// 字符串</span></span><br><span class="line">        builder.makeItems(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;             <span class="comment">// 条目</span></span><br><span class="line">            <span class="string">&quot;早上好。&quot;</span>,</span><br><span class="line">            <span class="string">&quot;下午好。&quot;</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">        builder.makeString(<span class="string">&quot;晚上&quot;</span>);                 <span class="comment">// 其他字符串</span></span><br><span class="line">        builder.makeItems(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;             <span class="comment">// 其他条目</span></span><br><span class="line">            <span class="string">&quot;晚上好。&quot;</span>,</span><br><span class="line">            <span class="string">&quot;晚安。&quot;</span>,</span><br><span class="line">            <span class="string">&quot;再见。&quot;</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">        builder.close();                            <span class="comment">// 完成文档</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TextBuilder 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TextBuilder</span> <span class="keyword">extends</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">StringBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();           <span class="comment">// 文档内容保存在该字段中 </span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">buildTitle</span><span class="params">(String title)</span> &#123;                       <span class="comment">// 纯文本的标题</span></span><br><span class="line">        buffer.append(<span class="string">&quot;==============================\n&quot;</span>);          <span class="comment">// 装饰线</span></span><br><span class="line">        buffer.append(<span class="string">&quot;『&quot;</span> + title + <span class="string">&quot;』\n&quot;</span>);                       <span class="comment">// 为标题添加『』</span></span><br><span class="line">        buffer.append(<span class="string">&quot;\n&quot;</span>);                                        <span class="comment">// 换行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">buildString</span><span class="params">(String str)</span> &#123;                        <span class="comment">// 纯文本的字符串</span></span><br><span class="line">        buffer.append(<span class="string">&#x27;■&#x27;</span> + str + <span class="string">&quot;\n&quot;</span>);                           <span class="comment">// 为字符串添加■</span></span><br><span class="line">        buffer.append(<span class="string">&quot;\n&quot;</span>);                                        <span class="comment">// 换行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">buildItems</span><span class="params">(String[] items)</span> &#123;                     <span class="comment">// 纯文本的条目</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">            buffer.append(<span class="string">&quot;　・&quot;</span> + items[i] + <span class="string">&quot;\n&quot;</span>);                <span class="comment">// 为条目添加・</span></span><br><span class="line">        &#125;</span><br><span class="line">        buffer.append(<span class="string">&quot;\n&quot;</span>);                                        <span class="comment">// 换行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">buildDone</span><span class="params">()</span> &#123;                                 <span class="comment">// 完成文档</span></span><br><span class="line">        buffer.append(<span class="string">&quot;==============================\n&quot;</span>);          <span class="comment">// 装饰线</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getResult</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> buffer.toString();                                   <span class="comment">// 将StringBuffer转换为String </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HTMLBuilder 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HTMLBuilder</span> <span class="keyword">extends</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String filename;                                    <span class="comment">// 文件名</span></span><br><span class="line">    <span class="keyword">private</span> PrintWriter writer;                                 <span class="comment">// 用于编写文件的PrintWriter</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">buildTitle</span><span class="params">(String title)</span> &#123;                       <span class="comment">// HTML文件的标题</span></span><br><span class="line">        filename = title + <span class="string">&quot;.html&quot;</span>;                                 <span class="comment">// 将标题作为文件名</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            writer = <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(filename));     <span class="comment">// 生成PrintWriter</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        writer.println(<span class="string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;&quot;</span> + title + <span class="string">&quot;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&quot;</span>);    <span class="comment">// 输出标题  </span></span><br><span class="line">        writer.println(<span class="string">&quot;&lt;h1&gt;&quot;</span> + title + <span class="string">&quot;&lt;/h1&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">buildString</span><span class="params">(String str)</span> &#123;                        <span class="comment">// HTML中的文字</span></span><br><span class="line">        writer.println(<span class="string">&quot;&lt;p&gt;&quot;</span> + str + <span class="string">&quot;&lt;/p&gt;&quot;</span>);                       <span class="comment">// 输出&lt;p&gt;标签</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">buildItems</span><span class="params">(String[] items)</span> &#123;                     <span class="comment">// HTML中的条目</span></span><br><span class="line">        writer.println(<span class="string">&quot;&lt;ul&gt;&quot;</span>);                                     <span class="comment">// 输出&lt;ul&gt;和&lt;li&gt;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">            writer.println(<span class="string">&quot;&lt;li&gt;&quot;</span> + items[i] + <span class="string">&quot;&lt;/li&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        writer.println(<span class="string">&quot;&lt;/ul&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">buildDone</span><span class="params">()</span> &#123;                                 <span class="comment">// 完成文档</span></span><br><span class="line">        writer.println(<span class="string">&quot;&lt;/body&gt;&lt;/html&gt;&quot;</span>);                           <span class="comment">// 关闭标签</span></span><br><span class="line">        writer.close();                                             <span class="comment">// 关闭文件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getResult</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> filename;                                            <span class="comment">// 返回文件名</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Main 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length != <span class="number">1</span>) &#123;</span><br><span class="line">            usage();</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (args[<span class="number">0</span>].equals(<span class="string">&quot;plain&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">TextBuilder</span> <span class="variable">textbuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextBuilder</span>();</span><br><span class="line">            <span class="type">Director</span> <span class="variable">director</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Director</span>(textbuilder);</span><br><span class="line">            director.construct();</span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> textbuilder.getResult();</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (args[<span class="number">0</span>].equals(<span class="string">&quot;html&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">HTMLBuilder</span> <span class="variable">htmlbuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HTMLBuilder</span>();</span><br><span class="line">            <span class="type">Director</span> <span class="variable">director</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Director</span>(htmlbuilder);</span><br><span class="line">            director.construct();</span><br><span class="line">            <span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> htmlbuilder.getResult();</span><br><span class="line">            System.out.println(filename + <span class="string">&quot;文件编写完成。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            usage();</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">usage</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Usage: java Main plain      编写纯文本文档&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Usage: java Main html       编写HTML文档&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建造者模式在-JDK-的应用和源码"><a href="#建造者模式在-JDK-的应用和源码" class="headerlink" title="建造者模式在 JDK 的应用和源码"></a>建造者模式在 JDK 的应用和源码</h2><p>​java.lang.StringBuilder 中的建造者模式</p><p>源码中建造者模式角色分析</p><ol><li><p>Appendable 接口定义了多个 append 方法(抽象方法), 即 Appendable 为抽象建造者, 定义了抽象方<img src="1.png" alt="1"></p></li><li><p>AbstractStringBuilder 实现了 Appendable 接口方法，这里的 AbstractStringBuilder 已经是建造者，只是不能实例化</p></li><li><p><img src="2.png" alt="1"></p></li><li><p>StringBuilder 即充当了指挥者角色，同时充当了具体的建造者，建造方法的实现是由 AbstractStringBuilder 完成 , 而 StringBuilder 继承了 AbstractStringBuilder</p></li></ol><p><img src="3.png" alt="1"></p><p><img src="4.png" alt="1"></p><p>​StringBuilder类,append方法就是给我们提供了一种链式创建对象的方法，然后toString方法返回了一个完整的对象。</p><h2 id="MyBatis中SqlSessionFactoryBuiler"><a href="#MyBatis中SqlSessionFactoryBuiler" class="headerlink" title="MyBatis中SqlSessionFactoryBuiler"></a>MyBatis中SqlSessionFactoryBuiler</h2><p><img src="5.jpg" alt="1"></p><p>​上面就是构建一个SqlSessionFactory对象的方法，我们看到里面的XMLConfigBuilder其实就是一个<strong>具体建造者角色</strong>，而其父类BaseBuilder就是一个<strong>抽象建造者角色</strong>。</p><p><img src="6.jpg" alt="1"></p><p><img src="7.jpg" alt="1"></p><h2 id="Spring框架中建造者模式的应用"><a href="#Spring框架中建造者模式的应用" class="headerlink" title="Spring框架中建造者模式的应用"></a>Spring框架中建造者模式的应用</h2><p>​Spring框架中的建造者模式的应用有很多，例如BeanDefinitionBuilder用于构建Bean定义信息对象，将BeanDefinition的创建过程进行封装，并提供BeanDefinitionBuilder各种Bean定义信息对象的创建方法，其实现更加的简洁（省略了抽象builder以及指挥者）并且符合实际开发需求。<br><img src="5.png" alt="1"></p><p>​以下方法为链式调用创建对象</p><p><img src="8.jpg" alt="1"></p><h2 id="链式，静态内部类，创建动态SQL"><a href="#链式，静态内部类，创建动态SQL" class="headerlink" title="链式，静态内部类，创建动态SQL"></a>链式，静态内部类，创建动态SQL</h2><p><a href="https://juejin.cn/post/7024026719120490527">用建造者模式实现一个防SQL注入的ORM框架 - 掘金 (juejin.cn)</a></p><p><a href="https://www.cnblogs.com/yinyunmoyi/p/14313217.html">庞大的建造者模式：以组装SQL为例 - 勇闯8 - 博客园 (cnblogs.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 建造者模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象工厂模式</title>
      <link href="/2022/07/13/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/07/13/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><h2 id="工厂模式的区别"><a href="#工厂模式的区别" class="headerlink" title="工厂模式的区别"></a>工厂模式的区别</h2><p>一句话概括工厂模式</p><p>简单工厂：一个工厂类（一个工厂实现类），一个产品抽象类。<br>工厂方法：多个工厂类（多个工厂实现类实现同一类产品的不同定制），一个产品抽象类。<br>抽象工厂：多个工厂类（上层在多一个抽象工厂接口中有不同条产品线）（子类实现多条产品线工厂），多个产品抽象类（多条产品线生产不同的产品）。</p><p>生活中的工厂模式</p><p>简单工厂类：一个麦当劳店，可以生产多种汉堡。<br>工厂方法类：一个麦当劳店，可以生产多种汉堡。一个肯德基店，也可以生产多种汉堡。<br>抽象工厂类：百胜餐饮集团下有肯德基和百事公司，肯德基生产汉堡，百事公司生成百事可乐。</p><span id="more"></span><h2 id="抽象工厂模式-1"><a href="#抽象工厂模式-1" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>​抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p><p>​同种类称为同等级，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如农场里既养动物又种植物，电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。</p><p>​抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，图 1 所示的是海尔工厂和 TCL 工厂所生产的电视机与空调对应的关系图。</p><p><img src="5.png" alt="1"></p><p>使用抽象工厂模式一般要满足以下条件。</p><ul><li>系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。</li><li>系统一次只可能消费其中某一族产品，即同族的产品一起使用。</li></ul><p>抽象工厂模式除了具有工厂方法模式的优点外，其他主要优点如下。</p><ul><li>可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。</li><li>当需要产品族时，抽象工厂可以保证客户端始终只使用同一个产品的产品组。</li><li>抽象工厂增强了程序的可扩展性，当增加一个新的产品族时，不需要修改原代码，满足开闭原则。</li></ul><p>其缺点是：当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。增加了系统的抽象性和理解难度。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>​抽象工厂模式同工厂方法模式一样，也是由抽象工厂、具体工厂、抽象产品和具体产品等 4 个要素构成，但抽象工厂中方法个数不同，抽象产品的个数也不同。现在我们来分析其基本结构和实现方法。</p><p>抽象工厂模式的主要角色如下。</p><ol><li>抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。</li><li>具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li><li>抽象产品（零件）（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</li><li>具体产品（产品）（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。</li></ol><p><img src="6.png" alt="1"></p><h2 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h2><p>​创建 <em>Shape</em> 和 <em>Color</em> 接口和实现这些接口的实体类。下一步是创建抽象工厂类 <em>AbstractFactory</em>。接着定义工厂类 <em>ShapeFactory</em> 和 <em>ColorFactory</em>，这两个工厂类都是扩展了 <em>AbstractFactory</em>。然后创建一个工厂创造器&#x2F;生成器类 <em>FactoryProducer</em>。<em>AbstractFactoryPatternDemo</em> 类使用 <em>FactoryProducer</em> 来获取 <em>AbstractFactory</em> 对象。它将向 <em>AbstractFactory</em> 传递形状信息 <em>Shape</em>（<em>CIRCLE &#x2F; RECTANGLE &#x2F; SQUARE</em>），以便获取它所需对象的类型。同时它还向 <em>AbstractFactory</em> 传递颜色信息 <em>Color</em>（<em>RED &#x2F; GREEN &#x2F; BLUE</em>），以便获取它所需对象的类型。<br>​        为 Color 和 Shape 对象创建抽象类来获取工厂。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AbstractFactory.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> Color <span class="title function_">getColor</span><span class="params">(String color)</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> Shape <span class="title function_">getShape</span><span class="params">(String shape)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ShapeFactory.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShapeFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Shape <span class="title function_">getShape</span><span class="params">(String shapeType)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(shapeType == <span class="literal">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;        </span><br><span class="line">      <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;CIRCLE&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;RECTANGLE&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;SQUARE&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Square</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Color <span class="title function_">getColor</span><span class="params">(String color)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ColorFactory.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ColorFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Shape <span class="title function_">getShape</span><span class="params">(String shapeType)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Color <span class="title function_">getColor</span><span class="params">(String color)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(color == <span class="literal">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;        </span><br><span class="line">      <span class="keyword">if</span>(color.equalsIgnoreCase(<span class="string">&quot;RED&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Red</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(color.equalsIgnoreCase(<span class="string">&quot;GREEN&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Green</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(color.equalsIgnoreCase(<span class="string">&quot;BLUE&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Blue</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个工厂创造器&#x2F;生成器类，通过传递形状或颜色信息来获取工厂。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FactoryProducer.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryProducer</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> AbstractFactory <span class="title function_">getFactory</span><span class="params">(String choice)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(choice.equalsIgnoreCase(<span class="string">&quot;SHAPE&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ShapeFactory</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(choice.equalsIgnoreCase(<span class="string">&quot;COLOR&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ColorFactory</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为形状创建一个接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Shape.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建实现接口的实体类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Rectangle.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Rectangle::draw() method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Square.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Square::draw() method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Circle.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Circle::draw() method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为颜色创建一个接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Color.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">fill</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建实现接口的实体类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Red.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Red</span> <span class="keyword">implements</span> <span class="title class_">Color</span> &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fill</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Red::fill() method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Green.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Green</span> <span class="keyword">implements</span> <span class="title class_">Color</span> &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fill</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Green::fill() method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Blue.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Blue</span> <span class="keyword">implements</span> <span class="title class_">Color</span> &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fill</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Blue::fill() method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">AbstractFactoryPatternDemo.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractFactoryPatternDemo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取形状工厂</span></span><br><span class="line">      <span class="type">AbstractFactory</span> <span class="variable">shapeFactory</span> <span class="operator">=</span> FactoryProducer.getFactory(<span class="string">&quot;SHAPE&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取形状为 Circle 的对象</span></span><br><span class="line">      <span class="type">Shape</span> <span class="variable">shape1</span> <span class="operator">=</span> shapeFactory.getShape(<span class="string">&quot;CIRCLE&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Circle 的 draw 方法</span></span><br><span class="line">      shape1.draw();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取形状为 Rectangle 的对象</span></span><br><span class="line">      <span class="type">Shape</span> <span class="variable">shape2</span> <span class="operator">=</span> shapeFactory.getShape(<span class="string">&quot;RECTANGLE&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Rectangle 的 draw 方法</span></span><br><span class="line">      shape2.draw();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//获取形状为 Square 的对象</span></span><br><span class="line">      <span class="type">Shape</span> <span class="variable">shape3</span> <span class="operator">=</span> shapeFactory.getShape(<span class="string">&quot;SQUARE&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Square 的 draw 方法</span></span><br><span class="line">      shape3.draw();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取颜色工厂</span></span><br><span class="line">      <span class="type">AbstractFactory</span> <span class="variable">colorFactory</span> <span class="operator">=</span> FactoryProducer.getFactory(<span class="string">&quot;COLOR&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取颜色为 Red 的对象</span></span><br><span class="line">      <span class="type">Color</span> <span class="variable">color1</span> <span class="operator">=</span> colorFactory.getColor(<span class="string">&quot;RED&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Red 的 fill 方法</span></span><br><span class="line">      color1.fill();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取颜色为 Green 的对象</span></span><br><span class="line">      <span class="type">Color</span> <span class="variable">color2</span> <span class="operator">=</span> colorFactory.getColor(<span class="string">&quot;GREEN&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Green 的 fill 方法</span></span><br><span class="line">      color2.fill();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取颜色为 Blue 的对象</span></span><br><span class="line">      <span class="type">Color</span> <span class="variable">color3</span> <span class="operator">=</span> colorFactory.getColor(<span class="string">&quot;BLUE&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Blue 的 fill 方法</span></span><br><span class="line">      color3.fill();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模式的应用场景"><a href="#模式的应用场景" class="headerlink" title="模式的应用场景"></a>模式的应用场景</h2><p>​抽象工厂模式最早的应用是用于创建属于不同操作系统的视窗构件。如 <a href="http://c.biancheng.net/java/">Java</a> 的 AWT 中的 Button 和 Text 等构件在 Windows 和 UNIX 中的本地实现是不同的。</p><p>​抽象工厂模式通常适用于以下场景：</p><ol><li>当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。</li><li>系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。</li><li>系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。</li></ol><h2 id="模式的扩展"><a href="#模式的扩展" class="headerlink" title="模式的扩展"></a>模式的扩展</h2><p>​抽象工厂模式的扩展有一定的“开闭原则”倾斜性：</p><ol><li>当增加一个新的产品族（新写一个小米电器工厂类）时只需增加一个新的具体工厂，不需要修改原代码，满足开闭原则。</li><li>当产品族中需要增加一个新种类的产品时（比如要增加洗碗机，那么所有品牌的工厂都必须要增加一个生产洗碗机的方法），则所有的工厂类都需要进行修改，不满足开闭原则。</li><li>另一方面，当系统中只存在一个等级结构的产品时，抽象工厂模式将退化到工厂方法模式。也就是不同的工厂实现生产同一类的产品比如生产不同品牌的电视机。</li></ol><h2 id="工厂模式在JDK中的应用"><a href="#工厂模式在JDK中的应用" class="headerlink" title="工厂模式在JDK中的应用"></a>工厂模式在JDK中的应用</h2><p>​JDK 中的工厂模式运用比较常见的就是当我们在构建线程池的时候会使用到 Executors 类进行构建，而阿里巴巴的 Java 开发手册中强制不使用 Executors，而是使用 ThreadPoolExecutor 进行手动指定参数进行创建。ThreadPoolExecutor 的构造方法由 7 个参数：</p><p>​核心线程数（corePoolSize）：线程池中执行的线程数，即线程池中的线程数，即使没有线程在运行，线程池也会持有这些线程不会销毁<br>​最大线程数（maximumPoolSize）：最大执行线程数，线程池中可以执行线程数的最大值<br>​空闲线程存活时间（keepAliveTime）：空闲线程在线程池中的存活时间，当空闲线程的存活时间超过该值时线程池会对其进行销毁，知道只剩 corePoolSize 个线程<br>​时间单位（unit）：keepAliveTime 空闲线程存活时间的单位<br>​阻塞队列（workQueue）：当请求线程数大于 maximumPoolSize 时，将多于线程存入该阻塞队列中，BlockingQueue 也有多种实现<br>​线程工厂（threadFactory）：用来生产线程的线程工厂<br>​拒绝策略（handler）：当请求线程数超过 maximumPoolSize 并且达到阻塞队列的上限时，对多于线程的处理方式，如直接丢弃、丢弃线程池存在时间最长的线程等<br>​<strong>注意到参数中有一个线程工厂，通过 ThreadFactory 这个接口传入，在线程池构建 Worker 的时候会通过调用传入线程工厂对象的 newThread() 方法创建Worker 持有的线程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadFactory 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a new &#123;<span class="doctag">@code</span> Thread&#125;.  Implementations may also initialize</span></span><br><span class="line"><span class="comment">     * priority, name, daemon status, &#123;<span class="doctag">@code</span> ThreadGroup&#125;, etc.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r a runnable to be executed by new thread instance</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> constructed thread, or &#123;<span class="doctag">@code</span> null&#125; if the request to</span></span><br><span class="line"><span class="comment">     *         create a thread is rejected</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Worker 构造方法</span></span><br><span class="line">Worker(Runnable firstTask) &#123;</span><br><span class="line">    setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">    <span class="built_in">this</span>.firstTask = firstTask;</span><br><span class="line">    <span class="built_in">this</span>.thread = getThreadFactory().newThread(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​这里便是工厂模式的典型应用，在构建 Worker 的时候我们并不关心他是怎么创建线程的，直接调用对应工厂的 newThread() 方法创建线程即可。在这里的应用中，ThreadFactory 就是抽象工厂，而下面的各种实现类如DefaultThreadFactory、DaemonThreadFactory 等就是对应的具体工厂，而最终构建的线程 Thread 就是工厂所生产的产品。</p><p><img src="1.png" alt="1"></p><h2 id="抽象工厂模式在spring源码中的应用"><a href="#抽象工厂模式在spring源码中的应用" class="headerlink" title="抽象工厂模式在spring源码中的应用"></a>抽象工厂模式在spring<a href="https://so.csdn.net/so/search?q=%E6%BA%90%E7%A0%81&spm=1001.2101.3001.7020">源码</a>中的应用</h2><p>​在 Spring 中，BeanFactory 是用于管理 Bean 的一个工厂，所有工厂都是 BeanFactory 的子类。这样我们可以通过 IOC 容器来管理访问 Bean，根据不同的策略调用 getBean() 方法，从而获得具体对象。具体获取过程可以参考：<a href="https://blog.csdn.net/qq_38550836/article/details/106865370">Spring源码分析——获取Bean</a></p><p><img src="2.png" alt="1"></p><p>​从上面的简化图中可以看到在 BeanFactory 这个 bean 工厂体系中，BeanFactory 接口便是抽象工厂，而在实际调用中用的时下面的具体实现子类（具体工厂），如 AbstractBeanFactory 、AbstractApplicationContext、 DefaultListableBeanFactory 等等，而在调用 getBean() 等方法之后获取到的具体实例便是生产出的产品。</p><p>其中，BeanFactory 接口的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanFactory</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">FACTORY_BEAN_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;&amp;&quot;</span>;</span><br><span class="line">    Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">    &lt;T&gt; T <span class="title function_">getBean</span><span class="params">(String name, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">    Object <span class="title function_">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">    &lt;T&gt; T <span class="title function_">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">    &lt;T&gt; T <span class="title function_">getBean</span><span class="params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">containsBean</span><span class="params">(String name)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isPrototype</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isTypeMatch</span><span class="params">(String name, <span class="meta">@Nullable</span> Class&lt;?&gt; typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    Class&lt;?&gt; getType(String name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line">    String[] getAliases(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BeanFactory 的子类主要有 ClassPathXmlApplicationContext、XmlWebApplicationContext、StaticWebApplicationContext、StaticApplicationContext。在 Spring 中，DefaultListableBeanFactory 实现了所有工厂的公共逻辑。</p><h2 id="MyBatis-中的工厂模式"><a href="#MyBatis-中的工厂模式" class="headerlink" title="MyBatis 中的工厂模式"></a>MyBatis 中的工厂模式</h2><p>​在 MyBatis 中有一个接口叫做 SqlSessionFactory ，有 DefaultSqlSessionFactory、SqlSessionManager 这两个。该类的作用在于获取到 SqlSession 对象，并利用该对象对数据库进行增删改查操作，具体源码分析可以参考：<a href="https://blog.csdn.net/qq_38550836/article/details/104258225">MyBatis源码分析——使用SqlSession操作数据库</a>。</p><p><img src="3.png" alt="1"></p><p><img src="4.png" alt="1"></p><p>在 SqlSessionFactory 这个体系中，各个类在抽象工厂模式中的应用：</p><p>抽象工厂：接口 SqlSessionFactory<br>具体工厂：DefaultSqlSessionFactory、SqlSessionManager 便是对应的具体工厂，这个两个工厂用于通过调用 openSession() 方法用于获取 SqlSession 对象<br>抽象产品：SqlSession 对象便是具体的抽象产品<br>具体产品：DefaultSqlSession、SqlSessionManager、SqlSessionTemplate 这三个类实现接口 SqlSession ，便是具体的产品<br>从接口 SqlSessionFactory 中可以看到该工厂不仅能够生产 SqlSession 对象，还能生产 Configuration ，因此整个 SqlSessionFactory 和 SqlSession 体系是个非常标准的抽象工厂模式。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 抽象工厂模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模板模式</title>
      <link href="/2022/07/12/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/07/12/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h1><p>​在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式（比如多个方法的执行顺序）&#x2F;模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。</p><p>​主要是为了定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p>该模式的主要优点如下。</p><ol><li>它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。</li><li>它在父类中提取了公共的部分代码，便于代码复用。</li><li>部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。</li></ol><span id="more"></span><p>该模式的主要缺点如下。</p><ol><li>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象，间接地增加了系统实现的复杂度。</li><li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果（比如钩子方法，父类中有有flag，子类传入不同flag来执行父类不同的方法），这导致一种反向的控制结构，它提高了代码阅读的难度。</li><li>由于继承关系自身的缺点，如果父类添加新的抽象方法，则所有子类都要改一遍。</li></ol><h1 id="模板方法的结构"><a href="#模板方法的结构" class="headerlink" title="模板方法的结构"></a>模板方法的结构</h1><p>模板方法模式包含以下主要角色。</p><h4 id="1）抽象类-x2F-抽象模板（Abstract-Class）"><a href="#1）抽象类-x2F-抽象模板（Abstract-Class）" class="headerlink" title="1）抽象类&#x2F;抽象模板（Abstract Class）"></a>1）抽象类&#x2F;抽象模板（Abstract Class）</h4><p>抽象模板类，负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。这些方法的定义如下。</p><p>① 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。</p><p>② 基本方法：是整个算法中的一个步骤，包含以下几种类型。</p><ul><li>抽象方法：在抽象类中声明，由具体子类实现。</li><li>具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。</li><li>钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。</li></ul><h4 id="2）具体子类-x2F-具体实现（Concrete-Class）"><a href="#2）具体子类-x2F-具体实现（Concrete-Class）" class="headerlink" title="2）具体子类&#x2F;具体实现（Concrete Class）"></a>2）具体子类&#x2F;具体实现（Concrete Class）</h4><p>具体实现类，实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的一个组成步骤。</p><h1 id="通用代码"><a href="#通用代码" class="headerlink" title="通用代码"></a>通用代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="comment">// 共同的且繁琐的操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">baseOperation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由子类定制的操作</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">customOperation</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模板方法定义的框架</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">templateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用基本方法，完成固定逻辑</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        baseOperation();</span><br><span class="line">        customOperation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass1</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">customOperation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 具体模板1 业务逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;具体模板1：customOperation()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass2</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">customOperation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 具体模板2 业务逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;具体模板2：customOperation()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TemplateClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AbstractClass</span> <span class="variable">abstractClass1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteClass1</span>();</span><br><span class="line">        <span class="type">AbstractClass</span> <span class="variable">abstractClass2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteClass2</span>();</span><br><span class="line">        applyTemplate(abstractClass1);</span><br><span class="line">        applyTemplate(abstractClass2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">applyTemplate</span><span class="params">(AbstractClass abstractClass)</span>&#123;</span><br><span class="line">        abstractClass.templateMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了解决模板模式的缺点，我们可以利用回调函数代替子类继承。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callback</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">customOperation</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模板类</span></span><br><span class="line"><span class="comment"> * 声明为 final，无法被继承</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Template</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">baseOperation</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;模板类公共操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">templateMethod</span><span class="params">(Callback callback)</span>&#123;</span><br><span class="line">        baseOperation();</span><br><span class="line">        callback.customOperation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Template是一个稳定的final类，无法被继承，不存在子类行为影响父类结果的问题，而Callback是一个接口，为了继承而继承的问题消失了。</p><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TemplateClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Template</span> <span class="variable">template</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Template</span>();</span><br><span class="line">        applyTemplate(template);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">applyTemplate</span><span class="params">(Template template)</span>&#123;</span><br><span class="line">        <span class="type">Callback</span> <span class="variable">callback</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubCallback</span>();</span><br><span class="line">        template.templateMethod(callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Java-8-的函数式编程"><a href="#Java-8-的函数式编程" class="headerlink" title="Java 8 的函数式编程"></a><strong>Java 8 的函数式编程</strong></h1><p>​2014年，Oracle发布了 Java 8，在Java 8中最大的新特性就是提供了对函数式编程的支持。</p><p>​Java 8在java.util.function下面增加增加一系列的函数接口。其中主要有Consumer、Supplier、Predicate、Function等。</p><p>​下面介绍一下Supplier和Consumer这两个，使用者两个接口，可以帮我们很好的改造模板方法。这里只是简单介绍下他们的用法，并不会深入展开，如果大家想要学习更多用法，可以自行google一下。</p><p><strong>Supplier</strong></p><p>​Supplier是一个<strong>供给型</strong>的接口，简单点说，这就是一个返回某些值的方法。</p><p>最简单的一个Supplier就是下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getList</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Supplier表示就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;List&lt;String&gt;&gt; listSupplier = ArrayList::<span class="keyword">new</span>;</span><br></pre></td></tr></table></figure><p><strong>Consumer</strong></p><p>Consumer 接口<strong>消费型</strong>接口，简单点说，这就是一个使用某些值(如方法参数)并对其进行操作的方法。</p><p>最简单的一个Consumer就是下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sum</span><span class="params">(String a1)</span> &#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(a1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Consumer表示就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; printConsumer = a1 -&gt; System.out.println(a1);</span><br></pre></td></tr></table></figure><p>Consumer的用法，最见的的例子就是是Stream.forEach(Consumer)这样的用法，</p><p>它接受一个Consumer，该Consumer消费正在迭代的流中的元素，并对每个元素执行一些操作，比如打印：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; stringConsumer = (s) -&gt; System.out.println(s.length());</span><br><span class="line"></span><br><span class="line">Arrays.asList(<span class="string">&quot;ab&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;abcd&quot;</span>).stream().forEach(stringConsumer);</span><br></pre></td></tr></table></figure><h1 id="Java-8以后的模板方法"><a href="#Java-8以后的模板方法" class="headerlink" title="Java 8以后的模板方法"></a><strong>Java 8以后的模板方法</strong></h1><p>在介绍过了Java 8中的Consumer、Supplier之后，我们来看下怎么改造之前我们介绍过的模板方法。</p><p>首先，我们定义一个BankBusinessHandler类，并且重新定义一个execute方法，这个方法有一个入参，是Consumer类型的，然后移除handle方法，重新编排后的模板方法内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hollis</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankBusinessHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Consumer&lt;BigDecimal&gt; consumer)</span> &#123;</span><br><span class="line"></span><br><span class="line">        getNumber();</span><br><span class="line"></span><br><span class="line">        consumer.accept(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        judge();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getNumber</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;number-00&quot;</span> + RandomUtils.nextInt());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">judge</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;give a praised&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们实现的模板方法execute中，编排了getNumber、judge以及consumer.accept，这里面consumer.accept就是具体的业务逻辑，可能是存钱、取钱、理财等。需要由其他方法调用execute的时候传入。</p><p>这时候，我们想要实现”存钱”业务的时候，需要BankBusinessHandler类中增加以下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hollis</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankBusinessHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(BigDecimal amount)</span> &#123;</span><br><span class="line"></span><br><span class="line">        execute(a -&gt; System.out.println(<span class="string">&quot;save &quot;</span> + amount));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在save方法中，调用execute方法，并且在入参处传入一个实现了”存钱”的业务逻辑的Comsumer。</p><p>这样，我们在执行存钱的业务逻辑的时候，只需要调用 BankBusinessHandler的save方法即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">BankBusinessHandler</span> <span class="variable">businessHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BankBusinessHandler</span>();</span><br><span class="line"></span><br><span class="line">    businessHandler.save(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1000&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">number-<span class="number">001736151440</span></span><br><span class="line"></span><br><span class="line">save1000</span><br><span class="line"></span><br><span class="line">give a praised</span><br></pre></td></tr></table></figure><p>如上，当我们想要实现取钱、理财等业务逻辑的时候，和存钱类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hollis</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankBusinessHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(BigDecimal amount)</span> &#123;</span><br><span class="line"></span><br><span class="line">        execute(a -&gt; System.out.println(<span class="string">&quot;save &quot;</span> + amount));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(BigDecimal amount)</span> &#123;</span><br><span class="line"></span><br><span class="line">        execute(a -&gt; System.out.println(<span class="string">&quot;draw &quot;</span> + amount));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moneyManage</span><span class="params">(BigDecimal amount)</span> &#123;</span><br><span class="line"></span><br><span class="line">        execute(a -&gt; System.out.println(<span class="string">&quot;draw &quot;</span> + amount));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，通过使用Java 8中的Comsumer，我们把模板方法改造了，<strong>改造之后不再需要抽象类、抽象方法，也不再需要为每一个业务都创建一个实现类了</strong>。我们可以把所有的业务逻辑内聚在同一个业务类中。这样非常方便这段代码的后期运维。</p><p>前面介绍如何使用Consumer进行改造模板方法，那么Supplier有什么用呢？</p><p>我们的例子中，在取号、办业务、评价这三个步骤中，办业务是需要根据业务情况进行定制的，所以，我们在模板方法中，把办业务这个作为扩展点开放给外部。</p><p>有这样一种情况，那就是现在我们办业务的时候，取号的方式也不一样，可能是到银行网点取号、在网上取号或者银行客户经理预约的无需取号等。</p><p>无论取号的方式如何，最终结果都是取一个号；而取到的号的种类不同，可能接收到的具体服务也不同，比如vip号会到VIP柜台办理业务等。</p><p>想要实现这样的业务逻辑，就需要使用到Supplier，<strong>Supplier是一个”供给者”，他可以用来定制”取号逻辑”。</strong></p><p>首先，我们需要改造下模板方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 模板方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Supplier&lt;String&gt; supplier, Consumer&lt;BigDecimal&gt; consumer)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">number</span> <span class="operator">=</span> supplier.get();</span><br><span class="line"></span><br><span class="line">    System.out.println(number);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (number.startsWith(<span class="string">&quot;vip&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Vip号分配到VIP柜台</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Assign To Vip Counter&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (number.startsWith(<span class="string">&quot;reservation&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//预约号分配到专属客户经理</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Assign To Exclusive Customer Manager&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//默认分配到普通柜台</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Assign To Usual Manager&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    consumer.accept(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    judge();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过改造，execute的入参增加了一个supplier，这个supplier可以提供一个号码。至于如何取号的，交给调用execute的方法来执行。</p><p>之后，我们可以定义多个存钱方法，分别是Vip存钱、预约存钱和普通存钱：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankBusinessHandler</span> <span class="keyword">extends</span> <span class="title class_">AbstractBusinessHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveVip</span><span class="params">(BigDecimal amount)</span> &#123;</span><br><span class="line"></span><br><span class="line">        execute(() -&gt; <span class="string">&quot;vipNumber-00&quot;</span> + RandomUtils.nextInt(), a -&gt; System.out.println(<span class="string">&quot;save &quot;</span> + amount));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(BigDecimal amount)</span> &#123;</span><br><span class="line"></span><br><span class="line">        execute(() -&gt; <span class="string">&quot;number-00&quot;</span> + RandomUtils.nextInt(), a -&gt; System.out.println(<span class="string">&quot;save &quot;</span> + amount));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveReservation</span><span class="params">(BigDecimal amount)</span> &#123;</span><br><span class="line"></span><br><span class="line">        execute(() -&gt; <span class="string">&quot;reservationNumber-00&quot;</span> + RandomUtils.nextInt(), a -&gt; System.out.println(<span class="string">&quot;save &quot;</span> + amount));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在多个不同的存钱方法中，实现不同的取号逻辑，把取号逻辑封装在supplier中，然后传入execute方法即可。</p><p>测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BankBusinessHandler</span> <span class="variable">businessHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BankBusinessHandler</span>();</span><br><span class="line"></span><br><span class="line">businessHandler.saveVip(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1000&quot;</span>));</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vipNumber-001638110566</span><br><span class="line"></span><br><span class="line">Assign To Vip Counter</span><br><span class="line"></span><br><span class="line">save <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">give a praised</span><br></pre></td></tr></table></figure><p>以上，我们就是用Comsumer和Supplier改造了模板方法模式。</p><p>使用Java 8对模板方法进行改造之后，可以进一步的减少代码量，至少可少创建很多实现类，大大的减少重复代码，提升可维护性。</p><h1 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h1><p>编写制作豆浆的程序，说明如下:</p><p>制作豆浆的流程 选材—&gt;添加配料—&gt;浸泡—&gt;放到豆浆机打碎通过添加不同的配料，可以制作出不同口味的豆浆<br>选材、浸泡和放到豆浆机打碎这几个步骤对于制作每种口味的豆浆都是一样的(红豆、花生豆浆。。。)</p><p>抽象模板</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象类，表示豆浆</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SoyaMilk</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//模板方法 make，模板方法可以做成 final，不让子类去覆盖</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">make</span><span class="params">()</span> &#123;</span><br><span class="line">        select(); </span><br><span class="line">        addCondiments(); </span><br><span class="line">        soak();</span><br><span class="line">        beat();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//选材料</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第一步：选择好的新鲜黄豆 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//添加不同的配料， 抽象方法,  子类具体实现</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">addCondiments</span><span class="params">()</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//浸泡</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">soak</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第三步， 黄豆和配料开始浸泡，需要 3 小时 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">beat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第四步：黄豆和配料放到豆浆机去打碎   &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同的子类的具体实现，重写父类的某些方法实现定制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedBeanSoyaMilk</span> <span class="keyword">extends</span> <span class="title class_">SoyaMilk</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addCondiments</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 加入上好的红豆 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PeanutSoyaMilk</span> <span class="keyword">extends</span> <span class="title class_">SoyaMilk</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addCondiments</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 加入上好的花生 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//制作红豆豆浆</span></span><br><span class="line">        System.out.println(<span class="string">&quot;---- 制作红豆豆浆 ----&quot;</span>);</span><br><span class="line">        <span class="type">SoyaMilk</span> <span class="variable">redBeanSoyaMilk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedBeanSoyaMilk</span>(); </span><br><span class="line">        redBeanSoyaMilk.make();</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;---- 制作花生豆浆 ----&quot;</span>); </span><br><span class="line">        <span class="type">SoyaMilk</span> <span class="variable">peanutSoyaMilk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PeanutSoyaMilk</span>(); </span><br><span class="line">        peanutSoyaMilk.make();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Spring源码中模板模式的使用"><a href="#Spring源码中模板模式的使用" class="headerlink" title="Spring源码中模板模式的使用"></a>Spring源码中模板模式的使用</h1><p>Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。一般情况下，我们都是使用继承的方式来实现模板模式，但是 Spring 并没有使用这种方式，而是使用Callback 模式与模板方法模式配合，既达到了代码复用的效果，同时增加了灵活性。Spring中几乎所有的扩展都是用了模板方法模式，以下以SpringIOC为例：</p><h3 id="1、首先定义一个接口ConfigurableApplicationContext，声明模板方法refresh。"><a href="#1、首先定义一个接口ConfigurableApplicationContext，声明模板方法refresh。" class="headerlink" title="1、首先定义一个接口ConfigurableApplicationContext，声明模板方法refresh。"></a>1、首先定义一个接口ConfigurableApplicationContext，声明模板方法refresh。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ConfigurableApplicationContext</span> <span class="keyword">extends</span> <span class="title class_">ApplicationContext</span>, Lifecycle, Closeable &#123;</span><br><span class="line">　　<span class="comment">/**声明了一个模板方法*/</span></span><br><span class="line">　　<span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、抽象类AbstractApplicationContext实现了接口"><a href="#2、抽象类AbstractApplicationContext实现了接口" class="headerlink" title="2、抽象类AbstractApplicationContext实现了接口"></a>2、抽象类AbstractApplicationContext实现了接口</h3><p>主要实现了模板方法refresh（这个方法很重要，是各种IOC容器初始化的入口）的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模板方法的具体实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line">　　　　　<span class="comment">//注意这个方法是，里面调用了两个抽象方法refreshBeanFactory、getBeanFactory</span></span><br><span class="line">        <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">        <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line">        <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">　　　　　　　<span class="comment">//注意这个方法是钩子方法</span></span><br><span class="line">            <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line">            <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">            <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line">            <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">            initMessageSource();</span><br><span class="line">            <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line">　　　　　　　　　 <span class="comment">//注意这个方法是钩子方法</span></span><br><span class="line">            <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">            onRefresh();</span><br><span class="line">            <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">            registerListeners();</span><br><span class="line">            <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">            <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">            destroyBeans();</span><br><span class="line">            <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line">            <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里最主要有一个抽象方法obtainFreshBeanFactory、两个钩子方法postProcessBeanFactory和onRefresh，看看他们在类中的定义</p><p>两个钩子方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onRefresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="comment">// For subclasses: do nothing by default.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看看获取Spring容器的抽象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**其实他内部只调用了两个抽象方法**/</span>    </span><br><span class="line"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title function_">obtainFreshBeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    refreshBeanFactory();</span><br><span class="line">    <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> getBeanFactory();</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    logger.debug(<span class="string">&quot;Bean factory for &quot;</span> + getDisplayName() + <span class="string">&quot;: &quot;</span> + beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> ConfigurableListableBeanFactory <span class="title function_">getBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException;</span><br></pre></td></tr></table></figure><p>具体要取那种BeanFactory容器的决定权交给了子类！</p><h3 id="3、AbstractRefreshableApplicationContext"><a href="#3、AbstractRefreshableApplicationContext" class="headerlink" title="3、AbstractRefreshableApplicationContext"></a>3、AbstractRefreshableApplicationContext</h3><p>AbstractRefreshableApplicationContext是实现了抽象方法getBeanFactory的子类；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractRefreshableApplicationContext</span> <span class="keyword">extends</span> <span class="title class_">AbstractApplicationContext</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ConfigurableListableBeanFactory <span class="title function_">getBeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.beanFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;BeanFactory not initialized or already closed - &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;call &#x27;refresh&#x27; before accessing beans via the ApplicationContext&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里的this.beanFactory在另一个抽象方法refreshBeanFactory的设置的</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.beanFactory;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericApplicationContext</span> <span class="keyword">extends</span> <span class="title class_">AbstractApplicationContext</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionRegistry</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ConfigurableListableBeanFactory <span class="title function_">getBeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line">　　　　<span class="comment">//同样这里的this.beanFactory在另一个抽象方法中设置        </span></span><br><span class="line">　　　　<span class="keyword">return</span> <span class="built_in">this</span>.beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这里的差别还不是很大，我们可以看看另一个抽象方法refreshBeanFactory的实现，两个抽象方法的配合使用。</p><h2 id="模板方法模式在-Spring-源码中的应用"><a href="#模板方法模式在-Spring-源码中的应用" class="headerlink" title="模板方法模式在 Spring 源码中的应用"></a>模板方法模式在 Spring 源码中的应用</h2><p>​在使用 XML 定义 Spring 的 Bean 时，我们需要读取 XML 并解析其中定义好的 Bean，在解析的时候会调用 DefaultBeanDefinitionDocumentReader 中的doRegisterBeanDefinitions() 方法解析 XML 中的节点来注册 Bean。该方法源码如下：<br><img src="1.jpg" alt="1"></p><p>​在该方法中调用了 preProcessXml 和 postProcessXml 两个方法，用于在解析 XML 前后添加处理逻辑，而进入这两个方法后可以看到方法时空的，因此我们可以通过对 DefaultBeanDefinitionDocumentReader 进行继承并重写 preProcessXml 和 postProcessXml 这两个方法在处理 XML 前后自定义添加新的功能逻辑，而这个地方便是使用的模板方法模式。</p><pre><code>## 模板方法模式在 MyBatis 源码中的应用</code></pre><p>​在 MyBatis 中有一个类叫 BaseExecutor，该类定义了增删改查等基本操作。在 BaseExecutor 类中有 update()、flushStatements()、queryFromDatabase()、queryCursorqueryCursor() 四个方法，而在四个方法中又分别调用了doUpdate()、doFlushStatements()、doQuery()、doQueryCursor() 这四个最终执行的 do 方法，可以看到在该类中这几个 do 方法是空的，真正的实现交给了其子类，因此这里也是一个典型的模板方法模式。<br><img src="2.jpg" alt="1"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模板模式 </tag>
            
            <tag> Java8之后的模板模式代码优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静态工厂模式</title>
      <link href="/2022/07/12/%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/07/12/%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>​在Template Method 模式中’我们在父类中规定处理的流程．在子类中实现具体的处理。如果我们将该模式用于生成实例（子类中定制对象的创建），它就演变为本章中我们所要学习的Factory Method模式。</p><p>​在Factory Method 模式中，父类决定实例的生成方式，但并不决定所要生成的具体的类． 具体的处理全部交给子类负责。这样就可以将生成实例的框架（ framework ）和实际负责生成实例的类。</p><p>​主要是为了定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。主要解决接口选择的问题。我们明确地计划不同条件下创建不同实例时。让其子类实现工厂接口，返回的也是一个抽象的产品。创建过程在其子类执行。</p><span id="more"></span><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol><li>工厂类包含必要的逻辑判断，可以决定在什么时候创建哪一个产品的实例。客户端可以免除直接创建产品对象的职责，很方便的创建出相应的产品。工厂和产品的职责区分明确。</li><li>客户端无需知道所创建具体产品的类名，只需知道参数即可（甚至可以定义一个当前可以创建那些产品参数的枚举，用户之间传入枚举就可以）。</li><li>也可以引入配置文件，在不修改客户端代码的情况下更换和添加新的具体产品类。</li></ol><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol><li>简单工厂模式的工厂类单一，负责所有产品的创建，职责过重，一旦异常，整个系统将受影响。且工厂类代码会非常臃肿，违背高聚合原则。</li><li>使用简单工厂模式会增加系统中类的个数（引入新的工厂类），增加系统的复杂度和理解难度</li><li>系统扩展困难，一旦增加新产品不得不修改工厂逻辑，在产品类型较多时，可能造成逻辑过于复杂</li><li>简单工厂模式使用了 static 工厂方法，造成工厂角色无法形成基于继承的等级结构。</li></ol><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>​对于产品种类相对较少的情况，考虑使用简单工厂模式。使用简单工厂模式的客户端只需要传入工厂类的参数，不需要关心如何创建对象的逻辑，可以很方便地创建所需产品。</p><p>​一句话概括工厂模式</p><p>简单工厂：一个工厂类，一个产品抽象类。<br>工厂方法：多个工厂类，一个产品抽象类。<br>抽象工厂：多个工厂类，多个产品抽象类。</p><p>生活中的工厂模式</p><p>​简单工厂类：一个麦当劳店，可以生产多种汉堡。<br>工厂方法类：一个麦当劳店，可以生产多种汉堡。一个肯德基店，也可以生产多种汉堡。<br>抽象工厂类：百胜餐饮集团下有肯德基和百事公司，肯德基生产汉堡，百事公司生成百事可乐。</p><p>​其实工厂模式就如它的名字一般，是个密不透风的工厂。我们只需要把我们需要的清单交给它，他就能做出相应的物品给我们，而不需要我们亲力亲为，亲手去制造物品。如 我们需要汽车 car，我们不需要自己new Car()创建一个汽车对象，而是只需要将 “car”（枚举字符串）这种清单交给工厂就可以了。换句话来说，调用者并不知道运行时真正的类名，只知道从“Circle”可以创建出一个shape接口的类，至于类的名称是否叫’Circle”，调用者并不知情。所以真正的对工厂进行扩展的方式（防止程序员调用出错）可以考虑使用一个枚举类（防止传入参数时，把circle拼写错误）。</p><p>简单工厂模式的主要角色如下：</p><ul><li>简单工厂（SimpleFactory）：是简单工厂模式的核心，负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。</li><li>抽象产品（Product）：是简单工厂创建的所有对象的父类，负责描述所有实例共有的公共接口。</li><li>具体产品（ConcreteProduct）：是简单工厂模式的创建目标。</li></ul><h1 id="简单工厂模式实例"><a href="#简单工厂模式实例" class="headerlink" title="简单工厂模式实例"></a>简单工厂模式实例</h1><p>我们将创建一个 <em>Shape</em> 接口（抽象产品）和实现 <em>Shape</em> 接口的实体类（具体产品）。下一步是定义工厂类 <em>ShapeFactory</em>。<em>FactoryPatternDemo</em> 类使用 <em>ShapeFactory</em> 来获取 <em>Shape</em> 对象。它将向 <em>ShapeFactory</em> 传递信息（<em>CIRCLE &#x2F; RECTANGLE &#x2F; SQUARE</em>），以便获取它所需对象的类型。</p><p><img src="%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%5C1.jpg" alt="1"></p><p>产品接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体产品实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Rectangle::draw() method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Square::draw() method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Circle::draw() method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单工厂（可以是单例的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShapeFactory</span> &#123;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//使用 getShape 方法获取形状类型的对象</span></span><br><span class="line">   <span class="keyword">public</span> Shape <span class="title function_">getShape</span><span class="params">(String shapeType)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(shapeType == <span class="literal">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;        </span><br><span class="line">      <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;CIRCLE&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;RECTANGLE&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;SQUARE&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Square</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用、</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryPatternDemo</span> &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">ShapeFactory</span> <span class="variable">shapeFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShapeFactory</span>();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取 Circle 的对象，并调用它的 draw 方法</span></span><br><span class="line">      <span class="type">Shape</span> <span class="variable">shape1</span> <span class="operator">=</span> shapeFactory.getShape(<span class="string">&quot;CIRCLE&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Circle 的 draw 方法</span></span><br><span class="line">      shape1.draw();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取 Rectangle 的对象，并调用它的 draw 方法</span></span><br><span class="line">      <span class="type">Shape</span> <span class="variable">shape2</span> <span class="operator">=</span> shapeFactory.getShape(<span class="string">&quot;RECTANGLE&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Rectangle 的 draw 方法</span></span><br><span class="line">      shape2.draw();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取 Square 的对象，并调用它的 draw 方法</span></span><br><span class="line">      <span class="type">Shape</span> <span class="variable">shape3</span> <span class="operator">=</span> shapeFactory.getShape(<span class="string">&quot;SQUARE&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Square 的 draw 方法</span></span><br><span class="line">      shape3.draw();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Spring中的工厂方法模式"><a href="#Spring中的工厂方法模式" class="headerlink" title="Spring中的工厂方法模式"></a>Spring中的工厂方法模式</h1><p>Spring使用工厂模式可以通过 <code>BeanFactory</code> 或 <code>ApplicationContext</code> 创建 bean 对象。</p><p><strong>两者对比：</strong></p><ul><li>BeanFactory：延迟注入(使用到某个 bean 的时候才会注入),相比于ApplicationContext 来说会占用更少的内存，程序启动速度更快。</li><li>ApplicationContext ：容器启动的时候，不管你用没用到，一次性创建所有 bean 。BeanFactory仅提供了最基本的依赖注入支持，ApplicationContext 扩展了 BeanFactory,除了有BeanFactory的功能还有额外更多功能，所以一般开发人员使用ApplicationContext会更多。</li></ul><p>ApplicationContext的三个实现类：</p><ol><li>ClassPathXmlApplication：把上下文文件当成类路径资源。</li><li>FileSystemXmlApplication：从文件系统中的 XML 文件载入上下文定义信息。</li><li>XmlWebApplicationContext：从Web系统中的XML文件载入上下文定义信息。</li></ol><p>BeanFactory 和 FactoryBean 的区别是什么？</p><p>BeanFactory 是一个大工厂，是IOC容器的根基，有繁琐的 bean 生命周期处理过程，可以生成出各种各样的 Bean<br>FactoryBean 是一个小工厂，它自己也是一个 Bean ，但是可以生成其他 Bean</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 静态工厂模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>适配器模式</title>
      <link href="/2022/07/11/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/07/11/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>​用于填补现有的程序和所需的程序之间差异的设计模式就是Adapter模式。主要解决在软件系统中，常常要将一些”现存的对象”放到新的环境中，而新环境要求的接口是现对象不能满足的。</p><p>​比如是有个A，A要去用B的方法，但是不能直接用，所以通过一个适配器，A 用适配器，适配器用 B。</p><p>​主要方式是：适配器继承或依赖已有的对象，实现想要的目标接口。</p><p>​优点：1.可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。</p><p>​缺点：过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况， 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。</p><span id="more"></span><p>主要角色：</p><ol><li>被适配类：此类因为种种原因不能使用，如类的参数不匹配等。</li><li>适配类，将不能使用的方法进行适配，转化为可以使用的方法来给其他类使用。</li><li>目标类：适配好之后可以交给此类使用。</li></ol><h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><h2 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h2><p>Adapter 类通过继承 src 类，实现 dst 类接口，完成 src-&gt;dst 的适配。如将220v交流电（被适配者）转换成（适配器）5v直流电（目标）</p><p>使用者：传入5v电压的实例判断可不可以充电</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nemo.adapter.classadapter;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="comment">//充电</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">charging</span><span class="params">(IVoltage5V iVoltage5V)</span> &#123; </span><br><span class="line">        <span class="keyword">if</span>(iVoltage5V.output5V() == <span class="number">5</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;电压为 5V, 可以充电~~&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iVoltage5V.output5V() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;电压大于 5V, 不能充电~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目标接口：5v</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nemo.adapter.classadapter;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//适配接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IVoltage5V</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">output5V</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被适配类：220v电压</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nemo.adapter.classadapter;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//被适配的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Voltage220V</span> &#123;</span><br><span class="line">    <span class="comment">//输出 220V 的电压</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">output220V</span><span class="params">()</span> &#123; <span class="type">int</span> <span class="variable">src</span> <span class="operator">=</span> <span class="number">220</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;电压=&quot;</span> + src + <span class="string">&quot;伏&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> src;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>适配器类：继承被适配类实现目标接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nemo.adapter.classadapter;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//适配器类</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VoltageAdapter</span> <span class="keyword">extends</span> <span class="title class_">Voltage220V</span> <span class="keyword">implements</span> <span class="title class_">IVoltage5V</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">output5V</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="comment">//获取到 220V 电压</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">srcV</span> <span class="operator">=</span> output220V();</span><br><span class="line">        <span class="type">int</span> <span class="variable">dstV</span> <span class="operator">=</span> srcV / <span class="number">44</span> ; <span class="comment">//转成 5v </span></span><br><span class="line">        <span class="keyword">return</span> dstV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nemo.adapter.classadapter;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub </span></span><br><span class="line">        System.out.println(<span class="string">&quot; === 类适配器模式 ====&quot;</span>); </span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        phone.charging(<span class="keyword">new</span> <span class="title class_">VoltageAdapter</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项：</p><ol><li>Java 是单继承机制，所以类适配器需要继承 src 类这一点算是一个缺点, 因为这要求 dst 必须是接口，有一定局限性;</li><li>src 类的方法在 Adapter 中都会暴露出来，也增加了使用的成本。</li><li>由于其继承了 src 类，所以它可以根据需求重写 src 类的方法，使得 Adapter 的灵活性增强了。1.</li></ol><h2 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h2><p>​与上面不同的是，Adapter 类不是继承 src 类，而是持有 src 类的实例，以解决兼容性的问题。 即：持有 src 类，实现 dst 类接口，完成 src-&gt;dst 的适配。</p><p>上述代码需要修改的只有适配器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nemo.adapter.objectadapter;</span><br><span class="line"> <span class="comment">//适配器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VoltageAdapter</span> <span class="keyword">implements</span> <span class="title class_">IVoltage5V</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Voltage220V voltage220V; <span class="comment">// 关联关系-聚合</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//通过构造器，传入一个 Voltage220V 实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VoltageAdapter</span><span class="params">(Voltage220V voltage220v)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.voltage220V = voltage220v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">output5V</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">dst</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span> != voltage220V) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">src</span> <span class="operator">=</span> voltage220V.output220V();<span class="comment">//获取 220V 电压</span></span><br><span class="line">            System.out.println(<span class="string">&quot;使用对象适配器，进行适配~~&quot;</span>); </span><br><span class="line">            dst = src / <span class="number">44</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;适配完成，输出的电压为=&quot;</span> + dst);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项：</p><ol><li>对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。根据合成复用原则，使用组合替代继承， 所以它解决了类适配器必须继承 src 的局限性问题，也不再要求 dst 必须是接口。</li><li>使用成本更低，更灵活。</li></ol><h2 id="接口适配器（缺省适配器模式）"><a href="#接口适配器（缺省适配器模式）" class="headerlink" title="接口适配器（缺省适配器模式）"></a>接口适配器（缺省适配器模式）</h2><p>​核心思路：当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求</p><p>​适用于一个接口不想使用其所有的方法的情况。</p><p>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nemo.adapter.interfaceadapter;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Interface4</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span>; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>适配器实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nemo.adapter.interfaceadapter;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//在 AbsAdapter 我们将 Interface4 的方法进行默认实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbsAdapter</span> <span class="keyword">implements</span> <span class="title class_">Interface4</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//默认实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nemo.adapter.interfaceadapter;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//使用匿名内部类将抽象类实例化</span></span><br><span class="line">        <span class="type">AbsAdapter</span> <span class="variable">absAdapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AbsAdapter</span>() &#123;</span><br><span class="line">            <span class="comment">//只需要去覆盖我们 需要使用 接口方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">                System.out.println(<span class="string">&quot;使用了 m1 的方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        absAdapter.m1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="适配器模式在-SpringMVC-框架应用的源码"><a href="#适配器模式在-SpringMVC-框架应用的源码" class="headerlink" title="适配器模式在 SpringMVC 框架应用的源码"></a>适配器模式在 SpringMVC 框架应用的源码</h1><p>​SpringMvc 中的 HandlerAdapter, 就使用了适配器模式</p><p>​使用 HandlerAdapter 的原因分析:可以看到处理器的类型不同，有多重实现方式，那么调用方式就不是确定的，如果需要直接调用 Controller 方法，需要调用的时候就得不断是使用 if else 来进行判断是哪一种子类然后执行。那么如果后面要扩展 Controller， 就得修改原来的代码，这样违背了 OCP 原则。</p><p>​springmvc 源码在 controller 拿到的情况下不能直接调用方法，是因为每个 controller 的处理方法名称不同，所以采用适配器能够统一调用不同 controller 的目标方法</p><p>​获取 controller → 得到相应适配器 → 利用适配器使用controller的对应方法最后完成相应的功能<br>​controller 适配 相应功能,系统需要使用现有的类，而此类的接口不符合系统的需要。因为方法名不一样，系统不能调用类的方法。所以需要适配器，使用适配器来将方法名统一，好提供给系统使用。</p><p>参考：<a href="https://www.cnblogs.com/blknemo/p/13257966.html">https://www.cnblogs.com/blknemo/p/13257966.html</a></p><p><a href="https://blog.csdn.net/u010288264/article/details/53835185">(22条消息) 从SpringMVC来看适配器模式__PPB的博客-CSDN博客_springmvc 适配器模式</a></p><p><a href="https://cloud.tencent.com/developer/article/1701955">适配器模式与SpringMVC - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 适配器模式 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态代理</title>
      <link href="/2022/07/03/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
      <url>/2022/07/03/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><p>​所谓静态代理，就是通过声明一个明确的代理类来访问源对象，例如我们有2个接口，Person和Animal。每个接口各有2个实现类，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wakeup</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(StrUtil.format(<span class="string">&quot;学生[&#123;&#125;]早晨醒来啦&quot;</span>,name));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(StrUtil.format(<span class="string">&quot;学生[&#123;&#125;]晚上睡觉啦&quot;</span>,name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><p>​假设我们现在要做一件事，就是在所有的实现类调用<code>wakeup()</code>前增加一行输出<code>早安~</code>，调用<code>sleep()</code>前增加一行输出<code>晚安~</code>。那我们只需要编写2个代理类<code>PersonProxy</code>和<code>AnimalProxy</code>：</p><p><strong>PersonProxy:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonProxy</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PersonProxy</span><span class="params">(Person person)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.person = person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wakeup</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;早安~&quot;</span>);</span><br><span class="line">        person.wakeup();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;晚安~&quot;</span>);</span><br><span class="line">        person.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AnimalProxy:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnimalProxy</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Animal animal;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AnimalProxy</span><span class="params">(Animal animal)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.animal = animal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wakeup</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;早安~&quot;</span>);</span><br><span class="line">        animal.wakeup();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;晚安~&quot;</span>);</span><br><span class="line">        animal.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最终执行代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    <span class="type">PersonProxy</span> <span class="variable">studentProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PersonProxy</span>(student);</span><br><span class="line">    studentProxy.wakeup();</span><br><span class="line">    studentProxy.sleep();</span><br><span class="line"></span><br><span class="line">    <span class="type">Person</span> <span class="variable">doctor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Doctor</span>(<span class="string">&quot;王教授&quot;</span>);</span><br><span class="line">    <span class="type">PersonProxy</span> <span class="variable">doctorProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PersonProxy</span>(doctor);</span><br><span class="line">    doctorProxy.wakeup();</span><br><span class="line">    doctorProxy.sleep();</span><br><span class="line"></span><br><span class="line">    <span class="type">Animal</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;旺旺&quot;</span>);</span><br><span class="line">    <span class="type">AnimalProxy</span> <span class="variable">dogProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnimalProxy</span>(dog);</span><br><span class="line">    dogProxy.wakeup();</span><br><span class="line">    dogProxy.sleep();</span><br><span class="line"></span><br><span class="line">    <span class="type">Animal</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;咪咪&quot;</span>);</span><br><span class="line">    <span class="type">AnimalProxy</span> <span class="variable">catProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnimalProxy</span>(cat);</span><br><span class="line">    catProxy.wakeup();</span><br><span class="line">    catProxy.sleep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Interface</span> &#123; </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">somethingElse</span><span class="params">(String arg)</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实际类（实现接口）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealObject</span> <span class="keyword">implements</span> <span class="title class_">Interface</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doSomething&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">somethingElse</span><span class="params">(String arg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;somethingElse &quot;</span> + arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理类 （传入实现接口）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleProxy</span> <span class="keyword">implements</span> <span class="title class_">Interface</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Interface proxied;</span><br><span class="line">    <span class="comment">// 传入真实对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleProxy</span><span class="params">(Interface proxied)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.proxied = proxied;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SimpleProxy doSomething&quot;</span>);</span><br><span class="line">        proxied.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">somethingElse</span><span class="params">(String arg)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SimpleProxy somethingElse &quot;</span> + arg);</span><br><span class="line">        proxied.somethingElse(arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleProxyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">(Interface iface)</span> &#123;</span><br><span class="line">        iface.doSomething();</span><br><span class="line">        iface.somethingElse(<span class="string">&quot;bonobo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        consumer(<span class="keyword">new</span> <span class="title class_">RealObject</span>());</span><br><span class="line">        consumer(<span class="keyword">new</span> <span class="title class_">SimpleProxy</span>(<span class="keyword">new</span> <span class="title class_">RealObject</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">doSomething</span></span><br><span class="line"><span class="comment">somethingElse bonobo</span></span><br><span class="line"><span class="comment">SimpleProxy doSomething</span></span><br><span class="line"><span class="comment">doSomething</span></span><br><span class="line"><span class="comment">SimpleProxy somethingElse bonobo</span></span><br><span class="line"><span class="comment">somethingElse bonobo</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure><p>​因为 consumer()接受的是Interface，所以它无法知道正在获得的到底是RealObject还是SimpleProxy，因为这二者都实现了 Interface。但是 SimpleProxy已经被插入到了客户端和RealObject之间，因此它会执行操作，然后调用RealObject上相同的方法在任何时刻，只要你想要将额外的操作从“实际”对象中分离到不同的地方，特别是当你希望能够很容易地做出修改，从没有使用额外操作转为使用这些操作，或者反过来时，代理就显得很有用（设计模式的关键就是封装修改一因此你需要修改事务以证明这种模式的正确性）。</p><h2 id="静态代理结论"><a href="#静态代理结论" class="headerlink" title="静态代理结论"></a>静态代理结论</h2><p>这种模式虽然好理解，但是缺点也很明显：</p><ul><li>会存在大量的冗余的代理类，这里演示了2个接口，如果有10个接口，就必须定义10个代理类。</li><li>不易维护，一旦接口更改，代理类和目标类都需要更改。</li></ul><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>​代理是基本的设计模式之一，它是你为了提供额外的或不同的操作，而插入的用来代替“实际”对象的对象。这些操作通常涉及与“实际”对象的通信，因此代理通常充当着中间人的角色，能够使得在不修改源目标的前提下，额外扩展源目标的功能。即通过访问源目标的代理类，再由代理类去访问源目标。这样一来，要扩展功能，就无需修改源目标的代码了。只需要在代理类上增加就可以了。<strong>动态代理也是spring aop的核心思想，spring其他很多功能也是通过动态代理来实现的，比如拦截器，事务控制等。</strong></p><p>​动态代理，通俗点说就是：无需声明式的创建java代理类，而是在运行过程中生成”虚拟”的代理类，被ClassLoader加载。从而避免了静态代理那样需要声明大量的代理类。主要核心类只有2个：<code>java.lang.reflect.Proxy</code>和<code>java.lang.reflect.InvocationHandler</code>。</p><p><img src="1.jpg" alt="1"></p><p>动态代理的好处：</p><p>​可以使得我们的真实角色更加纯粹 . </p><p>​不再去关注一些公共的事情 . 公共的业务由代理来完成 . </p><p>​实现了业务的分工 , 公共业务发生扩展时变得更加集中和方便 . </p><p>​一个动态代理 , 一般代理某一类业务</p><p>​ 一个动态代理可以代理多个类，代理的是接口！也就是可以通过多个接口来代理类</p><p>下面是一个用来展示<strong>静态代理</strong>结构的简单示例：</p><p>Java<strong>动态代理</strong>比静态代理的思想更向前迈进了一步，因为它可以<strong>动态地创建代理并动态地处理对所代理方法的调用。动态代理的代理类是动态生成的 ，静态代理的代理类是我们提前写好的</strong>在动态代理上所做的所有调用都会被重定向到单一的调用处理器上，它的工作是揭示调用的类型并确定相应的对策。下面是用动态代理重写的 SimpleProxyDemo.java：</p><h2 id="JDk动态代理"><a href="#JDk动态代理" class="headerlink" title="JDk动态代理"></a>JDk动态代理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Interface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">somethingElse</span><span class="params">(String arg)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealObject</span> <span class="keyword">implements</span> <span class="title class_">Interface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doSomething&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">somethingElse</span><span class="params">(String arg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;somethingElse &quot;</span> + arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//**提供的方法增强，可以在真实对象的方法前或者是方法后进行数据增强**proxied指的是被代理的对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DynamicProxyHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object proxied;  <span class="comment">//这个是要传入的真实对象也就是被代理的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DynamicProxyHandler</span><span class="params">(Object proxied)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.proxied = proxied;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//proxy是真实对象的代理对象，也就是调度者，客户通过proxy去访问真实对象的方法，与下文的proxy类型相同</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 调用proxy.toString()方法来打印代理对象将会陷入死循环</span></span><br><span class="line">        <span class="comment">// 在invoke()内部进入无限循环，并最终崩溃(java.lang.StackOverflowError)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;**** proxy: &quot;</span> + proxy.getClass() + <span class="string">&quot;, method: &quot;</span> + method + <span class="string">&quot;, args: &quot;</span> + args);</span><br><span class="line">        <span class="keyword">if</span>(args != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">for</span>(Object arg : args)</span><br><span class="line">                System.out.println(<span class="string">&quot; &quot;</span> + arg);</span><br><span class="line">        <span class="comment">//在这里调用方法 method就是真实类提供的方法，proxied是真实对象，args是要传入真实对象的参数</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(proxied, args);</span><br><span class="line">        <span class="comment">//这里可以对执行方法后进行操作处理。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E22_SimpleDynamicProxyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">(Interface iface)</span> &#123;</span><br><span class="line">        iface.doSomething();</span><br><span class="line">        iface.somethingElse(<span class="string">&quot;bonobo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RealObject</span> <span class="variable">real</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealObject</span>();</span><br><span class="line">        consumer(real);</span><br><span class="line">        <span class="comment">// 插入代理再调用一遍</span></span><br><span class="line">        <span class="comment">// 通过调用静态方法 Proxy.newProxyInstance可以创建动态代理，这个方法需要:</span></span><br><span class="line">        <span class="comment">// 1.一个类加载器（你通常可以从已经被加载的对象中获取其类加载器，然后传递给它）</span></span><br><span class="line">        <span class="comment">// 2.一个你希望该代理实现的接口列表（不是类或抽象类）</span></span><br><span class="line">        <span class="comment">// 3.以及InvocationHandler接口的一个实现</span></span><br><span class="line">        <span class="type">Interface</span> <span class="variable">proxy</span> <span class="operator">=</span> (Interface)Proxy.newProxyInstance( <span class="comment">//动态创建代理实例</span></span><br><span class="line">                Interface.class.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123; Interface.class &#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">DynamicProxyHandler</span>(real));</span><br><span class="line">        consumer(proxy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">/*Output:</span></span><br><span class="line"><span class="comment">doSomething</span></span><br><span class="line"><span class="comment">somethingElse bonobo</span></span><br><span class="line"><span class="comment">**** proxy: class chapter14.exercise22.$Proxy0, method: public abstract void chapter14.exercise22.Interface.doSomething(), args: null</span></span><br><span class="line"><span class="comment">doSomething</span></span><br><span class="line"><span class="comment">**** proxy: class chapter14.exercise22.$Proxy0, method: public abstract void chapter14.exercise22.Interface.somethingElse(java.lang.String), args: [Ljava.lang.Object;@2503dbd3</span></span><br><span class="line"><span class="comment"> bonobo</span></span><br><span class="line"><span class="comment">somethingElse bonobo</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>还是前面那个例子，用JDK动态代理类去实现的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"><span class="comment">//传入的真实的被代理的对象</span></span><br><span class="line">    <span class="keyword">private</span> Object bean;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JdkProxy</span><span class="params">(Object bean)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bean = bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> method.getName();</span><br><span class="line">        <span class="keyword">if</span> (methodName.equals(<span class="string">&quot;wakeup&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;早安~~~&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(methodName.equals(<span class="string">&quot;sleep&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;晚安~~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> method.invoke(bean, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">JdkProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdkProxy</span>(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>));</span><br><span class="line">    <span class="type">Person</span> <span class="variable">student</span> <span class="operator">=</span> (Person) Proxy.newProxyInstance(proxy.getClass().getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Person.class&#125;, proxy);</span><br><span class="line">    student.wakeup();</span><br><span class="line">    student.sleep();</span><br><span class="line"></span><br><span class="line">    proxy = <span class="keyword">new</span> <span class="title class_">JdkProxy</span>(<span class="keyword">new</span> <span class="title class_">Doctor</span>(<span class="string">&quot;王教授&quot;</span>));</span><br><span class="line">    <span class="type">Person</span> <span class="variable">doctor</span> <span class="operator">=</span> (Person) Proxy.newProxyInstance(proxy.getClass().getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Person.class&#125;, proxy);</span><br><span class="line">    doctor.wakeup();</span><br><span class="line">    doctor.sleep();</span><br><span class="line"></span><br><span class="line">    proxy = <span class="keyword">new</span> <span class="title class_">JdkProxy</span>(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;旺旺&quot;</span>));</span><br><span class="line">    <span class="type">Animal</span> <span class="variable">dog</span> <span class="operator">=</span> (Animal) Proxy.newProxyInstance(proxy.getClass().getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Animal.class&#125;, proxy);</span><br><span class="line">    dog.wakeup();</span><br><span class="line">    dog.sleep();</span><br><span class="line"></span><br><span class="line">    proxy = <span class="keyword">new</span> <span class="title class_">JdkProxy</span>(<span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;咪咪&quot;</span>));</span><br><span class="line">    <span class="type">Animal</span> <span class="variable">cat</span> <span class="operator">=</span> (Animal) Proxy.newProxyInstance(proxy.getClass().getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Animal.class&#125;, proxy);</span><br><span class="line">    cat.wakeup();</span><br><span class="line">    cat.sleep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，相对于静态代理类来说，无论有多少接口，这里只需要一个代理类。核心代码也很简单。唯一需要注意的点有以下2点：</p><ul><li>JDK动态代理是需要声明接口的，创建一个动态代理类必须得给这个”虚拟“的类一个接口。可以看到，这时候经动态代理类创造之后的每个bean已经不是原来那个对象了。</li></ul><p><img src="2.jpg" alt="1"></p><ul><li>为什么这里<code>JdkProxy</code>还需要构造传入原有的bean呢？因为处理完附加的功能外，需要执行原有bean的方法，以完成<code>代理</code>的职责。</li></ul><p>这里<code>JdkProxy</code>最核心的方法就是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span><br></pre></td></tr></table></figure><p>其中proxy为代理过之后的对象(并不是原对象)，method为被代理的方法，args为方法的参数。如果你不传原有的bean，直接用<code>method.invoke(proxy, args)</code>的话，那么就会陷入一个死循环。</p><p><strong>可以代理什么</strong></p><p>​JDK的动态代理是也平时大家使用的最多的一种代理方式。也叫做接口代理。前几天有一个小伙伴在群里问我，动态代理是否一次可以代理多个类。</p><p>JDK动态代理说白了只是根据接口”凭空“来生成类，至于具体的执行，都被代理到了<code>InvocationHandler</code> 的实现类里。上述例子我是需要继续执行原有bean的逻辑，才将原有的bean构造进来。只要你需要，你可以构造进任何对象到这个代理实现类。也就是说，你可以传入多个对象，或者说你什么类都不代理。只是为某一个接口”凭空“的生成多个代理实例，这多个代理实例最终都会进入<code>InvocationHandler</code>的实现类来执行某一个段共同的代码。</p><p>所以，在以往的项目中的一个实际场景就是，我有多个以yaml定义的规则文件，通过对yaml文件的扫描，来为每个yaml规则文件生成一个动态代理类。而实现这个，我只需要事先定义一个接口，和定义<code>InvocationHandler</code>的实现类就可以了，同时把yaml解析过的对象传入。最终这些动态代理类都会进入<code>invoke</code>方法来执行某个共同的逻辑。</p><h2 id="Cglib动态代理"><a href="#Cglib动态代理" class="headerlink" title="Cglib动态代理"></a>Cglib动态代理</h2><p>​Spring在5.X之前默认的动态代理实现一直是jdk动态代理。但是从5.X开始，spring就开始默认使用Cglib来作为动态代理实现。并且springboot从2.X开始也转向了Cglib动态代理实现。</p><p>​Cglib是一个开源项目，它的底层是字节码处理框架ASM，Cglib提供了比jdk更为强大的动态代理。主要相比jdk动态代理的优势有：</p><ul><li>jdk动态代理只能基于接口，代理生成的对象只能赋值给接口变量，而Cglib就不存在这个问题，Cglib是通过生成子类来实现的，代理对象既可以赋值给实现类，又可以赋值给接口。</li><li>Cglib速度比jdk动态代理更快，性能更好。</li></ul><p><strong>创建CglibProxy类，用于统一代理：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxy</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object bean;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CglibProxy</span><span class="params">(Object bean)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bean = bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//设置需要创建子类的类</span></span><br><span class="line">        enhancer.setSuperclass(bean.getClass());</span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//通过字节码技术动态创建子类实例</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//实现MethodInterceptor接口方法</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> method.getName();</span><br><span class="line">        <span class="keyword">if</span> (methodName.equals(<span class="string">&quot;wakeup&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;早安~~~&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(methodName.equals(<span class="string">&quot;sleep&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;晚安~~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用原bean的方法</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(bean,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">CglibProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CglibProxy</span>(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>));</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) proxy.getProxy();</span><br><span class="line">    student.wakeup();</span><br><span class="line">    student.sleep();</span><br><span class="line"></span><br><span class="line">    proxy = <span class="keyword">new</span> <span class="title class_">CglibProxy</span>(<span class="keyword">new</span> <span class="title class_">Doctor</span>(<span class="string">&quot;王教授&quot;</span>));</span><br><span class="line">    <span class="type">Doctor</span> <span class="variable">doctor</span> <span class="operator">=</span> (Doctor) proxy.getProxy();</span><br><span class="line">    doctor.wakeup();</span><br><span class="line">    doctor.sleep();</span><br><span class="line"></span><br><span class="line">    proxy = <span class="keyword">new</span> <span class="title class_">CglibProxy</span>(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;旺旺&quot;</span>));</span><br><span class="line">    <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) proxy.getProxy();</span><br><span class="line">    dog.wakeup();</span><br><span class="line">    dog.sleep();</span><br><span class="line"></span><br><span class="line">    proxy = <span class="keyword">new</span> <span class="title class_">CglibProxy</span>(<span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;咪咪&quot;</span>));</span><br><span class="line">    <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> (Cat) proxy.getProxy();</span><br><span class="line">    cat.wakeup();</span><br><span class="line">    cat.sleep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里用Cglib作为代理，其思路和jdk动态代理差不多。也需要把原始bean构造传入。</p><p>关键的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置需要创建子类的类</span></span><br><span class="line">enhancer.setSuperclass(bean.getClass());</span><br><span class="line">enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line"><span class="comment">//通过字节码技术动态创建子类实例</span></span><br><span class="line"><span class="keyword">return</span> enhancer.create();</span><br></pre></td></tr></table></figure><p>​可以看到，Cglib”凭空”的创造了一个原bean的子类，并把Callback指向了this，也就是当前对象，也就是这个proxy对象。从而会调用<code>intercept</code>方法。而在<code>intercept</code>方法里，进行了附加功能的执行，最后还是调用了原始bean的相应方法。</p><h2 id="javassist动态代理"><a href="#javassist动态代理" class="headerlink" title="javassist动态代理"></a>javassist动态代理</h2><p>​Javassist是一个开源的分析、编辑和创建Java字节码的类库，可以直接编辑和生成Java生成的字节码。相对于bcel, asm等这些工具，开发者不需要了解虚拟机指令，就能动态改变类的结构，或者动态生成类。在日常使用中，javassit通常被用来动态修改字节码。它也能用来实现动态代理的功能。还是一样的例子，我用javassist动态代理来实现一遍</p><p><strong>创建JavassitProxy，用作统一代理：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavassitProxy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object bean;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JavassitProxy</span><span class="params">(Object bean)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bean = bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">()</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException &#123;</span><br><span class="line">        <span class="type">ProxyFactory</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">        f.setSuperclass(bean.getClass());</span><br><span class="line">        f.setFilter(m -&gt; ListUtil.toList(<span class="string">&quot;wakeup&quot;</span>,<span class="string">&quot;sleep&quot;</span>).contains(m.getName()));</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> f.createClass();</span><br><span class="line">        <span class="type">MethodHandler</span> <span class="variable">mi</span> <span class="operator">=</span> (self, method, proceed, args) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> method.getName();</span><br><span class="line">            <span class="keyword">if</span> (methodName.equals(<span class="string">&quot;wakeup&quot;</span>))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;早安~~~&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(methodName.equals(<span class="string">&quot;sleep&quot;</span>))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;晚安~~~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(bean, args);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> c.newInstance();</span><br><span class="line">        ((Proxy)proxy).setHandler(mi);</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="type">JavassitProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JavassitProxy</span>(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>));</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) proxy.getProxy();</span><br><span class="line">    student.wakeup();</span><br><span class="line">    student.sleep();</span><br><span class="line"></span><br><span class="line">    proxy = <span class="keyword">new</span> <span class="title class_">JavassitProxy</span>(<span class="keyword">new</span> <span class="title class_">Doctor</span>(<span class="string">&quot;王教授&quot;</span>));</span><br><span class="line">    <span class="type">Doctor</span> <span class="variable">doctor</span> <span class="operator">=</span> (Doctor) proxy.getProxy();</span><br><span class="line">    doctor.wakeup();</span><br><span class="line">    doctor.sleep();</span><br><span class="line"></span><br><span class="line">    proxy = <span class="keyword">new</span> <span class="title class_">JavassitProxy</span>(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;旺旺&quot;</span>));</span><br><span class="line">    <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) proxy.getProxy();</span><br><span class="line">    dog.wakeup();</span><br><span class="line">    dog.sleep();</span><br><span class="line"></span><br><span class="line">    proxy = <span class="keyword">new</span> <span class="title class_">JavassitProxy</span>(<span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;咪咪&quot;</span>));</span><br><span class="line">    <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> (Cat) proxy.getProxy();</span><br><span class="line">    cat.wakeup();</span><br><span class="line">    cat.sleep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​大致思路也是类似的。同样把原始bean构造传入。可以看到，javassist也是用”凭空“生成子类的方式类来解决，代码的最后也是调用了原始bean的目标方法完成代理。</p><p>​javaassit比较有特点的是，可以对所需要代理的方法用filter来设定，里面可以像Criteria构造器那样进行构造。</p><p><a href="https://blog.csdn.net/qq_45058208/article/details/126554234">参考：</a></p><p><a href="https://blog.csdn.net/weixin_39825906/article/details/126099743">参考</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写RPC</title>
      <link href="/2022/07/01/%E6%89%8B%E5%86%99RPC/"/>
      <url>/2022/07/01/%E6%89%8B%E5%86%99RPC/</url>
      
        <content type="html"><![CDATA[<h1 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h1><p>​将请求对象序列化成字节码，并且压缩体积之后，需要使用网络将字节码传输到服务器。常用网络传输协议有 HTTP 、 TCP 、 WebSocke t等。HTTP、WebSocket 是应用层协议，TCP 是传输层协议。有些追求简洁、易用的 RPC 框架也有选择 HTTP 协议的。TCP传输的高可靠性和极致性能是主流RPC框架选择的最主要原因。谈到 Java 生态的通信领域，<code>Netty </code>的领衔地位短时间内无人能及。选用 Netty 作为网络通信模块， TCP 数据流的粘包、拆包不可避免。</p><p>粘包、拆包</p><p>​TCP 传输协议是一种面向连接的、可靠的、基于字节流的传输层通信协议。为了最大化传输效率。发送方可能将单个较小数据包合并发送，这种情况就需要接收方来拆包处理数据了。</p><p>Netty 提供了3种类型的解码器来处理 TCP 粘包&#x2F;拆包问题：</p><ul><li>定长消息解码器：<code>FixedLengthFrameDecoder</code> 。发送方和接收方规定一个固定的消息长度，不够用空格等字符补全，这样接收方每次从接受到的字节流中读取固定长度的字节即可，长度不够就保留本次接受的数据，再在下一个字节流中获取剩下数量的字节数据。</li><li>分隔符解码器：<code>LineBasedFrameDecoder</code> 或 <code>DelimiterBasedFrameDecoder</code>。<code>LineBasedFrameDecoder </code>是行分隔符解码器，分隔符为 <code>\n</code> 或 <code>\r\n</code> ； <code>DelimiterBasedFrameDecoder</code> 是自定义分隔符解码器，可以定义一个或多个分隔符。接收端在收到的字节流中查找分隔符，然后返回分隔符之前的数据，没找到就继续从下一个字节流中查找。</li><li>数据长度解码器：<code>LengthFieldBasedFrameDecoder</code>。将发送的消息分为 header 和 body，header 存储消息的长度（字节数），body 是发送的消息的内容。同时发送方和接收方要协商好这个 header 的字节数，因为 int 能表示长度，long 也能表示长度。接收方首先从字节流中读取前n（header的字节数）个字节（header），然后根据长度读取等量的字节，不够就从下一个数据流中查找。</li></ul><p>不想使用内置的解码器也可自定义解码器，自定传输协议。</p>]]></content>
      
      
      <categories>
          
          <category> TODO </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ArrayDeque和LinkedList添加null元素</title>
      <link href="/2022/06/28/ArrayDeque%E5%92%8CLinkedList%E6%B7%BB%E5%8A%A0null%E5%85%83%E7%B4%A0/"/>
      <url>/2022/06/28/ArrayDeque%E5%92%8CLinkedList%E6%B7%BB%E5%8A%A0null%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="异常场景"><a href="#异常场景" class="headerlink" title="异常场景"></a>异常场景</h1><p>​ 力扣102二叉树的层序遍历中，需要向队列中插入null元素，在队列的操作中，ArrayDeque内部通过数组+双索引的方式，使用&amp;操作来定位对于元素的存放删除，LinkedList内部以链表的形式来保存集合中的元素，ArrayList明显快于LinkedList，所以我一直使用ArrayDeque作为队列的数据结构使用（栈相反），在插入null元素时 ArrayDeque报了空指针异常，而LinkedList则没有异常抛出。</p><h1 id="ArrayDeque的offer源码"><a href="#ArrayDeque的offer源码" class="headerlink" title="ArrayDeque的offer源码"></a>ArrayDeque的offer源码</h1><p><img src="1.jpg" alt="1"></p><span id="more"></span><p><img src="2.jpg" alt="1"></p><p>点入offer方法进入源码，发现ArrayDeque的offer()方法等效于addLast()方法，源码显示在插入元素时，会首先判断该元素是否为null，如果为null，则抛出NullPointerException</p><p><img src="3.jpg" alt="1"></p><h1 id="LinkedList的offer-方法源码："><a href="#LinkedList的offer-方法源码：" class="headerlink" title="LinkedList的offer()方法源码："></a>LinkedList的offer()方法源码：</h1><p><img src="5.jpg" alt="1"></p><p><img src="4.jpg" alt="1"></p><p>可以看出LinkedList的offer()方法等效于linkedLast()方法，该方法中并未进行是否为null的判断</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>如果遇到需要添加null的队列时，使用LinkedList，或者使用ArrayDeque时进行判断，如果为null则不添加。</p><h1 id="Queue的常用方法："><a href="#Queue的常用方法：" class="headerlink" title="Queue的常用方法："></a>Queue的常用方法：</h1><p><img src="6.jpg" alt="1"></p><p>add 增加一个元索 如果队列已满，则抛出一个IIIegaISlabEepeplian异常<br> remove 移除并返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常<br> element 返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常<br> offer 添加一个元素并返回true 如果队列已满，则返回false<br> poll 移除并返问队列头部的元素 如果队列为空，则返回null<br> peek 返回队列头部的元素 如果队列为空，则返回null<br> put 添加一个元素 如果队列满，则阻塞<br> take 移除并返回队列头部的元素</p><h2 id="1、add-和offer-区别"><a href="#1、add-和offer-区别" class="headerlink" title="1、add()和offer()区别:"></a>1、add()和offer()区别:</h2><p>​add()和offer()都是向<a href="https://so.csdn.net/so/search?q=%E9%98%9F%E5%88%97&spm=1001.2101.3001.7020">队列</a>中添加一个元素。一些队列有大小限制，因此如果想在一个满的队列中加入一个新项，调用 add() 方法就会抛出一个 unchecked 异常，而调用 offer() 方法会返回 false。因此就可以在程序中进行有效的判断！</p><h2 id="2、poll-和remove-区别："><a href="#2、poll-和remove-区别：" class="headerlink" title="2、poll()和remove()区别："></a>2、poll()和remove()区别：</h2><p>​remove() 和 poll() 方法都是从队列中删除第一个元素。如果队列元素为空，调用remove() 的行为与 Collection 接口的版本相似会抛出异常，但是新的 poll() 方法在用空集合调用时只是返回 null。因此新的方法更适合容易出现异常条件的情况。</p><h2 id="3、element-和-peek-区别："><a href="#3、element-和-peek-区别：" class="headerlink" title="3、element() 和 peek() 区别："></a>3、element() 和 peek() 区别：</h2><p>​element() 和 peek() 用于在队列的头部查询元素。与 remove() 方法类似，在队列为空时， element() 抛出一个异常，而 peek() 返回 null。</p><h2 id="Deque常用方法："><a href="#Deque常用方法：" class="headerlink" title="Deque常用方法："></a>Deque常用方法：</h2><p>双端队列的addFirst是左进removeFirst左出，先进后出类似于栈</p><p>addLst是右进removeFirst左出，先进先出，正常队列</p><p>addFirst(): 向队头插入元素，如果元素为空，则发生NPE(空指针异常)<br>addLast(): 向队尾插入元素，如果为空，则发生NPE<br>offerFirst(): 向队头插入元素，如果插入成功返回true，否则返回false<br>offerLast(): 向队尾插入元素，如果插入成功返回true，否则返回false<br>removeFirst(): 返回并移除队头元素，如果该元素是null，则发生NoSuchElementException<br>removeLast(): 返回并移除队尾元素，如果该元素是null，则发生NoSuchElementException<br>pollFirst(): 返回并移除队头元素，如果队列无元素，则返回null<br>pollLast(): 返回并移除队尾元素，如果队列无元素，则返回null<br>getFirst(): 获取队头元素但不移除，如果队列无元素，则发生NoSuchElementException<br>getLast(): 获取队尾元素但不移除，如果队列无元素，则发生NoSuchElementException<br>peekFirst(): 获取队头元素但不移除，如果队列无元素，则返回null<br>peekLast(): 获取队尾元素但不移除，如果队列无元素，则返回null<br>pop(): 弹出栈中元素，也就是返回并移除队头元素，等价于removeFirst()，如果队列无元素，则发生NoSuchElementException<br>push(): 向栈中压入元素，也就是向队头增加元素，等价于addFirst()，如果元素为null，则发生NPE，如果栈空间受到限制，则发生IllegalStateException</p>]]></content>
      
      
      <categories>
          
          <category> Java容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内部类</title>
      <link href="/2022/06/26/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/2022/06/26/%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>​Java 类中不仅可以定义变量和方法，还可以定义类，这样定义在类内部的类就被称为内部类。根 据定义的方式不同，内部类分为静态内部类，成员内部类，局部内部类，匿名内部类四种。</p><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Out</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> a;</span><br><span class="line"> <span class="keyword">private</span> <span class="type">int</span> b;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code> 1. 静态内部类可以访问外部类所有的静态变量和方法，即使是 private 的也一样。  2. 静态内部类和一般类一致，可以定义静态变量、方法，构造方法等。  3. 其它类使用静态内部类需要使用“外部类.静态内部类”方式，如下所示：Out.Inner inner =  new Out.Inner();inner.print();  4.  Java集合类HashMap内部就有一个静态内部类Entry。Entry是HashMap存放元素的抽象， HashMap 内部维护 Entry 数组用来存放键值对元素，但是 Entry 对使用者是透明的。像这种和外部 类关系密切的，且不依赖外部类实例的，都可以使用静态内部类。</code></pre><span id="more"></span><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>​定义在类内部的非静态类，就是成员内部类。<strong>成员内部类不能定义静态方法和变量（final 修饰的 除外）</strong>。这是因为成员内部类是非静态的，类初始化的时候先初始化静态成员，如果允许成员内 部类定义静态变量，那么成员内部类的静态变量初始化顺序是有歧义的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Out</span> &#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> a;</span><br><span class="line">     <span class="keyword">private</span> <span class="type">int</span> b;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">             System.out.println(a);</span><br><span class="line">             System.out.println(b);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.成员内部类的创建需要依赖于外部类对象（成员方法必须通过对象调用），在没有外部类实例之前无法创建成员内部类对象</p><p>2.内部类与外部类相对独立，不是is a 的关系</p><p>3.私有属性的互相访问，内部类可以直接访问外部类，而外部类访问内部类需要内部类的对象来访问</p><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>​定义在方法中的类，就是局部类。如果一个类只在某个方法中使用，则可以考虑使用局部类。</p><ol><li>实现了某类型的接口，于是可以创建并返回对其的引用。</li><li>要解决一个复杂的问题，想创建一个类来辅助你的解决方案，但是又不希望这个类是公共可用的。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Out</span> &#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> a;</span><br><span class="line">     <span class="keyword">private</span> <span class="type">int</span> b;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> c)</span> &#123;</span><br><span class="line">         <span class="keyword">final</span> <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">             <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">             System.out.println(c);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义在方法内部：类比局部变量</p><p>1.对外部完全隐藏，因此方法内部类不能有任何访问修饰符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Destination</span> &#123;</span><br><span class="line">    String <span class="title function_">readLabel</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parcel5</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">public</span> Destination <span class="title function_">destination</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        i++;                <span class="comment">//可以访问且修改</span></span><br><span class="line">        &#123;</span><br><span class="line">            i++;            <span class="comment">//可以访问且修改</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">321</span>; </span><br><span class="line">            <span class="keyword">class</span> <span class="title class_">PDestination</span> <span class="keyword">implements</span> <span class="title class_">Destination</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i;     <span class="comment">//可以访问</span></span><br><span class="line">                <span class="comment">//! i++        //不可以修改</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> j;     <span class="comment">//可以访问</span></span><br><span class="line">                <span class="comment">//! j++        //不可以修改</span></span><br><span class="line">                <span class="keyword">private</span> String label;</span><br><span class="line">                <span class="keyword">private</span> <span class="title function_">PDestination</span><span class="params">(String whereTo)</span> &#123;</span><br><span class="line">                    label = whereTo;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">public</span> String <span class="title function_">readLabel</span><span class="params">()</span> &#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PDestination</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//! return new PDestination(s); //在作用域外就不可见</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Parcel5</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parcel5</span>();</span><br><span class="line">        <span class="type">Destination</span> <span class="variable">d</span> <span class="operator">=</span> p.destination(<span class="string">&quot;Wuhan&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PDestination 是destination()方法的一部分，而不是Parcel5的一部分，所以方法（当在作用域内即作用域）之外不能访问PDestination。</p><blockquote><p><strong>而且方法或者作用域内的内部类可以访问但不能修改内部类之外的变量</strong>。从内存中看，当方法里的局部变量所在方法结束时，该变量即在栈内存中消失；而内部类其实是一个类，只有内存中对它的所有引用都消失后，该内部类才”死亡”，即内部类的生命周期可能比局部变量长。如果局部内部类能访问一般的局部变量，则在多线程中，可能当方法结束后，局部内部类(是线程类时)还在使用局部变量。为了避免方法内的变量脱离方法而存在的现象发生，于是在jdk1.8之前java规定局部内部类不能访问一般的局部变量，但能访问被final修饰的局部变量。java 强制内部类使用的临时局部变量为final的，而在jdk1.8后就不需要手动添加final修饰局部变量，jvm会自动在底层添加final修饰符。</p></blockquote><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>​匿名内部类我们必须要继承一个父类或者实现一个接口，当然也仅能只继承一个父类或者实现一 个接口。同时它也是没有 class 关键字，这是因为匿名内部类是直接使用 new 来生成一个对象的引 用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">     <span class="keyword">private</span> String name;</span><br><span class="line">     <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> name;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.name = name;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Bird bird)</span>&#123;</span><br><span class="line">        System.out.println(bird.getName() + <span class="string">&quot;能够飞 &quot;</span> + bird.fly() + <span class="string">&quot;米&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="comment">//匿名内部类</span></span><br><span class="line">        test.test(<span class="keyword">new</span> <span class="title class_">Bird</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">10000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;大雁&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>一个类用于隐式地继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是覆盖；或者说，匿名内部类是一个继承了该类或者实现了该接口的子类匿名对象。</li><li>只是为了获得一个对象实例，不需要知道其实际类型。</li><li>类名没有意义，也就是不需要使用到。</li></ol><p><strong>格式：new 类名&#x2F;接口名( ) { }；</strong><code>这是一个表达式语句，后面要加分号。</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Outer.i = &quot;</span> + i );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">h</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Object</span>() &#123;        <span class="comment">//匿名类</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">g</span><span class="params">()</span> &#123;</span><br><span class="line">                i ++;</span><br><span class="line">                f();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.g();             <span class="comment">//新建对象调用自己的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E12</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        outer.h();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*Output:</span></span><br><span class="line"><span class="comment">    Outer.i = 1</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>​在匿名类中不可能有命名构造器（因为它根本没名字！），但通过实例初始化，就能够达到为匿名内部类创建一个构造器的效果，like this:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parcel10</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Destination <span class="title function_">destination</span><span class="params">(String dest, <span class="type">float</span> price)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Destination</span>() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="type">int</span> cost;</span><br><span class="line">            <span class="comment">// 实例初始化--&gt;匿名类的构造器效果</span></span><br><span class="line">            &#123;</span><br><span class="line">                cost = Math.round(price);</span><br><span class="line">                <span class="keyword">if</span>(cost &gt; <span class="number">100</span>)</span><br><span class="line">                    System.out.println(<span class="string">&quot;Over budget!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">private</span> <span class="type">String</span> <span class="variable">label</span> <span class="operator">=</span> dest;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">readLabel</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> label;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Parcel10</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parcel10</span>();</span><br><span class="line">        <span class="type">Destination</span> <span class="variable">d</span> <span class="operator">=</span> p.destination(<span class="string">&quot;Tasmania&quot;</span>, <span class="number">101.395F</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*Output:</span></span><br><span class="line"><span class="comment">    Over budget!</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h1 id="内部类的创建"><a href="#内部类的创建" class="headerlink" title="内部类的创建"></a>内部类的创建</h1><p>内部类和组合（java中的组合是在类中实现has-a关系的设计技术。可以在java中使用java继承或对象组合来重用代码。在Java编程中表现出来的就是：一个类使用另一个类作为它的成员。通过使用引用其他对象的实例变量来实现Java组合。例如，一个人(Person)有一份工作(Job)）是完全不同的概念，并不仅仅是将类置于其他类的内部那么简单，他能够与外部类进行通信。内部类对象的创建应具体指明这个对象的类型：<strong>OutClassName.InnerClassName</strong>；有两种方式：<strong>用函数返回一个内部类对象，或者用.new，两种都要先创建外部类对象</strong>；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> Outer <span class="title function_">getOuter</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Outer.<span class="built_in">this</span>;                   <span class="comment">//生成对外部类对象的引用 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInner</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();              <span class="comment">//先创建外部类对象</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outer.getInner();   <span class="comment">//用函数创建</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">inner1</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">Inner</span>(); <span class="comment">//用.new创建</span></span><br><span class="line">        inner.getOuter().f(); <span class="comment">//访问外部类对象的成员方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内部类与向上转型"><a href="#内部类与向上转型" class="headerlink" title="内部类与向上转型"></a>内部类与向上转型</h1><p>​向上转型和向下转型<a href="https://baijiahao.baidu.com/s?id=1552327142891960&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1552327142891960&amp;wfr=spider&amp;for=pc</a></p><p>​当将内部类向上转型为其基类，尤其是转型为一个接口的时候，内部类就有了用武之地。（从实现了某个接口的对象，得到对此接口的引用，与向上转型为这个对象的基类，实质上效果是一样的。）这是因为此内部类–某个接口的实现–能够完全不可见，并且不可用。所得到的只是指向基类或接口的引用，所以能够很方便地隐藏实现细节。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目的地</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Destination</span> &#123;</span><br><span class="line"><span class="comment">// 读标签</span></span><br><span class="line">String <span class="title function_">readLabel</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Contents</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parcel4</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">PContents</span> <span class="keyword">implements</span> <span class="title class_">Contents</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">class</span> <span class="title class_">PDestination</span> <span class="keyword">implements</span> <span class="title class_">Destination</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String label;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="title function_">PDestination</span><span class="params">(String whereTo)</span> &#123;</span><br><span class="line">label = whereTo;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">readLabel</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> label;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> Destination <span class="title function_">destination</span><span class="params">(String s)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PDestination</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> Contents <span class="title function_">contents</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PContents</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestParcel</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Parcel4</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parcel4</span>();</span><br><span class="line"><span class="type">Contents</span> <span class="variable">c</span> <span class="operator">=</span> p.contents(); <span class="comment">//向上转型</span></span><br><span class="line"><span class="type">Destination</span> <span class="variable">d</span> <span class="operator">=</span> p.destination(<span class="string">&quot;Tasmania&quot;</span>); <span class="comment">//向上转型</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code> Parcel4中增加了一些新东西：内部类PContents是private，所以除了Parcel4，没有人能访问它。PDestination是protected，所以只有Parcel4及其子类，还有与Parcel4同一个包中的类（因为protected也给予了包访问权）能访问PDestination，其他类都不能访问PDestination。这意味着，如果客户端程序员想了解或访问这些成员，那是要受到限制的。实际上，甚至不能向下转型成private内部类（或protected内部类，除非是继承自它的子类），因为不能访问其名字，就像在TestParcel类中看到的那样。于是，private内部类各类的设计者提供了一种途径，通过这种方式可以完全阻止任何依赖于类型的编码，并且完全隐藏了实现的细节。此外，从客户端程序员的角度来看，由于不能访问任何新增加的、原本不属于公共接口的方法，所以扩展接口是没有价值的。这也给java编译器提供了生成更高效代码的机会。</code></pre><h1 id="为什么使用内部类"><a href="#为什么使用内部类" class="headerlink" title="为什么使用内部类"></a>为什么使用内部类</h1><p>使用内部类最吸引人的原因：<strong>每个内部类都能独立的继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响</strong>。</p><p>例如内部类可以有效地实现“多重继承”，考虑这样一种情形：即必须在一个类中以某种方式实现两个接口。由于接口允许多继承，有两种选择：使用单一类，或者使用内部类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">interface A &#123;&#125;</span><br><span class="line"></span><br><span class="line">interface B &#123;&#125;</span><br><span class="line"></span><br><span class="line">class X implements A,B &#123;&#125;</span><br><span class="line"></span><br><span class="line">class Y implements A &#123;</span><br><span class="line">    B makeB() &#123;</span><br><span class="line">        // 匿名内部类</span><br><span class="line">        return new B() &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MutiInterfaces &#123;</span><br><span class="line">    static void takesA(A a) &#123;&#125;</span><br><span class="line">    static void takesB(B b) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        X x = new X();</span><br><span class="line">        Y y = new Y();</span><br><span class="line">        takesA(x);</span><br><span class="line">        takesB(x);</span><br><span class="line">        takesA(y);</span><br><span class="line">        takesB(y.makeB());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果拥有的是抽象的类或具体的类，而不是接口，那就只能使用内部类才能实现多继承。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class D &#123;&#125;</span><br><span class="line"></span><br><span class="line">abstract class E &#123;&#125;</span><br><span class="line"></span><br><span class="line">class Z extends D &#123;</span><br><span class="line">    E makeE() &#123;</span><br><span class="line">        return new E() &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MutiImplementation &#123;</span><br><span class="line">    static void takesD(D d) &#123;&#125;</span><br><span class="line">    static void takesE(E e) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Z z = new Z();</span><br><span class="line">        takesD(z);</span><br><span class="line">        takesE(z.makeE());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="闭包和回调"><a href="#闭包和回调" class="headerlink" title="闭包和回调"></a><strong>闭包和回调</strong></h2><p>闭包（closure）是一个可调用的对象，他记录了一些信息，这些信息来自于创建它的作用域。<strong>可以看出，内部类是面向对象的闭包，因为它不仅包含外围类对象（创建内部类的作用域）的信息，还自动拥有一个指向此外围类对象的引用，在此作用域内，内部类有权操作所有的成员，包括private成员。</strong></p><p>通过<strong>回调（callback）</strong>，对象能够携带一些信息，这些信息允许他在稍后的某个时刻调用初始的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Incrementable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单的解决方式，直接实现接口Incrementable：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Callee1</span> <span class="keyword">implements</span> <span class="title class_">Incrementable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span> <span class="params">()</span> &#123;</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyIncrement</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Other operation&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(MyIncrement mi)</span> &#123;</span><br><span class="line">        mi.increment();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果要求类必须以不同的方式（应该指通过不同的引用调用）</span></span><br><span class="line"><span class="comment">// 如下c2.getCallbackReference() ）实现increment()方法，必须使用内部类：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Callee2</span> <span class="keyword">extends</span> <span class="title class_">MyIncrement</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.increment();</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Closure</span> <span class="keyword">implements</span> <span class="title class_">Incrementable</span> &#123;   <span class="comment">//内部类就是一个闭包</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// Specify outer-class method, otherwise you&#x27;d get an infinite recursion:</span></span><br><span class="line">            Callee2.<span class="built_in">this</span>.increment();</span><br><span class="line">            <span class="comment">// 内部类Closure实现了Incrementable，以提供一个返回Callee2的钩子（hook），</span></span><br><span class="line">            <span class="comment">// 而且是一个安全的钩子，无论谁获得此Incrementable的引用，都只能调用increment()方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Incrementable <span class="title function_">getCallbackReference</span><span class="params">()</span> &#123;   <span class="comment">//回调Incrementable类型</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Closure</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Caller</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Incrementable callbackReference;</span><br><span class="line">    Caller(Incrementable cbh) &#123;</span><br><span class="line">        callbackReference = cbh;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span> &#123;</span><br><span class="line">        callbackReference.increment();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Callbacks</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Callee1</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Callee1</span>();</span><br><span class="line">        <span class="type">Callee2</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Callee2</span>();</span><br><span class="line">        MyIncrement.f(c2);</span><br><span class="line">        <span class="type">Caller</span> <span class="variable">caller1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Caller</span>(c1);</span><br><span class="line">        <span class="type">Caller</span> <span class="variable">caller2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Caller</span>(c2.getCallbackReference()); <span class="comment">// 通过不同的引用调用</span></span><br><span class="line">        caller1.go();</span><br><span class="line">        caller1.go();</span><br><span class="line">        caller2.go();</span><br><span class="line">        caller2.go();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Output:</span></span><br><span class="line"><span class="comment">    Other operation</span></span><br><span class="line"><span class="comment">    1</span></span><br><span class="line"><span class="comment">    1</span></span><br><span class="line"><span class="comment">    2</span></span><br><span class="line"><span class="comment">    Other operation</span></span><br><span class="line"><span class="comment">    2</span></span><br><span class="line"><span class="comment">    other operation</span></span><br><span class="line"><span class="comment">    3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h1 id="内部类的继承"><a href="#内部类的继承" class="headerlink" title="内部类的继承"></a><strong>内部类的继承</strong></h1><p>内部类的继承，在导出类的构造器中，需要定义特殊的语法来说明导出类与外围类对象之间的关系，即必须使用以下语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enclosingClassReference.super();</span><br></pre></td></tr></table></figure><p>这个语句用在导出类构造器的第一行，为导出类提供必要的引用。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">InnerA</span> &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">InnerA</span><span class="params">()</span> &#123;i = <span class="number">47</span>;&#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">InnerA</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.i  = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;InnerA.f&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">AA</span> <span class="keyword">extends</span> <span class="title class_">InnerA</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">AA</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">InnerB</span> <span class="keyword">extends</span> <span class="title class_">A</span>.InnerA &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">InnerB</span><span class="params">(A a)</span> &#123;</span><br><span class="line">            a.<span class="built_in">super</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">InnerB</span><span class="params">(A a, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">            a.<span class="built_in">super</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;InnerB.f&quot;</span>);</span><br><span class="line">            <span class="built_in">super</span>.f();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E26</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        A.<span class="type">InnerA</span>  <span class="variable">innerA</span> <span class="operator">=</span> a.<span class="keyword">new</span> <span class="title class_">InnerA</span>();</span><br><span class="line">        B.<span class="type">InnerB</span> <span class="variable">innerB</span> <span class="operator">=</span> (<span class="keyword">new</span> <span class="title class_">B</span>()).<span class="keyword">new</span> <span class="title class_">InnerB</span>(a,<span class="number">2</span>);</span><br><span class="line">        innerB.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码讨论的是一般情况，具体情况要具体对待，例如class AA与class A处于同一个外围类中就不需要这种特殊语法；又或者当class B也继承class A时也不需要这种特殊语法，因为此时外围类与导出类存在可连接的默认对象，在8中有相关事例。</p><p>有一种特殊情况是静态内部类（嵌套类）并不能继承同级的内部类，因为继承内部类需要此类具有相同的内外结构，而<strong>嵌套类并不是其”外围类”的子类</strong>，参考<a href="https://stackoverflow.com/questions/22117072/no-enclosing-instance-of-type-in-scope">https://stackoverflow.com/questions/22117072/no-enclosing-instance-of-type-in-scope</a></p><hr><h1 id="内部类不可以被覆盖"><a href="#内部类不可以被覆盖" class="headerlink" title="内部类不可以被覆盖"></a><strong>内部类不可以被覆盖</strong></h1><p>当继承某个外部类的时候，内部类并没有发生什么特别的变化。即使你在外围类的导出类中重写一个类名与外围类的内部类类名相同的类时，这两个内部类是完全独立的两个实体，不存在覆盖或者继承关系，当然明确的继承某个内部类也是可以的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Egg</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">class</span> <span class="title class_">Yolk</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Yolk</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Egg.Yolk()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Egg.f()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Yolk</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Yolk</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Egg</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;New Egg()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertYolk</span><span class="params">(Yolk yy)</span> &#123;</span><br><span class="line">        y = yy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">g</span><span class="params">()</span> &#123;</span><br><span class="line">        y.f(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigEgg</span> <span class="keyword">extends</span> <span class="title class_">Egg</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Yolk</span> <span class="keyword">extends</span> <span class="title class_">Egg</span>.Yolk &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Yolk</span><span class="params">()</span> &#123;   <span class="comment">//此处也不需要enclosingClassReference.super();</span></span><br><span class="line">            System.out.println(<span class="string">&quot;BigEgg.Yolk()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;BigEgg.Yolk.f()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BigEgg</span><span class="params">()</span> &#123;</span><br><span class="line">        insertYolk(<span class="keyword">new</span> <span class="title class_">Yolk</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Egg</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigEgg</span>();</span><br><span class="line">        e.g();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*Output:</span></span><br><span class="line"><span class="comment">    Egg.Yolk()</span></span><br><span class="line"><span class="comment">    New Egg()</span></span><br><span class="line"><span class="comment">    Egg.Yolk()</span></span><br><span class="line"><span class="comment">    BigEgg.Yolk()</span></span><br><span class="line"><span class="comment">    BigEgg.Yolk.f()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h1 id="内部类标识符"><a href="#内部类标识符" class="headerlink" title="内部类标识符"></a><strong>内部类标识符</strong></h1><p>由于每个类都会产生一个.class文件，其中包含了如何创建该类型的对象的全部信息（此信息产生一个”meta-class”，叫做Class对象），你可能猜到了，内部类也必须生成一个.class文件以包含它们的Class对象信息。这些类文件的命名有严格的规则：外围类的名字，加上“$”,再加上内部类的名字。<strong>如果是局部内部类的话，编译器会在”$”后，局部类名前加上数字编号，防止同一个类中局部类重复；如果是匿名内部类，编译器会简单地产一个数字作为其标识符。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内部类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继承</title>
      <link href="/2022/06/24/%E7%BB%A7%E6%89%BF/"/>
      <url>/2022/06/24/%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<p>多继承<a href="https://blog.csdn.net/weixin_43533825/article/details/96574691">https://blog.csdn.net/weixin_43533825/article/details/96574691</a></p><p>java的三大特性 封装</p><h2 id="封装："><a href="#封装：" class="headerlink" title="封装："></a><strong>封装：</strong></h2><p><strong>将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互.</strong></p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>​继承是使用<strong>已存在的类</strong>的定义作为基础建立新类的技术，新类的定义可以增加<strong>新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类</strong>。通过使用继承我们能够非常方便地复用以前的代码。</p><p>​子类重新实现父类的方法称重写；重写时可以修改访问权限修饰符和返回值，方法名和参数类型及个数都不可以修改；仅当返回值为类类型时，重写的方法才可以修改返回值类型，且必须是父类方法返回值的子类；要么就不修改，与父类返回值类型相同。那么，该如何理解呢？为什么要是父类返回值类型的子类？</p><p>​我的理解是，这是为了向上转型；<strong>既然子类重写了父类的方法，有时候就需要用父类对象引用来调用子类重写的方法，</strong>为方便说明，记父类的返回值类型为A。也就是说要把A的子类对象引用赋给A的对象引用，如果此时返回值类型不是A类或A的子类，其他类的对象引用是不能赋给A的对象引用的，这样就会出错；所以说，子类重写的方法，如果返回值为类类型，其返回值类型必须与父类返回值类型相同或为父类返回值类型的子类。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>​首先我觉得即<strong>一个引用变量到底会指向哪个类的实例对象</strong>，该<strong>引用变量发出的方法调用到底是哪个类中实现的方法</strong>，必须在由程序<strong>运行期间</strong>才能决定。强调在编译的时候，不知道该引用指向的是哪个对象的实例，包括调用哪个实例的方法，只有运行的时候，动态知道。</p><p>​举个例子：</p><p>​任何事物的多个姿态，多个形态。比如，你说一个猫在吃东西，同样的，你也能说一个动物在吃东西。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Animal animal = new Cat();</span><br><span class="line">        animal.eat() // 猫也会吃饭</span><br><span class="line">        // 你看到了一只猫，同样它也是动物</span><br><span class="line">        // 比如有很多其他种类继承了动物哈，</span><br><span class="line">        // 当编译期间的animal引用变量，到底指的哪个实例对象，（重要）（主语是引用变量）</span><br><span class="line">        // 或者该引用调用的eat方法，到底是哪个实例对象的eat，编译期间恐怕不知道哦（主语是引用变量）</span><br><span class="line">        // 只有运行期间，哦哦， 原来是猫的eat方法哇...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="表现形式"><a href="#表现形式" class="headerlink" title="表现形式"></a>表现形式</h3><ul><li><strong>Java的方法重载，就是在类中可以创建多个方法，它们具有相同的名字，但可具有不同的参数列表、返回值类型。调用方法时通过传递的参数类型来决定具体使用哪个方法</strong>，这就是多态性。比如，java lang的包很多工具类如String工具类，那么就有很多相同的名字，但是参数类型、数量和返回值等等不一样。</li><li><strong>Java的方法重写，是父类与子类之间的多态性，子类可继承父类中的方法，但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写。重写的参数列表和返回类型均不可修改</strong>。这也是多态性。比如JUC的AQS框架，凡事继承了AQS的那几个类，其中几个重要的方法，都被重写了，很多这样的情况。</li></ul><h3 id="底层原理："><a href="#底层原理：" class="headerlink" title="底层原理："></a>底层原理：</h3><p>​首先当程序运行需要某个类时，类加载器会将相应的class文件载入到JVM中，并在方法区建立该类的类型信息（包括方法代码，类变量、成员变量以及<strong>方法表</strong>）。方法表的结构如同字段表一样，依次包括了<strong>访问标志、名称索引、描述符索引、属性表集合</strong>几项。</p><p>​<strong>方法表是实现动态调用的核心。为了优化对象调用方法的速度，方法区的类型信息会增加一个指针，该指针指向记录该类方法的方法表，方法表中的每一个项都是对应方法的指针</strong>。</p><p><strong>方法调用的多态：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 重写object的toString</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I&#x27;m a person.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boy</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="comment">// 重写object的toString</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I&#x27;m a boy&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 继承Person的speak</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 自己实现的自定义方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fight</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="comment">// 重写object的toString</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I&#x27;m a girl&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 继承Person的speak</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 自己实现的自定义方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​在方法表中方法表条目指向的是<strong>具体的方法地址</strong>，最开始的条目是继承值Object的方法，接着是继承自父类的方法，再接着是自定义的方法。</p><p>​上例中继承自于 Person 的方法 eat() 和 speak() 分别指向 <strong>Person 的方法实现和子类本身的实现</strong>。如果子类改写了父类的方法，那么子类和父类的那些<strong>同名的方法共享一个方法表项</strong>就是处在方法表中同一个索引的位置。因此，<strong>所有继承父类的子类的方法表中，其父类所定义的方法的偏移量也总是一个定值</strong>。Person 或 Object中的任意一个方法，在它们的方法表和其子类 Girl 和 Boy 的方法表中的位置 (index) 是一样的。这样 JVM 在调用实例方法其实只需要指定调用方法表中的第几个方法即可。</p><p>调用过程：</p><ol><li>在常量池里找到方法调用的<strong>符号引用</strong>（肯定先看到Person定义引用类型）</li><li>查看Person的方法表，得到speak方法在该<strong>方法表的偏移量</strong>（假设为15），这样就得到该方法的直接引用。</li><li>根据this（invoker this字节码）指针得到<strong>具体的对象</strong>（即 girl 所指向的位于堆中的对象）。</li><li>根据对象得到该对象对应的方法表，根据偏移量15查看<strong>有无重写（override）该方法</strong>，如果重写，则可以直接调用（Girl的方法表的speak项指向自身的方法而非父类）；如果没有重写，则需要拿到按照继承关系从下往上的基类（这里是Person类）的方法表，同样按照这个偏移量15查看有无该方法。</li></ol><p><strong>接口调用的多态：</strong></p><p>​一个类可以实现多个接口，那么就像多继承一样，这样的话，在方法表中的索引就会不一样，所以Java 对于接口方法的调用是采用<strong>搜索方法表</strong>的方式。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cookie与Session</title>
      <link href="/2022/06/23/Cookie%E4%B8%8ESession/"/>
      <url>/2022/06/23/Cookie%E4%B8%8ESession/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP无状态"><a href="#HTTP无状态" class="headerlink" title="HTTP无状态"></a>HTTP无状态</h1><p>​HTTP 是无状态的。也就是说，HTTP 请求方和响应方间无法维护状态（客户端和服务端互相不认识），都是一次性的，它不知道前后的请求都发生了什么。但有的场景下，我们需要维护状态。最典型的，一个用户登陆微博，发布、关注、评论，都应是在登录后的用户状态下的。所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。</p><h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><p>​Cookies是一些存储在用户电脑上的小文件。它是被设计用来保存一些站点的用户数据，这样能够让服务器为这样的用户定制内容。页面代码能够获取到Cookie值然后发送给服务器，比如Cookie中存储了所在地理位置，以后每次进入地图就可以默认定位到改地点。</p><p>​cookie的执行原理：就是当客户端访问服务器的时候（服务器运用了cookie），服务器会生成一份cookie传输给客户端，客户端会自动把cookie保存起来，以后客户端每次访问服务器，都会自动的携带着这份cookie。简单来说，就是当客户端访问服务器时，服务器会生成一个票据给客户端，当客户端收到票据的之后就保存起来，以后再访问服务器就会自动带着票据。</p><span id="more"></span><p>​过程如下：</p><p>​在服务端提供标记的接口，通过 HTTP 返回头的 Set-Cookie 字段，直接保存到浏览器上。</p><p>​之后浏览器发起请求时，会自动把 cookie 通过 HTTP 请求头的 Cookie 字段，带给接口。</p><p><strong>cookie 存储在客户端</strong> cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。</p><p><strong>cookie 是不可跨域的</strong>：每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，</p><h1 id="Cookie属性配置"><a href="#Cookie属性配置" class="headerlink" title="Cookie属性配置"></a>Cookie属性配置</h1><h2 id="Domain-x2F-Path"><a href="#Domain-x2F-Path" class="headerlink" title="Domain &#x2F; Path"></a><strong>Domain &#x2F; Path</strong></h2><p>​cookie通过 Domain（域）&#x2F; Path（路径）两级来限制有效范围，</p><p>​Domain属性指定浏览器发出 HTTP 请求时，哪些域名要附带这个 Cookie。如果没有指定该属性，浏览器会默认将其设为当前 URL 的一级域名，比如 <a href="http://www.example.com/">www.example.com</a> 会设为 example.com，而且以后如果访问example.com的任何子域名，HTTP 请求也会带上这个 Cookie。如果服务器在Set-Cookie字段指定的域名，不属于当前域名，浏览器会拒绝这个 Cookie。Path属性指定浏览器发出 HTTP 请求时，哪些路径要附带这个 Cookie。只要浏览器发现，Path属性是 HTTP 请求路径的开头一部分，就会在头信息里面带上这个 Cookie。比如，PATH属性是&#x2F;，那么请求&#x2F;docs路径也会包含该 Cookie。当然，前提是域名必须一致。</p><h2 id="Expires-x2F-Max-Age"><a href="#Expires-x2F-Max-Age" class="headerlink" title="Expires &#x2F; Max-Age"></a>Expires &#x2F; Max-Age</h2><p>​cookie通过通过 Expires、Max-Age 中的一种来限制有效时间范围。Expires属性指定一个具体的到期时间，到了指定时间以后，浏览器就不再保留这个 Cookie。它的值是 UTC 格式。如果不设置该属性，或者设为null，Cookie 只在当前会话（session）有效，浏览器窗口一旦关闭，当前 Session 结束，该 Cookie 就会被删除。另外，浏览器根据本地时间，决定 Cookie 是否过期，由于本地时间是不精确的，所以没有办法保证 Cookie 一定会在服务器指定的时间过期。Max-Age属性指定从现在开始 Cookie 存在的秒数，比如60 * 60 * 24 * 365（即一年）。过了这个时间以后，浏览器就不再保留这个 Cookie。如果同时指定了Expires和Max-Age，那么Max-Age的值将优先生效。如果Set-Cookie字段没有指定Expires或Max-Age属性，那么这个 Cookie 就是 Session Cookie，即它只在本次对话存在，一旦用户关闭浏览器，浏览器就不会再保留这个 Cookie。</p><h2 id="Cookie缺点："><a href="#Cookie缺点：" class="headerlink" title="Cookie缺点："></a>Cookie缺点：</h2><ol><li>保存在客户端，容易被篡改。</li><li>大小受限，本身最大4kb。</li></ol><h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><p>​Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了session是一种特殊的cookie。cookie是保存在客户端的，而session是保存在服务端。</p><h2 id="Session原理"><a href="#Session原理" class="headerlink" title="Session原理"></a>Session原理</h2><p>​当客户端第一次请求服务器的时候，服务器生成一份session保存在服务端，将该数据(session)的id以cookie的形式传递给客户端；以后的每次请求，浏览器都会自动的携带cookie来访问服务器(session数据id)。</p><h2 id="session-登陆-x2F-验证流程："><a href="#session-登陆-x2F-验证流程：" class="headerlink" title="session 登陆&#x2F;验证流程："></a>session 登陆&#x2F;验证流程：</h2><ul><li>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session</li><li>请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器</li><li>浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名</li><li>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</li></ul><h2 id="Session-的存储方式"><a href="#Session-的存储方式" class="headerlink" title="Session 的存储方式"></a><strong>Session 的存储方式</strong></h2><p>​显然，服务端只是给 cookie 一个 sessionId，而 session 的具体内容（可能包含用户信息、session 状态等），要自己存一下。存储的方式有几种：</p><ul><li>Redis（推荐）：内存型数据库，redis中文官方网站。以 key-value 的形式存，正合 sessionId-sessionData 的场景；且访问快。</li><li>内存：直接放到变量里。一旦服务重启就没了</li><li>数据库：普通数据库。性能不高。</li></ul><h2 id="Session-的分布式问题"><a href="#Session-的分布式问题" class="headerlink" title="Session 的分布式问题"></a>Session 的分布式问题</h2><p>通常服务端是集群，而用户请求过来会走一次负载均衡，不一定打到哪台机器上。那一旦用户后续接口请求到的机器和他登录请求的机器不一致，或者登录请求的机器宕机了，session 不就失效了吗？这个问题现在有几种解决方式。</p><ul><li>一是从「存储」角度，把 session 集中存储。如果我们用独立的 Redis 或普通数据库，就可以把 session 都存到一个库里。</li><li>二是从「分布」角度，让相同 IP 的请求在负载均衡时都打到同一台机器上。以 nginx 为例，可以配置 ip_hash 来实现。</li></ul><p>​但通常还是采用第一种方式，因为第二种相当于阉割了负载均衡，且仍没有解决「用户请求的机器宕机」的问题。</p><h1 id="Cookie-和-Session-的区别"><a href="#Cookie-和-Session-的区别" class="headerlink" title="Cookie 和 Session 的区别"></a>Cookie 和 Session 的区别</h1><ol><li>安全性：Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的。</li><li>存取值的类型不同：Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。</li><li>有效期不同：Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。</li><li>存储大小不同：单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。</li></ol><h1 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h1><p>​session 的维护给服务端造成很大困扰，我们必须找地方存放它，又要考虑分布式的问题，甚至要单独为了它启用一套 Redis 集群。</p><p>​Token是在服务端产生的，如果前端使用用户名&#x2F;密码向服务端请求认证，服务端认证成功，那么在服务端会返回token给前端，前端可以在每次请求的时候带上token证明自己的合法地位。如果这个 Token 在服务端持久化（比如存入数据库），那它就是一个永久的身份令牌。</p><h2 id="Token登录流程"><a href="#Token登录流程" class="headerlink" title="Token登录流程"></a>Token登录流程</h2><ul><li>用户登录，服务端校验账号密码，获得用户信息</li><li>把用户信息、token 配置编码成 token，通过 cookie set 到浏览器</li><li>此后用户请求业务接口，通过 cookie 携带 token</li><li>接口校验 token 有效性，进行正常业务接口处理</li></ul><h2 id="客户端-token-的存储方式"><a href="#客户端-token-的存储方式" class="headerlink" title="客户端 token 的存储方式"></a><strong>客户端 token 的存储方式</strong></h2><p>​在前面 cookie 说过，cookie 并不是客户端存储凭证的唯一方式。token 因为它的「无状态性」，有效期、使用限制都包在 token 内容里，对 cookie 的管理能力依赖较小，客户端存起来就显得更自由。但 web 应用的主流方式仍是放在 cookie 里，毕竟少操心。</p><p>​token怎么防止用户篡改数据。如果 token 涉及到敏感权限，就要想办法避免 token 被篡改。解决方案就是给 token 加签名，来识别 token 是否被篡改过。例如在 cookie-session - npm 库中，增加两项配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">secret: <span class="string">&#x27;iAmSecret&#x27;</span>,signed: <span class="literal">true</span>, </span><br></pre></td></tr></table></figure><p>​这样会多种一个 .sig cookie，里面的值就是 <code>&#123;&quot;userid&quot;:&quot;abb”&#125;</code> 和 <code>iAmSecret</code>通过加密算法计算出来的，常见的比如HMACSHA256 类 (System.Security.Cryptography)现在 cdd 虽然能伪造出<code>eyJ1c2VyaWQiOiJhIn0=</code>，但伪造不出 sig 的内容，因为他不知道 secret。</p><h1 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a><strong>JWT</strong></h1><p>Token加Cookie的做法额外增加了 cookie 数量，数据本身也没有规范的格式，所以 JSON Web Token Introduction - jwt.io 横空出世了。</p><p>​JSON Web Token (JWT) 是一个开放标准，定义了一种传递 JSON 信息的方式。这些信息通过数字签名确保可信。</p><p>它是一种成熟的 token 字符串生成方案，包含了我们前面提到的数据、签名。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>HTTP 是无状态的，为了维持前后请求，需要前端存储标记</li><li>cookie 是一种完善的标记方式，通过 HTTP 头或 js 操作，有对应的安全策略，是大多数状态管理方案的基石</li><li>session 是一种状态管理方案，前端通过 cookie 存储 id，后端存储数据，但后端要处理分布式问题</li><li>token 是另一种状态管理方案，相比于 session 不需要后端存储，数据全部存在前端，解放后端，释放灵活性</li><li>token 的编码技术，通常基于 base64，或增加加密算法防篡改，jwt 是一种成熟的编码方案</li><li>在复杂系统中，token 可通过 service token、refresh token 的分权，同时满足安全性和用户体验</li><li>session 和 token 的对比就是「用不用cookie」和「后端存不存」的对比</li><li>单点登录要求不同域下的系统「一次登录，全线通用」，通常由独立的 SSO 系统记录登录状态、下发 ticket，各业务系统配合存储和认证 ticket</li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 鉴权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>List集合的坑</title>
      <link href="/2022/06/16/List%E9%9B%86%E5%90%88%E7%9A%84%E5%9D%91/"/>
      <url>/2022/06/16/List%E9%9B%86%E5%90%88%E7%9A%84%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<p><strong>在使用java的ArrayList时遇到过的一些坑</strong></p><h3 id="迭代时删除元素"><a href="#迭代时删除元素" class="headerlink" title="迭代时删除元素"></a>迭代时删除元素</h3><p>使用<code>for-each</code>迭代遍历时，删除集合中的元素，会报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">       <span class="comment">//初始化集合</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">           list.add(String.valueOf(i));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">//使用for-each迭代时删除元素</span></span><br><span class="line">       <span class="keyword">for</span> (String str : list) &#123;</span><br><span class="line">           <span class="keyword">if</span> (<span class="string">&quot;1&quot;</span>.equals(str)) &#123;</span><br><span class="line">               list.remove(str);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><span id="more"></span><p>或者你使用迭代器<code>Iterator</code>遍历时，删除元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">//使用Iterator迭代器遍历时，删除元素</span></span><br><span class="line">       Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">       <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> it.next();</span><br><span class="line">           <span class="keyword">if</span> (<span class="string">&quot;1&quot;</span>.equals(str)) &#123;</span><br><span class="line">               list.remove(str);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>以上两种情况都会报这个错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.util.ConcurrentModificationException</span><br><span class="line">at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:<span class="number">901</span>)</span><br><span class="line">at java.util.ArrayList$Itr.next(ArrayList.java:<span class="number">851</span>)</span><br></pre></td></tr></table></figure><p>这就是不正确的删除姿势，那怎么删呢？</p><p>使用<code>for-i</code>循环遍历删除(亲测有效)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">//使用Iterator迭代器遍历时，删除元素</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">           <span class="keyword">if</span> (<span class="string">&quot;1&quot;</span>.equals(s)) &#123;</span><br><span class="line">               list.remove(s);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       list.forEach(System.out::println);<span class="comment">//2 3 4 5 6 7 8 9 10</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>使用<code>for-i</code>循环倒序遍历，删除元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">//使用for-i倒序遍历，删除元素</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> list.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">           <span class="keyword">if</span> (<span class="string">&quot;1&quot;</span>.equals(str)) &#123;</span><br><span class="line">               list.remove(str);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       list.forEach(System.out::println);<span class="comment">//2 3 4 5 6 7 8 9 10</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>使用<code>Iterator</code>的<code>remove()</code>方法删除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">//使用Iterator迭代器遍历时，删除元素</span></span><br><span class="line">       Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">       <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> it.next();</span><br><span class="line">           <span class="keyword">if</span> (<span class="string">&quot;1&quot;</span>.equals(str)) &#123;</span><br><span class="line">               it.remove();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       list.forEach(System.out::println);<span class="comment">//2 3 4 5 6 7 8 9 10</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>用<code>Lambda</code>表达式。在java8中，<code>List</code>增加了一个<code>removeIf()</code>方法用于删除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">//使用removeIf()遍历时，删除元素。删除集合中为1的元素</span></span><br><span class="line">       list.removeIf(str -&gt; <span class="string">&quot;1&quot;</span>.equals(str));</span><br><span class="line">       list.forEach(System.out::println);<span class="comment">//2 3 4 5 6 7 8 9 10</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id><a href="#" class="headerlink" title></a></h3><h3 id="使用asList-获得集合删除-x2F-增加"><a href="#使用asList-获得集合删除-x2F-增加" class="headerlink" title="使用asList()获得集合删除&#x2F;增加"></a>使用asList()获得集合删除&#x2F;增加</h3><p>看代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       List&lt;Integer&gt; nums = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">       nums.add(<span class="number">7</span>);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       List&lt;Integer&gt; nums = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">       nums.remove(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如果你进行以上操作，就会看到报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException</span><br><span class="line">at java.util.AbstractList.remove(AbstractList.java:161)</span><br></pre></td></tr></table></figure><p>为什么会报这个错？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">RandomAccess</span>, java.io.Serializable &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ArrayList</code>不是<code>util</code>包的<code>ArrayList</code>，而是<code>Arrays</code>的一个内部类。因为继承了<code>AbstractList</code>抽象类，但是又没有实现<code>add()</code>、<code>remove()</code>方法。所以会调用抽象类的<code>add()</code>和<code>remove()</code>。 抽象类的<code>add()</code>直接抛出异常。。。。。。。。。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>所以不能用<code>asList()</code>得到的集合去增删了！</p><h3 id="-1"><a href="#-1" class="headerlink" title></a></h3><h3 id="通过subList-方法获得集合后增删"><a href="#通过subList-方法获得集合后增删" class="headerlink" title="通过subList()方法获得集合后增删"></a>通过subList()方法获得集合后增删</h3><p>当使用<code>subList()</code>方法获得集合后删除，原(父)集合也会被删除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       List&lt;String&gt; subList = list.subList(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">       System.out.println(list);<span class="comment">//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br><span class="line">       System.out.println(subList);<span class="comment">//[1, 2, 3, 4, 5]</span></span><br><span class="line">       subList.remove(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">       System.out.println(list);<span class="comment">//[2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br><span class="line">       System.out.println(subList);<span class="comment">//[2, 3, 4, 5]</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>当使用<code>subList()</code>方法获得集合后增加元素，原(父)集合也会增加。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       List&lt;String&gt; subList = list.subList(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">       System.out.println(list);<span class="comment">//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br><span class="line">       System.out.println(subList);<span class="comment">//[1, 2, 3, 4, 5]</span></span><br><span class="line">       subList.add(<span class="string">&quot;11&quot;</span>);</span><br><span class="line">       System.out.println(list);<span class="comment">//[1, 2, 3, 4, 5, 11, 6, 7, 8, 9, 10]</span></span><br><span class="line">       System.out.println(subList);<span class="comment">//[1, 2, 3, 4, 5, 11]</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>源码中是这样写的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">SubList</span> <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">RandomAccess</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E e)</span> &#123;</span><br><span class="line">            rangeCheckForAdd(index);</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="comment">//父集合添加元素</span></span><br><span class="line">            parent.add(parentOffset + index, e);</span><br><span class="line">            <span class="built_in">this</span>.modCount = parent.modCount;</span><br><span class="line">            <span class="built_in">this</span>.size++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">            rangeCheck(index);</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="comment">//父集合删除元素</span></span><br><span class="line">            <span class="type">E</span> <span class="variable">result</span> <span class="operator">=</span> parent.remove(parentOffset + index);</span><br><span class="line">            <span class="built_in">this</span>.modCount = parent.modCount;</span><br><span class="line">            <span class="built_in">this</span>.size--;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果希望截取的集合是和原集合互不干扰的话，可以这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; subList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list.subList(<span class="number">0</span>, <span class="number">5</span>));</span><br></pre></td></tr></table></figure><h3 id="-2"><a href="#-2" class="headerlink" title></a></h3><h3 id="使用Collections-unmodifiableList-创建不可变集合也是可变的。"><a href="#使用Collections-unmodifiableList-创建不可变集合也是可变的。" class="headerlink" title="使用Collections.unmodifiableList()创建不可变集合也是可变的。"></a>使用Collections.unmodifiableList()创建不可变集合也是可变的。</h3><p>当不可变集合的原集合改变时，不可变集合也跟着改变。演示代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       List&lt;String&gt; unmodifiableList = Collections.unmodifiableList(list);</span><br><span class="line">       System.out.println(unmodifiableList);<span class="comment">//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br><span class="line">       <span class="comment">//删除原集合元素</span></span><br><span class="line">       list.remove(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">       System.out.println(unmodifiableList);<span class="comment">//[2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>看源码就知道原因了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UnmodifiableList(List&lt;? <span class="keyword">extends</span> <span class="title class_">E</span>&gt; list) &#123;</span><br><span class="line">   <span class="built_in">super</span>(list);</span><br><span class="line">   <span class="built_in">this</span>.list = list;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>因为不可变集合的成员变量的引用是指向原集合的，所以当原集合改变时，不可变集合也会随之改变</strong>。</p><p>解决方式：使用<code>Guava</code>工具包的<code>ImmutableList.copyOf()</code>方法创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       List&lt;String&gt; unmodifiableList = ImmutableList.copyOf(list);</span><br><span class="line">       list.remove(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">       System.out.println(unmodifiableList);<span class="comment">//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java序列化和反序列化</title>
      <link href="/2022/06/09/Java%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2022/06/09/Java%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="序列化和反序列化的定义："><a href="#序列化和反序列化的定义：" class="headerlink" title="序列化和反序列化的定义："></a>序列化和反序列化的定义：</h3><ul><li>Java序列化就是指把Java对象转换为字节序列的过程，便于持久化到本地磁盘，避免程序运行结束后对象从内存中消失，字节序列也方便在网络中传输。</li><li>Java反序列化就是指把字节序列恢复为Java对象的过程。</li></ul><h3 id="序列化使用场景："><a href="#序列化使用场景：" class="headerlink" title="序列化使用场景："></a>序列化使用场景：</h3><ol><li>将对象存储到文件中时进行序列化，从文件中读取对象时需要反序列化；</li><li>分布式传递对象，或者网络传输，需要序列化；</li><li>存入缓存数据库（如 Redis）时需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；</li></ol><span id="more"></span><h3 id="Java序列化的方式"><a href="#Java序列化的方式" class="headerlink" title="Java序列化的方式"></a>Java序列化的方式</h3><ol><li>实现 Serializable 接口：可以自定义 writeObject、readObject、writeReplace、readResolve 方法，会通过反射调用。</li><li>实现 Externalizable 接口，它是Serializable接口的子类，用户要实现的writeExternal()和readExternal() 方法，用来决定如何序列化和反序列化。因为序列化哪些字段，需要方法指定，所以transient在这里无效。</li></ol><p>上述方式可以采用JDK类库提供的序列化API:</p><ul><li>java.io.ObjectOutputStream ：表示对象输出流，其中writeObject(Object obj)方法可以将给定参数的obj对象进行序列化，将转换的一连串的字节序列写到指定的目标输出流中。</li><li>java.io.ObjectInputStream：该类表示对象输入流，该类下的readObject(Object obj)方法会从源输入流中读取字节序列，并将它反序列化为一个java对象并返回。</li></ul><h3 id="序列化规则："><a href="#序列化规则：" class="headerlink" title="序列化规则："></a>序列化规则：</h3><p><strong>静态字段不会序列化：</strong>序列化时不保存静态变量，这是因为序列化保存的是对象的状态，静态变量属于类的状态，因此序列化并不保存静态变量。</p><p><strong>transient关键字修饰的变量不会序列化：</strong> 在持久化对象时，对于一些特殊的数据成员（如用户的密码，银行卡号等），我们不想用序列化机制来保存它。为了在一个特定对象的一个成员变量上关闭序列化，可以在这个成员变量前加上关键字transient。</p><p><strong>父类的序列化：</strong>当一个父类实现序列化，子类自动实现序列化；而子类实现了 Serializable 接口，父类也需要实现Serializable 接口。</p><p><strong>引用对象序列化</strong>：当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化，这样就可以利用序列化实现深拷贝。</p><p><strong>序列化后private域不受保护：</strong>一个对象拥有private，public等field，对于一个要传输的对象，比如写到文件，或者进行RMI传输等等，在序列化进行传输的过程中，这个对象的private等域是不受保护的；</p><h2 id="Jackson序列化与反序列化"><a href="#Jackson序列化与反序列化" class="headerlink" title="Jackson序列化与反序列化"></a>Jackson序列化与反序列化</h2><p>Jackson被认为是”Java JSON库”或”Java最好的JSON解析器”。或简单地被当作”JSON for Java”。</p><h2 id="ObjectMapper"><a href="#ObjectMapper" class="headerlink" title="ObjectMapper"></a>ObjectMapper</h2><p>ObjectMapper 是 JSON 操作的核心，它有多个 JSON 序列化的方法，可以把 JSON 字符串保存FileOutputStream 等不同的介质中</p><ul><li>ObjectMapper 通过 writeValue 系列方法 将 java 对 象序列化 为 json，并 将 json 存 储成不同的格式，String（writeValueAsString），Byte Array（writeValueAsString），Writer， File，OutStream 和 DataOutput。</li><li>ObjectMapper 通过 readValue 系列方法从不同的数据源像 String ， Byte Array， Reader，File，URL， InputStream 将 json 反序列化为 java 对象。</li></ul><p>下面来说下 ObjectMapper 几个 writeValue 主要使用的方法</p><ul><li>writeValue(File arg0, Object arg1):把arg1转成json序列，并保存到arg0文件中</li><li>writeValue(OutputStream arg0, Object arg1)把arg1转成json序列，并保存到arg0输出流中</li><li>writeValueAsBytes(Object arg0)把arg0转成json序列，并把结果输出成字节数组</li><li>writeValueAsString(Object arg0)把arg0转成json序列，并把结果输出成字符串</li></ul><p>readValue 主要的使用方法</p><ul><li>readValue (String content, Class<T> valueType)把json序列字符串转成valueType对象，并把结果输出所映射的对象</T></li></ul><p><strong>注意</strong>：</p><p>Jackson 是基于 JavaBean 来序列化属性的，所以必须写 set与get 方法 。如果属性没有 GETTER 方法，默认是不会输出该属性的。</p><h2 id="Jackson-常用注解"><a href="#Jackson-常用注解" class="headerlink" title="Jackson 常用注解"></a><strong>Jackson 常用注解</strong></h2><p>Jackson 包含了很多注解，用来个性化序列化和反序列化操作，主要包含如下注解。</p><p>@JsonProperty，作用在属性上，用来为 JSON Key 指定一个别名；</p><p>@JsonIgnore，作用在属性上，用来忽略此属性；</p><p>@JsonIgnoreProperties，忽略一组属性，作用在类上，比如 @JsonIgnorePropertiess({“id”,”phone”})；</p><p>@JsonAnySetter，标记在某个方法上，此方法接收 Key、Value，用于 Jackson 在反序列化过程中，未找到的对应属性都调用此方法。通常这个方法用一个 Map 来实现；</p><p>@JsonAnyGetter，此注解标注在一个返回 Map 的方法上，Jackson 会取出 Map中的每一个值进行序列化；</p><p><strong>@JsonFormat，用于日期的格式化，如：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@JsonFormat(pattern=&quot;yyyy-MM-dd HH-mm-ss&quot;)</span><br><span class="line">private Date createDate;</span><br></pre></td></tr></table></figure><p>@JsonNaming，用于指定一个命名策略，作用于类或者属性上，类似 @JsonProperty，但是会自动命名。Jackson  自带了多种命名策略，你也可以实现自己的命名策略，比如输入的 Key 由 Java 命名方式转换为下划线命名方式：userName 转换为  user-name；</p><p>@JsonSerialize，指定一个实现类来自定义序列化。类必须实现 JsonSerializer 接口；</p><p>@JsonDeserialize，用户自定义反序列化，同 @JsonSerialize，类需要实现 JsonDeserialize 接口；</p><p>@JsonView，作用在类或者属性上，用来定义一个序列化组。Spring MVC 的 Controller 方法可以使用同样的 @JsonView 来序列化属于这一组的配置。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 序列化和反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发-创建线程的常见方式</title>
      <link href="/2022/06/02/%E5%B9%B6%E5%8F%91-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E5%BC%8F/"/>
      <url>/2022/06/02/%E5%B9%B6%E5%8F%91-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="方式一：新建class继承Thread类"><a href="#方式一：新建class继承Thread类" class="headerlink" title="方式一：新建class继承Thread类"></a>方式一：新建class继承Thread类</h1><p>​新建class继承Thread类，并重写run()方法，调用 线程实例名.start开启线程，开始之后，线程并不一定立即执行，仍然由CPU调度安排。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;新建的线程-&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startThread1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//创建一个线程对象，调用start方法，开启多线程</span></span><br><span class="line">    <span class="comment">//注：线程开启不一定立即执行，由CPU调度安排</span></span><br><span class="line">    <span class="type">Thread1</span> <span class="variable">testThread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread1</span>();</span><br><span class="line">    testThread1.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="方式二：新建class-实现Runnable接口"><a href="#方式二：新建class-实现Runnable接口" class="headerlink" title="方式二：新建class 实现Runnable接口"></a>方式二：新建class 实现Runnable接口</h1><p>新建一个class实现Runnable接口，在其中重写run方法，执行线程需要新建线程然后丢入runnable接口实现类，调用start方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;新建的线程-&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startThread2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//创建runnable接口的实现类对象</span></span><br><span class="line">    <span class="type">Thread2</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread2</span>();</span><br><span class="line">    <span class="comment">//创建线程对象，通过线程对象来开启我们的线程，代理</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(thread2);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方式三：lambda表达式实现Runnable"><a href="#方式三：lambda表达式实现Runnable" class="headerlink" title="方式三：lambda表达式实现Runnable"></a>方式三：lambda表达式实现Runnable</h1><p>直接在new线程的时候，新建lambda表达式（业务逻辑）实现Runnable接口，传入 new Thread中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startThread3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="comment">//具体的业务</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(t.getName()+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//启动线程</span></span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方式四：直接在函数括号中重写run方法"><a href="#方式四：直接在函数括号中重写run方法" class="headerlink" title="方式四：直接在函数括号中重写run方法"></a>方式四：直接在函数括号中重写run方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startThread4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//具体的业务</span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                System.out.println(t.getName() + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方式五：线程池（√）"><a href="#方式五：线程池（√）" class="headerlink" title="方式五：线程池（√）"></a>方式五：线程池（√）</h1><h2 id="使用线程池的好处："><a href="#使用线程池的好处：" class="headerlink" title="使用线程池的好处："></a>使用线程池的好处：</h2><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</li></ul><h2 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h2><h3 id="自动创建（×）："><a href="#自动创建（×）：" class="headerlink" title="自动创建（×）："></a>自动创建（×）：</h3><p>​自动创建主要使用Executors工具类，常见的可以创建一下几种线程池</p><p><strong>newFixedThreadPool</strong></p><p>​设置了corePoolSize&#x3D;maxPoolSize，keepAliveTime&#x3D;0(此时该参数没作用)，无界队列，允许请求的队列长度为 Integer.MAX_VALUE，任务可以无限放入，当请求过多时(任务处理速度跟不上任务提交速度造成请求堆积)可能导致占用过多内存或直接导致OOM异常。</p><p><strong>newSingleThreadExecutor</strong></p><p>​单个线程的线程池，缺点同上</p><p><strong>newCachedThreadPool</strong></p><p>​每次来请求直接创建新线程来处理任务，也不使用队列缓冲，会自动回收多余线程，由于将maxPoolSize设置成Integer.MAX_VALUE，当请求很多时就可能创建过多的线程，导致资源耗尽OOM。</p><p><strong>newScheduledThreadPool</strong></p><p>​弊端同上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> var0)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(var0, var0, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Executors</span>.FinalizableDelegatedExecutorService(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, <span class="number">2147483647</span>, <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span> var0)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(var0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="手动创建（√）"><a href="#手动创建（√）" class="headerlink" title="手动创建（√）"></a>手动创建（√）</h3><p>​手动创建可以灵活设置线程池的各个参数，主要是使用ThreadPoolExecutor类构造器定义实参来满足对线程池的定制要求：</p><p><strong>ThreadPoolExecutor 3 个最重要的参数：</strong></p><ul><li><strong>corePoolSize:</strong> 核心线程数线程数定义了最小可以同时运行的线程数量。</li><li><strong>maximumPoolSize :</strong> 当<strong>队列中存放的任务达到队列容量</strong>的时候，当前可以同时运行的线程数量变为最大线程数。</li><li><strong>runnableTaskQueue（任务队列）</strong>：用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列。<br>1 <strong>ArrayBlockingQueue</strong>：是一个基于数组结构的有界阻塞队列，此队列按FIFO（先进先出）原则对元素进行排序。<br>2 LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。<br>3 SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于Linked-BlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。<br>4 PriorityBlockingQueue：一个具有优先级的无限阻塞队列。</li></ul><p><code>ThreadPoolExecutor</code>其他常见参数 :</p><ol><li><strong>keepAliveTime</strong>:当线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁；</li><li><strong>unit</strong> : keepAliveTime 参数的时间单位。</li><li><strong>threadFactory</strong> :executor 创建新线程的时候会用到。</li><li><strong>handler</strong> :饱和策略。</li></ol><p><strong>饱和策略主要有：</strong></p><ul><li><strong>ThreadPoolExecutor.AbortPolicy</strong>（默认） ：抛出 RejectedExecutionException来拒绝新任务的处理。</li><li><strong>ThreadPoolExecutor.CallerRunsPolicy</strong> （建议）：调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li><li><strong>ThreadPoolExecutor.DiscardPolicy</strong> ：不处理新任务，直接丢弃掉。</li><li><strong>ThreadPoolExecutor.DiscardOldestPolicy</strong> ： 此策略将丢弃最早的未处理的任务请求。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,//线程池的核心线程数量</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,//线程池的最大线程数</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span></span><br><span class="line"><span class="params">                          TimeUnit unit,//时间单位</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，用来储存等待执行任务的队列</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="built_in">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h2><h3 id="Runnable、callcable定义任务"><a href="#Runnable、callcable定义任务" class="headerlink" title="Runnable、callcable定义任务"></a>Runnable、callcable定义任务</h3><p>​执行任务需要实现的 <strong>Runnable 接口</strong> 或 <strong>Callable接口</strong>（重写call() 方法）。两者的实现类都可以被 <strong>ThreadPoolExecutor</strong> 或 <strong>ScheduledThreadPoolExecutor</strong> 执行。ScheduledThreadPoolExecutor实际上是继承了 ThreadPoolExecutor并实现了 ScheduledExecutorService ，而 ScheduledExecutorService又实现了 ExecutorService。</p><p>​<strong><code>Runnable</code> 接口</strong> 不会返回结果或抛出检查异常，但是 <strong><code>Callable</code> 接口</strong> 可以。所以，如果任务不需要返回结果或抛出异常推荐使用 <strong><code>Runnable</code> 接口</strong> ，这样代码看起来会更加简洁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Runnable.java</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 被线程执行，没有返回值也无法抛出异常</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Callable.java</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算结果，或在无法这样做时抛出异常。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 计算得出的结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> 如果无法计算结果，则抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><p>使用execute（）或者submit（）函数将任务提交给<strong>ThreadPoolExecutor</strong> 或 <strong>ScheduledThreadPoolExecutor</strong> 执行，其中使用</p><p>Runnable 接口定义的任务<strong>不会返回结果或抛出检查异常</strong>，使用callable定义的任务可以。</p><p>**execute()**方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</p><p>**submit()**方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功，并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用 <code>get（long timeout，TimeUnit unit）</code>方法的话，如果在 <code>timeout</code> 时间内任务还没有执行完，就会抛出 <code>java.util.concurrent.TimeoutException</code>。</p><h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><ul><li><strong>shutdown（）</strong> :关闭线程池，线程池的状态变为 <code>SHUTDOWN</code>。线程池不再接受新任务了，但是队列里的任务得执行完毕。</li><li><strong>shutdownNow（）</strong> :关闭线程池，线程的状态变为 <code>STOP</code>。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Runnable使用ThreadPoolExecutor线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">threadPoolTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CORE_POOL_SIZE</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_POOL_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">QUEUE_CAPACITY</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">KEEP_ALIVE_TIME</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//使用阿里巴巴推荐的创建线程池的方式</span></span><br><span class="line">        <span class="comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span></span><br><span class="line"><span class="comment">//        ExecutorService executorService = Executors.newFixedThreadPool(10);</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">myThreadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                CORE_POOL_SIZE,</span><br><span class="line">                MAX_POOL_SIZE,</span><br><span class="line">                KEEP_ALIVE_TIME,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            myThreadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;CurrentThread name:&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;date：&quot;</span> + Instant.now());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//终止线程池</span></span><br><span class="line">        myThreadPool.shutdown();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            myThreadPool.awaitTermination(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Finished all threads&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Callable使用ThreadPoolExecutor线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">threadPoolTetsCallableReturn</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CORE_POOL_SIZE</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_POOL_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">QUEUE_CAPACITY</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">KEEP_ALIVE_TIME</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用阿里巴巴推荐的创建线程池的方式</span></span><br><span class="line">        <span class="comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                CORE_POOL_SIZE,</span><br><span class="line">                MAX_POOL_SIZE,</span><br><span class="line">                KEEP_ALIVE_TIME,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(QUEUE_CAPACITY),<span class="comment">//任务队列</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());<span class="comment">//饱和策略</span></span><br><span class="line">        <span class="comment">//返回值</span></span><br><span class="line">        List&lt;Future&lt;String&gt;&gt; futureList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//重写call（）方法</span></span><br><span class="line">        Callable&lt;String&gt; callable = <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="comment">//返回执行当前 Callable 的线程名字</span></span><br><span class="line">                <span class="keyword">return</span> Thread.currentThread().getName();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//提交任务到线程池</span></span><br><span class="line">            Future&lt;String&gt; future = executor.submit(callable);</span><br><span class="line">            <span class="comment">//将返回值 future 添加到 list，我们可以通过 future 获得 执行 Callable 得到的返回值</span></span><br><span class="line">            futureList.add(future);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Future&lt;String&gt; fut : futureList) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;::&quot;</span> + fut.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程池的工作流程"><a href="#线程池的工作流程" class="headerlink" title="线程池的工作流程"></a>线程池的工作流程</h2><ul><li>线程池中刚开始没有线程，当一个任务提交给线程池后，线程池会创建一个新线程来执行任务。</li><li>当线程数达到 corePoolSize 并没有线程空闲，这时再加入任务，新加的任务会被加入workQueue 队列排 队，直到有空闲的线程。</li><li>如果队列选择了<strong>有界队列</strong>（如果是无界队列，就没有救急线程的概念了），那么任务超过了队列大小时，会创建 maximumPoolSize - corePoolSize 数目的线程来救急。</li><li>如果线程到达 maximumPoolSize 仍然有新任务这时会执行拒绝策略。拒绝策略jdk提供了 4 种实现，其它著名框架也提供了实现：<ul><li>AbortPolicy 让调用者抛出 RejectedExecutionException 异常，这是默认策略</li><li>CallerRunsPolicy 让调用者运行任务</li><li>DiscardPolicy 放弃本次任务</li><li>DiscardOldestPolicy 放弃队列中最早的任务，本任务取而代之</li></ul></li></ul><p><img src="1.jpg"></p><h2 id="调度功能的实现：ScheduledThreadPoolExecutor"><a href="#调度功能的实现：ScheduledThreadPoolExecutor" class="headerlink" title="调度功能的实现：ScheduledThreadPoolExecutor"></a>调度功能的实现：ScheduledThreadPoolExecutor</h2><p>在<strong>任务调度线程池</strong>功能加入之前，可以使用 java.util.Timer 来实现定时功能，Timer 的优点在于简单易用，但由于所有任务都是由同一个线程来调度，因此所有任务都是<strong>串行执行</strong>的，同一时间只能有一个任务在执行，前一个任务的<strong>延迟</strong>或<strong>异常</strong>都将会影响到之后的任务。为了解决这个问题吗，引入了调度线程池，调度线程池同时继承自<code>ScheduledExecutorService</code> 和 <code>ThreadPoolExecutor</code>，<strong>我们可以在调度线程池里新建多个线程实现并行的延时或者定时执行任务</strong>。</p><p>构造方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public ScheduledThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                                   ThreadFactory threadFactory,</span><br><span class="line">                                   RejectedExecutionHandler handler) &#123;</span><br><span class="line">    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,</span><br><span class="line">          new DelayedWorkQueue(), threadFactory, handler); // 这里的 super 调用的是 ThreadPoolExecutor 类的构造方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看出最大线程数无限，也就是说对于核心线程和救急线程数量都没有限制，但救急线程存活时间为 0，即执行完就灭亡。</li><li>super 调用的是 ThreadPoolExecutor 类的构造方法，唯一的不同是基于 DelayedWorkQueue，这是一个基于堆的阻塞队列，在堆头加锁，并可以设置延时时间，这也是实现延时调度和定时调度的基础。</li></ul><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 1. 延时执行</span><br><span class="line">ScheduledExecutorService pool = Executors.newScheduledThreadPool(2); // 线程池大小为 2</span><br><span class="line"></span><br><span class="line">pool.schedule(() -&gt; &#123;</span><br><span class="line">    log.debug(&quot;task1&quot;);</span><br><span class="line">    sleep(2); // 睡眠 2 s</span><br><span class="line">&#125;, 1, TimeUnit.SECONDS); // 延时1s</span><br><span class="line"></span><br><span class="line">pool.schedule(() -&gt; &#123;</span><br><span class="line">    log.debug(&quot;task2&quot;);</span><br><span class="line">&#125;, 1, TimeUnit.SECONDS); // 延时1s</span><br><span class="line"></span><br><span class="line">/* 可以看到两个任务是同时执行的，都延时了1s</span><br><span class="line">21:01:27.906 c.TestTimer [pool-1-thread-1] - task1</span><br><span class="line">21:01:27.906 c.TestTimer [pool-1-thread-2] - task2</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">// 2. 定时执行</span><br><span class="line">ScheduledExecutorService pool = Executors.newScheduledThreadPool(1);</span><br><span class="line">log.debug(&quot;start...&quot;);</span><br><span class="line">pool.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">    log.debug(&quot;running...&quot;);</span><br><span class="line">&#125;, 1, 1, TimeUnit.SECONDS); // 任务对象；初始延时时间；时间间隔；时间单位</span><br><span class="line"></span><br><span class="line">/* 每隔一秒执行一次，但如果每个任务执行时间较长，会影响这个设置</span><br><span class="line">21:07:34.063 c.TestTimer [main] - start...</span><br><span class="line">21:07:35.195 c.TestTimer [pool-1-thread-1] - running...</span><br><span class="line">21:07:36.160 c.TestTimer [pool-1-thread-1] - running...</span><br><span class="line">21:07:37.161 c.TestTimer [pool-1-thread-1] - running...</span><br><span class="line">21:07:38.163 c.TestTimer [pool-1-thread-1] - running...</span><br><span class="line">...</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>注意：可以使用try-catch 处理异常或者 Future 的 get 方法处理异常。</p><h2 id="工厂方法-Executors"><a href="#工厂方法-Executors" class="headerlink" title="工厂方法 Executors"></a>工厂方法 Executors</h2><p>根据 ThreadPoolExecutor 的构造方法，JDK Executors 类中提供了众多工厂方法来创建各种用途的线程池：</p><h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool()"></a>newFixedThreadPool()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;()); // 不指定大小，默认为Integer.MAX_VALUE，相当于无界队列</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>特点<ul><li>核心线程数 &#x3D;&#x3D; 最大线程数（没有救急线程被创建），因此也无需超时时间</li><li>阻塞队列是无界的，可以放任意数量的任务</li><li>默认线程工厂，当然也可以自己定义线程工厂（起个好名字）</li></ul></li><li>评价<ul><li>适用于任务量已知，相对耗时的任务</li></ul></li></ul><h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor()"></a>newSingleThreadExecutor()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">    return new FinalizableDelegatedExecutorService</span><br><span class="line">        (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用场景：希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。任务执行完毕，这唯一的线程也不会被释放。</li><li>区别：<ul><li>与自己创建一个单线程串行执行任务的区别<ul><li>自己创建线程如果任务执行失败而终止那么没有任何补救措施，而 newSingleThreadExecutor() 线程池（其实其他线程池也是这样）还会新建一个线程，保证池的正常工作</li></ul></li><li>与 newFixedThreadPool(1) 的区别<ul><li>Executors.newSingleThreadExecutor() 线程个数始终为1，不能修改<ul><li>因为FinalizableDelegatedExecutorService 应用的是装饰器模式，只对外暴露了 ExecutorService 接口，因此不能调用 ThreadPoolExecutor 中特有的方法；</li></ul></li><li>Executors.newFixedThreadPool(1) 初始时为1，以后还可以修改<ul><li>因为对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改</li></ul></li></ul></li></ul></li></ul><h2 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool()"></a>newCachedThreadPool()</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                  60L, TimeUnit.SECONDS,</span><br><span class="line">                                  new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>特点<ul><li>核心线程数是 0， 最大线程数是 Integer.MAX_VALUE，意味着<ul><li>全部都是救急线程（救急线程的空闲生存时间是 60s，60s 后可以回收）</li><li>救急线程可以无限创建</li></ul></li><li>队列采用了 <code>SynchronousQueue</code> 实现特点是，它没有容量，没有线程来取是放不进去的，陷入阻塞（一手交钱、一手交货），感觉就是为 CachedThreadPool 设计的，只要有了救急线程来了任务就会立即被执行。</li></ul></li><li>评价<ul><li>整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲 1分钟后释放线程。适合任务数比较密集，但每个任务执行时间较短的情况。</li></ul></li></ul><h2 id="线程池源码"><a href="#线程池源码" class="headerlink" title="线程池源码"></a>线程池源码</h2><p><strong>execute源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">workerCountOf</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c &amp; CAPACITY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果任务为null，则抛出异常。</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">// ctl 中保存的线程池当前的一些状态信息</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  下面会涉及到 3 步 操作</span></span><br><span class="line">    <span class="comment">// 1.首先判断当前线程池中执行的任务数量是否小于 corePoolSize</span></span><br><span class="line">    <span class="comment">// 如果小于的话，通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.如果当前执行的任务数量大于等于 corePoolSize 的时候就会走到这里</span></span><br><span class="line">    <span class="comment">// 通过 isRunning 方法判断线程池状态，线程池处于 RUNNING 状态并且队列可以加入任务，该任务才会被加入进去</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">// 再次获取线程池状态，如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。</span></span><br><span class="line">        <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">            <span class="comment">// 如果当前线程池为空就新创建一个线程并执行。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. 通过addWorker(command, false)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span></span><br><span class="line">    <span class="comment">//如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过下图可以更好的对上面这 3 步做一个展示</p><p><img src="2.jpg"></p><h1 id="直接调用Thread类的run方法"><a href="#直接调用Thread类的run方法" class="headerlink" title="直接调用Thread类的run方法"></a>直接调用Thread类的run方法</h1><p>​new 一个 <code>Thread</code>，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p><p><strong>总结： 调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程创建 </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>保证接口的幂等性</title>
      <link href="/2022/05/28/%E4%BF%9D%E8%AF%81%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7/"/>
      <url>/2022/05/28/%E4%BF%9D%E8%AF%81%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>​所谓幂等，其实它是一个数学上的概念，在计算机编程领域中，幂等是指一个方法被多次重复执行的时候产生的影响和第一次执行的影响相同。之所以要考虑到幂等性问题，是因为在网络通信中，存在两种行为可能会导致接口被重复执行。</p><ol><li>用户的重复提交或者用户的恶意攻击，导致这个请求会被多次重复执行。</li><li>在分布式架构中，为了避免网络通信导致的数据丢失，在服务之间进行通信的时候都会设计超时重试的机制，而这种机制有可能导致服务端接口被重复调用。</li></ol><p>所以在程序设计中，对于数据变更类操作的接口，需要保证接口的幂等性。</p><span id="more"></span><p>而幂等性的核心思想，其实就是保证这个接口的执行结果只影响一次，后续即便再次调用，也不能对数据产生影响，所以基于这样一个诉求，常见的解决方法有很多。</p><ol><li><p>使用数据库的唯一约束实现幂等，比如对于数据插入类的场景，比如创建订单，因为订单号肯定是唯一的，所以如果是多次调用就会触发数据库的唯一约束异常，从而避免一个请求创建多个订单的问题。</p></li><li><p>使用redis里面提供的setNX指令，比如对于MQ消费的场景，为了避免MQ重复消费导致数据多次被修改的问题，可以在接受到MQ的消息时，把这个消息通过setNx写入到redis里面，一旦这个消息被消费过，就不会再次消费。</p></li><li><p>使用状态机来实现幂等，所谓的状态机是指一条数据的完整运行状态的转换流程，比如订单状态，因为它的状态只会向前变更，所以多次修改同一条数据的时候，一旦状态发生变更，那么对这条数据修改造成的影响只会发生一次。</p></li><li><p>token机制，防止页面重复提交</p><p>业务要求：页面的数据只能被点击提交一次<br>　　发生原因：由于重复点击或者网络重发，或者nginx重发等情况会导致数据被重复提交<br>解决办法：</p><p>集群环境：采用token加redis（redis单线程的，处理需要排队）<br>单JVM环境：采用token加redis或token加jvm内存</p><p>处理流程：</p><p>数据提交前要向服务的申请token，token放到redis或jvm内存，token有效时间<br>提交后后台校验token，同时删除token，生成新的token返回</p><p>token特点:要申请，一次有效性，可以限流</p></li><li><p>全局唯一ID</p><p>如果使用全局唯一ID，就是根据业务的操作和内容生成一个全局ID，在执行操作前先根据这个全局唯一ID是否存在，来判断这个操作是否已经执行。如果不存在则把全局ID，存储到存储系统中，比如数据库、redis等。如果存在则表示该方法已经执行。</p></li></ol><p>不管是什么方法，无非就是两种，</p><ul><li>要么就是接口只允许调用一次，比如唯一约束、基于redis的锁机制。</li><li>要么就是对数据的影响只会触发一次，比如幂等性、乐观锁。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 幂等性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的SetNX实现分布式锁</title>
      <link href="/2022/05/28/Redis%E7%9A%84SetNX%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2022/05/28/Redis%E7%9A%84SetNX%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis的SetNX实现分布式锁"><a href="#Redis的SetNX实现分布式锁" class="headerlink" title="Redis的SetNX实现分布式锁"></a>Redis的SetNX实现分布式锁</h1><p>分布式锁：目的是确保在多个线程并发时，只有一个线程在同一时刻操作这个业务或者这个方法、变量。在一个进程中，也就是一个jvm或者说应用中，很容易去处理控制，在<code>java.util</code>并发包中已经为我们提供了这些方法去加锁，比如<code>synchronized</code>关键字或者<code>Lock</code>锁，都可以处理。但是如果在分布式环境下，要保证多个线程同时只有1个能访问某个资源，就需要用到分布式锁。</p><p>SETnx命令：指的是set命令加上nx参数进行使用具体命令如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET key value [EX seconds] [PX milliseconds] [NX|XX]</span><br></pre></td></tr></table></figure><ul><li><code>EX second</code> ：设置键的过期时间为 second 秒。<code>SET key value EX second</code>效果等同于 SETEX key second value 。</li><li><code>PX millisecond </code>：设置键的过期时间为 millisecond 毫秒。 <code>SET key value PX millisecond </code>效果等同于<code> PSETEX key millisecond value</code> 。</li><li><code>NX</code> ：只在键不存在时，才对键进行设置操作。 <code>SET key value NX </code>效果等同于 <code>SETNX key value</code> 。</li><li><code>XX</code> ：只在键已经存在时，才对键进行设置操作。</li></ul><p>一般使用<code>setIfAbsent</code>，这个函数实现的功能与<code>setnx</code>命令一样，代表如果没有这个key则set成功获取到锁，否则set失败没有获取到锁。</p><span id="more"></span><h2 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h2><p>使用<code>setnx</code>命令方式虽然操作比较简单方便，但是会有如下问题：</p><blockquote><p>1.当前线程如果获得了锁就不能再重入了（在锁释放前不能再获得锁）。</p></blockquote><p>可以在再次获取锁时，如果锁被占用就get值，判断值是否是当前线程存的随机值，如果是则再次执行<code>set</code>命令重新上锁；当然为了保证原子性这些操作都要用<code>lua</code>脚本来执行。</p><blockquote><p>2.获取锁方式非阻塞，其它线程没有获取到锁就只能失败返回了，只适合于个别业务场景。</p></blockquote><p>可以使用<code>while</code>循环重复执行<code>setnx</code>命令，并设置一个超时时间退出循环。</p><blockquote><p>3.锁过期时间如果设置太短或者拿到锁的线程执行完方法耗时特别长，方法没等执行完，锁就自动释放了，然后别的线程也能拿到锁，导致不安全的操作。类似的还有几种情况：</p><p>因为网络延迟，等拿到锁时，锁已经过期了，可以设置超时时间远小于锁自动过期时间来解决。</p><p>程序拿到锁后进入GC导致程序暂定，恢复后锁过期了。</p><p>Redis所在的机器发生了时钟漂移（Clock Drift），时间向前跳跃导致锁提前过期。</p></blockquote><p>可以尽量把锁自动过期的时间设的冗余一些。但也不能彻底解决。</p><blockquote><p>4.锁自动过期后，第二个线程拿到锁开始操作，第一个拿到锁的等执行完回手就把别人的锁给删了，那么就会产生并发安全问题。</p></blockquote><p>可以在删除锁的时候先get值，判断值是否是当前线程存的随机值，只有相同才执行删锁的操作；当然也要使用<code>lua</code>脚本执行来保证原子性。</p><blockquote><p>5.在<code>Cluster</code>集群模式下，如果<code>redis</code>出现故障，进行主从切换，这个时候主机的锁如果还未同步到从机上，就会导致其他线程同样也可以获取到锁。</p></blockquote><p><strong>分布式锁需要满足的特性</strong></p><ul><li>互斥性。</li><li>锁超时。</li><li>支持阻塞和非阻塞。</li><li>可重入性。</li><li>高可用。</li></ul><p>综上：使用<code>setnx</code>命令来实现分布式锁并不是一个很严谨的方案，如果是Java技术栈，我们可以使用<strong>Redisson</strong></p><p><a href="https://juejin.cn/post/6844903839276122119">Redisson参考</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU0OTE4MzYzMw==&mid=2247506890&idx=3&sn=e8799537f21851a8dd84be43374e33ab&chksm=fbb15234ccc6db22e742ee2c79bf47d75f22094ce6978bf0954c5dac245aeaa3dc6ccd2cae09&scene=27">分布式锁参考</a></p>]]></content>
      
      
      <categories>
          
          <category> 分布式实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式锁 </tag>
            
            <tag> Redis的Setnx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM类加载机制</title>
      <link href="/2022/05/27/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
      <url>/2022/05/27/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Class类文件的结构"><a href="#Class类文件的结构" class="headerlink" title="Class类文件的结构"></a><strong>Class类文件的结构</strong></h1><p>​任何一个Class文件都对应着唯一的一个类或接口的定义信息，但是反过来说，类或接口并不一定都得定义在文件里（譬如类或接口也可以动态生成，直接送入类加载器中</p><p>​根据 Java 虚拟机规范，Class 文件通过 ClassFile 定义，有点类似 C 语言的结构体。这种伪结构中只有两种数据类型：“无符号数”和“表”。后面的解析都要以这两种数据类型为基础无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。·表是由多个无符号数或者其他表作为数据项构成的复合数据类型，为了便于区分，所有表的命名都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视作是一张表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic; <span class="comment">//Class 文件的标志 确定这个文件是否为</span></span><br><span class="line">一个能被虚拟机接受的Class文件</span><br><span class="line">    u2             minor_version;<span class="comment">//Class 的小版本号</span></span><br><span class="line">    u2             major_version;<span class="comment">//Class 的大版本号</span></span><br><span class="line">    u2             constant_pool_count;<span class="comment">//常量池的数量  容量计数值</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count<span class="number">-1</span>];<span class="comment">//常量池</span></span><br><span class="line">    u2             access_flags;<span class="comment">//Class 的访问标记 权限标志</span></span><br><span class="line">    u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">    u2             super_class;<span class="comment">//父类</span></span><br><span class="line">    u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">    u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">    u2             fields_count;<span class="comment">//Class 文件的字段属性 描述接口或类中声明的变量</span></span><br><span class="line">    field_info     fields[fields_count];<span class="comment">//一个类可以有多个字段</span></span><br><span class="line">    u2             methods_count;<span class="comment">//Class 文件的方法数量</span></span><br><span class="line">    method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">    u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">    attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="为什么说java是平台无关性"><a href="#为什么说java是平台无关性" class="headerlink" title="为什么说java是平台无关性"></a><strong>为什么说java是平台无关性</strong></h1><p>​在 Java 中各种不同平台的Java虚拟机，以及所有平台都统一支持的程序存储格式——字节码（Byte Code），JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。Java语言中的各种语法、关键字、常量变量和运算符号的语义最终都会由多条字节码指令组合来表达。</p><h1 id="类加载过程："><a href="#类加载过程：" class="headerlink" title="类加载过程："></a><strong>类加载过程：</strong></h1><p>​在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，java天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。</p><p>​整个生命周期将会经历加载（Loading）、<strong>验证（Verification）、准备（Preparation）、解析（Resolution）</strong>、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析三个部分统称为<strong>连接（Linking）</strong>。</p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><ol><li>通过全类名获取定义此类的二进制字节流</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构，这部分数据存储在元空间中。</li><li>在堆内存中生成一个代表该类的 java.lang.Class 对象，作为方法区这些数据的访问入口</li></ol><p>​一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 loadClass() 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。</p><p>​<strong>所有的类都由类加载器加载，加载的作用就是将.class文件加载到内存。</strong></p><p>注意：加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，而<strong>解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始， 这是为了支持Java语言的动态绑定特性（也称为运行时绑定或晚期绑定）类加载阶段并不知道它的实例对象是什么</strong>，没错这就是我们前面介绍调用方法字节码指令时的 <code>invokevirtual</code> 虚方法，后面在讲运行期（编译器）优化的方法内联时还会遇到多态的，可见多态这个特性对 Java 产生了多么深远的影响。</p><h2 id="验证："><a href="#验证：" class="headerlink" title="验证："></a><strong>验证：</strong></h2><p>​验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合Java虚拟机约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</p><h2 id="准备："><a href="#准备：" class="headerlink" title="准备："></a><strong>准备：</strong></h2><p>​<strong>准备阶段是正式为类变量也就是static变量分配内存并设置类变量初始值的阶段</strong>，这些内存在1.7中将在方法区中分配。但是在java1.8之后类变量会随着Class对象一起存放在java堆中。</p><ol><li><p>这时候进行内存分配的仅包括类变量（ Class Variables ，即静态变量，被 static 关键字修饰的变量，只与类相关，因此被称为类变量），而不包括实例变量。实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</p></li><li><p>JDK 7 之前，HotSpot 使用永久代来实现方法区的时候，实现是完全符合这种逻辑概念的。 而在 JDK 7 及之后，HotSpot 已经把原本放在永久代的字符串常量池、静态变量等移动到堆中，这个时候类变量则会随着 Class 对象一起存放在 Java 堆中。</p></li><li><p>这里所设置的初始值”通常情况”下是数据类型默认的零值（如 0、0L、null、false 等）</p><ul><li><p><strong>普通 static 变量分配空间和赋值是两个步骤，分配空间在准备阶段完成，赋值在初始化阶段完成</strong></p></li><li><p>如果 static 变量是 final 的，但属于引用类型，那么赋值也会在初始化阶段完成</p></li><li><p>如果 static 变量是 final 的基本类型，以及字符串常量，那么编译阶段值就确定了，赋值在准备阶段完成</p></li></ul></li></ol><h2 id="解析："><a href="#解析：" class="headerlink" title="解析："></a><strong>解析：</strong></h2><p>​解析阶段是虚拟机将<strong>常量池内的符号引用替换为直接引用的过程</strong>，也就是得到类或者字段、方法在内存中的指针或者偏移量。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行。</p><p>​符号引用就是一组符号来描述目标，可以是任何字面量。<strong>直接引用</strong>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。<strong>通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</strong></p><h2 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a><strong>初始化：</strong></h2><p>初始化阶段是执行初始化方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。</p><p>​对于 <cinit>()V方法的调用，虚拟机会确保这个类的<code>『构造方法』</code>其在多线程环境中的安全性。如果多个线程同时去初始化一个类，<strong>那么只会有一个线程去执行这个类的 <code>&lt;clinit&gt;()</code> 方法</strong>，其他线程都需要阻塞等待，直到活动线程执行 <code>&lt;clinit&gt;()</code> 方法完毕，但如果执行<code>&lt;clinit&gt;()</code>方法后，其他线程唤醒之后不会再次进入 <code>&lt;clinit&gt;()</code> 方法。<strong>同一个加载器下，一个类型只会初始化一次。</strong>因为<cinit>()V方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起多个进程阻塞，并且这种阻塞很难被发现。</cinit></cinit></p><p>对于线程安全这个特性，可以<strong>应用于静态内部类实现的单例模式：</strong>（懒惰初始化，线程安全，但不能传参）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 私有的构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 利用类加载的懒惰特性，创建一个静态内部类（可以访问外部类的资源）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LazyHolder</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">SINGLETON</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;lazy holder init&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 只有调用 getInstance方法才会触发内部类的加载、连接、初始化，才会创建单例对象，而且是线程安全的 (JVM保证)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Singleton.getInstance(); <span class="comment">// 静态内部类的单例模式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>静态内部类的优点是：外部类加载时并不需要立即加载内部类，内部类不被加载则不去初始化INSTANCE，故而不占内存。具体来说当Singleton类第一次被加载时，并不需要去加载LazyHolder，只有当getInstance()方法第一次被调用时，使用INSTANCE的时候,才会导致虚拟机加载LazyHolder类。这种方法不仅能确保线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。</p><p>也就是说我们利用了调用得到单例的getInstance的下面介绍的第一条属性，也就是一个静态字段（Singleinstanc）被使用，因此此时则会进行静态内部类的初始化。</p><p>对于初始化阶段，虚拟机严格规范了有且只有 5 种情况下，必须对类进行初始化(其余情况只有主动去使用类才会初始化类)：</p><ol><li>当遇到 new 、 getstatic、putstatic 或 invokestatic 这 4 条直接码指令时，比如 new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。</li></ol><ul><li><ul><li>当 jvm 执行 new 指令时会初始化类。即当程序创建一个类的实例对象。</li><li>当 jvm 执行 getstatic 指令时会初始化类。即程序访问类的静态变量(不是静态常量（<strong>基本类型和字符串常量</strong>），常量会被加载到运行时常量池)。</li><li>当 jvm 执行 putstatic 指令时会初始化类。即程序给类的静态变量赋值。</li><li>当 jvm 执行 invokestatic 指令时会初始化类。即程序调用类的静态方法。</li></ul></li></ul><ol><li><p>使用 java.lang.reflect 包的方法对类进行反射调用时如 Class.forname(“…”), newInstance() 等等。如果类没初始化，需要触发其初始化。</p><ul><li>类对象.class 不会触发初始化</li></ul></li><li><p>初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。</p></li><li><p>当虚拟机启动时，用户需要定义一个要执行的主类 (包含 main 方法的那个类)，虚拟机会先初始化这个类。</p></li><li><p>MethodHandle 和 VarHandle 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用， 就必须先使用 findStaticVarHandle 来初始化要调用的类。</p></li><li><p>「补充，来自<a href="https://github.com/Snailclimb/JavaGuide/issues/745">issue745</a>」 当一个接口中定义了 JDK8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</p></li></ol><h2 id="卸载："><a href="#卸载：" class="headerlink" title="卸载："></a><strong>卸载：</strong></h2><p>​该类的class被GC，卸载类需要满足 3 个要求:</p><ol><li>该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。</li><li>该类没有在其他任何地方被引用</li><li>该类的类加载器的实例已被 GC</li></ol><p>​jdk 自带的 BootstrapClassLoader, ExtClassLoader, AppClassLoader 负责加载 jdk 提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。</p><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a><strong>类加载器</strong></h1><p>​JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自java.lang.ClassLoader：</p><ol><li>BootstrapClassLoader(启动类加载器) ：最顶层的加载类，由 C++实现，负责加载 %JAVA_HOME%&#x2F;lib目录下的 jar 包和类或者被 -Xbootclasspath参数指定的路径中的所有类。</li><li>ExtensionClassLoader(扩展类加载器) ：主要负责加载 %JRE_HOME%&#x2F;lib&#x2F;ext 目录下的 jar 包和类，或被 java.ext.dirs 系统变量所指定的路径下的 jar 包。</li><li>AppClassLoader(应用程序类加载器) ：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。</li></ol><h1 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a><strong>双亲委派模型</strong></h1><p>​在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派给父类加载器的 loadClass() ，因此所有的请求最终都应该传送到顶层的启动类加载器 BootstrapClassLoader 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为 null 时，会使用启动类加载器 BootstrapClassLoader 作为父类加载器。</p><p><img src="1.png" alt="1"></p><p>​<strong>好处：</strong>不管是哪个加载器加载，最终都会委托到 BootStrap ClassLoader 进行加载，这样保证了使用不同的类加载器得到的都是同一个结果。</p><p>​双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 java.lang.Object 类的话，那么程序运行的时候，系统就会出现多个不同的 Object 类。</p><h1 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a><strong>自定义类加载器</strong></h1><h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><ol><li>想加载非 classpath 随意路径中的类文件</li><li>都是通过接口来使用实现，希望解耦时，常用在框架设计</li><li>这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器</li></ol><h2 id="实现方法："><a href="#实现方法：" class="headerlink" title="实现方法："></a>实现方法：</h2><ol><li>继承 ClassLoader 父类</li><li><strong>要遵从双亲委派机制，重写 findClass 方法</strong>（重写 loadClass 方法，就不会走双亲委派机制）</li><li>读取类文件的字节码</li><li>调用父类的 defineClass 方法来加载类</li><li>使用者调用该类加载器的 loadClass 方法</li></ol><h1 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h1><p>​jvm推荐我们使用双亲委托机制，主要是保证了相同的类不会被重复加载。但是Java 提供了很多服务提供者接口（Service Provider Interface，SPI），允许第三方为这些接口提供实现。常见的 SPI 有 JDBC、JCE、JNDI、JAXP 和 JBI 等，在这些SPI场景中，却无法使用双亲委派机制。具体如JNDI服务，它的代码由启动类加载器来完成加载。但 JNDI 存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的 ClassPath 下的 JNDI 服务提供者接口<code>（Service Provider Interface，SPI）</code>的代码，也就是说<strong>高层提供了统一接口让低层去实现，同时又要是在高层加载（或实例化）低层的类时。</strong>现在问题来了，启动类加载器是绝不可能找到并加载这些代码的，<strong>必须通过线程上下文类加载器（TCCL）来帮助高层的ClassLoader找到并加载该类</strong></p><p>​解决方法：</p><p>​<strong>线程上下文类加载器</strong>（Thread Context ClassLoader）。<strong>这个类加载器可以通过 java.lang.Thread 类的 getContextClassLoader()与setContextClassLoader(ClassLoader cl)分别来获取和设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</strong></p><p>​在JDK 6时，JDK提供了 <code>java.util.ServiceLoader</code> 类，以 <code>META-INF/services</code> 中的配置信息，辅以责任链模式对SPI的实现类进行加载。</p><p><strong>下面我们对JDBC驱动加载过程进分析</strong></p><ul><li>JDBC（Java Database Connectivity）：即Java数据库连接，它是一种可以执行SQL语句的Java API。程序可通过JDBC API连接到关系数据库，并使用结构化查询语言（SQL，数据库标准的查询语言）来完成对数据库的查询、更新。与其他数据库编程环境相比，JDBC为数据库开发提供了标准的API，所以使用JDBC开发的数据库应用可以跨平台运行，而且可以跨数据库（如果全部使用标准的SQL）。</li><li>JDBC 驱动程序：最早的时候，Sun公司希望自己开发一组Java API，程序员通过这组Java API即可操作所有的数据库系统，但后来Sun发现这个目标具有不可实现性——因为数据库系统太多了，而且各数据库系统的内部特性又各不相同。后来Sun就制定了一组标准的API，它们只是接口，没有提供实现类——<strong>这些实现类由各数据库厂商提供实现，这些实现类就是驱动程序</strong>，数据库驱动程序是JDBC程序和数据库之间的转换层，数据库驱动程序负责将JDBC调用映射成特定的数据库调用。</li></ul><p>一般使用 JDBC 来访问 mysql 数据库的流程为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载 mysql 的驱动</span></span><br><span class="line">Class.forName(“com.mysql.jdbc.Driver”);</span><br><span class="line"><span class="comment">// 用管理 JDBC 驱动的服务类获取数据库连接对象</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(String url, String user, String pass); </span><br><span class="line"><span class="comment">// 通过 connection 对象创建用于执行SQL语句的 statement 对象</span></span><br><span class="line"><span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br></pre></td></tr></table></figure><p>在加载驱动时会触发com.mysql.jdbc.Driver 类的初始化，在这个类里有一段静态代码块：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> <span class="keyword">extends</span> <span class="title class_">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title class_">java</span>.sql.Driver &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DriverManager.registerDriver(<span class="keyword">new</span> <span class="title class_">Driver</span>());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException var1) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​代码中看出Driver 类会自动新建一个 Driver 的对象，并调用 DriverManager.registerDriver 把自己注册到 DriverManager 中去。</p><p>​在 JDK 6之后不写Class.forName(“com.mysql.jdbc.Driver”)也是可以让 com.mysql.jdbc.Driver 正确加载的。</p><p>这正是上面所说的增加的 <code>java.util.ServiceLoader</code> 类机制，在我们调用DriverManager.getConnection 方法获取连接时，调用的是静态方法会初始化该类，进而执行其静态代码块：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DriverManager</span> &#123;</span><br><span class="line">    <span class="comment">// 注册驱动的集合 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers </span><br><span class="line">        = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 初始化驱动 </span></span><br><span class="line">    <span class="keyword">static</span> &#123; </span><br><span class="line">        loadInitialDrivers(); </span><br><span class="line">        println(<span class="string">&quot;JDBC DriverManager initialized&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>继续看 loadInitialDrivers() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loadInitialDrivers</span><span class="params">()</span> &#123;</span><br><span class="line">    String drivers; </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//读取系统属性</span></span><br><span class="line">        drivers = AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> System.getProperty(<span class="string">&quot;jdbc.drivers&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        drivers = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1) 使用 ServiceLoader 机制加载驱动类，即 SPI</span></span><br><span class="line">    AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);</span><br><span class="line">            Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(driversIterator.hasNext()) &#123;</span><br><span class="line">                    driversIterator.next();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span>(Throwable t) &#123;</span><br><span class="line">                <span class="comment">// Do nothing</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;DriverManager.initialize: jdbc.drivers = &quot;</span> + drivers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2）使用 jdbc.drivers 定义的驱动名加载驱动类</span></span><br><span class="line">    <span class="keyword">if</span> (drivers == <span class="literal">null</span> || drivers.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] driversList = drivers.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">    println(<span class="string">&quot;number of Drivers:&quot;</span> + driversList.length);</span><br><span class="line">    <span class="keyword">for</span> (String aDriver : driversList) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            println(<span class="string">&quot;DriverManager.Initialize: loading &quot;</span> + aDriver);</span><br><span class="line">            <span class="comment">// 这里的 ClassLoader.getSystemClassLoader() 就是应用程序类加载器</span></span><br><span class="line">            Class.forName(aDriver, <span class="literal">true</span>, ClassLoader.getSystemClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            println(<span class="string">&quot;DriverManager.Initialize: load failed: &quot;</span> + ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看出JDBC中的DriverManager的加载Driver的步骤顺序依次是：</p><p>​通过SPI方式，读取 META-INF&#x2F;services 下文件中的类名，使用TCCL加载；<br>​通过System.getProperty(“jdbc.drivers”)获取设置，然后通过系统类加载器加载。</p><p>在上面（2）标注下发现它最后是使用 Class.forName 完成类的加载和初始化，关联的是应用程序类加载器，因此 可以顺利完成类加载；</p><p>上面（1）标注下就是采用了Service Provider Interface （SPI）， 要求在 jar 包的 META-INF&#x2F;services 包下，文件名命名为接口的全限定名，文件内容是所有实现接口的类名称，也就是驱动程序的类名称，只要按照约定设计jar包，那么将来就可以配合 ServiceLoader 来根据接口找到实现类并加载实例化。</p><p><img src="1.jpg"></p><p>这样就可以使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ServiceLoader&lt;接口类型&gt; allImpls = ServiceLoader.load(接口类型.class); </span><br><span class="line">Iterator&lt;接口类型&gt; iter = allImpls.iterator(); </span><br><span class="line"><span class="keyword">while</span>(iter.hasNext()) &#123; </span><br><span class="line">    iter.next();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>来得到实现类</p><p>再看下看ServiceLoader.load(Class)的代码，的确如此：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ServiceLoader <span class="title function_">load</span><span class="params">(Class service)</span> &#123;</span><br><span class="line">   <span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">   <span class="keyword">return</span> ServiceLoader.load(service, cl);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>ContextClassLoader默认存放了AppClassLoader的引用，由于它是在运行时被放在了线程中，所以不管当前程序处于何处（BootstrapClassLoader或是ExtClassLoader等），在任何需要的时候都可以用Thread.currentThread().getContextClassLoader()取出应用程序类加载器来完成需要的操作。</p><p><strong>总结SPI机制就是：JDK提供了一种帮第三方实现者加载服务（如数据库驱动、日志库）的便捷方式，只要遵循约定（把类名写在&#x2F;META-INF里），那当我启动时我会去扫描所有jar包里符合约定的类名，再调用forName加载，但我的ClassLoader是没法加载的，那就把它加载到当前执行线程的TCCL里，后续你可以在驱动实现类的static代码块中new一个自己的实例注册给我就行了也就是注册到系统的java.sql.DriverManager类中，其实就是add到它的一个名为registeredDrivers的静态成员CopyOnWriteArrayList中</strong></p><p>接着我们再看java.sql.DriverManager.getConnection()。它最终调用了以下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">(</span></span><br><span class="line"><span class="params">    String url, java.util.Properties info, Class&lt;?&gt; caller)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="comment">/* 传入的caller由Reflection.getCallerClass()得到，该方法</span></span><br><span class="line"><span class="comment">    \* 可获取到调用本方法的Class类，这获取到的是当前应用的类加载器</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">callerCL</span> <span class="operator">=</span> caller != <span class="literal">null</span> ? caller.getClassLoader() : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span>(DriverManager.class) &#123;</span><br><span class="line">      <span class="keyword">if</span> (callerCL == <span class="literal">null</span>) &#123;</span><br><span class="line">        callerCL = Thread.currentThread().getContextClassLoader();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(url == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SQLException</span>(<span class="string">&quot;The url cannot be null&quot;</span>, <span class="string">&quot;08001&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">SQLException</span> <span class="variable">reason</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 遍历注册到registeredDrivers里的Driver类</span></span><br><span class="line">    <span class="keyword">for</span>(DriverInfo aDriver : registeredDrivers) &#123;</span><br><span class="line">      <span class="comment">// 检查Driver类有效性</span></span><br><span class="line">      <span class="keyword">if</span>(isDriverAllowed(aDriver.driver, callerCL)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          println(<span class="string">&quot;   trying &quot;</span> + aDriver.driver.getClass().getName());</span><br><span class="line">          <span class="comment">// 调用com.mysql.jdbc.Driver.connect方法获取连接</span></span><br><span class="line">          <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> aDriver.driver.connect(url, info);</span><br><span class="line">          <span class="keyword">if</span> (con != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Success!</span></span><br><span class="line">            <span class="keyword">return</span> (con);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">          <span class="keyword">if</span> (reason == <span class="literal">null</span>) &#123;</span><br><span class="line">            reason = ex;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;   skipping: &quot;</span> + aDriver.getClass().getName());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SQLException</span>(<span class="string">&quot;No suitable driver found for &quot;</span>+ url, <span class="string">&quot;08001&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isDriverAllowed</span><span class="params">(Driver driver, ClassLoader classLoader)</span> &#123;</span><br><span class="line">   <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">if</span>(driver != <span class="literal">null</span>) &#123;</span><br><span class="line">     Class&lt;?&gt; aClass = <span class="literal">null</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 传入的classLoader为调用getConnetction的当前类加载器，从中寻找driver的class对象</span></span><br><span class="line">       aClass =  Class.forName(driver.getClass().getName(), <span class="literal">true</span>, classLoader);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">       result = <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">// 注意，只有同一个类加载器中的Class使用==比较时才会相等，此处就是校验用户注册Driver时该Driver所属的类加载器与调用时的是否同一个</span></span><br><span class="line">    <span class="comment">// driver.getClass()拿到就是当初执行Class.forName(&quot;com.mysql.jdbc.Driver&quot;)时的应用AppClassLoader</span></span><br><span class="line">     result = ( aClass == driver.getClass() ) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>由于TCCL本质就是当前应用类加载器，所以之前的初始化就是加载在当前的类加载器中，这一步就是校验存放的driver是否属于调用者的Classloader。例如在下文中的tomcat里，多个webapp都有自己的Classloader，如果它们都自带  mysql-connect.jar包，那底层Classloader的DriverManager里将注册多个不同类加载器的Driver实例，想要区分只能靠TCCL了。</strong></p><h1 id="Tomcat与spring的类加载器案例"><a href="#Tomcat与spring的类加载器案例" class="headerlink" title="Tomcat与spring的类加载器案例"></a>Tomcat与spring的类加载器案例</h1><p> 接下来将介绍《深入理解java虚拟机》一书中的案例（部分内容来自于书中原文）</p><p>Tomcat中的类加载器<br> 在Tomcat目录结构中，有三组目录（“&#x2F;common&#x2F;”,“&#x2F;server&#x2F;”和“shared&#x2F;”）可以存放公用Java类库，此外还有第四组Web应用程序自身的目录“&#x2F;WEB-INF&#x2F;*”，把java类库放置在这些目录中的含义分别是：</p><ul><li>放置在common目录中：类库可被Tomcat和所有的Web应用程序共同使用。</li><li>放置在server目录中：类库可被Tomcat使用，但对所有的Web应用程序都不可见。</li><li>放置在shared目录中：类库可被所有的Web应用程序共同使用，但对Tomcat自己不可见。</li><li>放置在&#x2F;WebApp&#x2F;WEB-INF目录中：类库仅仅可以被此Web应用程序使用，对Tomcat和其他Web应用程序都不可见。</li></ul><p> 为了支持这套目录结构，并对目录里面的类库进行加载和隔离，Tomcat自定义了多个类加载器，这些类加载器按照经典的双亲委派模型来实现，如下图所示</p><p><img src="2.jpg"></p><p> 最上面的3个类加载器是JDK默认提供的类加载器，这3个加载器的作用前面已经介绍过了。而  CommonClassLoader、CatalinaClassLoader、SharedClassLoader 和  WebAppClassLoader 则是 Tomcat 自己定义的类加载器，它们分别加载  &#x2F;common&#x2F;、&#x2F;server&#x2F;、&#x2F;shared&#x2F; 和 &#x2F;WebApp&#x2F;WEB-INF&#x2F;* 中的 Java 类库。其中 WebApp  类加载器和 Jsp 类加载器通常会存在多个实例，每一个 Web 应用程序对应一个 WebApp 类加载器，每一个 JSP 文件对应一个 Jsp  类加载器。</p><p>从图中的委派关系中可以看出，CommonClassLoader 能加载的类都可以被 CatalinaClassLoader 和  SharedClassLoader 使用，而 CatalinaClassLoader 和 SharedClassLoader  自己能加载的类则与对方相互隔离。WebAppClassLoader 可以使用 SharedClassLoader 加载到的类，但各个  WebAppClassLoader 实例之间相互隔离。而 JasperLoader 的加载范围仅仅是这个 JSP 文件所编译出来的那一个  Class，它出现的目的就是为了被丢弃：当服务器检测到 JSP 文件被修改时，会替换掉目前的 JasperLoader  的实例，并通过再建立一个新的 Jsp 类加载器来实现 JSP 文件的 HotSwap 功能。</p><h1 id="Spring加载问题"><a href="#Spring加载问题" class="headerlink" title="Spring加载问题"></a>Spring加载问题</h1><p> Tomcat  加载器的实现清晰易懂，并且采用了官方推荐的“正统”的使用类加载器的方式。这时作者提一个问题：如果有 10 个 Web  应用程序都用到了spring的话，可以把Spring的jar包放到 common 或 shared 目录下让这些程序共享。Spring  的作用是管理每个web应用程序的bean，getBean时自然要能访问到应用程序的类，而用户的程序显然是放在 &#x2F;WebApp&#x2F;WEB-INF  目录中的（由 WebAppClassLoader 加载），那么在 CommonClassLoader 或 SharedClassLoader  中的 Spring 容器如何去加载并不在其加载范围的用户程序（&#x2F;WebApp&#x2F;WEB-INF&#x2F;）中的Class呢？</p><p>解答<br>spring根本不会去管自己被放在哪里，它统统使用TCCL来加载类，而TCCL默认设置为了WebAppClassLoader，也就是说哪个WebApp应用调用了spring，spring就去取该应用自己的WebAppClassLoader来加载bean，简直完美~</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Java类加载 </tag>
            
            <tag> Java类加载器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM内存区域</title>
      <link href="/2022/05/12/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
      <url>/2022/05/12/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="java的内存区域"><a href="#java的内存区域" class="headerlink" title="java的内存区域"></a>java的内存区域</h1><h2 id="java的主要运行时数据区域"><a href="#java的主要运行时数据区域" class="headerlink" title="java的主要运行时数据区域"></a>java的主要运行时数据区域</h2><h3 id="堆Heap（线程共有）："><a href="#堆Heap（线程共有）：" class="headerlink" title="堆Heap（线程共有）："></a><strong>堆Heap（线程共有）</strong>：</h3><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，（就是新建的对象的实例数据），几乎所有的对象实例以及数组都在这里分配内存。</strong>Java堆是垃圾收集器管理的内存区域（与GC原理相关分为新生代和老年代再细致一点有：Eden、Survivor、Old），因此一些资料中它也被称作“GC堆”（Garbage CollectedHeap）Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的  。</p><p>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p><ol><li>新生代内存(Young Generation)</li><li>老生代(Old Generation)</li><li>永久代(Permanent Generation)</li></ol><p>1.8之后堆被分为四区，分别为eden区、s0(“From)区、s1(“To”)和tentired，永久代被元空间代替，并从堆中分离存放于直接内存中。</p><ul><li>在初始阶段，新创建的对象被分配到Eden区，survivor的两块空间都为空。</li><li>当Eden区满了的时候，minor GC触发</li><li>经过扫描与标记，存活的对象被复制到S0，不存活的对象被回收</li><li>在下一次的Minor  GC中，Eden区的情况和上面一致，没有引用的对象被回收，存活的对象被复制到survivor区。然而在survivor区，S0的所有的数据都被复制到S1，需要注意的是，在上次minor  GC过程中移动到S0中的相同存活的对象在复制到S1后其年龄要加1。此时Eden区S0区被清空，所有存活的数据都复制到了S1区，并且S1区存在着年龄不一样的对象（重点）</li><li>再下一次MinorGC则重复这个过程，这一次survivor的两个区对换，存活的对象被复制到S0，存活的对象年龄加1，Eden区和另一个survivor区被清空。</li></ul><span id="more"></span><p><img src="5.png"></p><p><img src="1.png"></p><h3 id="方法区（线程共有）："><a href="#方法区（线程共有）：" class="headerlink" title="方法区（线程共有）："></a><strong>方法区（线程共有）</strong>：</h3><p>是各个线程共享的内存区域。当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 <strong>类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据（原始的类的类型信息存储在方法区中）</strong>。</p><p>在1.8以前方法区被描述为堆的一个逻辑部分，设计团队选择把收集器的分代设计扩展至方法区，或者说使用永久代来实现方法区而已，这样使得HotSpot的垃圾收集器能够像管理Java堆一样管理这部分内存，省去专门为方法区编写内存管理代码的工作。这样很容易导致这种设计导致了Java应用更容易遇内存溢出的问题（永久代有-XX：MaxPermSize的上限，</p><h4 id="方法区的版本变化："><a href="#方法区的版本变化：" class="headerlink" title="方法区的版本变化："></a>方法区的版本变化：</h4><p>1.6</p><ul><li>静态常量池在Class文件中。</li><li>运行时常量池在Perm Gen区(也就是方法区)中。</li><li>字符串常量池在运行时常量池中。</li></ul><p>1.7</p><ul><li>静态常量池在Class文件中。</li><li>运行时常量池依然在Perm  Gen区(也就是方法区)中。在JDK7版本中，永久代的转移工作就已经开始了，将譬如符号引用转移到了native heap（使用到的本地的C&#x2F;C++ API时，C&#x2F;C++API 申请的内存）；字面量转移到了java heap；类的静态变量转移到了java heap。但是运行时常量池依然还存在，只是很多内容被转移，其只存着这些被转移的引用。</li><li>字符串常量池被分配到了Java堆的主要部分。也就是字符串常量池从运行时常量池分离出来了。</li></ul><p>1.8</p><ul><li>静态常量池在Class文件中。</li><li>J**JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)**元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。其主要用于存放一些元数据。</li><li>字符串常量池存在于Java堆中。</li></ul><p>​在1.8以后方法区的实现变成了元空间。元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 MaxPermSize 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。当元空间溢出时会得到如下错误： java.lang.OutOfMemoryError: MetaSpace可以使用 -XX：MaxMetaspaceSize 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。-XX：MetaspaceSize 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。</p><h3 id="运行时常量池（线程共享）："><a href="#运行时常量池（线程共享）：" class="headerlink" title="运行时常量池（线程共享）："></a><strong>运行时常量池（线程共享）：</strong></h3><p> 运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件即字节码文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种<strong>字面量（整数、浮点数和字符串字面量）与符号引用（类符号引用、字段符号引用、方法符号引用和接口方法符号引用）</strong>(在静态常量池的<strong>符号引用有一部分是会被转变为直接引用</strong>的，比如说类的<strong>静态方法或私有方法，实例构造方法，父类方法</strong>，这是因为这些方法不能被重写其他版本，所以能在加载的时候就可以将符号引用转变为直接引用，而其他的<strong>一些方法是在这个方法被第一次调用的时候才会将符号引用转变为直接引用的</strong>)，<strong>这两部分内容将在类加载后存放到方法区的运行时常量池中。</strong> <strong>JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</strong></p><h3 id="字符串常量池（线程共享）"><a href="#字符串常量池（线程共享）" class="headerlink" title="字符串常量池（线程共享）"></a>字符串常量池（线程共享）</h3><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p><ul><li>每当我们使用字面量（String  s&#x3D;“1”;）创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就将此字符串对象的地址赋值给引用s（引用s在Java栈。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中，并将此字符串对象的地址赋值给引用s（引用s在Java栈中）。</li><li>每当我们使用关键字new（String s&#x3D;new  String(”1”);）创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么不再在字符串常量池创建该字符串对象，而直接堆中创建该对象的副本，然后将堆中对象的地址赋值给引用s，如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中，然后在堆中创建该对象的副本，然后将堆中对象的地址赋值给引用s。</li><li>创建字符串变量拼接的原理是 StringBuilder（1.8，线程不安全的，所以比StringBuffer速度快，拼接创建的是对象，存在堆中。</li><li>可以调用intern()方法将这个字符串对象尝试放入字符串常量池，如果有则不会放入，如果没有则放入字符串常量池。</li></ul><p>JDK1.7 之前，字符串常量池存放在永久代。因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。<strong>JDK1.7 字符串常量池和静态变量从永久代移动了 Java 堆中。</strong></p><h3 id="虚拟机栈（线程私有）："><a href="#虚拟机栈（线程私有）：" class="headerlink" title="虚拟机栈（线程私有）："></a><strong>虚拟机栈（线程私有）：</strong></h3><p>它的生命周期和线程相同，<strong>虚拟机栈描述的方法执行时的内存模型</strong>，方法调用的数据需要通过栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。而每个栈帧中都拥有方法运行时的信息：<strong>局部变量表、操作数栈、动态链接（</strong>指向运行时常量池中该栈帧所属方法的引用<strong>）、方法返回地址</strong>（或方法正常退出或者异常退出的定义）。</p><ul><li><strong>局部变量表：</strong>主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。<ul><li>在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。</li><li>当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</li></ul></li><li><strong>操作数栈</strong> 主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。</li><li><strong>动态链接</strong> 主要服务一个方法需要调用其他方法的场景。在 Java 源文件被编译成字节码文件时，所有的变量和方法引用都作为符号引用（Symbilic Reference）保存在 <strong>Class 文件的静态常量池里</strong>。当一个方法要调用其他方法，需要将<strong>常量池中指向方法的符号引用转化为其在内存地址（方法区中的运行时常量池）中的直接引用</strong>。动态链接的作用就是为了将符号引用转换为调用方法的直接引用。</li></ul><p><img src="4.png"></p><p>栈空间虽然不是无限的，但一般正常调用的情况下是不会出现问题的。不过，如果函数调用陷入无限循环的话，就会导致栈中被压入太多栈帧而占用太多空间，导致栈空间过深。那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 <strong>StackOverFlowError</strong> 错误。栈还可能会出现<strong>OutOfMemoryError</strong>错误。在HotSpot虚拟机上是不会由于虚拟机栈无法扩展而导致OutOfMemoryError异常——只要线程申请栈空间成功了就不会有OOM，但是如果申请时就失败，仍然是会出现OOM异常的。</p><h3 id="本地方法栈（线程私有服务与native方法）："><a href="#本地方法栈（线程私有服务与native方法）：" class="headerlink" title="本地方法栈（线程私有服务与native方法）："></a><strong>本地方法栈（线程私有服务与native方法）：</strong></h3><p><strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。出现错误与虚拟机栈差不多。甚至有的Java虚拟机（譬如Hot-Spot虚拟机）直接 就把本地方法栈和虚拟机栈合二为一。</p><h3 id="程序计数器（线程私有）："><a href="#程序计数器（线程私有）：" class="headerlink" title="程序计数器（线程私有）："></a><strong>程序计数器（线程私有）：</strong></h3><p>多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。⚠️ 注意 ：程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存:"></a>直接内存:</h3><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域，实际上它属于系统内存。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。</p><ul><li>常见于 NIO 操作时，用于数据缓冲区；</li><li>分配回收成本较高，但读写性能高；</li><li><strong>不受 JVM 内存回收管理</strong>。</li></ul><h2 id="程序计数器为什么是私有的"><a href="#程序计数器为什么是私有的" class="headerlink" title="程序计数器为什么是私有的?"></a>程序计数器为什么是私有的?</h2><p>程序计数器主要有下面两个作用：</p><ol><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ol><p>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p><p>所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p><h2 id="虚拟机栈和本地方法栈为什么是私有的"><a href="#虚拟机栈和本地方法栈为什么是私有的" class="headerlink" title="虚拟机栈和本地方法栈为什么是私有的?"></a>虚拟机栈和本地方法栈为什么是私有的?</h2><ul><li><strong>虚拟机栈：</strong> 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li><li><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li></ul><p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p><h2 id="一句话简单了解堆和方法区"><a href="#一句话简单了解堆和方法区" class="headerlink" title="一句话简单了解堆和方法区"></a>一句话简单了解堆和方法区</h2><p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> JVM内存区域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常</title>
      <link href="/2021/04/29/%E5%BC%82%E5%B8%B8/"/>
      <url>/2021/04/29/%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="异常概念"><a href="#异常概念" class="headerlink" title="异常概念"></a>异常概念</h1><p>实际上，当java程序执行时出现错误时，jvm会把执行时出错的信息(例如出错原因、类型、 位置)收集，然后打包成为1个对象(object)，程序员可以对这种对象进行处理。这种对象就是所谓的异常。<strong>可能出现的异常的代码并不是肯定会出现异常, 还取决于执行环境和数据</strong>。</p><p>在Java中，所有的异常都有一个共同的超类Throwable（可抛出类）。Throwable类有两个重要的子类：Exception（异常）和 Error（错误），二者都是Java异常处理的重要子类，各自都包含大量子类。异常和错误的区别是：异常能被程序本身可以处理，错误是无法处理。</p><h1 id="异常分类：两种分类方法"><a href="#异常分类：两种分类方法" class="headerlink" title="异常分类：两种分类方法"></a>异常分类：两种分类方法</h1><h2 id="Error-和-Exception"><a href="#Error-和-Exception" class="headerlink" title="Error 和 Exception"></a>Error 和 Exception</h2><ul><li><strong>Error</strong>：表示程序在运行期间出现了非常严重的错误，并且该错误是不可恢复的，由于这属于JVM层次的严重错误，因此这种错误是会导致程序终止执行的。此外，编译器不会检查Error是否被处理，因此在程序中不推荐去捕获Error类型的异常，主要原因是运行时异常多是由于逻辑错误导致的，属于应该解决的错误，也就是说，一个正确的程序中是不应该存在Error的。OutOfMemoryError、ThreadDeath等都属于错误。当这些异常发生时，JVM一般会选择将线程终止。</li><li><strong>Exception</strong>：表示可恢复的异常，是编译器可以捕捉到的。可分为运行时异常（RuntimeException）和非运行时异常。</li></ul><p><img src="1.png"></p><span id="more"></span><h2 id="受查异常和不受查异常"><a href="#受查异常和不受查异常" class="headerlink" title="受查异常和不受查异常"></a>受查异常和不受查异常</h2><p>它包含两种类型：<strong>受查异常（checked exception）</strong>和<strong>不受查异常（unchecked exception）</strong>，其中不受查异常特指<strong>运行时异常（runtime exception）</strong>。</p><p>在实际开发中，经常会在程序编译时产生一些异常，而这些异常<strong>必须要进行处理</strong>，这种异常被称为<strong>编译时异常</strong>，也被称为<strong>受查异常</strong>，所有的Error都属于受查异常。另外还有一种异常是在程序运行时产生的（运行时异常），这种异常即使不编写异常处理代码，依然可以通过编译，因此被称为不受查异常。</p><p>总而言之，只能在代码中忽略RuntimeException（及其子类）类型的异常，其他类型异常的处理都是由编译器强制实施的。究其原因，RuntimeException代表的是编程错误：</p><ul><li>无法预料的错误。比如从你控制范围之外传递进来的null引用。</li><li>作为程序员，应该在代码中进行检查的错误。</li></ul><p>简而言之，它们之间的区别 ：</p><ul><li>非运行时异常：是需要显示用try-catch捕捉处理的异常，如IOException、SQLException等以及用户自定义的Exception异常。</li><li>运行时异常：不需要显示捕捉，如NullPointException，IndexOutOfBoundsException等，常见于程序逻辑问题导致。</li></ul><h1 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h1><h2 id="捕获与处理"><a href="#捕获与处理" class="headerlink" title="捕获与处理"></a>捕获与处理</h2><h3 id="try-catch-finally的处理机制"><a href="#try-catch-finally的处理机制" class="headerlink" title="try-catch-finally的处理机制"></a>try-catch-finally的处理机制</h3><p>完整的异常处理程序看起来像这样，但Java也允许缺少catch或者finally：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 监控区域（guarded region）</span></span><br><span class="line">    <span class="comment">// 可能抛出异常 A、B、C 的危险活动</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">A</span>(); <span class="comment">// A为自定义的异常类型</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(A a1) &#123;</span><br><span class="line">    <span class="comment">// 异常A的异常处理程序</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(B b1) &#123;</span><br><span class="line">    <span class="comment">// 异常B的异常处理程序</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(C c1) &#123;</span><br><span class="line">    <span class="comment">// 异常C的异常处理程序</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 每次必须执行的活动</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>try</strong>块为监控区域（guarded region），即可能产生异常的区域。关键字throw用来抛出异常，每个异常都作为一个对象抛出。</li><li><strong>catch</strong>块为异常处理程序，异常处理程序必须紧跟在try块之后，当异常被抛出时，异常处理程序将负责搜寻参数与异常类型相匹配的第一个处理程序，然后进入catch子句执行。注意，只有匹配的catch子句才能得到执行（第5部分将会讲到异常匹配），这与switch语句不同，switch语句需要在每一个case后面跟一个break，以避免执行后续的case子句。</li><li><strong>finally</strong>块是程序希望每次都要执行的代码，例如一些需要清理的资源：已经打开的文件或网络连接，在屏幕上画的图形，甚至可以是外部世界的某个开关。总之记住，finally最可靠。</li></ul><h3 id="自动关闭的try-catch"><a href="#自动关闭的try-catch" class="headerlink" title="自动关闭的try-catch"></a>自动关闭的try-catch</h3><p>补充：在Java7之前，如果遇到类似IO流的处理，要在finally部分关闭IO流；Java7增加了一个新用法，在Java7优化后的try-with-resource语句，该语句确保了每个资源在语句结束时关闭。所谓的资源是指在程序完成后，必须关闭的流对象。写在()里面的流对象对应的类都实现了自动关闭接口AutoCloseable；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try (创建流对象语句，如果多个,使用&#x27;;&#x27;隔开) &#123;</span><br><span class="line">    // 读写数据</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="try-catch-finally的执行机制"><a href="#try-catch-finally的执行机制" class="headerlink" title="try-catch-finally的执行机制"></a>try-catch-finally的执行机制</h3><p>一般的顺序就是try-&gt;catch-&gt;finally，但要注意当出现return时的情况。若在try或catch语句里面有return语句，finally语句和return语句的执行顺序问题：</p><ul><li><p>若有finally语句，则无论如何，都会执行该语句，在try或catch中的return语句会将它的返回值压入栈内，然后执行finally语句，当finally执行完成后，若finally语句里有return语句，则执行return语句并结束。return的作用就是结束当前方法。</p></li><li><p>若finally没有return语句，则返回被保存的栈里的return语句，再执行。然而，在压栈时候，要注意压入栈内的是什么东西，是值本身还是引用，若是引用则引用的值会改变，若是变量值，则不会改变。然而非常不建议在finally里面写return语句，因为它会吞掉异常，后面有例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Multiplereturns</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Initialization that requires cleadup&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Point 1&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;Point 2&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;Point 3&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">3</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;End&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Performing cleanup&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++)</span><br><span class="line">            f(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">/*Output:</span></span><br><span class="line"><span class="comment">Initialization that requires cleadup</span></span><br><span class="line"><span class="comment">Point 1</span></span><br><span class="line"><span class="comment">Performing cleanup</span></span><br><span class="line"><span class="comment">Initialization that requires cleadup</span></span><br><span class="line"><span class="comment">Point 1</span></span><br><span class="line"><span class="comment">Point 2</span></span><br><span class="line"><span class="comment">Performing cleanup</span></span><br><span class="line"><span class="comment">Initialization that requires cleadup</span></span><br><span class="line"><span class="comment">Point 1</span></span><br><span class="line"><span class="comment">Point 2</span></span><br><span class="line"><span class="comment">Point 3</span></span><br><span class="line"><span class="comment">Performing cleanup</span></span><br><span class="line"><span class="comment">Initialization that requires cleadup</span></span><br><span class="line"><span class="comment">Point 1</span></span><br><span class="line"><span class="comment">Point 2</span></span><br><span class="line"><span class="comment">Point 3</span></span><br><span class="line"><span class="comment">End</span></span><br><span class="line"><span class="comment">Performing cleanup</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="异常丢失"><a href="#异常丢失" class="headerlink" title="异常丢失"></a>异常丢失</h3><p>当用特殊的方式使用finally，可能会造成异常丢失，Thinking in Java中举了两个例子，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VeryImportantException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;A very important exception!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HoHumException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;A trivial exception&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LostMessage</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> <span class="keyword">throws</span> VeryImportantException &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">VeryImportantException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dispose</span><span class="params">()</span> <span class="keyword">throws</span> HoHumException &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">HoHumException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">LostMessage</span> <span class="variable">lm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LostMessage</span>();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lm.f();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lm.dispose();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">A trivial exception</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure><p>从输出可以看到，VeryImportantException不见了，在这种嵌套的异常处理机制中，程序对lm.f()所抛出的异常没有做任何处理，但却骗过了编译器。内层产生了两个异常，因为catch只能捕获一个异常，而编译器默认内层只能产生一个异常，所以它觉得自己已经对异常进行了处理。而实际上对lm.f()产生的异常没有任何处理但却通过了编译，这是一种非常可怕的缺陷。</p><p>注意此种情况与下文将要讲的<strong>重抛异常中的异常链</strong>的区别，重抛异常是在catch里面，即已经对上一个异常进行了处理，只是为了保留上一个异常的信息，不存在编译错误。<br>还有一种异常丢失的情况是在没有catch或者产生catch不匹配的异常的情况下就在fianlly子句中返回：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class ExceptionSilencer &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            throw new RuntimeException();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 在finally里返回，会忽略掉所有抛出的异常</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="捕获所有异常"><a href="#捕获所有异常" class="headerlink" title="捕获所有异常"></a>捕获所有异常</h2><h3 id="异常的信息：e-toString-和e-getMessage"><a href="#异常的信息：e-toString-和e-getMessage" class="headerlink" title="异常的信息：e.toString()和e.getMessage()"></a>异常的信息：e.toString()和e.getMessage()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class E03 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            throw new ArrayIndexOutOfBoundsException(&quot;An ArrayIndexOutOfBoundsException in main&quot;);</span><br><span class="line">            //throw new ArrayIndexOutOfBoundsException();</span><br><span class="line">        &#125;</span><br><span class="line">        catch (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">            System.out.println(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*Output:</span><br><span class="line">An ArrayIndexOutOfBoundsException in main</span><br><span class="line">java.lang.ArrayIndexOutOfBoundsException: An ArrayIndexOutOfBoundsException in main</span><br><span class="line">-----------------------------------------------------------------------------------</span><br><span class="line">null</span><br><span class="line">java.lang.ArrayIndexOutOfBoundsException</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>上面是传入字符串的输出，下面是默认构造器的输出。可以初步判断e.getMessage()获取的是传入的信息，而e.toString()包含两部分：类的信息+传入的信息。是否是这样哪？看源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private String detailMessage;</span><br><span class="line"></span><br><span class="line">public Throwable(String message) &#123;</span><br><span class="line">    fillInStackTrace();</span><br><span class="line">    detailMessage = message;</span><br><span class="line">&#125;</span><br><span class="line">...Throwable的构造方法都接收message传入detailMessage</span><br><span class="line"></span><br><span class="line">public String getMessage() &#123;</span><br><span class="line">    return detailMessage;</span><br><span class="line">&#125;</span><br><span class="line">...getMessage()获取detailMessage</span><br><span class="line"></span><br><span class="line">public String toString() &#123;</span><br><span class="line">    String s = getClass().getName();</span><br><span class="line">    String message = getLocalizedMessage();</span><br><span class="line">    return (message != null) ? (s + &quot;: &quot; + message) : s;</span><br><span class="line">&#125;</span><br><span class="line">public String getLocalizedMessage() &#123;</span><br><span class="line">    return getMessage();</span><br><span class="line">&#125;</span><br><span class="line">...toString()包含两部分：类的信息+传入的信息Message，真相大白了！</span><br></pre></td></tr></table></figure><p>所以通过源码我们可以看出信息的详细程度为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getMessage() &lt;= getLocalizedMessage() &lt; toString() &lt; printStackTrace()</span><br></pre></td></tr></table></figure><h3 id="栈轨迹和重抛异常"><a href="#栈轨迹和重抛异常" class="headerlink" title="栈轨迹和重抛异常"></a>栈轨迹和重抛异常</h3><h4 id="e-printStackTrace"><a href="#e-printStackTrace" class="headerlink" title="e.printStackTrace()"></a>e.printStackTrace()</h4><p>首先介绍大家常用的e.printStackTrace()，printStackTrace方法源码包含3个重载的方法，其中第一个方法输出到标准错误，后两个允许选择要输出的流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printStackTrace</span><span class="params">()</span> &#123;printStackTrace(System.err);&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Prints this throwable and its backtrace to the specified print stream.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s &#123;<span class="doctag">@code</span> PrintStream&#125; to use for output</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printStackTrace</span><span class="params">(PrintStream s)</span> &#123;</span><br><span class="line">    printStackTrace(<span class="keyword">new</span> <span class="title class_">WrappedPrintStream</span>(s));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printStackTrace</span><span class="params">(PrintStreamOrWriter s)</span> &#123;...&#125;</span><br></pre></td></tr></table></figure><p>printStackTrace()方法将此Throwable对象的堆栈跟踪输出至错误输出流，作为字段 System.err 的值。输出的第一行包含此对象的toString()方法的结果；剩余行表示由方法 <strong>fillInStackTrace()</strong> （下面将详细介绍）记录的数据，即Throwable的调用栈轨迹。</p><p>调用栈轨迹简单理解就是将调用的方法序列存储在栈中，printStackTrace()方法提供的信息可以通过getStackTrace()方法来直接访问，这个方法将返回栈轨迹中的元素所构成的数组。<strong>其中每一个元素都表示栈中的一帧，栈顶是元素0，也是调用序列最后一个方法调用（异常被创建和抛出之处）；栈底是调用序列中的第一个方法调用</strong>。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WhoCalled</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Generate an exception to fill in the stack trace</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">for</span> (StackTraceElement ste : e.getStackTrace())</span><br><span class="line">                System.out.println(ste.getMethodName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">g</span><span class="params">()</span> &#123; f(); &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">h</span><span class="params">()</span> &#123; g(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        f();</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">        g();</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">        h();</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">/*Output:</span></span><br><span class="line"><span class="comment">f</span></span><br><span class="line"><span class="comment">main</span></span><br><span class="line"><span class="comment">-----------------</span></span><br><span class="line"><span class="comment">f</span></span><br><span class="line"><span class="comment">g</span></span><br><span class="line"><span class="comment">main</span></span><br><span class="line"><span class="comment">-----------------</span></span><br><span class="line"><span class="comment">f</span></span><br><span class="line"><span class="comment">g</span></span><br><span class="line"><span class="comment">h</span></span><br><span class="line"><span class="comment">main</span></span><br><span class="line"><span class="comment">-----------------</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>第一个方法调用是main()方法，首先入栈，在栈底；创建异常的地方在f()，最后入栈，也就是栈顶。</p><h4 id="重新抛出异常"><a href="#重新抛出异常" class="headerlink" title="重新抛出异常"></a>重新抛出异常</h4><p>有时希望把刚捕获的异常重新抛出，尤其是在使用Exception捕获所有异常时，既然已经得到了对当前异常对象的引用，可以直接把它重新抛出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">catch(Exception e) &#123;</span><br><span class="line">    System.out.printin(&quot;An exception was thrown&quot;);</span><br><span class="line">    throw e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>重抛异常会把异常抛给上一级环境中的异常处理程序，同一个try块的后续catch子句将被忽略。如果只是把当前异常对象重新抛出，那么 printStackTrace方法显示的将是原来异常抛出点的调用栈信息，而并非重新抛出点的信息</strong>。要想更新这个信息，可以调用fillInStackTrace()方法，将返回一个Throwable对象，它是通过把当前调用栈信息填入原来那个异常対象而建立的，像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rethrowing</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;originating the exception in f()&quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;thrown from f()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">g</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            f();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Inside g(),e.printStackTrace&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> e; <span class="comment">//rethrow</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">h</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            f();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Inside h(),e.printStackTrace&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> (Exception) e.fillInStackTrace(); <span class="comment">//rethrow</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            g();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;main: printStackTrace()&quot;</span>);</span><br><span class="line">            e.printStackTrace(System.out);</span><br><span class="line">            System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            h();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;main: printStackTrace()&quot;</span>);</span><br><span class="line">            e.printStackTrace(System.out);</span><br><span class="line">            System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">/*</span></span><br><span class="line"><span class="comment">originating the exception in f()</span></span><br><span class="line"><span class="comment">Inside g(),e.printStackTrace</span></span><br><span class="line"><span class="comment">java.lang.Exception: thrown from f()</span></span><br><span class="line"><span class="comment">   at chapter12.Rethrowing.f(Rethrowing.java:6)</span></span><br><span class="line"><span class="comment">   at chapter12.Rethrowing.g(Rethrowing.java:10)</span></span><br><span class="line"><span class="comment">   at chapter12.Rethrowing.main(Rethrowing.java:33)</span></span><br><span class="line"><span class="comment">-----------------------------------------------------</span></span><br><span class="line"><span class="comment">main: printStackTrace()</span></span><br><span class="line"><span class="comment">java.lang.Exception: thrown from f()</span></span><br><span class="line"><span class="comment">   at chapter12.Rethrowing.f(Rethrowing.java:6)</span></span><br><span class="line"><span class="comment">   at chapter12.Rethrowing.g(Rethrowing.java:10)</span></span><br><span class="line"><span class="comment">   at chapter12.Rethrowing.main(Rethrowing.java:33)</span></span><br><span class="line"><span class="comment">-----------------------------------------------------</span></span><br><span class="line"><span class="comment">originating the exception in f()</span></span><br><span class="line"><span class="comment">Inside h(),e.printStackTrace</span></span><br><span class="line"><span class="comment">java.lang.Exception: thrown from f()</span></span><br><span class="line"><span class="comment">   at chapter12.Rethrowing.f(Rethrowing.java:6)</span></span><br><span class="line"><span class="comment">   at chapter12.Rethrowing.h(Rethrowing.java:21)</span></span><br><span class="line"><span class="comment">   at chapter12.Rethrowing.main(Rethrowing.java:41)</span></span><br><span class="line"><span class="comment">-----------------------------------------------------</span></span><br><span class="line"><span class="comment">main: printStackTrace()</span></span><br><span class="line"><span class="comment">java.lang.Exception: thrown from f()</span></span><br><span class="line"><span class="comment">   at chapter12.Rethrowing.h(Rethrowing.java:27)</span></span><br><span class="line"><span class="comment">   at chapter12.Rethrowing.main(Rethrowing.java:41)</span></span><br><span class="line"><span class="comment">-----------------------------------------------------</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>调用fillInStackTrace()那一行就成为异常的新发生地了，如果是在捕获异常之后抛出新异常，得到的效果类似于使用fillInStackTrace()，即得到新的抛出点相关的信息。java中e.printStackTrace()请谨慎使用，最好使用logger记录，可能会导致锁死。或者建议使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.error(&quot;异常信息&quot;,e);//注意这个方法在java.util.logging.Logger类里没有</span><br></pre></td></tr></table></figure><h3 id="异常链"><a href="#异常链" class="headerlink" title="异常链"></a>异常链</h3><ul><li><p>常常会再捕获一个异常后抛出另外一个异常，并且希望把<strong>异常原始信息保存下来，这被称为异常链</strong>。</p></li><li><p>现在所有Throwable的子类在构造器中都可以接受一个cause（因由）对象作为参数，这个cause表示原始异常，这样通过把原始异常传递给新的异常，使得即使在当前位置创建并抛出了新的异常，也可以通过这个cause追踪到异常最初发生的位置。</p></li><li><p>Throwable类及其所有的子类都提供了带cause参数的构造器，其他的异常类就只有通过initCause()来设置cause了。设置完cause的新异常可以通过getCause()方法返回原始异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionCause</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            test2();                                      <span class="comment">// 创建原始异常</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(NullPointerException e)&#123;                   <span class="comment">// 捕获原始异常</span></span><br><span class="line">            <span class="type">Exception</span> <span class="variable">Ex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;New exception&quot;</span>);<span class="comment">// 1</span></span><br><span class="line">            Ex.initCause(e);                              <span class="comment">// 把原始异常传递给新的异常</span></span><br><span class="line">            <span class="keyword">throw</span> Ex;                                     <span class="comment">// 抛出新的异常</span></span><br><span class="line"> <span class="comment">//           Ex.getCause();                                // 原始异常</span></span><br><span class="line"><span class="comment">//           throw new Exception(&quot;New exception&quot;, e);      // 2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span>  <span class="title class_">NullPointerException</span>(<span class="string">&quot;Str is null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        test1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">/*Output:</span></span><br><span class="line"><span class="comment">Exception in thread &quot;main&quot; java.lang.Exception: New exception</span></span><br><span class="line"><span class="comment">   at chapter12.ExceptionCause.test1(ExceptionCause.java:8)</span></span><br><span class="line"><span class="comment">   at chapter12.ExceptionCause.main(ExceptionCause.java:19)</span></span><br><span class="line"><span class="comment">Caused by: java.lang.NullPointerException: Str is null       //如果没有initCause(e),原始异常不会输出</span></span><br><span class="line"><span class="comment">   at chapter12.ExceptionCause.test2(ExceptionCause.java:15)</span></span><br><span class="line"><span class="comment">   at chapter12.ExceptionCause.test1(ExceptionCause.java:6)</span></span><br><span class="line"><span class="comment">   ... 1 more</span></span><br><span class="line"><span class="comment">*/</span>  </span><br></pre></td></tr></table></figure></li></ul><h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><h2 id="创建自定义异常"><a href="#创建自定义异常" class="headerlink" title="创建自定义异常"></a>创建自定义异常</h2><p>要自己定义异常类，必须从已有的异常类继承，最好是选择意思相近的异常类（但是并不好找）。建立新的异常类非常简单，可以是简单的继承，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class MyException extends Exception &#123;&#125;</span><br></pre></td></tr></table></figure><p>或者你想加点更详细的信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    String s;</span><br><span class="line">    MyException(String s) &#123;</span><br><span class="line">        <span class="built_in">super</span>(s);  <span class="comment">//可以用getMessage了</span></span><br><span class="line">        <span class="built_in">this</span>.s = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;A MyException in main&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (MyException m) &#123;</span><br><span class="line">            <span class="comment">//温习一下前面的知识</span></span><br><span class="line">            System.out.println(m.getMessage());</span><br><span class="line">            System.out.println(m.toString());</span><br><span class="line">            m.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">/*Output:</span></span><br><span class="line"><span class="comment">A MyException in main</span></span><br><span class="line"><span class="comment">A MyException in main</span></span><br><span class="line"><span class="comment">A MyException in main</span></span><br><span class="line"><span class="comment">A MyException in main</span></span><br><span class="line"><span class="comment">at chapter12.exercise4.E04.main(E04.java:17)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="异常说明"><a href="#异常说明" class="headerlink" title="异常说明"></a>异常说明</h2><p>Java鼓励人们把方法可能会抛出的异常告知使用此方法的客户端程序员，这是种优雅的做法，它使得调用者能确切知道写什么样的代码可以捕获所有潜在的异常。当然，如果提供了源代码，客户端程序员可以在源代码中查找throw语句来获知相关信息，然而程序库通常不与源代码一起发布。<strong>为了预防这样的问题，java提供了相应的语法来告知程序员方法可能会抛出的异常类型，这就是异常说明，属于方法声明的一部分，紧跟在形式参数列表之后</strong>。</p><p>异常说明可能有两种意思，一个是“我的代码会产生这种异常，这由你来处理”。另一个是“我的代码忽略了这些异常，这由你来处理”。学习异常处理的机制和语法的时候，我们一直在关注“你来处理”部分，但这里特别值得注意的事实是我们通常都忽略了异常说明所表达的完整含义。</p><p>异常说明使用了附加的关键字 throws，后面接一个所有潜在异常类型的列表，所以方法可能看起来像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void f() throws Exception1,Exception2,Exception3 &#123;&#125;</span><br></pre></td></tr></table></figure><p>但是，要是这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void f() &#123;&#125;</span><br></pre></td></tr></table></figure><p>就表示此方法不会抛出任何异常(<strong>除了从 RuntimeException继承的异常，它们可以在没有异常说明的情况下被抛出</strong>)。<br>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E08</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> <span class="keyword">throws</span> MyException&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">g</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            E08.f();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            E08.g();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">/*Output:</span></span><br><span class="line"><span class="comment">chapter12.exercise8.MyException</span></span><br><span class="line"><span class="comment">   at chapter12.exercise8.E08.f(E08.java:7)</span></span><br><span class="line"><span class="comment">   at chapter12.exercise8.E08.main(E08.java:14)</span></span><br><span class="line"><span class="comment">java.lang.NullPointerException</span></span><br><span class="line"><span class="comment">   at chapter12.exercise8.E08.g(E08.java:10)</span></span><br><span class="line"><span class="comment">   at chapter12.exercise8.E08.main(E08.java:20)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>上例必须在f()方法里进行异常声明，否则编译器会报错，因为自定义的异常属于非运行时异常，而NullPointerException属于运行时异常。</p><p><strong>代码必须与异常说明保持一致</strong>。如果方法里的代码产生了异常（非运行时异常）却没有处理，编译器会发现这个问题并提醒你：要么处理这个异常，要么在异常说明中说明此方法将产生异常。</p><p><strong>不过还是有个能“作弊”的地方：可以声明方法将抛出异常，实际上却不抛出，编译器相信了这个声明，并强制使用此方法的用户像真的抛出异常那样使用这个方法</strong>。这样做的好处是为异常先占个位子，以后就可以抛出这种异常而不用修改已有的代码。<strong>在定义抽象基类和接口时这种能力很重要，这样派生类或接口实现就能够抛出这些预先声明的异常。</strong></p><h2 id="异常的限制"><a href="#异常的限制" class="headerlink" title="异常的限制"></a>异常的限制</h2><p>但要注意当覆盖方法的时候，只能抛出在基类方法的异常说明中列出的那些异常（包括其子类）。这个限制意味着当基类使用的代码应用到其派生类对象的时候，一样能够工作（这是面向对象的概念）异常也不例外。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">E1</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E2</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E1_1</span> <span class="keyword">extends</span> <span class="title class_">E1</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> E1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> E2&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Scratch</span> <span class="keyword">extends</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">A</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>此时无法通过编译，因为Scratch类继承了B的方法作为接口方法的实现，但E2却不是E1及其子类。如果将类B换成如下即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> E1&#123;&#125;</span><br><span class="line"><span class="comment">//    public void test() throws E1_1&#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者在Scratch里实现test，但test不能抛出任何异常，此时类B中的test()方法与接口A中的test()方法没有直接关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Scratch</span> <span class="keyword">extends</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常与记录日志"><a href="#异常与记录日志" class="headerlink" title="异常与记录日志"></a>异常与记录日志</h2><h3 id="System-err和System-out的区别（补充）"><a href="#System-err和System-out的区别（补充）" class="headerlink" title="System.err和System.out的区别（补充）"></a>System.err和System.out的区别（补充）</h3><p>官方文档中给出的解释如下：</p><ul><li><p>System.out：“标准”输出流。通常，此流对应于显示器输出或者由主机环境或用户指定的另一个输出目标。对于简单独立的 Java 应用程序，编写一行输出数据的典型方式是：System.out.println(data)；</p></li><li><p>System.err：“标准”错误输出流。通常，此流对应于显示器输出或者由主机环境或用户指定的另一个输出目标。按照惯例，此输出流用于显示错误消息，或者显示那些即使用户输出流（变量 out 的值）已经重定向到通常不被连续监视的某一文件或其他目标，也应该立刻引起用户注意的其他信息。</p></li><li><p>区别：字面上理解二者的区别即是out用于正常的用户指定的输出，而err专门用于显示错误和异常消息；System.err输出的字符串位置会随机出现，但System.err输出的字符串之间的相对位置不会改变，System.out在JVM和操作系统都具有缓存功能，就是你输出的东西不一定实时输出，有时候会积攒到一定数量才会输出，System.err会实时输出，不需要缓冲，单独使用的话可能感觉不到，如果两种方式混合使用就会发现了。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrintTset</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;out1&quot;</span>);</span><br><span class="line">        System.err.println(<span class="string">&quot;err1&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;out2&quot;</span>);</span><br><span class="line">        System.err.println(<span class="string">&quot;err2&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;out3&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;out4&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;out5&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">/*Output:</span></span><br><span class="line"><span class="comment">out1</span></span><br><span class="line"><span class="comment">err1</span></span><br><span class="line"><span class="comment">err2</span></span><br><span class="line"><span class="comment">out2</span></span><br><span class="line"><span class="comment">out3</span></span><br><span class="line"><span class="comment">out4</span></span><br><span class="line"><span class="comment">out5</span></span><br><span class="line"><span class="comment">---</span></span><br><span class="line"><span class="comment">out1</span></span><br><span class="line"><span class="comment">err1</span></span><br><span class="line"><span class="comment">out2</span></span><br><span class="line"><span class="comment">err2</span></span><br><span class="line"><span class="comment">out3</span></span><br><span class="line"><span class="comment">out4</span></span><br><span class="line"><span class="comment">out5</span></span><br><span class="line"><span class="comment">---</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>输出结果每次都不一样，但System.err和System.out输出的相对顺序保持不变，这也是由于System.err不需要缓冲即可输出造成的。</p></li></ul><h3 id="Java-Logger使用"><a href="#Java-Logger使用" class="headerlink" title="Java Logger使用"></a>Java Logger使用</h3><p>…</p><h1 id="异常深入"><a href="#异常深入" class="headerlink" title="异常深入"></a>异常深入</h1><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p>有一点很重要，即你要时刻询问自己“如果异常发生了，所有东西能被正确的清理吗?”尽管大多数情况下是非常安全的，但涉及构造器时，问题就出现了，构造器会把对象设置成安全的初始状态，但还会有别的动作，比如打开一个文件，这样的动作只有在对象使用完毕并且用户调用了特殊的清理方法之后才能得以清理。如果在构造器内抛出了异常，这些清理行为也许就不能正常工作了。这意味着在编写构造器时要格外细心。</p><p>finally能解决所有问题吗？因为finally会每次执行清理代码，但如果构造器在其执行过程中半途而废，也许该对象的某些部分还没有被成功创建，而这些部分却是在finally里要清理的，这就出现问题了。</p><p>对于在构造阶段可能会抛出异常，并且要求清理的类，最安全的使用方式是使用嵌套的try子句，这种通用的清理惯用法在构造器不抛出异常时也应该运用，其基本规则是：<strong>在创建需要清理的对象之后，立即进入一个try-finally的语句块</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConstructionException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WithDispose</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> id;</span><br><span class="line">    WithDispose(<span class="type">int</span> id) &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dispose</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WithDispose.dispose(): &quot;</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FailingConstructor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WithDispose wd1, wd2;</span><br><span class="line">    <span class="comment">// 构造器可能在创建过程中失败并且抛出一个异常</span></span><br><span class="line">    FailingConstructor(<span class="type">boolean</span> fail) <span class="keyword">throws</span> ConstructionException &#123;</span><br><span class="line">        wd1 = <span class="keyword">new</span> <span class="title class_">WithDispose</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// &quot;Simulate&quot; other code that might throw exceptions</span></span><br><span class="line">             <span class="keyword">if</span>(fail) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConstructionException</span>();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(ConstructionException e) &#123;</span><br><span class="line">            wd1.dispose();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        wd2 = <span class="keyword">new</span> <span class="title class_">WithDispose</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用于清理成员对象的方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dispose</span><span class="params">()</span> &#123;   </span><br><span class="line">        wd2.dispose();</span><br><span class="line">        wd1.dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E24_FailingConstructor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">false</span>; ; b = !b)</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Constructing...&quot;</span>);</span><br><span class="line">                <span class="type">FailingConstructor</span> <span class="variable">fc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FailingConstructor</span>(b);</span><br><span class="line">                <span class="comment">// 在创建需要清理的对象之后，立即进入一个try-finally的语句块</span></span><br><span class="line">                <span class="comment">// 构造过程中抛出异常会终止进入外层catch，否则正常运行内层的try-finally块</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Processing...&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Cleanup...&quot;</span>);</span><br><span class="line">                    fc.dispose();  <span class="comment">// 记得清理，finally在内层就可以正常发挥作用了</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;-----------------------------&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span>(ConstructionException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Construction has failed: &quot;</span> + e);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">/*Output:</span></span><br><span class="line"><span class="comment">Constructing...</span></span><br><span class="line"><span class="comment">Processing...</span></span><br><span class="line"><span class="comment">Cleanup...</span></span><br><span class="line"><span class="comment">WithDispose.dispose(): 2</span></span><br><span class="line"><span class="comment">WithDispose.dispose(): 1</span></span><br><span class="line"><span class="comment">-----------------------------</span></span><br><span class="line"><span class="comment">Constructing...</span></span><br><span class="line"><span class="comment">WithDispose.dispose(): 1</span></span><br><span class="line"><span class="comment">Construction has failed: chapter12.exercise24.ConstructionException</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="异常匹配"><a href="#异常匹配" class="headerlink" title="异常匹配"></a>异常匹配</h2><p>抛出异常的时候，异常处理系统会按照代码的书写顺序找出“最近”的处理程序，找到匹配的处理程序之后，它就认为异常将得到处理，然后就不再继续查找。</p><p>查找的时候并不要求抛出的异常同处理程序所声明的异常完全匹配。派生类的对象也可以匹配其基类的处理程序，就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Level1Exception</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Level2Exception</span> <span class="keyword">extends</span> <span class="title class_">Level1Exception</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Level3Exception</span> <span class="keyword">extends</span> <span class="title class_">Level2Exception</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> <span class="keyword">throws</span> Level1Exception &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Level1Exception</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> <span class="keyword">throws</span> Level2Exception &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Level2Exception</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> <span class="keyword">throws</span> Level3Exception &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Level3Exception</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E25_ThreeLevelExceptions</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">A</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">            c.f();</span><br><span class="line">        <span class="comment">// catch按照异常的层级进行排列，基类异常在最后</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Level3Exception l3) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Catch &quot;</span> + l3);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Level2Exception l2) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Catch &quot;</span> + l2);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Level1Exception l1) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Catch &quot;</span> + l1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">/*Output:</span></span><br><span class="line"><span class="comment">// 找到最近的匹配处理程序之后，它就认为异常将得到处理，然后就不再继续查找。</span></span><br><span class="line"><span class="comment">Catch chapter12.exercise25.Level3Exception</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="异常处理的思想及其他思考"><a href="#异常处理的思想及其他思考" class="headerlink" title="异常处理的思想及其他思考"></a>异常处理的思想及其他思考</h2><p>异常处理的一个重要原则是“只有在你知道如何处理的情况下才捕获异常”。实际上，异常处理的一个重要目标就是把错误处理的代码同错误发生的地点相分离。这使你能在一段代码中专注与要完成的事情，至于如何处理错误，则放在另一段代码中完成。这样一来，主干代码就不会与错误代码逻辑混在一起，也更容易理解和维护。通过允许一个处理程序去处理多个出错点，异常处理还使得错误处理代码的数量趋向于减少。</p><p>受查异常（checked exception）使得这个问题变得复杂，因为它们强制你在可能还没准备好处理错误时被迫加上catch子句，这就导致<strong>吞食则有害（harmfal if swallowed）</strong>的问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//...to do something useful</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(ObligatoryException e) &#123;&#125;  <span class="comment">// Gulp! Do nothing after catch it</span></span><br></pre></td></tr></table></figure><p>程序员们只做最简单的事情，常常是无意中“吞食”了异常，然而一且这么做，虽然能通过编译，但除非你记得复查并改正代码，否则异常将会丢失。异常确实发生了，但“吞食”后它却完全消失了。因为编译器强迫你立刻写代码来处理异常，所以这种看起来最简单的方法，却可能是最糟糕的做法。接下来将讨论一下<strong>受查异常及其并发症</strong>，以及采用什么方法解决这些问题。</p><p>仅从示意性的例子和小程序来看，“被检查的异常”的好处很明显。但是当程序开始变大的时候，就会带来一些微妙的问题。当然，程序不是一下就变大的，这有个过程。如果把不适用于大项目的语言用于小项目，当这些项目不断膨胀时，突然有一天你会发现，原来可以管理的东西，现在已经变得无法管理了。这就是我所说的过多的类型检查，特别是“被检查的异常”所造成的问题。</p><p>看来程序的规模是个重要因素。由于很多讨论都用小程序来做演示，因此这并不足以说明问题。一名C#的设计人员发现：“仅从小程序来看，会认为异常说明能增加开发人员的效率，并提高代码的质量；但考察大项目的时候，结论就不同了——开发效率下降了，而代码质量只有微不足道的提高，甚至毫无提高”。</p><p>然而，如果发现有些受查异常挡住了路，尤其是发现你不得不去对付那些不知道该如何处理的异常，还是有些办法的。</p><ol><li>把异常传递给控制台</li></ol><p>对于简单的程序，比如本书中的许多例子，最简单而又不用写多少代码就能保护异常信息的方法，就是把它们从main()传递到控制台。例如，为了读取信息而打开一个文件，必须对FileInputStream进行打开和关闭操作，这就可能会产生异常。对于简单的程序，可以像这样做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainException</span> &#123;</span><br><span class="line">    <span class="comment">// Pass all exceptions to the console:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// Open the file:</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;MainException, java&quot;</span>);</span><br><span class="line">        <span class="comment">// Use the file...</span></span><br><span class="line">        <span class="comment">// Close the file:</span></span><br><span class="line">         file.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意， main()作为一个方法也可以有异常说明，这里异常的类型是 Exception,它也是所有受查异常的基类。通过把它传递到控制台，就不必在main()里写 try-catch子句了。</p><ol><li>把“受查异常”转换为“不受查异常”</li></ol><p>在编写你自己使用的简单程序时，从 main()中抛出异常是很方便的，但这不是通用的方法。异常链提供了一种新的思路来解决这个问题。可以直接把“受查异常”包装进 RuntimeException里面，就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//...to do something useful</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(IDontKnowWhatToDoWithThisCheckedException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想把“受查异常”这种功能“屏蔽”掉的话，这看上去像是一个好办法。不用“吞下”异常，也不必把它放到方法的异常说明里面，而异常链还能保证你不会丢失任何原始异常的信息。</p><p>这种技巧给了你一种选择，可以不写try-catch子句或异常说明，直接忽略异常，让他自己沿着调用栈往上“冒泡”，同时，还可以用getCause()捕获并处理特定的异常，就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Annoyance</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sneeze</span> <span class="keyword">extends</span> <span class="title class_">Annoyance</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E30_Human</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">throwRuntimeException</span><span class="params">(<span class="type">int</span> type)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Annoyance</span>();</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Sneeze</span>();</span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;   <span class="comment">// 将受查异常转换成不受查异常:</span></span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 throwRuntimeException(i);  <span class="comment">// 抛出异常链</span></span><br><span class="line">             &#125; <span class="keyword">catch</span>(RuntimeException re) &#123;</span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                     <span class="keyword">throw</span> re.getCause();   <span class="comment">// 获取原始异常</span></span><br><span class="line">                 &#125; <span class="keyword">catch</span>(Sneeze e) &#123;</span><br><span class="line">                     System.out.println(<span class="string">&quot;Caught Sneeze&quot;</span>);</span><br><span class="line">                 &#125; <span class="keyword">catch</span>(Annoyance e) &#123;</span><br><span class="line">                     System.out.println(<span class="string">&quot;Caught Annoyance&quot;</span>);</span><br><span class="line">                 &#125; <span class="keyword">catch</span>(Throwable t) &#123;</span><br><span class="line">                     System.out.println(t);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Caught Annoyance</span></span><br><span class="line"><span class="comment">Caught Sneeze</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>容器</title>
      <link href="/2021/04/25/%E5%AE%B9%E5%99%A8/"/>
      <url>/2021/04/25/%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Collection-与-Collections"><a href="#Collection-与-Collections" class="headerlink" title="Collection 与 Collections"></a>Collection 与 Collections</h1><ul><li>java.util.Collection 是一个集合接口，是描述所有序列容器的共性的根接口。它提供了对集合对象进行基本操作的通用接口方法。Collection 接口在 Java 类库中有很多具体的实现。Collection 接口的意义是为各种具体的集合提供了最大化的统一操作方式。如下图所示，基本包含了常用的容器的关系。</li><li>java.util.Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于 Java 的 Collection 框架。</li></ul><p><img src="7.jpg" alt="1"></p><span id="more"></span><p><img src="1.jpg" alt="1"></p><h1 id="Iterable-和-Iterator"><a href="#Iterable-和-Iterator" class="headerlink" title="Iterable 和 Iterator"></a>Iterable 和 Iterator</h1><p>持有事物是容器最基本的工作，任何容器类都必须有某种方式可以插入元素并将它们再次取回。对于特定类型的容器都具有 add() 和 get() 方法，但如果我们只是使用容器并不关心容器特定的类型，这种方法就必须为每一种容器都独自编程，这显然不高效。迭代器（也是一种设计模式）的概念可以用于达成此目的（类似于向上转型中的程序设计思想）。迭代器是一个对象，它的工作是遍历并选择序列中的对象，而客户端程序员不必知道或关心该序列底层的结构。Java 中与之相关的接口有两个，分别为 Iterable 和 Iterator。</p><p>Java集合类库将集合的接口与实现分离。同样的接口，可以有不同的实现。Java 集合类的基本接口是 Collection 接口。而 Collection 接口必须继承 java.lang.Iterable 接口。以下图表示集合框架的接口，java.lang 以及 java.util 两个包里的。</p><p>Collection源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">Iterable源码：</span><br><span class="line">public interface Iterable&lt;T&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Returns an iterator over a set of elements of type T.</span><br><span class="line">     * </span><br><span class="line">     * @return an Iterator.</span><br><span class="line">     */</span><br><span class="line">    Iterator&lt;T&gt; iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​Iterable 接口是 Java SE5 引入的接口，<strong>它包含一个能够产生 Iterator 的 iterator() 方法</strong>，是为了 for-each 循环而设计的接口，所以说它的功能就是为了产生 Iterator 对象。for-each 循环可以与任何实现了 Iterable 接口的对象一起工作。而 java.util.Collection 接口实现了 java.lang.Iterable，故标准类库中的任何集合都可以使用 for-each 循环。</p><h2 id="为啥搞这么复杂，直接在集合中继承-Iterator-接口不行吗？"><a href="#为啥搞这么复杂，直接在集合中继承-Iterator-接口不行吗？" class="headerlink" title="为啥搞这么复杂，直接在集合中继承 Iterator 接口不行吗？"></a>为啥搞这么复杂，直接在集合中继承 Iterator 接口不行吗？</h2><p>​因为 Iterator 接口的核心方法 next() 或者 hasNext() 是依赖于迭代器的当前迭代位置的。如果 Collection 直接实现 Iterator 接口，当集合在不同方法间被传递时，由于当前迭代位置不可预置，那么 next() 方法的结果会变成不可预知。除非再为 Iterator 接口添加一个 reset() 方法，用来重置当前迭代位置。但即使这样，Collection 也只能同时存在一个当前迭代位置。而 Iterable 则不然，<strong>每次调用都会返回一个从头开始计数的迭代器，多个迭代器是互不干扰的。</strong></p><h2 id="适配器模式增加一种迭代器"><a href="#适配器模式增加一种迭代器" class="headerlink" title="适配器模式增加一种迭代器"></a>适配器模式增加一种迭代器</h2><p>​如果现有一个 Iterable 类，你想要添加一种或多种在 for-each 语句中使用这个类的方法，应该怎么做呢? 例如，假设你希望可以选择以向前的方向或是向后的方向迭代一个单词列表。如果直接继承这个类，并覆盖 iterator() 方法，你只能替换现有的方法，而不能实现选择。一种解决方案是所谓适配器方法的惯用法，“适配器”部分来自于设计模式，因为你必须提供特定接口以满足 for-each 语句。当你有一个接口并需要另一个接口时，编写适配器就可以解决问题。这里，我希望在默认的前向选代器的基础上，添加产生反向迭代器的能力，因此不能使用覆盖，而是添加了一个能够产生 Iterable 对象的方法，该对象可以用于 for-each 语句，这样我们就可以提供多种使用 for-each 的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReversibleArrayList</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">ArrayList</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReversibleArrayList</span><span class="params">(Collection&lt;T&gt; c)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//实现反向迭代器方法</span></span><br><span class="line">    <span class="keyword">public</span> Iterable&lt;T&gt; <span class="title function_">reversed</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterable</span>&lt;T&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;T&gt;() &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> size() - <span class="number">1</span>;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> current &gt; -<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> get(current--);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdapterMethodIdiom</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ReversibleArrayList&lt;String&gt; ral =</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ReversibleArrayList</span>&lt;String&gt;(Arrays.asList(<span class="string">&quot;To be or not to be&quot;</span>.split(<span class="string">&quot; &quot;</span>)));</span><br><span class="line">        <span class="comment">//通过iterator()获取普通的迭代器</span></span><br><span class="line">        <span class="keyword">for</span> (String s : ral) &#123;</span><br><span class="line">            System.out.print(s + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//获取自定义的迭代器</span></span><br><span class="line">        <span class="keyword">for</span> (String s : ral.reversed() ) &#123;</span><br><span class="line">            System.out.print(s + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">/*Output:</span></span><br><span class="line"><span class="comment">To be or not to be</span></span><br><span class="line"><span class="comment">be to not or be To</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure><h1 id="Comparable-和-Comparator"><a href="#Comparable-和-Comparator" class="headerlink" title="Comparable 和 Comparator"></a>Comparable 和 Comparator</h1><p>Comparable、 Comparator 都是用来实现元素的比较、排序的，只是 Comparable 是在集合内部定义的方法实现的排序，Comparator是在集合外部实现的排序。<br>怎么理解？在这教大家一个速记法，如果英语好的人很容易区分这两者，因为它们的名字已经告诉了我们他们两个最大的区别。</p><ul><li>后缀 <code>able</code> 代表某事物具有什么能力，很显然实现了 Comparable 接口的类自身具有比较大小的能力，假如 A 类实现了 Comparable 接口，那么它必须实现 compareTo 方法，并自身对象 a1 可以直接调用 a1.compareTo(a2) 与另一个对象比较大小。它们的方法的名字也很讲究，这里是 To，也就是跟谁比较，换言之是自己跟别人比较。</li><li>后缀 <code>tor</code> 代表这个事物的属性是一个工具，如果一个类 T 实现了 Comparator 接口，那么它必须实现 compare 方法，那么 T 就是一个比较的工具，只用两个要比较的东西传进来，即 t.compare(a1,a2)，所以这个方法后面没有 To。</li></ul><h2 id="TreeMap-和-TreeSet-以及Collections-工具类中的-sort-方法如何比较元素："><a href="#TreeMap-和-TreeSet-以及Collections-工具类中的-sort-方法如何比较元素：" class="headerlink" title="TreeMap 和 TreeSet 以及Collections 工具类中的 sort()方法如何比较元素："></a>TreeMap 和 TreeSet 以及Collections 工具类中的 sort()方法如何比较元素：</h2><p>TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比 较元素的 compareTo()方法，当插入元素时会回调该方法比较元素的大小。 TreeMap 要求存放的键值对映射的键必须实现 Comparable 接口从而根据键对元 素进行排序。Collections 工具类的 sort 方法有两种重载的形式，第一种要求传入 的待排序容器中存放的对象比较实现 Comparable 接口以实现元素的比较；第二 种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是 Comparator 接口的子类型（需要重写 compare 方法实现元素的比较），相当于 一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对 回调模式的应用（Java 中对函数式编程的支持）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age; <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Student [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.age - o.age; <span class="comment">// 比较年龄(年龄的升序)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p>终于进入正题了…</p><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="为-List-添加元素：c-addAll-和-Collections-addAll"><a href="#为-List-添加元素：c-addAll-和-Collections-addAll" class="headerlink" title="为 List 添加元素：c.addAll() 和 Collections.addAll()"></a>为 List 添加元素：c.addAll() 和 Collections.addAll()</h2><ul><li>使用 c.addAll()的步骤为：<ul><li>先建一个 Collection 对象 c；</li><li>Arrays.asList() 方法接受一个数组或是一个用逗号分隔的元素列表（使用可变参数），并将其转换为一个 List 对象；</li><li>最后 c.addAll(Array.asList())。</li></ul></li><li>使用 Collections.addAll() 步骤：接收一个 Collection 对象，以及一个数组或是一个用逗号分割的列表，将元素添加到 Collection 中，<code>Collections.addAll(Collection&lt;? super T&gt; c, T... elements)</code>。</li></ul><h3 id="Arrays-asList"><a href="#Arrays-asList" class="headerlink" title="Arrays.asList()"></a><a href="https://blog.csdn.net/xlgen157387/article/details/91376347">Arrays.asList()</a></h3><p>ArrayList() 方法返回的是Arrays的一个内部类 Arrays.ArrayList，它底层是数组而且很多 List 的方法并没有实现，因此不能调整尺寸，即不能用 add() 或 delete() 方法。</p><h2 id="List-中的迭代器"><a href="#List-中的迭代器" class="headerlink" title="List 中的迭代器"></a>List 中的迭代器</h2><ul><li>Iterator 只能单向移动<ul><li>forEachRemaining(Consumer&lt;? super E&gt; action)：为每个剩余元素执行给定的操作，直到所有的元素都已经被处理或行动将抛出一个异常；</li><li>hasNext()：如果序列中还有元素，则返回true；</li><li>next()：返回序列中的下一个元素；</li><li>remove()：删除迭代器新近返回的元素。</li></ul></li></ul><p>ListIterator 是一个功能更加强大的 Iterator 的子类型，它继承于 Iterator 接口，只能用于各种 List 类型的访问。可以通过调用 listIterator() 方法产生一个指向 List 开始处的 ListIterator, 还可以调用 listIterator(n) 方法创建一个一开始就指向列表索引为 n 的元素处的 ListIterator。</p><ul><li>ListIterator 可以双向移动<ul><li>add()：在next()方法返回的元素之前或previous()方法返回的元素之后插入一个元素，插入后光标后移。</li><li>hasNext()：如果序列中正序遍历的方向上还有元素，则返回true；</li><li>hasPrevious()：如果序列中逆序遍历的方向上还有元素，则返回true；</li><li>next()：返回序列中的下一个元素，并将游标后移；</li><li>previous()：返回序列中的上一个元素，并将游标前移；</li><li>nextIndex()：返回序列中的上一个元素的坐标，跟随在next()后；</li><li>previousIndex()：返回序列中的下一个元素的坐标，跟随在previous()后 ；</li><li>remove()：删除由next()或previous()新近返回的元素；</li><li>set()：替换由next()或previous()新近返回的元素。</li></ul></li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CrossContainerIteration</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(Iterator&lt;Pet&gt; it)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">      <span class="type">Pet</span> <span class="variable">p</span> <span class="operator">=</span> it.next();</span><br><span class="line">      System.out.print(p.id() + <span class="string">&quot;:&quot;</span> + p + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ArrayList&lt;Pet&gt; pets = Pets.arrayList(<span class="number">8</span>);</span><br><span class="line">    LinkedList&lt;Pet&gt; petsLL = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Pet&gt;(pets);</span><br><span class="line">    HashSet&lt;Pet&gt; petsHS = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Pet&gt;(pets);</span><br><span class="line">    TreeSet&lt;Pet&gt; petsTS = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;Pet&gt;(pets);</span><br><span class="line">    display(pets.iterator());</span><br><span class="line">    display(petsLL.iterator());</span><br><span class="line">    display(petsHS.iterator());</span><br><span class="line">    display(petsTS.iterator());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx</span></span><br><span class="line"><span class="comment">4:Pug 6:Pug 3:Mutt 1:Manx 5:Cymric 7:Manx 2:Cymric 0:Rat</span></span><br><span class="line"><span class="comment">5:Cymric 2:Cymric 7:Manx 1:Manx 3:Mutt 6:Pug 4:Pug 0:Rat</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure><h2 id="ArrayList-和-LinkedList"><a href="#ArrayList-和-LinkedList" class="headerlink" title="ArrayList 和 LinkedList"></a>ArrayList 和 LinkedList</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Default initial capacity.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Shared empty array instance used for empty instances.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Shared empty array instance used for default sized empty instances. We</span></span><br><span class="line"><span class="comment">     * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span></span><br><span class="line"><span class="comment">     * first element is added.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The array buffer into which the elements of the ArrayList are stored.</span></span><br><span class="line"><span class="comment">     * The capacity of the ArrayList is the length of this array buffer. Any</span></span><br><span class="line"><span class="comment">     * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment">     * will be expanded to DEFAULT_CAPACITY when the first element is added.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The size of the ArrayList (the number of elements it contains).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pointer to first node.</span></span><br><span class="line"><span class="comment">     * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">     *            (first.prev == null &amp;&amp; first.item != null)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pointer to last node.</span></span><br><span class="line"><span class="comment">     * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">     *            (last.next == null &amp;&amp; last.item != null)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h3><ul><li>ArrayList 本质是一个支持扩容的数组，所以它是有序的（物理有序），而 LinkedList 本质是一个双向链表，所以无序；</li><li>LinkedList 实现了实现了 Deque(Double ended queue) 接口，而 Deque 又继承自 Queue，所以可以当做当作普通队列、双向队列（单调队列）、栈使用；</li><li>ArrayList 和 LinkedList 都实现了 Cloneable 接口，即覆盖了函数 clone()，能克隆；</li><li>ArrayList 和 LinkedList 都不是线程安全的。</li></ul><h3 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h3><p>ArrayList 和 LinkedList 都实现 java.io.Serializable 接口，所以都支持序列化，能通过序列化去传输，但注意它们的主要属性都被 <code>transient</code> 修饰了，那还怎么序列化？原来为了提升序列化的效率它们内部是通过实现 readObject() 和 writeObject() 方法（反射调用）来实现自定义序列化的，具体而言：</p><ul><li>ArrayList 在序列化的时候会调用 writeObject，直接将 size 和 element 写入 ObjectOutputStream；反序列化时调用 readObject，从 ObjectInputStream 获取 size 和 element，再恢复到 elementData。为什么不直接用 elementData 来序列化，而采用上诉的方式来实现序列化呢？原因在于 elementData 是一个缓存数组，它通常会预留一些容量，等容量不足时再扩充容量，那么有些空间可能就没有实际存储元素，采用上诉的方式来实现序列化时，就可以保证只序列化实际存储的那些元素，而不是整个数组，从而节省空间和时间。</li><li>同理 LinkedList 中也重写了 writeObject 方法，ObjectOutputStream 中将调用 ObjectStreamClass 里的方法通过反射根据方法名称来调用 writeObject 方法，以 LinkedList 中定义的方式来序列化链表中的元素和 size 字段，反序列化时调用 readObject，从 ObjectInputStream 获取 size 和 链表中的元素；</li></ul><h3 id="怎么选择？"><a href="#怎么选择？" class="headerlink" title="怎么选择？"></a>怎么选择？</h3><ul><li>涉及到“栈”、“队列”、“链表”等操作，应该考虑用List，具体的选择哪个List，根据下面的标准来取舍：<ul><li>对于需要快速插入、删除元素，中间插入、删除元素，应该使用 LinkedList；</li><li>对于需要快速随机访问元素，应该使用 ArrayList；</li><li>对于“单线程环境” 或者 “多线程环境，但 List 仅仅只会被单个线程操作”，此时应该使用非同步的类(如 ArrayList )；</li><li>对于“多线程环境，且 List 可能同时被多个线程操作”，此时，应该使用同步的类(Vector类 &#x2F; Colletions封装 &#x2F; JUC类)。</li></ul></li></ul><h3 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h3><p>唯有的几个线程安全的集合已经被弃用了，Vector 和 Hashtable 我觉得是因为大量使用 synchronized 加重量级锁导致的性能很差。</p><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>Set集合的特点：不能存储相同的元素。典型的实现包括：</p><ul><li>HashSet：为快速查找而设计的Set，存入HashSet的元素必须定义 hashCode()。哈希表是通过使用称为散列法的机制来存储信息的，元素并没有以某种特定顺序来存放；</li><li>LinkedHashSet：具有HashSet的查询速度，且内部使用链表维护元素的数据（插入的次序）。于是在使用迭代器遍历Set时，结果会按元素插入的次序显示。元素也必须定义hashCode()方法；</li><li>TreeSet：保持次序的Set，底层为树结构。使用它可以从set中提取有序的序列。元素必须实现Comparable接口。</li></ul><p>该接口主要继承于Collection接口，所以具有Collection的一些常见的方法，但与List不同的是，Set还提供了equals(Object o)和hashCode()，供其子类重写，以实现对集合中插入重复元素的处理。</p><table><thead><tr><th>No.</th><th>Method &amp; Description</th></tr></thead><tbody><tr><td>1</td><td>add( ) 向集合中添加元素</td></tr><tr><td>2</td><td>clear( ) 去掉集合中所有的元素</td></tr><tr><td>3</td><td>contains( ) 判断集合中是否包含某一个元素</td></tr><tr><td>4</td><td>isEmpty( ) 判断集合是否为空</td></tr><tr><td>5</td><td>iterator( ) 主要用于递归集合，返回一个Iterator()对象</td></tr><tr><td>6</td><td>remove( ) 从集合中去掉特定的对象</td></tr><tr><td>7</td><td>size( ) 返回集合的大小</td></tr></tbody></table><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>HashSet实现Set接口，<strong>底层由HashMap来实现</strong>，为哈希表结构，新增元素相当于HashMap的key，value默认为一个固定的Object。在我看来，HashSet相当于一个阉割版的HashMap;当有元素插入的时候，会计算元素的hashCode值，将元素插入到哈希表对应的位置中来；它继承于AbstractSet，实现了Set, Cloneable, Serializable接口。</p><ul><li>HashSet继承AbstractSet类，获得了Set接口大部分的实现，减少了实现此接口所需的工作，实际上是又继承了AbstractCollection类；</li><li>HashSet实现了Set接口，获取Set接口的方法，可以自定义具体实现，也可以继承AbstractSet类中的实现；</li><li>HashSet实现Cloneable，得到了clone()方法，可以实现克隆功能；</li><li>HashSet实现Serializable，表示可以被序列化，通过序列化去传输，典型的应用就是hessian协议。</li></ul><p>具有如下特点：</p><ul><li>不允许出现重复因素；</li><li>允许插入Null值；</li><li>元素无序（添加顺序和遍历顺序不一致）；</li><li>线程不安全。</li></ul><h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><p>从名字上可以看出，此集合的实现和树结构有关。与HashSet集合类似，TreeSet也是基于Map来实现，具体实现TreeMap，其底层结构为<strong>红黑树的排序二叉树来保存Map中的的每个Entry——每个Entry都被当做红黑树的一个节点来对待；</strong>；与HashSet不同的是，TreeSet具有排序功能，分为自然排序(123456)和自定义排序两类，默认是自然排序；在程序中，我们可以按照任意顺序将元素插入到集合中，等到遍历时TreeSet会按照一定顺序输出——倒序或者升序；它继承AbstractSet，实现NavigableSet, Cloneable, Serializable接口。</p><ul><li>与HashSet同理，TreeSet继承AbstractSet类，获得了Set集合基础实现操作；</li><li>TreeSet实现NavigableSet接口，而NavigableSet又扩展了SortedSet接口。这两个接口主要定义了搜索元素的能力，例如给定某个元素，查找该集合中比给定元素大于、小于、等于的元素集合，或者比给定元素大于、小于、等于的元素个数；简单地说，实现NavigableSet接口使得TreeSet具备了元素搜索功能；</li><li>TreeSet实现Cloneable接口，意味着它也可以被克隆；</li><li>TreeSet实现了Serializable接口，可以被序列化，可以使用hessian协议来传输；</li></ul><p>具有如下特点：</p><ul><li>对插入的元素进行排序，是一个有序的集合（主要与HashSet的区别）;</li><li>底层使用红黑树结构，而不是哈希表结构；</li><li>允许插入Null值；</li><li>不允许插入重复元素；</li><li>线程不安全。</li></ul><h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><p>队列是一个典型的先进先出（FIFO）的容器，一般在队尾插入，在队头删除。队列在并发编程中非常重要，可以安全地将对象从一个任务传输到另一个任务。</p><ul><li>有界队列：即队列中的元素个数有限制；</li><li>无界队列：即队列中的元素个数无限制。</li></ul><h2 id="Queue-的方法"><a href="#Queue-的方法" class="headerlink" title="Queue 的方法"></a>Queue 的方法</h2><ul><li>向队列中添加元素<ul><li>add()：向有界队列中添加元素的时候，如果元素的数量超过临界值，会抛出异常java.lang.IllegalStateException: Queue full；</li><li>offer()：向有界队列中添加元素的时候，如果元素的数量超过临界值，会添加失败，失败时返回一个特殊值(取决于操作，为null或false)，但不会抛出异常。</li></ul></li><li>获取队列中的头部元素并删除<ul><li>remove():当队列中没有可获取的元素时，会抛出异常 java.util.NoSuchElementException；</li><li>poll():当队列中没有可获取的元素时，返回一个特殊值(取决于操作，为null或false)。</li></ul></li><li>获取队列中的头部元素但不删除<ul><li>element():当队列中没有可获取的元素时，会抛出异常java.util.NoSuchElementException；</li><li>peek():当队列中没有可获取的元素时，返回一个特殊值(取决于操作，为null或false)。</li></ul></li></ul><h2 id="Deque-双向队列"><a href="#Deque-双向队列" class="headerlink" title="Deque (双向队列)"></a>Deque (双向队列)</h2><p>Deque （Double ended queue）接口继承自 Queue 接口，但它新增了很多方法以实现<strong>双向队列（单调队列）和栈</strong>。Queue 只能在队尾插入，在队头删除（或 peek() 获取），而双端队列队头队尾都能插入删除，主要增加了以下方法，first 代表队头，last 代表队尾：</p><h3 id="双向队列（单调队列）"><a href="#双向队列（单调队列）" class="headerlink" title="双向队列（单调队列）"></a>双向队列（单调队列）</h3><ul><li>添加和删除：<ul><li>addFirst（会抛异常）</li><li>addLast（会抛异常）</li><li>offerFirst</li><li>offerLast</li><li>removeFirst（会抛异常）</li><li>removeLast（会抛异常）</li><li>pollFirst</li><li>pollLast</li></ul></li><li>获取：<ul><li>peekFirst</li><li>peekLast</li><li>getFirst（会抛异常）</li><li>getLast（会抛异常）</li></ul></li></ul><h3 id="栈（栈顶在队头）"><a href="#栈（栈顶在队头）" class="headerlink" title="栈（栈顶在队头）"></a>栈（栈顶在队头）</h3><ul><li>push</li><li>pop</li><li>peek （返回栈顶元素，也就是队头）</li></ul><h2 id="PriorityQueue-堆"><a href="#PriorityQueue-堆" class="headerlink" title="PriorityQueue (堆)"></a>PriorityQueue (堆)</h2><p>先进先出声明的是下一个元素应该是等待时间最长的元素。优先级队列声明下一个弹出元素是最需要的元素(具有最高的优先级)。当在PriorityQueue上调用offer()方法来插入一个对象，要求这个对象一定是可排序的（继承自Comparable方法），这个对象会在队列中被排序。默认的排序将使用对象在队列中的自然顺序，但是你可以通过提供自己的Comparator来修改这个顺序。PriorityQueue可以确保当你调用peek()、poll()和 remove()等方法时，获取的元素将是队列中优先级最高的元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Origin &#123; &#125;</span><br><span class="line"></span><br><span class="line">public class E29 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        PriorityQueue&lt;Origin&gt; priorityQueue = new PriorityQueue&lt;&gt;();</span><br><span class="line">        System.out.println(&quot;Adding 1st instance...&quot;);</span><br><span class="line">        priorityQueue.offer(new Origin());</span><br><span class="line">        System.out.println(&quot;Adding 2st instance...&quot;);</span><br><span class="line">        priorityQueue.offer(new Origin());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中会抛出异常，因为JDK文档声明:“依赖于自然排序的优先级队列也不允许插入不可比较的对象(这样做可能会导致ClassCastException)。”所以第二次插入将触发异常，所以改成下面这样就好了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Origin implements Comparable&lt;Origin&gt;&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Origin o) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>通过查看Map接口描述，发现Map接口下的集合与Collection接口下的集合，它们存储数据的形式不同。Collection中的集合，元素是<strong>孤立</strong>存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。Map中的集合，元素是<strong>成对</strong>存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。Collection中的集合称为单列集合，Map中的集合称为双列集合。</p><p>需要注意的是，Map中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。</p><p>Map中常用的集合为HashMap集合、LinkedHashMap集合。</p><table><thead><tr><th>序号</th><th>方法描述</th></tr></thead><tbody><tr><td>1</td><td>void clear( ) 从此映射中移除所有映射关系（可选操作）。</td></tr><tr><td>2</td><td>boolean containsKey(Object k) 如果此映射包含指定键的映射关系，则返回 true。</td></tr><tr><td>3</td><td>boolean containsValue(Object v) 如果此映射将一个或多个键映射到指定值，则返回 true。</td></tr><tr><td>4</td><td>Set entrySet( ) 返回此映射中包含的映射关系的 Set 视图。</td></tr><tr><td>5</td><td>boolean equals(Object obj) 比较指定的对象与此映射是否相等。</td></tr><tr><td>6</td><td>Object get(Object k) 返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回 null。</td></tr><tr><td>7</td><td>int hashCode( ) 返回此映射的哈希码值。</td></tr><tr><td>8</td><td>boolean isEmpty( ) 如果此映射未包含键-值映射关系，则返回 true。</td></tr><tr><td>9</td><td>Set keySet( ) 返回此映射中包含的键的 Set 视图。</td></tr><tr><td>10</td><td>Object put(Object k, Object v) 将指定的值与此映射中的指定键关联（可选操作）。</td></tr><tr><td>11</td><td>void putAll(Map m) 从指定映射中将所有映射关系复制到此映射中（可选操作）。</td></tr><tr><td>12</td><td>Object remove(Object k) 如果存在一个键的映射关系，则将其从此映射中移除（可选操作）。</td></tr><tr><td>13</td><td>int size( ) 返回此映射中的键-值映射关系数。</td></tr><tr><td>14</td><td>Collection values( ) 返回此映射中包含的值的 Collection 视图。</td></tr></tbody></table><h2 id="hashcode-和-equals-的设计"><a href="#hashcode-和-equals-的设计" class="headerlink" title="hashcode() 和 equals() 的设计"></a>hashcode() 和 equals() 的设计</h2><ul><li>原则<ul><li>对象相同（场景定义下），hashcode 一定相同（等价表述：hashcode 不相同，对象一定不相同）；</li><li>hashcode 相同，对象不一定相同。</li></ul></li><li>原因<ul><li><strong>因为默认的hashcode方法是根据对象的地址生成的</strong>，所以任何一个对象的hash值都是不同的，但在实际的场景中可能出现含有相同意义的多个对象地址不同（hash值），这就导致了我们“不想要的一个key”对应多个value的问题，所以一定要重写hashcode方法；</li><li>同样因为重写了hashcode方法，所以同一个hashcode位置上可能对应多个对象（甚至包括场景定义下不同含义的对象——即hash冲突），这时就需要调用equals方法判断新来的对象（的key）与已经有的对象(的key)是否相等，<strong>因为默认的equals方法也是判断地址是否相同</strong>，所以仍然存在前面的问题，即含有相同意义的多个对象地址不同，而导致相同的key有多个value，所以也要重写equals方法，这里是双重检查。可以简单理解为我们要根据业务需求定义自己的相等机制。</li></ul></li><li>方案<ul><li>所以在 HashMap 中作为 key 的对象一定要重写 equals 和 hashcode 方法；</li><li>这样设计不仅可以解决上述问题，而且可以提高效率，在匹配桶位时，先计算hashcode 通过 hashcode 进行散列，相同对象的 hashcode 肯定散列到同一桶位；</li><li>而且可以防止 hash 冲突，因为可能存在不同对象产生相同 hashcode 的情况，然后再进入链表 or 红黑树通过 equals 方法判断是否存在相同对象，存在则更新，不存在则插入。</li></ul></li><li>流程<ul><li>计算对象的hashcode，看在表中是否存在;</li><li>如果存在则检查对应hashcode位置中的对象和当前对象是否“相等”，“相等”则说明为同一个key，覆盖；不“相等”则添加(key,value)对;</li><li>如果不存在直接添加(key,value)对。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 持有对象(容器) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射</title>
      <link href="/2021/04/21/%E5%8F%8D%E5%B0%84/"/>
      <url>/2021/04/21/%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1 id="关于RTTI（运行时识别对象和类的信息）"><a href="#关于RTTI（运行时识别对象和类的信息）" class="headerlink" title="关于RTTI（运行时识别对象和类的信息）"></a>关于RTTI（运行时识别对象和类的信息）</h1><p>主要有两种：一种是“传统”的RTTI，另一种是“反射”机制，它允许我们在运行时发现和使用类的信息。RTTI形式包括：</p><ul><li><p>传统的类型转换，如“（ Shape）”，由RTTI确保类型转换的正确性，如果执行了一个错误类型转换，就会抛出一个 ClassCastException异常。</p></li><li><p>代表对象的类型的Class对象。通过查询 Class对象可以获取运行时所需的信息。</p></li><li><p>关键字 instanceof。它返回一个布尔值，告诉我们对象是不是某个特定类型的实例。可以用提问的方式使用它，就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(x <span class="keyword">instanceof</span> Dog)</span><br><span class="line">    ((Dog)x).bark();</span><br></pre></td></tr></table></figure></li></ul><span id="more"></span><h1 id="Class对象"><a href="#Class对象" class="headerlink" title="Class对象"></a>Class对象</h1><p>​Java使用Class对象来执行其RTTI，Class对象是一种特殊的对象。每个类都有一个Class对象。换言之，每当编写并且编译了一个新类就会产生一个Class对象（更恰当地说，<strong>是被保存在一个同名的class件中，实际上在JVM中是保存在堆中的）。</strong></p><h2 id="Java中获取Class对象的三种方法"><a href="#Java中获取Class对象的三种方法" class="headerlink" title="Java中获取Class对象的三种方法"></a>Java中获取Class对象的三种方法</h2><ol><li>Class.forName（“类的路径”）</li></ol><p>​它是用一个包含目标类的文本名（注意拼写和大小写）的String作输入参数，返回的是一个Class对象的引用，上面的代码忽略了返回值。如果 Class.forName()找不到你要加载的类，它会抛出异常ClassNotFoundException。这里我们只需简单报告问题，但在更严密的程序里，可能要在异常处理程序。</p><ol start="2"><li>类字面常量：类名.class ()</li></ol><p>​类字面常量不仅可以应用于普通的类，也可以应用于接口、数组以及基本数据类型。另外，对于基本数据类型的包装器类，还有一个标准字段TYPE。TYPE字段是一个引用，指向对应的基本数据类型的Class对象，例如boolean.class…等价于…Boolean.TYPE。</p><ol start="3"><li>实例.getClass()</li></ol><p>​比较：注意，有一点很有趣，当使用“.class”来创建对Class对象的引用时，<strong>不会自动地初始化该Class对象</strong>，Class.forName（）<strong>会立即初始化</strong>。为了使用类而做的准备工作实际包含三个步骤：</p><ul><li>加载，这是由类加载器执行的。该步骤将查找字节码（通常在 classpath所指定的路径中查找，但这并非是必需的），并从这些字节码中创建一个Class对象。</li><li>链接(验证、准备、解析)。在链接阶段将验证类中的字节码，为静态域分配存储空间，并且如果必需的话将解析这个类创建的对其他类的所有引用</li><li>初始化。如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块。</li></ul><p>​初始化被延迟到了对静态方法（构造器隐式地是静态的）或者非常数静态域进行首次引用时才执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">class Initable &#123;</span><br><span class="line">    // 编译期常量</span><br><span class="line">    static final int staticFinal = 1;</span><br><span class="line">    // 不是编译期常量</span><br><span class="line">    static final int getStaticFinal2 =</span><br><span class="line">            ClassInitialization.rand.nextInt(1000);</span><br><span class="line">    static  &#123;</span><br><span class="line">        System.out.println(&quot;Initializing Initable&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Initable2 &#123;</span><br><span class="line">    static int staticNonFinal = 2;</span><br><span class="line">    static  &#123;</span><br><span class="line">        System.out.println(&quot;Initializing Initable2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Initable3 &#123;</span><br><span class="line">    static int staticNonFinal = 3;</span><br><span class="line">    static  &#123;</span><br><span class="line">        System.out.println(&quot;Initializing Initable3&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ClassInitialization &#123;</span><br><span class="line">    public static Random rand = new Random(47);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 仅使用.class语法来获得对类的引用不会引发初始化</span><br><span class="line">        Class initable = Initable.class;</span><br><span class="line">        System.out.println(&quot;After creating Initable ref&quot;);</span><br><span class="line"></span><br><span class="line">        // 没有触发初始化</span><br><span class="line">        // static final -- 编译器常量，那么这个值不需要对 Initable 类进行初始化就可以被读取</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(Initable.staticFinal);</span><br><span class="line"></span><br><span class="line">        // 触发初始化</span><br><span class="line">        // 如果只是将一个域设置为static和final的，还不足以确保这种行为</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(Initable.getStaticFinal2);</span><br><span class="line"></span><br><span class="line">        // 触发初始化</span><br><span class="line">        // 如果一个static域不是final的，那么在对它访问时，总是要求在它被读取之前</span><br><span class="line">        // 要先进行链接（为这个域分配存储空间）和初始化（初始化该存储空间）</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(Initable2.staticNonFinal);</span><br><span class="line"></span><br><span class="line">        // 触发初始化,并且可能会抛出ClassNotFoundException</span><br><span class="line">        System.out.println();</span><br><span class="line">        Class initiable3 = Class.forName(&quot;chapter14.Initable3&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(&quot;After creating Initable3 ref&quot;);</span><br><span class="line">        System.out.println(Initable3.staticNonFinal);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125; /* Output:</span><br><span class="line">After creating Initable ref</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">Initializing Initable</span><br><span class="line">258</span><br><span class="line"></span><br><span class="line">Initializing Initable2</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">Initializing Initable3</span><br><span class="line"></span><br><span class="line">After creating Initable3 ref</span><br><span class="line">3</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>​如果不知道某个对象的确切类型，RTTI可以告诉你。但是有一个限制：这个类型在编译时必须已知，这样才能使用RTTI识别它，并利用这些信息做一些有用的事。换句话说，<strong>在编译时编译器必须知道所有要通过RTTI来处理的类。</strong>但是假设你获取了一个指向某个并不在你的程序空间中的对象的引用，在编译时你的程序根本没法获知这个对象所属的类。既然这个类在编译器为你的程序生成代码之后很久才会出现，那么怎样才能使用这样的类呢？</p><p>​反射提供了一种机制一用来检查可用的方法，并返回方法名。想要在运行时获取类的信息的另一个动机，便是希望提供在跨网络的远程平台上创建和运行对象的能力。这被称为远程方法调用（RMI），它允许一个Java程序将对象分布到多台机器上。Class类与 java.lang.reflect类库一起对反射的概念进行了支持，该类库包含了 Field, Method以及Constructor类（每个类都实现了 Member接口）。</p><p>​Reflection（反射）是 Java 被视为动态语言的关键，反射机制允许程序在执行期借助 Reflection API 取得任何类的信息，并能直接操作任意对象的内部属性及方法。</p><p>​Class c &#x3D; Class.forName(“java.lang.String”)<br>​加载完类之后，在堆内存的方法区中就产生了一个 Class 类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，形象地称为反射，通俗点讲， 通过反射，该类对我们来说是完全透明的，想要获取任何东西都可以。</p><p>​正常方式：引入需要的“包类”名称 ——&gt; 通过 new 实例 ——&gt; 取得实例化对象</p><p>​反射方式：实例化对象 ——&gt; getClass() ——&gt; 得到完整的“包类”名称</p><p>​反射机制井没有什么神奇之处。当通过反射与一个未知类型的对象打交道时，JVM只是简单地检查这个对象，看它属于哪个特定的类（就像RTTI那样）。在用它做其他事情之前必须先加载那个类的Class对象。因此，那个类的.claas文件对于JVM来说必须是可获取的：要么在本地机器上，要么可以通过网络取得。<strong>所以RTTI和反射之间真正的区别只在于：对RTTI来说，编译器在编译时打开和检查 class文件；而对于反射机制来说，class文件在编译时是不可获取的，所以是在运行时打开和检查 class文件</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">package chapter14.exercise17;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.*;</span><br><span class="line">import java.util.regex.*;</span><br><span class="line"></span><br><span class="line">public class E17_ShowMethods2 &#123;</span><br><span class="line">    private static String usage =</span><br><span class="line">        &quot;usage:\n&quot; +</span><br><span class="line">        &quot;E17_ShowMethods2 qualified.class.name\n&quot; +</span><br><span class="line">        &quot;To show all methods in class or:\n&quot; +</span><br><span class="line">        &quot;E17_ShowMethods2 qualified.class.name word\n&quot; +</span><br><span class="line">        &quot;To search for methods involving &#x27;word&#x27;&quot;;</span><br><span class="line">    // 去掉native和final关键字</span><br><span class="line">    private static Pattern p =</span><br><span class="line">            Pattern.compile(&quot;\\w+\\.|native\\s|final\\s&quot;);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        if(args.length &lt; 1) &#123;</span><br><span class="line">            System.out.println(usage);</span><br><span class="line">            System.exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">        int lines = 0;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class&lt;?&gt; c = Class.forName(args[0]);</span><br><span class="line">            Method[] methods = c.getMethods();</span><br><span class="line">            Constructor&lt;?&gt;[] ctors = c.getConstructors();</span><br><span class="line">            if(args.length == 1) &#123;</span><br><span class="line">                for(Method method : methods)</span><br><span class="line">                    System.out.println(</span><br><span class="line">                            p.matcher(method.toString()).replaceAll(&quot;&quot;));</span><br><span class="line">                for(Constructor&lt;?&gt; ctor : ctors)</span><br><span class="line">                    System.out.println(</span><br><span class="line">                            p.matcher(ctor.toString()).replaceAll(&quot;&quot;));</span><br><span class="line">                lines = methods.length + ctors.length;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                for(Method method : methods)</span><br><span class="line">                    if(method.toString().indexOf(args[1]) != -1) &#123;</span><br><span class="line">                        System.out.println(</span><br><span class="line">                                p.matcher(method.toString()).replaceAll(&quot;&quot;));</span><br><span class="line">                        lines++;</span><br><span class="line">                    &#125;</span><br><span class="line">                for(Constructor&lt;?&gt; ctor : ctors)</span><br><span class="line">                    if(ctor.toString().indexOf(args[1]) != -1) &#123;</span><br><span class="line">                        System.out.println(p.matcher(</span><br><span class="line">                            ctor.toString()).replaceAll(&quot;&quot;));</span><br><span class="line">                        lines++;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch(ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(&quot;No such class: &quot; + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; /* Output:</span><br><span class="line">public static void main(String[])</span><br><span class="line">public int hashCode() public Class getClass()</span><br><span class="line">public void wait(long,int) throws InterruptedException</span><br><span class="line">public void wait() throws InterruptedException</span><br><span class="line">public void wait(long) throws InterruptedException</span><br><span class="line">public boolean equals(Object)</span><br><span class="line">public String toString()</span><br><span class="line">public void notify()</span><br><span class="line">public void notifyAll()</span><br><span class="line">//生成的默认构造器与类有相同的权限，E17_ShowMethods改成非public类就不会输出</span><br><span class="line">public E17_ShowMethods2()  </span><br><span class="line">*///:~</span><br><span class="line"></span><br><span class="line">/* 命令：</span><br><span class="line">java E17_ShowMethods2.java chapter14.exercise17.E17_ShowMethods2</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>​代理是基本的设计模式之一，它是你为了提供额外的或不同的操作，而插入的用来代替“实际”对象的对象。这些操作通常涉及与“实际”对象的通信，因此代理通常充当着中间人的角色。</p><p><img src="1.jpg" alt="1"></p><p>动态代理的好处：</p><p>​可以使得我们的真实角色更加纯粹 . </p><p>​不再去关注一些公共的事情 . 公共的业务由代理来完成 . </p><p>​实现了业务的分工 , 公共业务发生扩展时变得更加集中和方便 . </p><p>​一个动态代理 , 一般代理某一类业务</p><p>​ 一个动态代理可以代理多个类，代理的是接口！也就是可以通过多个接口来代理类</p><p>下面是一个用来展示<strong>静态代理</strong>结构的简单示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Interface</span> &#123; </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">somethingElse</span><span class="params">(String arg)</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实际类（实现接口）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealObject</span> <span class="keyword">implements</span> <span class="title class_">Interface</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doSomething&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">somethingElse</span><span class="params">(String arg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;somethingElse &quot;</span> + arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理类 （传入实现接口）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleProxy</span> <span class="keyword">implements</span> <span class="title class_">Interface</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Interface proxied;</span><br><span class="line">    <span class="comment">// 传入真实对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleProxy</span><span class="params">(Interface proxied)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.proxied = proxied;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SimpleProxy doSomething&quot;</span>);</span><br><span class="line">        proxied.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">somethingElse</span><span class="params">(String arg)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SimpleProxy somethingElse &quot;</span> + arg);</span><br><span class="line">        proxied.somethingElse(arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleProxyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">(Interface iface)</span> &#123;</span><br><span class="line">        iface.doSomething();</span><br><span class="line">        iface.somethingElse(<span class="string">&quot;bonobo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        consumer(<span class="keyword">new</span> <span class="title class_">RealObject</span>());</span><br><span class="line">        consumer(<span class="keyword">new</span> <span class="title class_">SimpleProxy</span>(<span class="keyword">new</span> <span class="title class_">RealObject</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">doSomething</span></span><br><span class="line"><span class="comment">somethingElse bonobo</span></span><br><span class="line"><span class="comment">SimpleProxy doSomething</span></span><br><span class="line"><span class="comment">doSomething</span></span><br><span class="line"><span class="comment">SimpleProxy somethingElse bonobo</span></span><br><span class="line"><span class="comment">somethingElse bonobo</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure><p>因为 consumer()接受的是Interface，所以它无法知道正在获得的到底是RealObject还是SimpleProxy，因为这二者都实现了 Interface。但是 SimpleProxy已经被插入到了客户端和RealObject之间，因此它会执行操作，然后调用RealObject上相同的方法在任何时刻，只要你想要将额外的操作从“实际”对象中分离到不同的地方，特别是当你希望能够很容易地做出修改，从没有使用额外操作转为使用这些操作，或者反过来时，代理就显得很有用（设计模式的关键就是封装修改一因此你需要修改事务以证明这种模式的正确性）。</p><p>Java<strong>动态代理</strong>比静态代理的思想更向前迈进了一步，因为它可以<strong>动态地创建代理并动态地处理对所代理方法的调用。动态代理的代理类是动态生成的 ，静态代理的代理类是我们提前写好的</strong>在动态代理上所做的所有调用都会被重定向到单一的调用处理器上，它的工作是揭示调用的类型并确定相应的对策。下面是用动态代理重写的 SimpleProxyDemo.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Interface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">somethingElse</span><span class="params">(String arg)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealObject</span> <span class="keyword">implements</span> <span class="title class_">Interface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doSomething&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">somethingElse</span><span class="params">(String arg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;somethingElse &quot;</span> + arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//**提供的方法增强，可以在真实对象的方法前或者是方法后进行数据增强**proxied指的是被代理的对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DynamicProxyHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object proxied;  <span class="comment">//这个是要传入的真实对象也就是被代理的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DynamicProxyHandler</span><span class="params">(Object proxied)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.proxied = proxied;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//proxy是真实对象的代理对象，也就是调度者，客户通过proxy去访问真实对象的方法，与下文的proxy类型相同</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 调用proxy.toString()方法来打印代理对象将会陷入死循环</span></span><br><span class="line">        <span class="comment">// 在invoke()内部进入无限循环，并最终崩溃(java.lang.StackOverflowError)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;**** proxy: &quot;</span> + proxy.getClass() + <span class="string">&quot;, method: &quot;</span> + method + <span class="string">&quot;, args: &quot;</span> + args);</span><br><span class="line">        <span class="keyword">if</span>(args != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">for</span>(Object arg : args)</span><br><span class="line">                System.out.println(<span class="string">&quot; &quot;</span> + arg);</span><br><span class="line">        <span class="comment">//在这里调用方法 method就是真实类提供的方法，proxied是真实对象，args是要传入真实对象的参数</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(proxied, args);</span><br><span class="line">        <span class="comment">//这里可以对执行方法后进行操作处理。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E22_SimpleDynamicProxyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">(Interface iface)</span> &#123;</span><br><span class="line">        iface.doSomething();</span><br><span class="line">        iface.somethingElse(<span class="string">&quot;bonobo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RealObject</span> <span class="variable">real</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealObject</span>();</span><br><span class="line">        consumer(real);</span><br><span class="line">        <span class="comment">// 插入代理再调用一遍</span></span><br><span class="line">        <span class="comment">// 通过调用静态方法 Proxy.newProxyInstance可以创建动态代理，这个方法需要:</span></span><br><span class="line">        <span class="comment">// 1.一个类加载器（你通常可以从已经被加载的对象中获取其类加载器，然后传递给它）</span></span><br><span class="line">        <span class="comment">// 2.一个你希望该代理实现的接口列表（不是类或抽象类）</span></span><br><span class="line">        <span class="comment">// 3.以及InvocationHandler接口的一个实现</span></span><br><span class="line">        <span class="type">Interface</span> <span class="variable">proxy</span> <span class="operator">=</span> (Interface)Proxy.newProxyInstance( <span class="comment">//动态创建代理实例</span></span><br><span class="line">                Interface.class.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123; Interface.class &#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">DynamicProxyHandler</span>(real));</span><br><span class="line">        consumer(proxy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">/*Output:</span></span><br><span class="line"><span class="comment">doSomething</span></span><br><span class="line"><span class="comment">somethingElse bonobo</span></span><br><span class="line"><span class="comment">**** proxy: class chapter14.exercise22.$Proxy0, method: public abstract void chapter14.exercise22.Interface.doSomething(), args: null</span></span><br><span class="line"><span class="comment">doSomething</span></span><br><span class="line"><span class="comment">**** proxy: class chapter14.exercise22.$Proxy0, method: public abstract void chapter14.exercise22.Interface.somethingElse(java.lang.String), args: [Ljava.lang.Object;@2503dbd3</span></span><br><span class="line"><span class="comment"> bonobo</span></span><br><span class="line"><span class="comment">somethingElse bonobo</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型</title>
      <link href="/2021/04/16/%E6%B3%9B%E5%9E%8B/"/>
      <url>/2021/04/16/%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>​泛型实现了参数化类型的概念，使代码可以应用于多种类型。“泛型”这个术语的意思是：“适用于许多许多的类型”。泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p><p>一些常用的泛型类型变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">E：元素（Element），多用于集合</span><br><span class="line">K：关键字（Key）</span><br><span class="line">V：值（Value）</span><br><span class="line">N：数字（Number）</span><br><span class="line">T：类型（Type）</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h1><p>泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassA&lt;T&gt; &#123;</span><br><span class="line">    private T a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h1><p>泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Generator&lt;T&gt; &#123;</span><br><span class="line">    public T next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别的，泛型同时继承类和实现接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;T extends Class1 &amp; Interface1&gt; // 具体的类在前面，接口在后</span><br><span class="line">&lt;T extends Class1 &amp; Interface1 &amp; Interface2&gt; // 具体的类只能有一个，接口可以有多个</span><br></pre></td></tr></table></figure><h1 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h1><p><strong>泛型类，是在创建对象的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型 。</strong></p><p>泛型方法使得该方法能够独立于类而产生变化。以下是一个基本的指导原则：<strong>无论何时只要你能做到，你就应该尽量使用泛型方法</strong>。也就是说，如果使用泛型方法可以取代将整个类泛型化，那么就应该只使用泛型方法，因为它可以使事情更清楚明白。另外，对于一个static的方法而言，无法访问泛型类的类型参数（因为static方法是与对象无关的），所以，<strong>如果static方法需要使用泛型能力，就必须使其成为泛型方法</strong>。</p><p>要定义泛型方法，只需将泛型参数列表置于返回值之前，就像下面这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class E09_GenericMethods &#123;</span><br><span class="line">    // 实现类似于无限重载的功能</span><br><span class="line">    public &lt;A,B,C&gt; void f(A a, B b, C c) &#123;</span><br><span class="line">        System.out.println(a.getClass().getName());</span><br><span class="line">        System.out.println(b.getClass().getName());</span><br><span class="line">        System.out.println(c.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        E09_GenericMethods gm = new E09_GenericMethods();</span><br><span class="line">        gm.f(&quot;&quot;, 1, 1.0);</span><br><span class="line">        gm.f(1.0F, &#x27;c&#x27;, gm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; /* Output:</span><br><span class="line">java.lang.String</span><br><span class="line">java.lang.Integer</span><br><span class="line">java.lang.Double</span><br><span class="line">java.lang.Float</span><br><span class="line">java.lang.Character</span><br><span class="line">generics.E09_GenericMethods2</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><p>static示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class StaticGenerator&lt;T&gt; &#123;</span><br><span class="line">    // 泛型方法里的T不是泛型类里的T，此处的T是一个局部变量，可以与类重名</span><br><span class="line">    public static &lt;T&gt; void show(T t)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，泛型方法与可变参数列表能够很好地共存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class GenericVarargs &#123;</span><br><span class="line">    public static &lt;T&gt; List&lt;T&gt; makeList(T... args) &#123;</span><br><span class="line">        List&lt;T&gt; result = new ArrayList&lt;T&gt;();</span><br><span class="line">        for(T item : args)</span><br><span class="line">            result.add(item);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;String&gt; ls = makeList(&quot;A&quot;);</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">        ls = makeList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">        ls = makeList(&quot;ABCDEFFHIJKLMNOPQRSTUVWXYZ&quot;.split(&quot;&quot;));</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; /* Output:</span><br><span class="line">[A]</span><br><span class="line">[A, B, C]</span><br><span class="line">[A, B, C, D, E, F, F, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z]</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><h1 id="通配符和边界"><a href="#通配符和边界" class="headerlink" title="通配符和边界"></a>通配符和边界</h1><p>除了用T表示泛型外，还有<code>&lt;?&gt;</code>这种形式。<code>？</code>被称为通配符。可能有同学会想，已经有了 ？的形式了，为什么还要引进 &lt;?&gt;这样的概念呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Base&#123;&#125;</span><br><span class="line"></span><br><span class="line">class Sub extends Base&#123;&#125;</span><br><span class="line"></span><br><span class="line">Sub sub = new Sub();</span><br><span class="line">Base base = sub;</span><br></pre></td></tr></table></figure><p>上面代码显示，Base 是 Sub 的父类，它们之间是继承关系，所以 Sub 的实例可以给一个 Base 引用赋值，那么</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Sub&gt; lsub = new ArrayList&lt;&gt;();</span><br><span class="line">//! List&lt;Base&gt; lbase = lsub; //编译错误</span><br></pre></td></tr></table></figure><p>最后一行代码成立吗？编译会通过吗？答案是否定的。编译器不会让它通过的。Sub 是 Base 的子类，不代表<code>List&lt;sub&gt;</code>和<code>List&lt;Base&gt;</code>有继承关系。但是，在现实编码中，确实有这样的需求，希望泛型能够处理某一范围内的数据类型，比如某个类和它的子类，对此Java引入了通配符这个概念。所以，<strong>通配符的出现是为了指定泛型中的类型范围。</strong></p><p>通配符有 3 种形式。无论是T还是？，我们都应该记住，它都是一个实参，而不是一类参数或者形参，记住这一点有助于我们理解后面的知识。</p><ul><li><code>&lt;?&gt;</code>被称作无限定的通配符；</li><li><code>&lt;? extends T&gt;</code>被称作有上限的通配符；</li><li><code>&lt;? super T&gt;</code>被称作有下限的通配符。</li></ul><h2 id="无限定通配符-lt-gt"><a href="#无限定通配符-lt-gt" class="headerlink" title="无限定通配符 &lt;?&gt;"></a>无限定通配符 &lt;?&gt;</h2><p>无限定通配符经常与容器类配合使用，它其中的 ? 其实代表的是未知类型，所以涉及到 ? 时的操作，一定与具体类型无关。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class TestWildCards &#123;</span><br><span class="line">    public void testWildCards(Collection&lt;?&gt; collection)&#123;</span><br><span class="line">        //! collection.add(123);    // 编译错误</span><br><span class="line">        //! collection.add(&quot;hello&quot;);// 编译错误</span><br><span class="line">        </span><br><span class="line">        collection.iterator().next();</span><br><span class="line">        collection.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，方法内的参数是被无限定通配符修饰的 Collection 对象，它隐略地表达了一个意图或者可以说是限定，那就是 testWidlCards() 这个方法内部无需关注 Collection 中的真实类型，因为它是未知的。所以，你只能调用 Collection 中与类型无关的方法。我们可以看到，当 &lt;?&gt;存在时，Collection 对象丧失了 add( ) 方法的功能，编译器不通过。</p><ul><li>典型应用：捕获转换</li></ul><p>​编译器并非总是关注像List和List &lt; ?&gt; 之间的这种差异，因此它们看起来就像是相同的事物。因为，事实上，由于泛型参数将擦除到它的第一个边界，因此List&lt;?&gt; 看起来等价于List，而List实际上也是List。List实际上表示“持有任何Object类型的原生List，而List&lt;? &gt; 表示“具有某种特定类型的非原生List，只是我们不知道那种类型是什么。” 有一种情况特别需要使用而不是原生类型。如果向一个使用的方法传递原生类型，那么对编译器来说，可能会推断出实际的类型参数，使得这个方法可以回转并调用另一个使用这个确切类型的方法。下面的示例演示了这种技术，它被称为捕获转换，因为未指定的通配符类型被捕获，并被转换为确切类型。这里，有关警告的注释只有在@Suppress Warnings注解被移除之后才能起作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Holder</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Holder</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Holder</span><span class="params">(T val)</span> &#123; value = val; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T val)</span> &#123; value = val; &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value.equals(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CaptureConversion</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(Holder&lt;T&gt; holder)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> holder.get();</span><br><span class="line">        System.out.println(t.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">(Holder&lt;?&gt; holder)</span> &#123;</span><br><span class="line">        f1(holder); <span class="comment">// Call with captured type</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Holder</span> <span class="variable">raw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Holder</span>&lt;Integer&gt;(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// f1(raw); // Produces warnings</span></span><br><span class="line">        f2(raw);    <span class="comment">// No warnings</span></span><br><span class="line">        <span class="type">Holder</span> <span class="variable">rawBasic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Holder</span>();</span><br><span class="line">        rawBasic.set(<span class="keyword">new</span> <span class="title class_">Object</span>()); <span class="comment">// Warning</span></span><br><span class="line">        f2(rawBasic);               <span class="comment">// No warnings</span></span><br><span class="line">        <span class="comment">// Upcast to Holder&lt;?&gt;, still figures it out:</span></span><br><span class="line">        Holder&lt;?&gt; wildcarded = <span class="keyword">new</span> <span class="title class_">Holder</span>&lt;Double&gt;(<span class="number">1.0</span>);</span><br><span class="line">        f2(wildcarded);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Integer</span></span><br><span class="line"><span class="comment">Object</span></span><br><span class="line"><span class="comment">Double</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>f1()中的类型参数都是确切的，没有通配符或边界。在f2()中， Holder参数是一个无界通配符，因此它看起来是未知的。但是，在f2()中，f1()被调用，而f1()需要一个已知参数。这里所发生的是：参数类型在调用f2()的过程中被捕获，因此它可以在对f1()的调用中被使用。注意，不能从f2()中返回T，因为T对于f2()来说是未知的。捕获转换十分有趣，但是非常受限。</strong></p><h2 id="有上限的通配符-lt-extends-T-gt"><a href="#有上限的通配符-lt-extends-T-gt" class="headerlink" title="有上限的通配符 &lt;? extends T&gt;"></a>有上限的通配符 &lt;? extends T&gt;</h2><p>​这一部分如果实在理解不了就先去看下面的类型擦除再来看这里例如List&lt;? extends T&gt; 中“? extends T”代表某个参数，不知道这个参数是什么，只知道它继承于T，注意是一个参数，不是代表的一类参数，把“? extends T”看作Person或者Teacher这种具体的一个参数；所以此时添加T或者任何T的子类都不安全，因为你不知道它是中间的哪一个；又因为List&lt;? extends T&gt;擦除为List，所以超类也不能存进去，但是擦除为T类型，所以可以读出T类型的信息。</p><p>​同理List&lt;? super T&gt; 中的“? super T”也代表某个参数，不知道这个参数是什么，只知道它是T的超类，所以此时添加T或者任何T的超类都不安全，但这个参数的下限是T啊，就是最差也是个List，所以这时存T及其子类是安全的；但其擦除为List,所以只能读出Object类型。</p><p>代表着类型未知，但是我们的确需要对于类型的描述再精确一点，我们希望在一个范围内确定类别，比如类型 A 及类型 A 的子类都可以。 表示类型的上界，表示参数化类型的可能是T或是T的子类。 **上界不能往里存，只能往外取**：</p><p><code>class Human&#123;&#125;class Father extends Human&#123;&#125;class Son extends Father&#123;&#125;class Grandson extends Father &#123;&#125;public class test &#123;    public static void main(String[] args) &#123;        List&lt;? extends Father&gt; list = new LinkedList&lt;&gt;();        //! list.add(new Son()); // 编译错误    &#125;&#125;</code></p><p>List 表示 “具有任何从Son继承类型的列表”，编译器无法确定List所持有的类型，所以无法安全的向其中添加对象。可以添加null,因为null 可以表示任何类型。所以List 的add 方法不能添加任何有意义的元素，但是可以接受现有的子类型List 赋值。 你也许试图这样做：</p><p><code>List&lt;? extends Father&gt; list = new LinkedList&lt;Son&gt;();//! list.add(new Son()); // 编译错误</code></p><p>即使你指明了为Son类型，也不能用add方法添加一个Son对象。list中为什么不能加入Father类和Father类的子类呢，我们来分析下。 List表示上限是Father,下面这样的赋值都是合法的</p><p><code>List&lt;? extends Father&gt; list1 = new ArrayList&lt;Father&gt;();List&lt;? extends Father&gt; list2 = new ArrayList&lt;Son&gt;();List&lt;? extends Father&gt; list3 = new ArrayList&lt;Grandson&gt;();</code></p><p>如果List支持add方法的话： - list1可以add Father和所有Father的子类； - list2可以add Son和所有Son的子类； - list3可以add Grandson和所有Grandson的子类。 下面代码是编译不通过的：</p><p><code>list1.add(new Father());//errorlist1.add(new Son());   //error</code></p><p>原因是编译器只知道容器内是Father或者它的派生类，但具体是什么类型不知道。可能是Father？可能是Son？也可能是LeiFeng，XiaoMing？编译器在看到后面用Father赋值以后，集合里并没有限定参数类型是“Father“。而是标上一个占位符：CAP#1，来表示捕获一个Father或Father的子类，具体是什么类不知道，代号CAP#1。然后无论是想往里插入Son或者Grandson或者Father编译器都不知道能不能和这个CAP#1匹配，所以就都不允许。 但是，这种形式还是很有用的，虽然不能使用add方法，但是可以在初始化的时候一个Season指定不同的类型。比如：</p><p><code>List&lt;? extends Father&gt; list1 = getFatherList();//getFatherList方法会返回一个Father的子类的list</code></p><p>另外，由于我们已经保证了List中保存的是Father类或者他的某一个子类，所以，可以用get方法直接获得值：</p><p>​**拓展：<a href="https://stackoverflow.com/questions/897935/when-do-java-generics-require-extends-t-instead-of-t-and-is-there-any-down"> 与 有什么区别？</a> ## 有下限的通配符 &#96;&#96; 表示类型下界（Java Core中叫超类型限定），表示参数化类型是此类型的超类型（父类型），直至Object。 <strong>下界不能往外取，只能往里存</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="built_in">super</span> Father&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Father</span>());</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Human</span>());<span class="comment">//compile error </span></span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Son</span>());</span><br><span class="line"><span class="type">Father</span> <span class="variable">person1</span> <span class="operator">=</span> list.get(<span class="number">0</span>);<span class="comment">//compile error </span></span><br><span class="line"><span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> list.get(<span class="number">0</span>);<span class="comment">//compile error </span></span><br><span class="line"><span class="type">Object</span> <span class="variable">object1</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>​super只能添加Father和Father的子类，不能添加Father的父类，读取出来的东西只能存放在Object类里。因为下界规定了元素的最小粒度的下限，实际上是放松了容器元素的类型控制。既然最小元素都是Father的基类，那往里存粒度比Father小的都可以。出于对类型安全的考虑，我们可以加入Father对象或者其任何子类（如Son）对象，但由于编译器并不知道List的内容究竟是Father的哪个超类，因此不允许加入特定的任何超类（如Human）。 而当我们读取的时候，编译器在不知道是什么类型的情况下只能返回Object对象，因为Object是任何Java类的最终祖先类。但这样的话，元素的类型信息就全部丢失了。 ### PECS原则 最后看一下什么是PECS（Producer Extends Consumer Super）原则，已经很好理解了： - 频繁往外读取内容的，适合用上界Extends； - 经常往里插入的，适合用下界Super。 ## 总结 - extends 可用于返回类型限定，不能用于参数类型限定（换句话说：? extends xxx 只能用于方法返回类型限定，jdk能够确定此类的最小继承边界为xxx，只要是这个类的父类都能接收，但是传入参数无法确定具体类型，只能接受null的传入）。 - super 可用于参数类型限定，不能用于返回类型限定（换句话说：? supper xxx 只能用于方法传参，因为jdk能够确定传入为xxx的子类，返回只能用Object类接收）。 - ? 既不能用于方法参数传入，也不能用于方法返回。 # 泛型的擦除 当开始更深入地钻研泛型时，会发现有大量的东西初看起来是没有意义的。例如，尽管可以声明 ArrayList.class，但是不能声明 ArrayList.class。请考虑下面的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErasedTypeEquivalence</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;().getClass();</span><br><span class="line">    <span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;().getClass();</span><br><span class="line">    System.out.println(c1 == c2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>****Java泛型是使用擦除来实现的**，这意味着当你在使用泛型时，任何具体的类型信息都被擦除了，你唯一知道的就是你在使用一个对象。因此List**和List在运行时事实上是相同的类型。这两种形式都被擦除成它们的“原生”类型，即List。理解擦除以及应该如何处理它，是你在学习Java泛型时面临的最大障碍，这也是我们在本节将要探讨的内容。 Java的泛型基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息的，使用泛型的时候加上类型参数，在编译器编译的时候会去掉，变成原始类型，这个过程就是类型擦除。 原始类型就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型，无论何时定义一个泛型，相应的原始类型都会被自动提供，类型变量擦除，并使用其限定类型（无限定的变量用Object）替换。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;  </span><br><span class="line">    <span class="keyword">private</span> T value;  </span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T  value)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>编译之后的原始类型：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> Object value;  </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(Object  value)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>因为在Pair</strong>中，T 是一个无限定的类型变量，所以用Object替换，其结果就是一个普通的类，如同泛型加入Java语言之前的已经实现的样子。在程序中可以包含不同类型的Pair，如Pair或Pair，但是擦除类型后他们的就成为原始的Pair类型了，原始类型都是Object。如果类型变量有限定，那么原始类型就用第一个边界的类型变量类替换。再比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Top</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Low</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">c</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">d</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TopLowImpl</span> <span class="keyword">implements</span> <span class="title class_">Top</span>, Low &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Top::a()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Top::b()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">c</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Low::c()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">d</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Low::d()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E25_Bounds</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Top</span>&gt; <span class="keyword">void</span> <span class="title function_">top</span><span class="params">(T obj)</span> &#123;</span><br><span class="line">        obj.a();</span><br><span class="line">        obj.b();</span><br><span class="line">        <span class="comment">//! obj.c(); // 编译错误</span></span><br><span class="line">        <span class="comment">//! obj.d(); // 编译错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Low</span>&gt; <span class="keyword">void</span> <span class="title function_">low</span><span class="params">(T obj)</span> &#123;</span><br><span class="line">        <span class="comment">//! obj.a(); // 编译错误</span></span><br><span class="line">        <span class="comment">//! obj.b(); // 编译错误</span></span><br><span class="line">        obj.c();</span><br><span class="line">        obj.d();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TopLowImpl</span> <span class="variable">tli</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TopLowImpl</span>();</span><br><span class="line">        top(tli); <span class="comment">// tli被擦除为Top,无法调用c、d方法</span></span><br><span class="line">        low(tli); <span class="comment">// tli被擦除为Low,无法调用a、b方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Top::a()</span></span><br><span class="line"><span class="comment">Top::b()</span></span><br><span class="line"><span class="comment">Low::c()</span></span><br><span class="line"><span class="comment">Low::d()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>要理解上面那种行为似乎有些困难，我们会发现这种称之为擦除的效果类似于向上转型，我自己的理解就是向上转型，因为对象已经建立了，是TopLowImpl类型的，擦除并不能在内存里改变对象的属性，只是在引用级别将其擦除为Top和Low，在这里不就是向上转型吗？记住，擦除发生在引用级别。 另外在调用泛型方法时，参数可以指定泛型，也可以不指定泛型。 - 在不指定泛型的情况下，泛型变量的类型为该方法中的几种类型的同一父类的最小级，直到Object - 在指定泛型的情况下，该方法的几种类型必须是该泛型的实例的类型或者其子类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">//这是一个简单的泛型方法  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">add</span><span class="params">(T x,T y)</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> y;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">         <span class="comment">/**不指定泛型的时候*/</span>  </span><br><span class="line">         <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Test.add(<span class="number">1</span>, <span class="number">2</span>);         <span class="comment">// 这两个参数都是Integer，所以T为Integer类型  </span></span><br><span class="line">        <span class="type">Number</span> <span class="variable">f</span> <span class="operator">=</span> Test.add(<span class="number">1</span>, <span class="number">1.2</span>);    <span class="comment">// 这两个参数一个是Integer，一个是Float，所以取同一父类的最小级，为Number  </span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> Test.add(<span class="number">1</span>, <span class="string">&quot;asd&quot;</span>);  <span class="comment">// 这两个参数一个是Integer，一个是Float，所以取同一父类的最小级，为Object  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**指定泛型的时候*/</span>  </span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Test.&lt;Integer&gt;add(<span class="number">1</span>, <span class="number">2</span>);       <span class="comment">// 指定了Integer，所以只能为Integer类型或者其子类  </span></span><br><span class="line">        <span class="comment">//! int b = Test.&lt;Integer&gt;add(1, 2.2); // 编译错误，指定了Integer，不能为Float  </span></span><br><span class="line">        <span class="type">Number</span> <span class="variable">c</span> <span class="operator">=</span> Test.&lt;Number&gt;add(<span class="number">1</span>, <span class="number">2.2</span>);   <span class="comment">// 指定为Number，所以可以为Integer和Float  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>其实在泛型类中，不指定泛型的时候，也差不多，只不过这个时候的泛型为Object，就比如ArrayList中，如果不指定泛型，那么这个ArrayList可以存储任意的对象：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">    <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();  </span><br><span class="line">    list.add(<span class="number">1</span>);  </span><br><span class="line">    list.add(<span class="string">&quot;121&quot;</span>);  </span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Date</span>());  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong># 泛型（擦除）的问题 ## 基本数据类型不能作为类型参数 不能用类型参数替换基本类型。就比如，没有ArrayList</strong></p><p>，只有ArrayList</p><p>。因为当类型擦除后，ArrayList的原始类型变为Object，但是Object类型不能存储double值，只能引用Double的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ListOfInt &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; li = new ArrayList&lt;Integer&gt;();</span><br><span class="line">    for(int i = 0; i &lt; 5; i++)</span><br><span class="line">      li.add(i);</span><br><span class="line">    for(int i : li)</span><br><span class="line">      System.out.print(i + &quot; &quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; /* Output:</span><br><span class="line">0 1 2 3 4</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure><p>- 8种基本类型及其封装类： | 数据类型 | 包 装 类 | 字节长度 | 默 认 值 | | :——: | :——-: | :——: | :——–: | | int | Integer | 4 | 0 | | short | Short | 2 | 0 | | long | Long | 8 | 0l或0L | | byte | Byte | 1 | 0 | | float | Float | 4 | 0.0F或0.0f | | double | Double | 8 | 0.0 | | char | Character | 2 | u0000 | | boolean | Boolean | 1 | false | ## 编译时集合的instanceof</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure><p>因为类型擦除之后，ArrayList</p><p>只剩下原始类型，泛型信息String不存在了。那么，编译时进行类型查询的时候使用下面的方法是错误的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(arrayList instanceof ArrayList&lt;String&gt;);</span><br></pre></td></tr></table></figure><p>## 实现参数化接口（基类劫持了接口） 一个类不能实现同一个泛型接口的两种变体，由于擦除的原因，这两个变体会成为相同的接口。下面是产生这种冲突的情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface Payable&lt;T&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">class Employee implements Payable&lt;Employee&gt; &#123;&#125;</span><br><span class="line"> // Hourly不能编译</span><br><span class="line">class Hourly extends Employee implements Payable&lt;Hourly&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><p>Hourly不能编译，因为擦除会将 Payable</p><p>和 Payable</p><p>简化为相同的类Payable，这样，上面的代码就意味着在重复两次地实现相同的接口。十分有趣的是，如果从Payable的两种用法中都移除掉泛型参数（就像编译器在擦除阶段所做的那样）这段代码就可以编译。 ## 擦除与方法重载 下面的程序是不能编译的，即使编译它是一种合理的尝试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class UseList&lt;W,T&gt; &#123;</span><br><span class="line">  void f(List&lt;T&gt; v) &#123;&#125;</span><br><span class="line">  void f(List&lt;W&gt; v) &#123;&#125;</span><br><span class="line">&#125; ///:~</span><br></pre></td></tr></table></figure><p>由于擦除的原因，重载方法将产生相同的类型签名。与此不同的是，当被擦除的参数不能产生唯一的参数列表时，必须提供明显有区别的方法名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class UseList2&lt;W,T&gt; &#123;</span><br><span class="line">  void f1(List&lt;T&gt; v) &#123;&#125;</span><br><span class="line">  void f2(List&lt;W&gt; v) &#123;&#125;</span><br><span class="line">&#125; ///:~</span><br></pre></td></tr></table></figure><p>## 类型擦除与多态的冲突和解决方法 现在有这样一个泛型类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Pair&lt;T&gt; &#123;  </span><br><span class="line">    private T value;  </span><br><span class="line">    public T getValue() &#123;  </span><br><span class="line">        return value;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public void setValue(T value) &#123;  </span><br><span class="line">        this.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们想要一个子类继承它。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class DateInter extends Pair&lt;Date&gt; &#123;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void setValue(Date value) &#123;  </span><br><span class="line">        super.setValue(value);  </span><br><span class="line">    &#125;  </span><br><span class="line">    @Override  </span><br><span class="line">    public Date getValue() &#123;  </span><br><span class="line">        return super.getValue();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个子类中，我们设定父类的泛型类型为Pair</p><p>，在子类中，我们重写了父类的两个方法，我们的原意是这样的：将父类的泛型类型限定为Date，那么父类里面的两个方法的参数都为Date类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public Date getValue() &#123;  </span><br><span class="line">    return value;  </span><br><span class="line">&#125;  </span><br><span class="line">public void setValue(Date value) &#123;  </span><br><span class="line">    this.value = value;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，我们在子类中重写这两个方法一点问题也没有，实际上，从他们的@Override标签中也可以看到，一点问题也没有，实际上是这样的吗？ 分析：实际上，类型擦除后，父类的的泛型类型全部变为了原始类型Object，所以父类编译之后会变成下面的样子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Pair &#123;  </span><br><span class="line">    private Object value;  </span><br><span class="line">    public Object getValue() &#123;  </span><br><span class="line">        return value;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public void setValue(Object  value) &#123;  </span><br><span class="line">        this.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>再看子类的两个重写的方法的类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override  </span><br><span class="line">public void setValue(Date value) &#123;  </span><br><span class="line">    super.setValue(value);  </span><br><span class="line">&#125;  </span><br><span class="line">@Override  </span><br><span class="line">public Date getValue() &#123;  </span><br><span class="line">    return super.getValue();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先来分析setValue方法，父类的类型是Object，而子类的类型是Date，参数类型不一样，这如果是在普通的继承关系中，根本就不会是重写，而是重载。我们在一个main方法测试一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws ClassNotFoundException &#123;  </span><br><span class="line">        DateInter dateInter = new DateInter();  </span><br><span class="line">        dateInter.setValue(new Date());                  </span><br><span class="line">        //! dateInter.setValue(new Object()); //编译错误  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是重载，那么子类中两个setValue方法，一个是参数Object类型，一个是Date类型，可是我们发现，根本就没有这样的一个子类继承自父类的Object类型参数的方法。所以说，的确是重写了，而不是重载了。为什么会这样呢？原因是这样的，我们传入父类的泛型类型是Date，Pair</p><p>，我们的本意是将泛型类变为如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Pair &#123;  </span><br><span class="line">    private Date value;  </span><br><span class="line">    public Date getValue() &#123;  </span><br><span class="line">        return value;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public void setValue(Date value) &#123;  </span><br><span class="line">        this.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在子类中重写参数类型为Date的那两个方法，实现继承中的多态。可是由于种种原因，虚拟机并不能将泛型类型变为Date，只能将类型擦除掉，变为原始类型Object。这样，我们的本意是进行重写，实现多态。可是类型擦除后，只能变为了重载。这样，类型擦除就和多态有了冲突。JVM知道你的本意吗？知道！！！可是它能直接实现吗，不能！！！如果真的不能的话，那我们怎么去重写我们想要的Date类型参数的方法啊。 于是JVM采用了一个特殊的方法，来完成这项功能，那就是桥方法。首先，我们用javap -c className的方式反编译下DateInter子类的字节码，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class com.tao.test.DateInter extends com.tao.test.Pair&lt;java.util.Date&gt; &#123;  </span><br><span class="line">  com.tao.test.DateInter();  </span><br><span class="line">    Code:  </span><br><span class="line">       0: aload_0  </span><br><span class="line">       1: invokespecial #8                  // Method com/tao/test/Pair.&quot;&lt;init&gt;&quot;:()V  </span><br><span class="line">       4: return  </span><br><span class="line"></span><br><span class="line">  public void setValue(java.util.Date);  // 我们重写的setValue方法  </span><br><span class="line">    Code:  </span><br><span class="line">       0: aload_0  </span><br><span class="line">       1: aload_1  </span><br><span class="line">       2: invokespecial #16                 // Method com/tao/test/Pair.setValue:(Ljava/lang/Object;)V  </span><br><span class="line">       5: return  </span><br><span class="line"></span><br><span class="line">  public java.util.Date getValue();    // 我们重写的getValue方法  </span><br><span class="line">    Code:  </span><br><span class="line">       0: aload_0  </span><br><span class="line">       1: invokespecial #23                 // Method com/tao/test/Pair.getValue:()Ljava/lang/Object;  </span><br><span class="line">       4: checkcast     #26                 // class java/util/Date  </span><br><span class="line">       7: areturn  </span><br><span class="line"></span><br><span class="line">  public java.lang.Object getValue();   // 编译时由编译器生成的巧方法  </span><br><span class="line">    Code:  </span><br><span class="line">       0: aload_0  </span><br><span class="line">       1: invokevirtual #28                 // Method getValue:()Ljava/util/Date 去调用我们重写的getValue方法;  </span><br><span class="line">       4: areturn  </span><br><span class="line"></span><br><span class="line">  public void setValue(java.lang.Object); // 编译时由编译器生成的巧方法  </span><br><span class="line">    Code:  </span><br><span class="line">       0: aload_0  </span><br><span class="line">       1: aload_1  </span><br><span class="line">       2: checkcast     #26                 // class java/util/Date  </span><br><span class="line">       5: invokevirtual #30                 // Method setValue:(Ljava/util/Date; 去调用我们重写的setValue方法)V  </span><br><span class="line">       8: return  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从编译的结果来看，我们本意重写setValue和getValue方法的子类，竟然有4个方法，其实不用惊奇，最后的两个方法，就是编译器自己生成的桥方法。可以看到桥方法的参数类型都是Object，也就是说，子类中真正覆盖父类两个方法的就是这两个我们看不到的桥方法。而打在我们自己定义的setvalue和getValue方法上面的@Oveerride只不过是假象。而桥方法的内部实现，就只是去调用我们自己重写的那两个方法。所以，虚拟机巧妙的使用了桥方法，来解决了类型擦除和多态的冲突。不过，要提到一点，这里面的setValue和getValue这两个桥方法的意义又有不同。setValue方法是为了解决类型擦除与多态之间的冲突。而getValue却有普遍的意义，怎么说呢，如果这是一个普通的继承关系，那么父类的setValue方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ObjectgetValue() &#123;  </span><br><span class="line">    return super.getValue();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而子类重写的方法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Date getValue() &#123;  </span><br><span class="line">    return super.getValue();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>其实这在普通的类继承中也是普遍存在的重写，这就是协变。 并且，还有一点也许会有疑问，子类中的桥方法Object getValue()和Date getValue()是同时存在的，可是如果是常规的两个方法，他们的方法签名是一样的，也就是说虚拟机根本不能分辨这两个方法。如果是我们自己编写Java代码，这样的代码是无法通过编译器的检查的，但是虚拟机却是允许这样做的，因为虚拟机通过参数类型和返回类型来确定一个方法，所以编译器为了实现泛型的多态允许自己做这个看起来“不合法”的事情，然后交给虚拟器去区别。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Array容器</title>
      <link href="/2021/04/09/Array%E5%AE%B9%E5%99%A8/"/>
      <url>/2021/04/09/Array%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="数组与容器"><a href="#数组与容器" class="headerlink" title="数组与容器"></a>数组与容器</h1><p>​在Java中，数组是一种效率最高的存储和随机访问对象引用序列的方式。数组就是一个简单的线性序，这使得元素访问非常快速。但是为这种速度所付出的代价是数组对象的大小被固定，并且在其生命周期中不可改变。</p><p>​数组可以持有基本类型，而泛型之前的容器则不能。但是有了泛型，容器就可以指定并检查它们所持有对象的类型，并且有了自动包装机制，容器看起来还能够持有基本类型。其后的Java版本对容器的支持得到了明显的改进，并且现在的容器在除了性能之外的各个方面都使得数组相形见绌。有了额外的自动包装机制和泛型，在容器中持有基本类型就变得易如反掌了，而这也进一步促使你用容器来替换数组。因为泛型可以产生类型安全的容器，因此数组面对这一变化，已经变得亳无优势了。</p><p>​所有这些话题都表示：“优选容器而不是数组”。只有在已证明性能成为问题（并且切换到数组对性能提高有所帮助）时，你才应该将程序重构为使用数组。</p><span id="more"></span><h1 id="数组保存对象和基本类型的区别"><a href="#数组保存对象和基本类型的区别" class="headerlink" title="数组保存对象和基本类型的区别"></a>数组保存对象和基本类型的区别</h1><p>​无论使用哪种类型的数组，数组标识符其实只是一个引用，指向在堆中创建的一个真实对象，这个（数组）对象用以保存指向其他对象的引用。可以作为数组初始化语法的一部分隐式地创建此对象，或者用new表达式显式地创建。</p><p>​对象数组和基本类型数组在使用上几乎是相同的；唯一的区别就是对象数组保存的是引用，基本类型数组直接保存基本类型的值。你无法知道在数组中确切地有多少元素，因为 length只表示数组能够容纳多少元素。也就是说，length是数组的大小，而不是实际保存的元素个数。新生成一个数组对象时，其中所有的引用被自动初始化为null，所以检查其中的引用是否为nul，即可知道数组的某个位置是否存有对象。同样，基本类型的数组如果是数值型的，就被自动初始化为0；如果是字符型（char）的，就被自动初始化为（char）0；如果是布尔型（ boolean），就被自动初始化为false。</p><h1 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h1><p>​对于基本类型的多维数组，可以通过使用花括号将每个向量分隔开，每对花括号括起来的集合都会把你带到下一级数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultidimensionalPrimitiveArray</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] a = &#123;</span><br><span class="line">      &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, &#125;,</span><br><span class="line">      &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">      <span class="comment">//将多维数组转换为多个String.</span></span><br><span class="line">    System.out.println(Arrays.deepToString(a));</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[[1, 2, 3], [4, 5, 6]]</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Arrays类包含的方法"><a href="#Arrays类包含的方法" class="headerlink" title="Arrays类包含的方法"></a>Arrays类包含的方法</h1><h2 id="Arrays-asList"><a href="#Arrays-asList" class="headerlink" title="Arrays.asList()"></a>Arrays.asList()</h2><p>​注意：该方法返回的是 Arrays 内部静态类 ArrayList，而不是我们平常使用的 ArrayList,，该静态类 ArrayList 没有覆盖父类的 add(), remove() 等方法，所以如果直接调用，会报 UnsupportedOperationException 异常。</p><ul><li><p>将数组转换为集合，接收一个可变参。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">list.forEach(System.out::println); <span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line">Integer[] data = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(data);</span><br><span class="line">list.forEach(System.out::println); <span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure></li><li><p>如果将基本数据类型的数组作为参数传入，该方法会把整个数组当作一个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] data = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">List&lt;<span class="type">int</span>[]&gt; list = Arrays.asList(data);</span><br><span class="line">System.out.println(list.size()); <span class="comment">// 1</span></span><br><span class="line">System.out.println(Arrays.toString(list.get(<span class="number">0</span>))); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Arrays-fill"><a href="#Arrays-fill" class="headerlink" title="Arrays.fill()"></a>Arrays.fill()</h2><ul><li><p>Arrays.fill(Object[] array, Object obj)：用指定元素填充整个数组 (会替换掉数组中原来的元素)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[] data = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">Arrays.fill(data, <span class="number">9</span>);</span><br><span class="line">System.out.println(Arrays.toString(data)); <span class="comment">// [9, 9, 9, 9]</span></span><br></pre></td></tr></table></figure></li><li><p>Arrays.fill(Object[] array, int fromIndex, int toIndex, Object obj)：用指定元素填充数组，从起始位置到结束位置，取头不取尾 (会替换掉数组中原来的元素)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[] data = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">Arrays.fill(data, <span class="number">0</span>, <span class="number">2</span>, <span class="number">9</span>);</span><br><span class="line">System.out.println(Arrays.toString(data)); <span class="comment">// [9, 9, 3, 4]</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Arrays-sort"><a href="#Arrays-sort" class="headerlink" title="Arrays.sort()"></a>Arrays.sort()</h2><ul><li><p>Arrays.sort(Object[] array)：对数组元素进行排序 (串行排序)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] data = &#123;&quot;1&quot;, &quot;4&quot;, &quot;3&quot;, &quot;2&quot;&#125;;</span><br><span class="line">System.out.println(Arrays.toString(data)); // [1, 4, 3, 2]</span><br><span class="line">Arrays.sort(data);</span><br><span class="line">System.out.println(Arrays.toString(data)); // [1, 2, 3, 4]</span><br></pre></td></tr></table></figure></li><li><p>Arrays.sort(T[] array, Comparator&lt;? super T&gt; comparator)：使用自定义比较器，对数组元素进行排序 (串行排序)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String[] data = &#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;2&quot;</span>&#125;;</span><br><span class="line">System.out.println(Arrays.toString(data)); <span class="comment">// [1, 4, 3, 2]</span></span><br><span class="line"><span class="comment">// 实现降序排序，返回-1放左边，1放右边，0保持不变</span></span><br><span class="line">Arrays.sort(data, (str1, str2) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (str1.compareTo(str2) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(Arrays.toString(data)); <span class="comment">// [4, 3, 2, 1]</span></span><br></pre></td></tr></table></figure></li><li><p>Arrays.sort(Object[] array, int fromIndex, int toIndex)： 对指定范围内的数组元素进行排序 (串行排序)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String[] data = &#123;&quot;1&quot;, &quot;4&quot;, &quot;3&quot;, &quot;2&quot;&#125;;</span><br><span class="line">System.out.println(Arrays.toString(data)); // [1, 4, 3, 2]</span><br><span class="line">// 对下标[0, 3)的元素进行排序，即对1，4，3进行排序，2保持不变</span><br><span class="line">Arrays.sort(data, 0, 3);</span><br><span class="line">System.out.println(Arrays.toString(data)); // [1, 3, 4, 2]</span><br></pre></td></tr></table></figure></li><li><p>Arrays.sort(T[] array, int fromIndex, int toIndex, Comparator&lt;? super T&gt; c)：使用自定义比较器，对指定范围内的数组元素进行排序 (串行排序)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String[] data = &#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;2&quot;</span>&#125;;</span><br><span class="line">System.out.println(Arrays.toString(data)); <span class="comment">// [1, 4, 3, 2]</span></span><br><span class="line"><span class="comment">// 对下标[0, 3)的元素进行降序排序，即对1，4，3进行降序排序，2保持不变</span></span><br><span class="line">Arrays.sort(data, <span class="number">0</span>, <span class="number">3</span>, (str1, str2) -&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (str1.compareTo(str2) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(Arrays.toString(data)); <span class="comment">// [4, 3, 1, 2]</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Arrays-binarySearch"><a href="#Arrays-binarySearch" class="headerlink" title="Arrays.binarySearch()"></a>Arrays.binarySearch()</h2><ul><li>Arrays.binarySearch(Object[] array, Object key)：使用二分法查找数组内指定元素的索引值。</li></ul><p>注意：在调用该方法之前，必须先调用 Arrays.sort() 方法进行排序，如果数组没有排序，那么结果是不确定的，此外如果数组中包含多个指定元素，则无法保证将找到哪个元素； 当搜索元素是数组元素时，返回该元素的索引值，当搜索元素不是数组元素时，返回 - (索引值 + 1)。</p><p>搜索元素是数组元素，返回该元素索引值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[] data = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br><span class="line">Arrays.sort(data);</span><br><span class="line">System.out.println(Arrays.binarySearch(data, <span class="number">1</span>)); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>搜索元素不是数组元素，且小于数组中的最小值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer[] data = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br><span class="line">Arrays.sort(data);</span><br><span class="line"><span class="comment">// 此时程序会把数组看作 &#123;0, 1, 3, 5, 7&#125;，此时0的索引值为0，则搜索0时返回 -(0 + 1) = -1</span></span><br><span class="line">System.out.println(Arrays.binarySearch(data, <span class="number">0</span>)); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure><p>搜索元素不是数组元素，且大于数组中的最大值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer[] data = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br><span class="line">Arrays.sort(data);</span><br><span class="line"><span class="comment">// 此时程序会把数组看作 &#123;1, 3, 5, 7， 9&#125;，此时9的索引值为4，则搜索8时返回 -(4 + 1) = -5</span></span><br><span class="line">System.out.println(Arrays.binarySearch(data, <span class="number">9</span>)); <span class="comment">// -5</span></span><br></pre></td></tr></table></figure><p>搜索元素不是数组元素，但在数组范围内：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer[] data = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br><span class="line">Arrays.sort(data);</span><br><span class="line"><span class="comment">// 此时程序会把数组看作 &#123;1, 2, 3, 5, 7&#125;，此时2的索引值为1，则搜索2时返回 -(1 + 1) = -2</span></span><br><span class="line">System.out.println(Arrays.binarySearch(data, <span class="number">2</span>)); <span class="comment">// -2</span></span><br></pre></td></tr></table></figure><ul><li><p>Arrays.binarySearch(Object[] array, int fromIndex, int toIndex, Object obj)：使用二分法查找数组内指定范围内的指定元素的索引值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer[] data = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br><span class="line">Arrays.sort(data);</span><br><span class="line"><span class="comment">// &#123;1, 3&#125;，3的索引值为1</span></span><br><span class="line">System.out.println(Arrays.binarySearch(data, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Arrays-copyOf"><a href="#Arrays-copyOf" class="headerlink" title="Arrays.copyOf()"></a>Arrays.copyOf()</h2><ul><li><p>System.arraycopy(T[] original,int fromIndex, T[] object, int toIndex, copyNumber)：Arrays.copyOf()内部调用了 System.arraycopy() 方法，arraycopy()需要的参数有：源数组，表示从源数组中的什么位置开始复制的偏移量，目标数组，表示从目标数组的什么位置开始复制的偏移量，以及需要复制的元素个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyingArrays</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] i = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">7</span>];</span><br><span class="line">    <span class="type">int</span>[] j = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    Arrays.fill(i, <span class="number">47</span>);</span><br><span class="line">    Arrays.fill(j, <span class="number">99</span>);</span><br><span class="line">    print(<span class="string">&quot;i = &quot;</span> + Arrays.toString(i));</span><br><span class="line">    print(<span class="string">&quot;j = &quot;</span> + Arrays.toString(j));</span><br><span class="line">    System.arraycopy(i, <span class="number">0</span>, j, <span class="number">0</span>, i.length);</span><br><span class="line">    print(<span class="string">&quot;j = &quot;</span> + Arrays.toString(j));</span><br><span class="line">    <span class="type">int</span>[] k = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">    Arrays.fill(k, <span class="number">103</span>);</span><br><span class="line">    System.arraycopy(i, <span class="number">0</span>, k, <span class="number">0</span>, k.length);</span><br><span class="line">    print(<span class="string">&quot;k = &quot;</span> + Arrays.toString(k));</span><br><span class="line">    Arrays.fill(k, <span class="number">103</span>);</span><br><span class="line">    System.arraycopy(k, <span class="number">0</span>, i, <span class="number">0</span>, k.length);</span><br><span class="line">    print(<span class="string">&quot;i = &quot;</span> + Arrays.toString(i));</span><br><span class="line">    <span class="comment">// Objects:</span></span><br><span class="line">    Integer[] u = <span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">10</span>];</span><br><span class="line">    Integer[] v = <span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">5</span>];</span><br><span class="line">    Arrays.fill(u, <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">47</span>));</span><br><span class="line">    Arrays.fill(v, <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">99</span>));</span><br><span class="line">    print(<span class="string">&quot;u = &quot;</span> + Arrays.toString(u));</span><br><span class="line">    print(<span class="string">&quot;v = &quot;</span> + Arrays.toString(v));</span><br><span class="line">    System.arraycopy(v, <span class="number">0</span>, u, u.length/<span class="number">2</span>, v.length);</span><br><span class="line">    print(<span class="string">&quot;u = &quot;</span> + Arrays.toString(u));</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">i = [47, 47, 47, 47, 47, 47, 47]</span></span><br><span class="line"><span class="comment">j = [99, 99, 99, 99, 99, 99, 99, 99, 99, 99]</span></span><br><span class="line"><span class="comment">j = [47, 47, 47, 47, 47, 47, 47, 99, 99, 99]</span></span><br><span class="line"><span class="comment">k = [47, 47, 47, 47, 47]</span></span><br><span class="line"><span class="comment">i = [103, 103, 103, 103, 103, 47, 47]</span></span><br><span class="line"><span class="comment">u = [47, 47, 47, 47, 47, 47, 47, 47, 47, 47]</span></span><br><span class="line"><span class="comment">v = [99, 99, 99, 99, 99]</span></span><br><span class="line"><span class="comment">u = [47, 47, 47, 47, 47, 99, 99, 99, 99, 99]</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure><p>这个例子说明基本类型数组与对象数组都可以复制。然而，<strong>如果复制对象数组，那么只是复制了对象的引用一而不是对象本身的拷贝</strong>。这被称作浅复制（shallow copy）。System.arraycopy()不会执行自动包装和自动拆包，两个数组必须具有相同的确切类型。</p></li><li><p>Arrays.copyOf(T[] original, int newLength)：拷贝数组，其内部调用了 System.arraycopy() 方法，从下标 0 开始，如果超过原数组长度，则会用 null 进行填充。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer[] data1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">Integer[] data2 = Arrays.copyOf(data1, <span class="number">2</span>);</span><br><span class="line">System.out.println(Arrays.toString(data2)); <span class="comment">// [1, 2]</span></span><br><span class="line">Integer[] data3 = Arrays.copyOf(data1, <span class="number">5</span>);</span><br><span class="line">System.out.println(Arrays.toString(data3)); <span class="comment">// [1, 2, 3, 4, null]</span></span><br></pre></td></tr></table></figure></li><li><p>Arrays.copyOfRange(T[] original, int from, int to)： 拷贝数组，指定起始位置和结束位置，如果超过原数组长度，则会用 null 进行填充。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer[] data1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">Integer[] data2 = Arrays.copyOfRange(data1, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">System.out.println(Arrays.toString(data2)); <span class="comment">// [1, 2]</span></span><br><span class="line">Integer[] data2 = Arrays.copyOfRange(data1, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">System.out.println(Arrays.toString(data2)); <span class="comment">// [1, 2, 3, 4, null]</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Arrays-equals-Object-array1-Object-array2"><a href="#Arrays-equals-Object-array1-Object-array2" class="headerlink" title="Arrays.equals(Object[] array1, Object[] array2)"></a>Arrays.equals(Object[] array1, Object[] array2)</h2><p>​判断两个数组是否相等。数组元素为基本数据类型时，依次比较值；数组元素为引用数据类型时，依次调用元素的 equals() 方法进行比较。即如果两个数组被认为是相等的，则两个数组中应包含相同顺序的相同元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[] data1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">Integer[] data2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">System.out.println(Arrays.equals(data1, data2)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="Arrays-deepEquals-Object-array1-Object-array2"><a href="#Arrays-deepEquals-Object-array1-Object-array2" class="headerlink" title="Arrays.deepEquals(Object[] array1, Object[] array2)"></a>Arrays.deepEquals(Object[] array1, Object[] array2)</h2><p>​判断两个多维数组是否相等。数组元素为基本数据类型时，依次比较值；数组元素为引用数据类型时，依次调用元素的 equals() 方法进行比较。即如果两个多维数组被认为是相等的，则两个多维数组中应包含相同顺序的相同元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[][] data1 = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;&#125;;</span><br><span class="line">Integer[][] data2 = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;&#125;;</span><br><span class="line">System.out.println(Arrays.deepEquals(data1, data2)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="Arrays-hashCode-Object-array"><a href="#Arrays-hashCode-Object-array" class="headerlink" title="Arrays.hashCode(Object[] array)"></a>Arrays.hashCode(Object[] array)</h2><p>返回数组的哈希值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer[] data = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">System.out.println(Arrays.hashCode(data)); <span class="comment">// 30817</span></span><br></pre></td></tr></table></figure><h2 id="Arrays-deepHashCode-Object-array"><a href="#Arrays-deepHashCode-Object-array" class="headerlink" title="Arrays.deepHashCode(Object[] array)"></a>Arrays.deepHashCode(Object[] array)</h2><p>返回多维数组的哈希值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer[][] data = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line">System.out.println(Arrays.deepHashCode(data)); <span class="comment">// 987105j</span></span><br></pre></td></tr></table></figure><h2 id="Arrays-toString-Object-array"><a href="#Arrays-toString-Object-array" class="headerlink" title="Arrays.toString(Object[] array)"></a>Arrays.toString(Object[] array)</h2><p>返回数组元素的字符串形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer[] data = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">System.out.println(Arrays.toString(data)); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><h2 id="Arrays-deepToString-Object-array"><a href="#Arrays-deepToString-Object-array" class="headerlink" title="Arrays.deepToString(Object[] array)"></a>Arrays.deepToString(Object[] array)</h2><p>返回多维数组元素的字符串形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer[][] data = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line">System.out.println(Arrays.deepToString(data)); <span class="comment">// [[1, 2, 3], [1, 2, 3]]</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
